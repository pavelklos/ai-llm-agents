<small>Claude Sonnet 4 **(Pr콢vodce d캩jinami um캩n칤 a muzejn칤 AI asistent)**</small>
# Art History and Museum Guide

## Kl칤캜ov칠 koncepty projektu

### RAG (Retrieval-Augmented Generation)
Hybridn칤 p콏칤stup kombinuj칤c칤 vyhled치v치n칤 relevantn칤ch informac칤 z datab치ze znalost칤 s generativn칤mi schopnostmi LLM model콢. Umo쮄갓je poskytovat p콏esn칠, kontextu치ln캩 relevantn칤 odpov캩di zalo쬰n칠 na faktick칳ch datech.

### Informace o um캩leck칳ch d칤lech
Strukturovan치 datab치ze obsahuj칤c칤 metadata um캩leck칳ch d캩l v캜etn캩 n치zvu, autora, datace, techniky, rozm캩r콢, provenience a detailn칤ho popisu.

### Biografie um캩lc콢
Komplexn칤 쬴votopisn칠 칰daje um캩lc콢 zahrnuj칤c칤 obdob칤 tvorby, um캩leck칠 sm캩ry, v칳znamn치 d칤la a historick칳 kontext jejich p콢soben칤.

### V칳stavn칤 katalogy
Digitalizovan칠 katalogy v칳stav obsahuj칤c칤 kur치torsk칠 eseje, kritick칠 anal칳zy a kontextu치ln칤 informace o vystavovan칳ch d칤lech.

### Kulturn칤 kontext
Historick칠, spole캜ensk칠 a kulturn칤 pozad칤 vzniku um캩leck칳ch d캩l, v캜etn캩 politick칳ch ud치lost칤, filozofick칳ch proud콢 a spole캜ensk칳ch zm캩n.

### Muzejn칤 API
Rozhran칤 pro p콏칤stup k digit치ln칤m sb칤rk치m muze칤, umo쮄갓j칤c칤 z칤sk치v치n칤 vysokorozli코en칳ch obr치zk콢 a metadat um캩leck칳ch d캩l.

### Anal칳za obrazu
Po캜칤ta캜ov칠 vid캩n칤 a AI technologie pro automatickou identifikaci um캩leck칳ch d캩l, styl콢, technik a ikonografick칳ch prvk콢.

### Virtu치ln칤 prohl칤dky
Interaktivn칤 digit치ln칤 prost콏ed칤 umo쮄갓j칤c칤 vzd치len칠 prozkoum치v치n칤 muzejn칤ch prostor a sb칤rek s dopln캩n칳mi informacemi.

## Komplexn칤 vysv캩tlen칤 projektu

### C칤le projektu
Projekt si klade za c칤l vytvo콏it inteligentn칤ho AI asistenta pro d캩jiny um캩n칤, kter칳 dok치쬰:
- Poskytovat odborn칠 informace o um캩leck칳ch d칤lech a um캩lc칤ch
- Analyzovat um캩leck치 d칤la z hlediska stylu, techniky a historick칠ho kontextu
- Vytv치콏et personalizovan칠 muzejn칤 prohl칤dky
- Odpov칤dat na slo쬴t칠 dotazy t칳kaj칤c칤 se d캩jin um캩n칤
- Propojovat d칤la nap콏칤캜 epochami a kulturami

### V칳zvy projektu
- **Multimod치ln칤 zpracov치n칤**: Kombinace textov칳ch informac칤 s vizu치ln칤 anal칳zou um캩leck칳ch d캩l
- **P콏esnost informac칤**: Zaji코t캩n칤 faktick칠 spr치vnosti v oblasti d캩jin um캩n칤
- **Kulturn칤 citlivost**: Respektov치n칤 r콢zn칳ch kulturn칤ch perspektiv a interpretac칤
- **맒치lovatelnost**: Schopnost zpracovat rozs치hl칠 muzejn칤 sb칤rky
- **Aktualizace dat**: Udr쬺v치n칤 sou캜asnosti informac칤 o v칳stav치ch a akvizic칤ch

### Potenci치ln칤 dopad
Demokratizace p콏칤stupu k odborn칳m znalostem d캩jin um캩n칤, podpora vzd캩l치v치n칤, zlep코en칤 muzejn칤ho z치쬴tku n치v코t캩vn칤k콢 a vytvo콏en칤 nov칳ch mo쬹ost칤 pro v칳zkum v oblasti kulturn칤ho d캩dictv칤.

## Komplexn칤 p콏칤klad implementace v Pythonu

````python
import os
import requests
import numpy as np
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import json
import base64
from io import BytesIO
from PIL import Image

# Modern칤 AI a RAG frameworky
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.chains import RetrievalQA
from langchain.llms import OpenAI
from langchain.schema import Document
from langchain.prompts import PromptTemplate

# Pro pr치ci s obr치zky
import cv2
from transformers import BlipProcessor, BlipForConditionalGeneration
import torch

# Pro web scraping a API
import aiohttp
import asyncio
from bs4 import BeautifulSoup

@dataclass
class ArtworkInfo:
    """Struktura pro informace o um캩leck칠m d칤le"""
    title: str
    artist: str
    year: Optional[int]
    medium: str
    dimensions: str
    location: str
    description: str
    style: str
    period: str
    image_url: Optional[str] = None
    provenance: Optional[str] = None
    exhibitions: Optional[List[str]] = None

class MuseumAPIClient:
    """Klient pro pr치ci s muzejn칤mi API"""
    
    def __init__(self):
        self.met_api_base = "https://collectionapi.metmuseum.org/public/collection/v1"
        self.rijks_api_base = "https://www.rijksmuseum.nl/api/nl/collection"
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def search_met_museum(self, query: str, limit: int = 10) -> List[Dict]:
        """Vyhled치v치n칤 v kolekci Metropolitan Museum"""
        try:
            search_url = f"{self.met_api_base}/search"
            params = {"q": query, "hasImages": "true"}
            
            async with self.session.get(search_url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    object_ids = data.get("objectIDs", [])[:limit]
                    
                    artworks = []
                    for obj_id in object_ids:
                        artwork = await self._get_met_object(obj_id)
                        if artwork:
                            artworks.append(artwork)
                    
                    return artworks
        except Exception as e:
            print(f"Chyba p콏i vyhled치v치n칤 v Met Museum: {e}")
            return []
    
    async def _get_met_object(self, object_id: int) -> Optional[ArtworkInfo]:
        """Z칤sk치n칤 detail콢 objektu z Met Museum"""
        try:
            object_url = f"{self.met_api_base}/objects/{object_id}"
            
            async with self.session.get(object_url) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    return ArtworkInfo(
                        title=data.get("title", "Nezn치m칳 n치zev"),
                        artist=data.get("artistDisplayName", "Nezn치m칳 um캩lec"),
                        year=data.get("objectBeginDate"),
                        medium=data.get("medium", ""),
                        dimensions=data.get("dimensions", ""),
                        location="Metropolitan Museum of Art, New York",
                        description=data.get("title", ""),
                        style=data.get("classification", ""),
                        period=data.get("period", ""),
                        image_url=data.get("primaryImageSmall"),
                        provenance=data.get("creditLine", "")
                    )
        except Exception as e:
            print(f"Chyba p콏i z칤sk치v치n칤 objektu {object_id}: {e}")
            return None

class ImageAnalyzer:
    """Analyz치tor pro vizu치ln칤 anal칳zu um캩leck칳ch d캩l"""
    
    def __init__(self):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        # Na캜ten칤 modelu pro popis obr치zk콢
        self.processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
        self.model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")
        self.model.to(self.device)
    
    def analyze_artwork_image(self, image_url: str) -> Dict[str, str]:
        """Anal칳za um캩leck칠ho d칤la z obr치zku"""
        try:
            # Sta쬰n칤 obr치zku
            response = requests.get(image_url)
            image = Image.open(BytesIO(response.content)).convert("RGB")
            
            # Generov치n칤 popisu
            inputs = self.processor(image, return_tensors="pt").to(self.device)
            out = self.model.generate(**inputs, max_length=100)
            description = self.processor.decode(out[0], skip_special_tokens=True)
            
            # Z치kladn칤 anal칳za barev
            colors = self._analyze_colors(image)
            
            # Detekce kompozice
            composition = self._analyze_composition(image)
            
            return {
                "description": description,
                "dominant_colors": colors,
                "composition": composition,
                "analysis_timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            print(f"Chyba p콏i anal칳ze obr치zku: {e}")
            return {"error": str(e)}
    
    def _analyze_colors(self, image: Image.Image) -> List[str]:
        """Anal칳za dominantn칤ch barev"""
        # P콏evod na numpy array
        img_array = np.array(image)
        
        # Zmen코en칤 rozli코en칤 pro rychlej코칤 zpracov치n칤
        small_img = cv2.resize(img_array, (100, 100))
        
        # K-means clustering pro nalezen칤 dominantn칤ch barev
        data = small_img.reshape((-1, 3))
        data = np.float32(data)
        
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 20, 1.0)
        _, labels, centers = cv2.kmeans(data, 5, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
        
        # P콏evod center na seznam barev
        colors = []
        for center in centers:
            color_name = self._get_color_name(center)
            colors.append(color_name)
        
        return colors[:3]  # Vr치t칤me top 3 barvy
    
    def _get_color_name(self, rgb: np.ndarray) -> str:
        """P콏evod RGB hodnot na n치zev barvy"""
        r, g, b = int(rgb[0]), int(rgb[1]), int(rgb[2])
        
        # Jednoduch치 klasifikace barev
        if r > 200 and g > 200 and b > 200:
            return "b칤l치"
        elif r < 50 and g < 50 and b < 50:
            return "캜ern치"
        elif r > g and r > b:
            return "캜erven치"
        elif g > r and g > b:
            return "zelen치"
        elif b > r and b > g:
            return "modr치"
        elif r > 150 and g > 150:
            return "쬷ut치"
        else:
            return "neutr치ln칤"
    
    def _analyze_composition(self, image: Image.Image) -> str:
        """Z치kladn칤 anal칳za kompozice"""
        width, height = image.size
        aspect_ratio = width / height
        
        if aspect_ratio > 1.5:
            return "horizont치ln칤"
        elif aspect_ratio < 0.7:
            return "vertik치ln칤"
        else:
            return "캜tvercov치"

class ArtHistoryKnowledgeBase:
    """Datab치ze znalost칤 d캩jin um캩n칤"""
    
    def __init__(self):
        self.embeddings = OpenAIEmbeddings()
        self.vectorstore = None
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
    
    def create_sample_knowledge_base(self):
        """Vytvo콏en칤 uk치zkov칠 datab치ze znalost칤"""
        sample_texts = [
            """Leonardo da Vinci (1452-1519) byl italsk칳 renesan캜n칤 um캩lec, vyn치lezce a u캜enec. 
            Jeho nejslavn캩j코칤 d칤la zahrnuj칤 Mona Lisu a Posledn칤 ve캜e콏i. Da Vinci byl pr콢kopn칤kem 
            techniky sfumato a anatomick칳ch studi칤. Pracoval ve Florencii, Mil치n캩 a pozd캩ji ve Francii.""",
            
            """Vincent van Gogh (1853-1890) byl holandsk칳 postimpresionistick칳 mal칤콏. 
            Jeho charakteristick칳 styl zahrnuje v칳razn칠 tahy 코t캩tcem a 쬴v칠 barvy. 
            Mezi jeho nejzn치m캩j코칤 d칤la pat콏칤 Hv캩zdn치 noc, Slune캜nice a Autoportr칠ty. 
            B캩hem 쬴vota prodal pouze jeden obraz.""",
            
            """Impresionismus byl um캩leck칳 sm캩r 19. stolet칤, kter칳 se vyzna캜oval zachycen칤m 
            sv캩teln칳ch efekt콢 a atmosf칠ry. Hlavn칤 p콏edstavitel칠 zahrnovali Claude Moneta, 
            Pierre-Auguste Renoira a Edgar Degase. Impresionist칠 캜asto malovali en plein air.""",
            
            """Barokn칤 um캩n칤 (17.-18. stolet칤) se vyzna캜ovalo dramati캜nost칤, pohybem a bohatou 
            ornamentac칤. Vzniklo jako reakce na reformaci a m캩lo podporovat katolickou c칤rkev. 
            V칳znamn칤 barokn칤 um캩lci: Caravaggio, Bernini, Rubens.""",
            
            """Kubismus byl revolucion치rn칤 um캩leck칳 sm캩r za캜치tku 20. stolet칤 zalo쬰n칳 Picassem 
            a Braquem. Charakterizoval se rozkladem objekt콢 na geometrick칠 tvary a zobrazen칤m 
            z v칤ce 칰hl콢 sou캜asn캩. Rozli코ujeme analytick칳 a syntetick칳 kubismus."""
        ]
        
        # Rozd캩len칤 text콢 na men코칤 캜치sti
        documents = []
        for text in sample_texts:
            chunks = self.text_splitter.split_text(text)
            for chunk in chunks:
                documents.append(Document(page_content=chunk))
        
        # Vytvo콏en칤 vektorov칠 datab치ze
        self.vectorstore = Chroma.from_documents(
            documents=documents,
            embedding=self.embeddings,
            persist_directory="./art_history_db"
        )
        
        print(f"Vytvo콏ena datab치ze znalost칤 s {len(documents)} dokumenty")
    
    def add_artwork_to_knowledge_base(self, artwork: ArtworkInfo):
        """P콏id치n칤 um캩leck칠ho d칤la do datab치ze znalost칤"""
        if not self.vectorstore:
            self.create_sample_knowledge_base()
        
        # Vytvo콏en칤 textov칠 reprezentace d칤la
        artwork_text = f"""
        N치zev: {artwork.title}
        Um캩lec: {artwork.artist}
        Rok: {artwork.year}
        Technika: {artwork.medium}
        Rozm캩ry: {artwork.dimensions}
        Lokace: {artwork.location}
        Popis: {artwork.description}
        Styl: {artwork.style}
        Obdob칤: {artwork.period}
        """
        
        # P콏id치n칤 do vektorov칠 datab치ze
        chunks = self.text_splitter.split_text(artwork_text)
        documents = [Document(page_content=chunk) for chunk in chunks]
        
        self.vectorstore.add_documents(documents)
        self.vectorstore.persist()

class ArtHistoryRAGAssistant:
    """Hlavn칤 RAG asistent pro d캩jiny um캩n칤"""
    
    def __init__(self, openai_api_key: str):
        os.environ["OPENAI_API_KEY"] = openai_api_key
        
        self.knowledge_base = ArtHistoryKnowledgeBase()
        self.image_analyzer = ImageAnalyzer()
        self.llm = OpenAI(temperature=0.7, max_tokens=1000)
        
        # Vytvo콏en칤 syst칠mov칠ho promptu
        self.prompt_template = PromptTemplate(
            input_variables=["context", "question"],
            template="""Jsi odborn칳 pr콢vodce d캩jinami um캩n칤 a muzejn칤 asistent. 
            Odpov칤dej v 캜e코tin캩 a poskytuj p콏esn칠, odborn칠 informace.
            
            Kontext z datab치ze znalost칤:
            {context}
            
            Ot치zka n치v코t캩vn칤ka:
            {question}
            
            Odpov캩캞:"""
        )
        
        self.qa_chain = None
    
    def initialize(self):
        """Inicializace RAG syst칠mu"""
        try:
            # Vytvo콏en칤 nebo na캜ten칤 datab치ze znalost칤
            if not os.path.exists("./art_history_db"):
                print("Vytv치콏칤m novou datab치ze znalost칤...")
                self.knowledge_base.create_sample_knowledge_base()
            else:
                print("Na캜칤t치m existuj칤c칤 datab치zi znalost칤...")
                self.knowledge_base.vectorstore = Chroma(
                    persist_directory="./art_history_db",
                    embedding_function=self.knowledge_base.embeddings
                )
            
            # Vytvo콏en칤 QA chain
            self.qa_chain = RetrievalQA.from_chain_type(
                llm=self.llm,
                chain_type="stuff",
                retriever=self.knowledge_base.vectorstore.as_retriever(search_k=3),
                chain_type_kwargs={"prompt": self.prompt_template}
            )
            
            print("RAG asistent inicializov치n 칰sp캩코n캩!")
            
        except Exception as e:
            print(f"Chyba p콏i inicializaci: {e}")
            raise
    
    async def search_and_analyze_artwork(self, query: str) -> Dict:
        """Vyhled치n칤 a anal칳za um캩leck칠ho d칤la"""
        try:
            # Vyhled치n칤 v muzejn칤ch API
            async with MuseumAPIClient() as api_client:
                artworks = await api_client.search_met_museum(query, limit=3)
            
            if not artworks:
                return {
                    "error": "Nenalezena 쮂멳n치 um캩leck치 d칤la pro tento dotaz",
                    "suggestions": ["Zkuste jin칳 vyhled치vac칤 term칤n", "Ov캩콏te spr치vnost n치zvu"]
                }
            
            results = []
            for artwork in artworks:
                # P콏id치n칤 do datab치ze znalost칤
                self.knowledge_base.add_artwork_to_knowledge_base(artwork)
                
                # Anal칳za obr치zku (pokud je k dispozici)
                image_analysis = None
                if artwork.image_url:
                    image_analysis = self.image_analyzer.analyze_artwork_image(artwork.image_url)
                
                # Z칤sk치n칤 kontextov칳ch informac칤 pomoc칤 RAG
                context_info = await self._get_contextual_information(artwork)
                
                results.append({
                    "artwork": artwork.__dict__,
                    "image_analysis": image_analysis,
                    "context": context_info
                })
            
            return {"results": results, "count": len(results)}
            
        except Exception as e:
            return {"error": f"Chyba p콏i vyhled치v치n칤: {str(e)}"}
    
    async def _get_contextual_information(self, artwork: ArtworkInfo) -> str:
        """Z칤sk치n칤 kontextov칳ch informac칤 o um캩leck칠m d칤le"""
        try:
            if not self.qa_chain:
                return "RAG syst칠m nen칤 inicializov치n"
            
            query = f"콎ekni mi v칤ce o um캩lci {artwork.artist} a stylu {artwork.style}"
            response = self.qa_chain.run(query)
            return response
            
        except Exception as e:
            return f"Chyba p콏i z칤sk치v치n칤 kontextu: {str(e)}"
    
    def ask_question(self, question: str) -> str:
        """Odpov캩zen칤 na ot치zku o d캩jin치ch um캩n칤"""
        try:
            if not self.qa_chain:
                return "RAG syst칠m nen칤 inicializov치n. Zavolejte initialize() nejprve."
            
            response = self.qa_chain.run(question)
            return response
            
        except Exception as e:
            return f"Chyba p콏i zpracov치n칤 ot치zky: {str(e)}"
    
    def create_virtual_tour(self, theme: str, artworks: List[ArtworkInfo]) -> Dict:
        """Vytvo콏en칤 virtu치ln칤 prohl칤dky na z치klad캩 t칠matu"""
        try:
            tour_description = f"""
            Virtu치ln칤 prohl칤dka: {theme}
            
            V칤tejte v na코칤 tematick칠 prohl칤dce zam캩콏en칠 na {theme}. 
            B캩hem t칠to prohl칤dky se sezn치m칤te s {len(artworks)} v칳znamn칳mi d칤ly.
            """
            
            tour_stops = []
            for i, artwork in enumerate(artworks, 1):
                # Z칤sk치n칤 kontextov칳ch informac칤
                context_question = f"Vysv캩tli v칳znam d칤la {artwork.title} od {artwork.artist} v kontextu t칠matu {theme}"
                context = self.ask_question(context_question)
                
                stop = {
                    "stop_number": i,
                    "artwork": artwork.__dict__,
                    "commentary": context,
                    "estimated_duration": "5-7 minut"
                }
                tour_stops.append(stop)
            
            return {
                "tour_title": f"Virtu치ln칤 prohl칤dka: {theme}",
                "description": tour_description,
                "total_stops": len(tour_stops),
                "estimated_total_duration": f"{len(tour_stops) * 6} minut",
                "stops": tour_stops
            }
            
        except Exception as e:
            return {"error": f"Chyba p콏i vytv치콏en칤 prohl칤dky: {str(e)}"}

# Uk치zkov칠 pou쬴t칤
async def main():
    """Hlavn칤 funkce demonstruj칤c칤 funkcionalitu syst칠mu"""
    
    # Inicializace (vy쬬duje OpenAI API kl칤캜)
    OPENAI_API_KEY = "your-openai-api-key-here"
    
    if OPENAI_API_KEY == "your-openai-api-key-here":
        print("丘멆잺  Pros칤m nastavte skute캜n칳 OpenAI API kl칤캜")
        return
    
    # Vytvo콏en칤 RAG asistenta
    assistant = ArtHistoryRAGAssistant(OPENAI_API_KEY)
    assistant.initialize()
    
    print("游꿛 Muzejn칤 AI asistent je p콏ipraven!")
    print("=" * 50)
    
    # Uk치zka vyhled치v치n칤 um캩leck칳ch d캩l
    print("\n1. Vyhled치v치n칤 um캩leck칳ch d캩l:")
    search_results = await assistant.search_and_analyze_artwork("Van Gogh")
    
    if "results" in search_results:
        print(f"Nalezeno {search_results['count']} d캩l")
        for i, result in enumerate(search_results["results"][:2], 1):
            artwork = result["artwork"]
            print(f"\n  {i}. {artwork['title']} - {artwork['artist']}")
            if result["image_analysis"]:
                print(f"     Anal칳za: {result['image_analysis'].get('description', 'N/A')}")
    
    # Uk치zka odpov칤d치n칤 na ot치zky
    print("\n2. Odpov칤d치n칤 na odborn칠 ot치zky:")
    questions = [
        "Jak칠 jsou charakteristiky impresionismu?",
        "Kdo byl Leonardo da Vinci?",
        "Co je to kubismus?"
    ]
    
    for question in questions:
        print(f"\nOt치zka: {question}")
        answer = assistant.ask_question(question)
        print(f"Odpov캩캞: {answer[:200]}...")
    
    # Uk치zka vytvo콏en칤 virtu치ln칤 prohl칤dky
    print("\n3. Vytvo콏en칤 virtu치ln칤 prohl칤dky:")
    sample_artworks = [
        ArtworkInfo(
            title="Mona Lisa",
            artist="Leonardo da Vinci",
            year=1506,
            medium="Olej na d콏ev캩",
            dimensions="77 칑 53 cm",
            location="Louvre, Pa콏칤",
            description="Portr칠t Lisy Gherardini",
            style="Renesance",
            period="Vysok치 renesance"
        ),
        ArtworkInfo(
            title="Hv캩zdn치 noc",
            artist="Vincent van Gogh",
            year=1889,
            medium="Olej na pl치tn캩",
            dimensions="73,7 칑 92,1 cm",
            location="Museum of Modern Art, New York",
            description="No캜n칤 krajina s cyp콏i코em",
            style="Postimpresionismus",
            period="19. stolet칤"
        )
    ]
    
    tour = assistant.create_virtual_tour("Mistrovsk치 d칤la z치padn칤ho um캩n칤", sample_artworks)
    
    if "error" not in tour:
        print(f"Prohl칤dka: {tour['tour_title']}")
        print(f"Po캜et zast치vek: {tour['total_stops']}")
        print(f"Odhadovan치 doba: {tour['estimated_total_duration']}")

if __name__ == "__main__":
    # Spu코t캩n칤 uk치zkov칠 aplikace
    asyncio.run(main())
````

## Souhrn projektu

### Hodnota projektu
AI asistent pro d캩jiny um캩n칤 p콏edstavuje revolu캜n칤 n치stroj, kter칳:
- **Demokratizuje odborn칠 znalosti** - Zp콏칤stup켿uje komplexn칤 informace o um캩n칤 코irok칠mu publiku
- **Personalizuje muzejn칤 z치쬴tek** - Vytv치콏칤 individu치ln칤 prohl칤dky podle z치jm콢 n치v코t캩vn칤k콢  
- **Podporuje vzd캩l치v치n칤** - Poskytuje interaktivn칤 platformu pro studium d캩jin um캩n칤
- **Zachov치v치 kulturn칤 d캩dictv칤** - Digitalizuje a strukturuje muzejn칤 sb칤rky

### Kl칤캜ov칠 v칳hody
- **Multimod치ln칤 anal칳za** kombinuj칤c칤 text a obrazy
- **맒치lovateln치 architektura** podporuj칤c칤 roz코칤콏en칤 o dal코칤 muzea
- **P콏esn칠 informace** zalo쬰n칠 na ov캩콏en칳ch muzejn칤ch datech
- **Interaktivn칤 rozhran칤** umo쮄갓j칤c칤 p콏irozen칳 dialog

### Technologick칠 inovace
Projekt vyu쮂셨치 nejmodern캩j코칤 AI technologie v캜etn캩 RAG architektury, po캜칤ta캜ov칠ho vid캩n칤, prirodzen칠ho jazyka a integrace s muzejn칤mi API pro vytvo콏en칤 komplexn칤ho asistenta nov칠 generace.

Tento syst칠m p콏edstavuje budoucnost muzejnictv칤, kde se technologie a um캩n칤 spojuj칤 pro vytvo콏en칤 obohacuj칤c칤ho kulturn칤ho z치쬴tku dostupn칠ho kdykoli a kdekoli.