<small>Claude Sonnet 4 **(AI-Powered Tutor for Math)**</small>
# AI-Powered Tutor for Math

## Key Concepts Explanation

### Step-by-Step Reasoning
Systematic mathematical problem-solving approach where complex problems are broken down into logical, sequential steps, each with clear explanations and justifications, enabling students to understand the underlying thought process and methodology.

### Equation Solving Engine
Advanced computational system that can parse, interpret, and solve various mathematical equations ranging from basic arithmetic to complex calculus, providing detailed solution paths and alternative solving methods.

### Symbolic Mathematics
Computer algebra system capabilities that manipulate mathematical expressions symbolically rather than numerically, allowing for exact solutions, algebraic simplification, and formal mathematical reasoning.

### Adaptive Learning Algorithms
Machine learning techniques that personalize the tutoring experience by analyzing student performance patterns, identifying knowledge gaps, and adjusting difficulty levels and teaching strategies accordingly.

### Mathematical Knowledge Graph
Structured representation of mathematical concepts, their relationships, prerequisites, and learning pathways, enabling intelligent curriculum sequencing and personalized learning recommendations.

### Natural Language Processing for Math
Specialized NLP techniques for understanding mathematical problems expressed in natural language and converting them into formal mathematical representations for computational solving.

## Comprehensive Project Explanation

### Objectives
The AI-Powered Math Tutor aims to provide personalized, intelligent mathematics education that adapts to individual learning styles, provides detailed explanations, and guides students through complex problem-solving processes with the depth and patience of an expert human tutor.

### Key Features
- **Interactive Problem Solving**: Step-by-step guidance through mathematical problems with detailed explanations
- **Multi-Modal Input**: Support for text, images, handwritten equations, and voice input
- **Adaptive Curriculum**: Personalized learning paths based on individual progress and understanding
- **Real-Time Assessment**: Continuous evaluation of student comprehension and skill development
- **Visual Learning Tools**: Dynamic graphs, geometric visualizations, and interactive demonstrations
- **Comprehensive Coverage**: Support for arithmetic through advanced calculus and beyond

### Challenges
- **Mathematical Notation Parsing**: Accurate interpretation of complex mathematical expressions and symbols
- **Pedagogical Reasoning**: Determining optimal teaching strategies for different learning styles
- **Error Analysis**: Identifying and explaining common mathematical mistakes and misconceptions
- **Context Understanding**: Interpreting word problems and real-world mathematical applications
- **Scalability**: Supporting thousands of concurrent users with real-time responsiveness
- **Accuracy Validation**: Ensuring mathematical correctness across all solution methods

### Potential Impact
This system can democratize access to high-quality mathematics education, reduce math anxiety through patient personalized instruction, improve learning outcomes across diverse student populations, and provide teachers with powerful tools for differentiated instruction.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
streamlit==1.29.0
sympy==1.12
matplotlib==3.8.2
plotly==5.17.0
numpy==1.24.3
pandas==2.1.4
scipy==1.11.4
latex2mathml==3.76.0
Pillow==10.1.0
opencv-python==4.8.1.78
pytesseract==0.3.10
wolframalpha==5.0.0
requests==2.31.0
python-dotenv==1.0.0
pydantic==2.5.0
typing-extensions==4.8.0
networkx==3.2.1
beautifulsoup4==4.12.2
lxml==4.9.3
manim==0.17.3
````

### Core Implementation

````python
import os
import re
import json
import logging
import asyncio
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

import sympy as sp
from sympy import symbols, solve, diff, integrate, limit, series, simplify
from sympy.parsing.sympy_parser import parse_expr
from sympy.plotting import plot
import wolframalpha
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
import cv2
import pytesseract
from PIL import Image
import networkx as nx

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DifficultyLevel(Enum):
    ELEMENTARY = "elementary"
    MIDDLE_SCHOOL = "middle_school"
    HIGH_SCHOOL = "high_school"
    COLLEGE = "college"
    ADVANCED = "advanced"

class MathTopics(Enum):
    ARITHMETIC = "arithmetic"
    ALGEBRA = "algebra"
    GEOMETRY = "geometry"
    TRIGONOMETRY = "trigonometry"
    CALCULUS = "calculus"
    STATISTICS = "statistics"
    LINEAR_ALGEBRA = "linear_algebra"
    DISCRETE_MATH = "discrete_math"

class ProblemType(Enum):
    EQUATION = "equation"
    WORD_PROBLEM = "word_problem"
    PROOF = "proof"
    COMPUTATION = "computation"
    GRAPH_ANALYSIS = "graph_analysis"

class LearningStyle(Enum):
    VISUAL = "visual"
    ANALYTICAL = "analytical"
    INTERACTIVE = "interactive"
    STEP_BY_STEP = "step_by_step"

@dataclass
class MathStep:
    step_number: int
    operation: str
    explanation: str
    formula: str
    result: str
    reasoning: str

@dataclass
class ProblemSolution:
    problem: str
    solution_steps: List[MathStep]
    final_answer: str
    alternative_methods: List[str]
    key_concepts: List[str]
    difficulty_level: DifficultyLevel
    topic: MathTopics

@dataclass
class StudentProfile:
    student_id: str
    name: str
    current_level: DifficultyLevel
    strong_topics: List[MathTopics]
    weak_topics: List[MathTopics]
    learning_style: LearningStyle
    performance_history: Dict[str, float]
    last_active: datetime

@dataclass
class LearningSession:
    session_id: str
    student_id: str
    problems_attempted: List[str]
    solutions_provided: List[ProblemSolution]
    performance_score: float
    time_spent: int
    topics_covered: List[MathTopics]
    start_time: datetime

class MathExpressionParser:
    """Parse and interpret mathematical expressions."""
    
    def __init__(self):
        self.common_substitutions = {
            'sqrt': 'sqrt',
            'sin': 'sin',
            'cos': 'cos',
            'tan': 'tan',
            'log': 'log',
            'ln': 'log',
            'exp': 'exp',
            '^': '**',
            'œÄ': 'pi',
            'e': 'E'
        }
    
    def parse_expression(self, expression: str) -> sp.Expr:
        """Parse mathematical expression into SymPy format."""
        try:
            # Clean and normalize expression
            cleaned_expr = self._clean_expression(expression)
            
            # Parse with SymPy
            parsed_expr = parse_expr(cleaned_expr, transformations='all')
            
            return parsed_expr
            
        except Exception as e:
            logger.error(f"Expression parsing error: {e}")
            raise ValueError(f"Could not parse expression: {expression}")
    
    def _clean_expression(self, expression: str) -> str:
        """Clean and normalize mathematical expression."""
        # Remove spaces
        cleaned = expression.replace(' ', '')
        
        # Replace common mathematical notation
        for old, new in self.common_substitutions.items():
            cleaned = cleaned.replace(old, new)
        
        # Add multiplication signs where needed
        cleaned = re.sub(r'(\d)([a-zA-Z])', r'\1*\2', cleaned)
        cleaned = re.sub(r'(\))(\()', r'\1*\2', cleaned)
        cleaned = re.sub(r'(\d)(\()', r'\1*\2', cleaned)
        
        return cleaned
    
    def extract_variables(self, expression: sp.Expr) -> List[sp.Symbol]:
        """Extract variables from expression."""
        return list(expression.free_symbols)
    
    def validate_expression(self, expression: str) -> Tuple[bool, str]:
        """Validate mathematical expression."""
        try:
            self.parse_expression(expression)
            return True, "Valid expression"
        except Exception as e:
            return False, str(e)

class EquationSolver:
    """Solve various types of mathematical equations."""
    
    def __init__(self):
        self.parser = MathExpressionParser()
    
    def solve_equation(self, equation: str, variable: Optional[str] = None) -> Dict[str, Any]:
        """Solve mathematical equation with detailed steps."""
        try:
            # Parse equation
            if '=' in equation:
                left, right = equation.split('=')
                left_expr = self.parser.parse_expression(left)
                right_expr = self.parser.parse_expression(right)
                equation_expr = left_expr - right_expr
            else:
                equation_expr = self.parser.parse_expression(equation)
            
            # Determine variable to solve for
            if variable:
                solve_var = symbols(variable)
            else:
                variables = self.parser.extract_variables(equation_expr)
                if len(variables) == 1:
                    solve_var = variables[0]
                else:
                    solve_var = symbols('x')  # Default
            
            # Solve equation
            solutions = solve(equation_expr, solve_var)
            
            # Generate solution steps
            steps = self._generate_solution_steps(equation_expr, solve_var, solutions)
            
            return {
                'equation': equation,
                'variable': str(solve_var),
                'solutions': [str(sol) for sol in solutions],
                'steps': steps,
                'equation_type': self._classify_equation(equation_expr, solve_var)
            }
            
        except Exception as e:
            logger.error(f"Equation solving error: {e}")
            return {'error': str(e)}
    
    def _generate_solution_steps(self, equation: sp.Expr, variable: sp.Symbol, 
                               solutions: List[sp.Expr]) -> List[MathStep]:
        """Generate step-by-step solution."""
        steps = []
        
        # Step 1: Original equation
        steps.append(MathStep(
            step_number=1,
            operation="Original Equation",
            explanation=f"We need to solve for {variable}",
            formula=str(equation) + " = 0",
            result=str(equation) + " = 0",
            reasoning="Starting with the given equation"
        ))
        
        # Step 2: Simplification (if needed)
        simplified = simplify(equation)
        if simplified != equation:
            steps.append(MathStep(
                step_number=2,
                operation="Simplification",
                explanation="Simplify the equation",
                formula=str(simplified) + " = 0",
                result=str(simplified) + " = 0",
                reasoning="Combining like terms and simplifying"
            ))
        
        # Step 3: Solution method
        equation_type = self._classify_equation(equation, variable)
        
        if equation_type == "linear":
            steps.extend(self._linear_solution_steps(equation, variable, solutions))
        elif equation_type == "quadratic":
            steps.extend(self._quadratic_solution_steps(equation, variable, solutions))
        else:
            steps.extend(self._general_solution_steps(equation, variable, solutions))
        
        return steps
    
    def _classify_equation(self, equation: sp.Expr, variable: sp.Symbol) -> str:
        """Classify the type of equation."""
        degree = sp.degree(equation, variable)
        
        if degree == 1:
            return "linear"
        elif degree == 2:
            return "quadratic"
        elif degree == 3:
            return "cubic"
        else:
            return "general"
    
    def _linear_solution_steps(self, equation: sp.Expr, variable: sp.Symbol, 
                             solutions: List[sp.Expr]) -> List[MathStep]:
        """Generate steps for linear equations."""
        steps = []
        
        # Extract coefficients
        coeffs = sp.Poly(equation, variable).all_coeffs()
        
        if len(coeffs) == 2:  # ax + b = 0
            a, b = coeffs
            
            steps.append(MathStep(
                step_number=len(steps) + 2,
                operation="Isolate variable term",
                explanation=f"Move constant term to the right side",
                formula=f"{a}*{variable} = {-b}",
                result=f"{a}*{variable} = {-b}",
                reasoning="Subtracting constant from both sides"
            ))
            
            if a != 1:
                steps.append(MathStep(
                    step_number=len(steps) + 2,
                    operation="Solve for variable",
                    explanation=f"Divide both sides by {a}",
                    formula=f"{variable} = {-b}/{a}",
                    result=f"{variable} = {solutions[0]}",
                    reasoning="Dividing both sides by coefficient"
                ))
        
        return steps
    
    def _quadratic_solution_steps(self, equation: sp.Expr, variable: sp.Symbol, 
                                solutions: List[sp.Expr]) -> List[MathStep]:
        """Generate steps for quadratic equations."""
        steps = []
        
        # Extract coefficients
        coeffs = sp.Poly(equation, variable).all_coeffs()
        
        if len(coeffs) == 3:  # ax^2 + bx + c = 0
            a, b, c = coeffs
            
            # Check if it can be factored easily
            discriminant = b**2 - 4*a*c
            
            steps.append(MathStep(
                step_number=len(steps) + 2,
                operation="Identify coefficients",
                explanation="For quadratic equation ax¬≤ + bx + c = 0",
                formula=f"a = {a}, b = {b}, c = {c}",
                result=f"a = {a}, b = {b}, c = {c}",
                reasoning="Identifying coefficients for quadratic formula"
            ))
            
            steps.append(MathStep(
                step_number=len(steps) + 2,
                operation="Calculate discriminant",
                explanation="Discriminant = b¬≤ - 4ac",
                formula=f"Œî = {b}¬≤ - 4({a})({c}) = {discriminant}",
                result=f"Œî = {discriminant}",
                reasoning="Discriminant determines number of real solutions"
            ))
            
            steps.append(MathStep(
                step_number=len(steps) + 2,
                operation="Apply quadratic formula",
                explanation="x = (-b ¬± ‚àöŒî) / (2a)",
                formula=f"x = (-{b} ¬± ‚àö{discriminant}) / (2¬∑{a})",
                result=f"x = {solutions[0]} or x = {solutions[1] if len(solutions) > 1 else 'no second solution'}",
                reasoning="Using quadratic formula to find solutions"
            ))
        
        return steps
    
    def _general_solution_steps(self, equation: sp.Expr, variable: sp.Symbol, 
                              solutions: List[sp.Expr]) -> List[MathStep]:
        """Generate steps for general equations."""
        steps = []
        
        steps.append(MathStep(
            step_number=len(steps) + 2,
            operation="Apply solving method",
            explanation="Using appropriate algebraic or numerical methods",
            formula="Various techniques applied",
            result=f"Solutions: {[str(sol) for sol in solutions]}",
            reasoning="Complex equation requiring advanced techniques"
        ))
        
        return steps

class CalculusSolver:
    """Solve calculus problems with step-by-step explanations."""
    
    def __init__(self):
        self.parser = MathExpressionParser()
    
    def differentiate(self, expression: str, variable: str = 'x') -> Dict[str, Any]:
        """Compute derivative with steps."""
        try:
            expr = self.parser.parse_expression(expression)
            var = symbols(variable)
            
            # Compute derivative
            derivative = diff(expr, var)
            
            # Generate steps
            steps = self._generate_derivative_steps(expr, var, derivative)
            
            return {
                'original': str(expr),
                'derivative': str(derivative),
                'steps': steps,
                'variable': variable
            }
            
        except Exception as e:
            logger.error(f"Differentiation error: {e}")
            return {'error': str(e)}
    
    def integrate(self, expression: str, variable: str = 'x', 
                 definite: bool = False, limits: Tuple = None) -> Dict[str, Any]:
        """Compute integral with steps."""
        try:
            expr = self.parser.parse_expression(expression)
            var = symbols(variable)
            
            if definite and limits:
                # Definite integral
                integral_result = integrate(expr, (var, limits[0], limits[1]))
                integral_type = "definite"
            else:
                # Indefinite integral
                integral_result = integrate(expr, var)
                integral_type = "indefinite"
            
            # Generate steps
            steps = self._generate_integration_steps(expr, var, integral_result, integral_type, limits)
            
            return {
                'original': str(expr),
                'integral': str(integral_result),
                'steps': steps,
                'variable': variable,
                'type': integral_type
            }
            
        except Exception as e:
            logger.error(f"Integration error: {e}")
            return {'error': str(e)}
    
    def _generate_derivative_steps(self, expr: sp.Expr, variable: sp.Symbol, 
                                 derivative: sp.Expr) -> List[MathStep]:
        """Generate derivative calculation steps."""
        steps = []
        
        steps.append(MathStep(
            step_number=1,
            operation="Function to differentiate",
            explanation=f"Find d/d{variable} of the given function",
            formula=f"f({variable}) = {expr}",
            result=f"f({variable}) = {expr}",
            reasoning="Starting with the original function"
        ))
        
        # Analyze function structure for appropriate rules
        if expr.is_Add:
            steps.append(MathStep(
                step_number=2,
                operation="Sum rule",
                explanation="Derivative of sum equals sum of derivatives",
                formula="d/dx[f(x) + g(x)] = f'(x) + g'(x)",
                result="Apply sum rule to each term",
                reasoning="Using linearity of differentiation"
            ))
        
        if expr.has(sp.sin, sp.cos, sp.tan):
            steps.append(MathStep(
                step_number=len(steps) + 1,
                operation="Trigonometric rules",
                explanation="Apply trigonometric differentiation rules",
                formula="d/dx[sin(x)] = cos(x), d/dx[cos(x)] = -sin(x)",
                result="Apply appropriate trig derivatives",
                reasoning="Using standard trigonometric derivatives"
            ))
        
        steps.append(MathStep(
            step_number=len(steps) + 1,
            operation="Final result",
            explanation="Simplified derivative",
            formula=f"f'({variable}) = {derivative}",
            result=f"f'({variable}) = {derivative}",
            reasoning="Final answer after applying all rules"
        ))
        
        return steps
    
    def _generate_integration_steps(self, expr: sp.Expr, variable: sp.Symbol, 
                                  integral: sp.Expr, integral_type: str, 
                                  limits: Tuple = None) -> List[MathStep]:
        """Generate integration calculation steps."""
        steps = []
        
        if integral_type == "indefinite":
            steps.append(MathStep(
                step_number=1,
                operation="Indefinite integral",
                explanation=f"Find ‚à´ {expr} d{variable}",
                formula=f"‚à´ {expr} d{variable}",
                result=f"‚à´ {expr} d{variable}",
                reasoning="Finding the antiderivative"
            ))
        else:
            steps.append(MathStep(
                step_number=1,
                operation="Definite integral",
                explanation=f"Evaluate ‚à´[{limits[0]} to {limits[1]}] {expr} d{variable}",
                formula=f"‚à´[{limits[0]}‚Üí{limits[1]}] {expr} d{variable}",
                result=f"‚à´[{limits[0]}‚Üí{limits[1]}] {expr} d{variable}",
                reasoning="Evaluating definite integral over given bounds"
            ))
        
        # Add integration technique steps based on expression type
        if expr.is_polynomial():
            steps.append(MathStep(
                step_number=2,
                operation="Power rule",
                explanation="Use power rule: ‚à´ x^n dx = x^(n+1)/(n+1) + C",
                formula="‚à´ x^n dx = x^(n+1)/(n+1) + C",
                result="Apply power rule to each term",
                reasoning="Using fundamental power rule for integration"
            ))
        
        steps.append(MathStep(
            step_number=len(steps) + 1,
            operation="Final result",
            explanation="Final answer" + (" after evaluation" if integral_type == "definite" else " with constant of integration"),
            formula=str(integral) + ("" if integral_type == "definite" else " + C"),
            result=str(integral) + ("" if integral_type == "definite" else " + C"),
            reasoning="Complete solution"
        ))
        
        return steps

class WordProblemSolver:
    """Solve mathematical word problems using LLM reasoning."""
    
    def __init__(self, llm: ChatOpenAI):
        self.llm = llm
        self.equation_solver = EquationSolver()
        
        self.word_problem_prompt = ChatPromptTemplate.from_template("""
        Solve this mathematical word problem step by step:
        
        Problem: {problem}
        
        Please provide:
        1. Problem understanding - what is being asked
        2. Given information - what data is provided
        3. Mathematical setup - what equations or formulas to use
        4. Solution steps - detailed calculation process
        5. Final answer - clear conclusion with units if applicable
        6. Verification - check if the answer makes sense
        
        Format your response clearly with numbered steps.
        
        Solution:
        """)
    
    def solve_word_problem(self, problem: str) -> Dict[str, Any]:
        """Solve word problem with detailed explanation."""
        try:
            # Use LLM to analyze and solve
            response = self.llm.invoke(self.word_problem_prompt.format(problem=problem))
            
            # Extract mathematical expressions for computation
            equations = self._extract_equations(response.content)
            
            # Solve extracted equations
            computational_results = []
            for eq in equations:
                result = self.equation_solver.solve_equation(eq)
                if 'error' not in result:
                    computational_results.append(result)
            
            return {
                'problem': problem,
                'llm_solution': response.content,
                'extracted_equations': equations,
                'computational_results': computational_results,
                'problem_type': self._classify_word_problem(problem)
            }
            
        except Exception as e:
            logger.error(f"Word problem solving error: {e}")
            return {'error': str(e)}
    
    def _extract_equations(self, solution_text: str) -> List[str]:
        """Extract mathematical equations from solution text."""
        # Pattern to find equations
        equation_patterns = [
            r'[a-zA-Z0-9\+\-\*\/\^\(\)\s]*=\s*[a-zA-Z0-9\+\-\*\/\^\(\)\s]*',
            r'\$[^$]*\$',  # LaTeX math
            r'\\begin\{equation\}.*?\\end\{equation\}',  # LaTeX equations
        ]
        
        equations = []
        for pattern in equation_patterns:
            matches = re.findall(pattern, solution_text, re.DOTALL)
            equations.extend(matches)
        
        # Clean equations
        cleaned_equations = []
        for eq in equations:
            cleaned = eq.strip().replace('$', '').replace('\\', '')
            if '=' in cleaned and len(cleaned) > 3:
                cleaned_equations.append(cleaned)
        
        return cleaned_equations[:5]  # Limit to first 5 equations
    
    def _classify_word_problem(self, problem: str) -> str:
        """Classify the type of word problem."""
        problem_lower = problem.lower()
        
        if any(word in problem_lower for word in ['rate', 'speed', 'distance', 'time']):
            return "motion"
        elif any(word in problem_lower for word in ['percent', 'interest', 'discount']):
            return "percentage"
        elif any(word in problem_lower for word in ['mixture', 'solution', 'concentration']):
            return "mixture"
        elif any(word in problem_lower for word in ['age', 'years old', 'birthday']):
            return "age"
        elif any(word in problem_lower for word in ['area', 'perimeter', 'volume', 'length', 'width']):
            return "geometry"
        else:
            return "general"

class MathVisualizer:
    """Create visualizations for mathematical concepts."""
    
    def __init__(self):
        self.colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']
    
    def plot_function(self, expression: str, x_range: Tuple[float, float] = (-10, 10), 
                     variable: str = 'x') -> go.Figure:
        """Plot mathematical function."""
        try:
            # Parse expression
            parser = MathExpressionParser()
            expr = parser.parse_expression(expression)
            var = symbols(variable)
            
            # Generate points
            x_vals = np.linspace(x_range[0], x_range[1], 1000)
            y_vals = []
            
            # Convert to numerical function
            func = sp.lambdify(var, expr, 'numpy')
            
            for x_val in x_vals:
                try:
                    y_val = func(x_val)
                    if np.isfinite(y_val):
                        y_vals.append(y_val)
                    else:
                        y_vals.append(None)
                except:
                    y_vals.append(None)
            
            # Create plot
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=x_vals,
                y=y_vals,
                mode='lines',
                name=f'f({variable}) = {expression}',
                line=dict(color=self.colors[0], width=2)
            ))
            
            fig.update_layout(
                title=f'Graph of f({variable}) = {expression}',
                xaxis_title=variable,
                yaxis_title=f'f({variable})',
                hovermode='x unified',
                showlegend=True,
                grid=True
            )
            
            return fig
            
        except Exception as e:
            logger.error(f"Plotting error: {e}")
            # Return empty figure with error message
            fig = go.Figure()
            fig.add_annotation(
                text=f"Error plotting function: {str(e)}",
                xref="paper", yref="paper",
                x=0.5, y=0.5, showarrow=False
            )
            return fig
    
    def plot_derivative(self, expression: str, x_range: Tuple[float, float] = (-10, 10)) -> go.Figure:
        """Plot function and its derivative."""
        try:
            parser = MathExpressionParser()
            expr = parser.parse_expression(expression)
            x = symbols('x')
            
            # Calculate derivative
            derivative = diff(expr, x)
            
            # Create numerical functions
            func = sp.lambdify(x, expr, 'numpy')
            deriv_func = sp.lambdify(x, derivative, 'numpy')
            
            # Generate points
            x_vals = np.linspace(x_range[0], x_range[1], 1000)
            
            try:
                y_vals = func(x_vals)
                dy_vals = deriv_func(x_vals)
            except:
                y_vals = [func(x_val) if np.isfinite(func(x_val)) else None for x_val in x_vals]
                dy_vals = [deriv_func(x_val) if np.isfinite(deriv_func(x_val)) else None for x_val in x_vals]
            
            # Create plot
            fig = go.Figure()
            
            fig.add_trace(go.Scatter(
                x=x_vals, y=y_vals,
                mode='lines',
                name=f'f(x) = {expression}',
                line=dict(color=self.colors[0], width=2)
            ))
            
            fig.add_trace(go.Scatter(
                x=x_vals, y=dy_vals,
                mode='lines',
                name=f"f'(x) = {derivative}",
                line=dict(color=self.colors[1], width=2)
            ))
            
            fig.update_layout(
                title=f'Function and Derivative',
                xaxis_title='x',
                yaxis_title='y',
                hovermode='x unified',
                showlegend=True
            )
            
            return fig
            
        except Exception as e:
            logger.error(f"Derivative plotting error: {e}")
            return go.Figure()
    
    def create_step_visualization(self, steps: List[MathStep]) -> go.Figure:
        """Create visualization of solution steps."""
        step_numbers = [step.step_number for step in steps]
        operations = [step.operation for step in steps]
        
        fig = go.Figure(data=go.Scatter(
            x=step_numbers,
            y=list(range(len(steps))),
            mode='markers+text',
            text=operations,
            textposition='middle right',
            marker=dict(size=15, color=self.colors[0])
        ))
        
        fig.update_layout(
            title='Solution Steps',
            xaxis_title='Step Number',
            yaxis=dict(showticklabels=False),
            height=max(300, len(steps) * 50)
        )
        
        return fig

class AdaptiveTutor:
    """Main AI tutor that adapts to student needs."""
    
    def __init__(self, openai_api_key: str, wolfram_api_key: str = None):
        self.llm = ChatOpenAI(
            temperature=0.1, 
            model_name="gpt-4", 
            openai_api_key=openai_api_key
        )
        
        # Initialize components
        self.equation_solver = EquationSolver()
        self.calculus_solver = CalculusSolver()
        self.word_problem_solver = WordProblemSolver(self.llm)
        self.visualizer = MathVisualizer()
        
        # Wolfram Alpha client (optional)
        if wolfram_api_key:
            self.wolfram_client = wolframalpha.Client(wolfram_api_key)
        else:
            self.wolfram_client = None
        
        # Student profiles
        self.student_profiles = {}
        
        # Tutoring prompts
        self.explanation_prompt = ChatPromptTemplate.from_template("""
        As an expert math tutor, explain the following mathematical concept to a {level} student:
        
        Topic: {topic}
        Specific Question: {question}
        Student's Learning Style: {learning_style}
        
        Provide:
        1. Clear, age-appropriate explanation
        2. Relevant examples
        3. Common misconceptions to avoid
        4. Practice suggestions
        5. Connections to real-world applications
        
        Make the explanation engaging and easy to understand.
        
        Explanation:
        """)
    
    def solve_problem(self, problem: str, problem_type: ProblemType, 
                     student_id: str = None) -> Dict[str, Any]:
        """Solve mathematical problem with appropriate method."""
        try:
            if problem_type == ProblemType.EQUATION:
                result = self.equation_solver.solve_equation(problem)
            elif problem_type == ProblemType.WORD_PROBLEM:
                result = self.word_problem_solver.solve_word_problem(problem)
            elif problem_type == ProblemType.COMPUTATION:
                # Handle calculus problems
                if any(keyword in problem.lower() for keyword in ['derivative', 'differentiate', "d/dx"]):
                    # Extract expression from problem
                    expr = self._extract_expression_from_problem(problem)
                    result = self.calculus_solver.differentiate(expr)
                elif any(keyword in problem.lower() for keyword in ['integral', 'integrate', 'antiderivative']):
                    expr = self._extract_expression_from_problem(problem)
                    result = self.calculus_solver.integrate(expr)
                else:
                    result = self.equation_solver.solve_equation(problem)
            else:
                # Use LLM for general problems
                result = self._solve_with_llm(problem, problem_type)
            
            # Update student profile if provided
            if student_id and student_id in self.student_profiles:
                self._update_student_progress(student_id, problem, result)
            
            return result
            
        except Exception as e:
            logger.error(f"Problem solving error: {e}")
            return {'error': str(e)}
    
    def explain_concept(self, topic: str, question: str, student_id: str = None) -> str:
        """Provide detailed explanation of mathematical concept."""
        try:
            # Get student profile for personalization
            level = "high school"
            learning_style = "step by step"
            
            if student_id and student_id in self.student_profiles:
                profile = self.student_profiles[student_id]
                level = profile.current_level.value
                learning_style = profile.learning_style.value
            
            # Generate explanation
            response = self.llm.invoke(self.explanation_prompt.format(
                level=level,
                topic=topic,
                question=question,
                learning_style=learning_style
            ))
            
            return response.content
            
        except Exception as e:
            logger.error(f"Explanation error: {e}")
            return "I'm sorry, I couldn't generate an explanation for this topic."
    
    def create_student_profile(self, student_id: str, name: str, 
                             level: DifficultyLevel, 
                             learning_style: LearningStyle) -> StudentProfile:
        """Create new student profile."""
        profile = StudentProfile(
            student_id=student_id,
            name=name,
            current_level=level,
            strong_topics=[],
            weak_topics=[],
            learning_style=learning_style,
            performance_history={},
            last_active=datetime.now()
        )
        
        self.student_profiles[student_id] = profile
        return profile
    
    def get_personalized_problems(self, student_id: str, topic: MathTopics, 
                                count: int = 5) -> List[str]:
        """Generate personalized practice problems."""
        if student_id not in self.student_profiles:
            return []
        
        profile = self.student_profiles[student_id]
        
        # Problem difficulty based on student level and performance
        difficulty_map = {
            DifficultyLevel.ELEMENTARY: "elementary",
            DifficultyLevel.MIDDLE_SCHOOL: "middle school",
            DifficultyLevel.HIGH_SCHOOL: "high school",
            DifficultyLevel.COLLEGE: "college",
            DifficultyLevel.ADVANCED: "advanced"
        }
        
        difficulty = difficulty_map[profile.current_level]
        
        # Generate problems using LLM
        problem_prompt = f"""
        Generate {count} {difficulty} level math problems for the topic: {topic.value}.
        
        Make the problems:
        1. Appropriate for {difficulty} level
        2. Progressively challenging
        3. Varied in format
        4. Clear and well-structured
        
        Return only the problems, one per line.
        """
        
        try:
            response = self.llm.invoke(problem_prompt)
            problems = [p.strip() for p in response.content.split('\n') if p.strip()]
            return problems[:count]
        except Exception as e:
            logger.error(f"Problem generation error: {e}")
            return []
    
    def _extract_expression_from_problem(self, problem: str) -> str:
        """Extract mathematical expression from problem text."""
        # Simple extraction - look for expressions after keywords
        keywords = ['differentiate', 'integrate', 'derivative of', 'integral of']
        
        for keyword in keywords:
            if keyword in problem.lower():
                # Find text after keyword
                start_idx = problem.lower().find(keyword) + len(keyword)
                remaining = problem[start_idx:].strip()
                
                # Extract until punctuation
                expr_match = re.search(r'^[^.!?]*', remaining)
                if expr_match:
                    return expr_match.group().strip()
        
        # Fallback: return entire problem
        return problem
    
    def _solve_with_llm(self, problem: str, problem_type: ProblemType) -> Dict[str, Any]:
        """Solve problem using LLM reasoning."""
        prompt = f"""
        Solve this {problem_type.value} step by step:
        
        Problem: {problem}
        
        Provide detailed solution with clear steps and final answer.
        """
        
        try:
            response = self.llm.invoke(prompt)
            return {
                'problem': problem,
                'solution': response.content,
                'method': 'llm_reasoning'
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _update_student_progress(self, student_id: str, problem: str, result: Dict[str, Any]):
        """Update student performance tracking."""
        if student_id in self.student_profiles:
            profile = self.student_profiles[student_id]
            
            # Simple scoring based on whether solution was found
            score = 1.0 if 'error' not in result else 0.0
            
            # Update performance history
            topic = "general"  # Would determine actual topic
            if topic not in profile.performance_history:
                profile.performance_history[topic] = []
            
            profile.performance_history[topic].append(score)
            profile.last_active = datetime.now()

def create_sample_problems() -> List[Dict[str, Any]]:
    """Create sample math problems for demonstration."""
    return [
        {
            'problem': 'Solve for x: 2x + 5 = 13',
            'type': ProblemType.EQUATION,
            'topic': MathTopics.ALGEBRA,
            'difficulty': DifficultyLevel.MIDDLE_SCHOOL
        },
        {
            'problem': 'Find the derivative of x^3 + 2x^2 - 5x + 1',
            'type': ProblemType.COMPUTATION,
            'topic': MathTopics.CALCULUS,
            'difficulty': DifficultyLevel.HIGH_SCHOOL
        },
        {
            'problem': 'A train travels 240 miles in 4 hours. What is its average speed?',
            'type': ProblemType.WORD_PROBLEM,
            'topic': MathTopics.ARITHMETIC,
            'difficulty': DifficultyLevel.MIDDLE_SCHOOL
        },
        {
            'problem': 'Solve the quadratic equation: x^2 - 5x + 6 = 0',
            'type': ProblemType.EQUATION,
            'topic': MathTopics.ALGEBRA,
            'difficulty': DifficultyLevel.HIGH_SCHOOL
        }
    ]

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="AI Math Tutor",
        page_icon="üßÆ",
        layout="wide"
    )
    
    st.title("üßÆ AI-Powered Math Tutor")
    st.markdown("Intelligent mathematics education with step-by-step reasoning")
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        openai_api_key = st.text_input("OpenAI API Key", type="password")
        wolfram_api_key = st.text_input("Wolfram Alpha API Key (optional)", type="password")
        
        st.header("üë§ Student Profile")
        student_name = st.text_input("Student Name", value="John Doe")
        student_level = st.selectbox("Level", [level.value.title() for level in DifficultyLevel])
        learning_style = st.selectbox("Learning Style", [style.value.title() for style in LearningStyle])
        
        if st.button("üìù Create/Update Profile"):
            st.session_state['student_profile'] = {
                'name': student_name,
                'level': student_level.lower(),
                'learning_style': learning_style.lower()
            }
            st.success("Profile updated!")
        
        st.header("üìö Quick Access")
        if st.button("üìä Load Sample Problems"):
            st.session_state['sample_problems'] = create_sample_problems()
            st.success("Sample problems loaded!")
    
    if not openai_api_key:
        st.warning("Please enter your OpenAI API key in the sidebar to continue.")
        return
    
    # Initialize tutor
    try:
        tutor = AdaptiveTutor(openai_api_key, wolfram_api_key)
    except Exception as e:
        st.error(f"Error initializing tutor: {e}")
        return
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "üî¢ Problem Solver",
        "üìö Learn Concepts", 
        "üìä Visualizations",
        "üìà Progress Tracking",
        "üéØ Practice Problems"
    ])
    
    with tab1:
        st.header("üî¢ Mathematical Problem Solver")
        
        # Problem input
        st.subheader("Enter Your Problem")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            problem_text = st.text_area(
                "Math Problem",
                placeholder="Enter your mathematical problem here...",
                height=100
            )
        
        with col2:
            problem_type = st.selectbox(
                "Problem Type",
                [ptype.value.title() for ptype in ProblemType]
            )
            
            solve_button = st.button("üöÄ Solve Problem", type="primary")
        
        # Sample problems
        if 'sample_problems' in st.session_state:
            st.subheader("üìù Sample Problems")
            
            for i, sample in enumerate(st.session_state['sample_problems']):
                if st.button(f"üìå {sample['problem'][:50]}...", key=f"sample_{i}"):
                    problem_text = sample['problem']
                    st.session_state['current_problem'] = problem_text
                    st.rerun()
        
        # Solve problem
        if solve_button and problem_text:
            with st.spinner("Solving problem..."):
                try:
                    problem_type_enum = ProblemType(problem_type.lower().replace(' ', '_'))
                    
                    result = tutor.solve_problem(
                        problem_text, 
                        problem_type_enum,
                        st.session_state.get('student_profile', {}).get('name', 'default')
                    )
                    
                    st.session_state['current_solution'] = result
                    
                except Exception as e:
                    st.error(f"Error solving problem: {e}")
        
        # Display solution
        if 'current_solution' in st.session_state:
            solution = st.session_state['current_solution']
            
            if 'error' in solution:
                st.error(f"Error: {solution['error']}")
            else:
                st.subheader("‚úÖ Solution")
                
                # Equation solutions
                if 'solutions' in solution:
                    st.success(f"**Solutions:** {', '.join(solution['solutions'])}")
                    
                    if 'steps' in solution:
                        st.subheader("üìã Step-by-Step Solution")
                        
                        for step in solution['steps']:
                            with st.expander(f"Step {step.step_number}: {step.operation}"):
                                st.write(f"**Explanation:** {step.explanation}")
                                st.code(step.formula, language='latex')
                                st.write(f"**Result:** {step.result}")
                                st.info(f"üí° {step.reasoning}")
                
                # Calculus solutions
                elif 'derivative' in solution:
                    st.success(f"**Derivative:** {solution['derivative']}")
                    
                    if 'steps' in solution:
                        st.subheader("üìã Differentiation Steps")
                        for step in solution['steps']:
                            with st.expander(f"Step {step.step_number}: {step.operation}"):
                                st.write(step.explanation)
                                st.code(step.formula, language='latex')
                
                elif 'integral' in solution:
                    st.success(f"**Integral:** {solution['integral']}")
                    
                    if 'steps' in solution:
                        st.subheader("üìã Integration Steps")
                        for step in solution['steps']:
                            with st.expander(f"Step {step.step_number}: {step.operation}"):
                                st.write(step.explanation)
                                st.code(step.formula, language='latex')
                
                # Word problem solutions
                elif 'llm_solution' in solution:
                    st.markdown(solution['llm_solution'])
                    
                    if solution.get('extracted_equations'):
                        st.subheader("üîç Extracted Equations")
                        for eq in solution['extracted_equations']:
                            st.code(eq, language='latex')
                
                # General LLM solutions
                elif 'solution' in solution:
                    st.markdown(solution['solution'])
    
    with tab2:
        st.header("üìö Learn Mathematical Concepts")
        
        # Concept explanation
        st.subheader("Ask About Math Concepts")
        
        col1, col2 = st.columns(2)
        
        with col1:
            topic = st.selectbox("Topic", [topic.value.title() for topic in MathTopics])
        
        with col2:
            question = st.text_input("Specific Question", placeholder="What would you like to learn about?")
        
        if st.button("üéì Get Explanation") and question:
            with st.spinner("Generating explanation..."):
                try:
                    student_id = st.session_state.get('student_profile', {}).get('name', 'default')
                    explanation = tutor.explain_concept(topic, question, student_id)
                    
                    st.subheader("üìñ Explanation")
                    st.markdown(explanation)
                    
                except Exception as e:
                    st.error(f"Error generating explanation: {e}")
        
        # Common topics
        st.subheader("üîç Common Topics")
        
        common_topics = [
            ("Algebra", "How do I solve linear equations?"),
            ("Calculus", "What is a derivative and how do I find it?"),
            ("Geometry", "How do I calculate the area of a circle?"),
            ("Trigonometry", "What are sine, cosine, and tangent?"),
            ("Statistics", "How do I calculate mean, median, and mode?")
        ]
        
        for topic_name, sample_question in common_topics:
            if st.button(f"üìå {topic_name}: {sample_question}", key=f"topic_{topic_name}"):
                with st.spinner("Generating explanation..."):
                    try:
                        explanation = tutor.explain_concept(topic_name, sample_question)
                        st.subheader(f"üìñ {topic_name} Explanation")
                        st.markdown(explanation)
                    except Exception as e:
                        st.error(f"Error: {e}")
    
    with tab3:
        st.header("üìä Mathematical Visualizations")
        
        # Function plotting
        st.subheader("üìà Function Plotter")
        
        col1, col2 = st.columns(2)
        
        with col1:
            func_expression = st.text_input("Function", value="x^2 + 2*x - 3", placeholder="Enter function (e.g., x^2 + 2*x - 3)")
            x_min = st.number_input("X Min", value=-10.0)
            x_max = st.number_input("X Max", value=10.0)
        
        with col2:
            plot_type = st.selectbox("Plot Type", ["Function Only", "Function + Derivative", "Function + Integral"])
            
            if st.button("üìä Generate Plot"):
                try:
                    if plot_type == "Function Only":
                        fig = tutor.visualizer.plot_function(func_expression, (x_min, x_max))
                    elif plot_type == "Function + Derivative":
                        fig = tutor.visualizer.plot_derivative(func_expression, (x_min, x_max))
                    else:
                        fig = tutor.visualizer.plot_function(func_expression, (x_min, x_max))
                    
                    st.plotly_chart(fig, use_container_width=True)
                    
                except Exception as e:
                    st.error(f"Plotting error: {e}")
        
        # Pre-made visualizations
        st.subheader("üéØ Common Functions")
        
        common_functions = [
            ("Linear: y = 2x + 1", "2*x + 1"),
            ("Quadratic: y = x¬≤ - 4", "x**2 - 4"),
            ("Cubic: y = x¬≥ - 3x", "x**3 - 3*x"),
            ("Exponential: y = e^x", "exp(x)"),
            ("Logarithmic: y = ln(x)", "log(x)"),
            ("Trigonometric: y = sin(x)", "sin(x)")
        ]
        
        cols = st.columns(3)
        
        for i, (name, expr) in enumerate(common_functions):
            with cols[i % 3]:
                if st.button(name, key=f"func_{i}"):
                    try:
                        fig = tutor.visualizer.plot_function(expr, (-10, 10))
                        st.plotly_chart(fig, use_container_width=True)
                    except Exception as e:
                        st.error(f"Error: {e}")
    
    with tab4:
        st.header("üìà Progress Tracking")
        
        if 'student_profile' in st.session_state:
            profile = st.session_state['student_profile']
            
            # Student overview
            st.subheader("üë§ Student Overview")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("Student", profile['name'])
            with col2:
                st.metric("Level", profile['level'].title())
            with col3:
                st.metric("Learning Style", profile['learning_style'].title())
            
            # Mock performance data
            st.subheader("üìä Performance Analytics")
            
            # Topic performance
            topic_performance = pd.DataFrame({
                'Topic': ['Algebra', 'Calculus', 'Geometry', 'Statistics'],
                'Score': [85, 72, 90, 78],
                'Problems Solved': [15, 8, 12, 10]
            })
            
            col1, col2 = st.columns(2)
            
            with col1:
                fig = px.bar(topic_performance, x='Topic', y='Score', 
                           title="Performance by Topic",
                           color='Score', color_continuous_scale='RdYlGn')
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                fig = px.pie(topic_performance, values='Problems Solved', names='Topic',
                           title="Problems Solved by Topic")
                st.plotly_chart(fig, use_container_width=True)
            
            # Progress over time
            st.subheader("üìà Progress Over Time")
            
            progress_data = pd.DataFrame({
                'Date': pd.date_range('2024-01-01', periods=30, freq='D'),
                'Daily Score': np.random.normal(75, 10, 30).clip(0, 100),
                'Cumulative Average': np.cumsum(np.random.normal(75, 10, 30).clip(0, 100)) / np.arange(1, 31)
            })
            
            fig = px.line(progress_data, x='Date', y=['Daily Score', 'Cumulative Average'],
                         title="Learning Progress Over Time")
            st.plotly_chart(fig, use_container_width=True)
            
            # Recommendations
            st.subheader("üí° Personalized Recommendations")
            
            recommendations = [
                "Focus on integration techniques in Calculus",
                "Practice more word problems in Algebra",
                "Review geometric proof methods",
                "Strengthen statistical analysis skills"
            ]
            
            for i, rec in enumerate(recommendations, 1):
                st.info(f"{i}. {rec}")
        
        else:
            st.info("Create a student profile in the sidebar to track progress.")
    
    with tab5:
        st.header("üéØ Practice Problems")
        
        # Generate practice problems
        st.subheader("üìù Personalized Practice")
        
        col1, col2 = st.columns(2)
        
        with col1:
            practice_topic = st.selectbox("Topic", [topic.value.title() for topic in MathTopics], key="practice_topic")
            num_problems = st.slider("Number of Problems", 1, 10, 5)
        
        with col2:
            if st.button("üé≤ Generate Problems"):
                with st.spinner("Generating practice problems..."):
                    try:
                        student_id = st.session_state.get('student_profile', {}).get('name', 'default')
                        topic_enum = MathTopics(practice_topic.lower())
                        
                        problems = tutor.get_personalized_problems(student_id, topic_enum, num_problems)
                        st.session_state['practice_problems'] = problems
                        
                        if problems:
                            st.success(f"Generated {len(problems)} problems!")
                        else:
                            st.warning("Could not generate problems. Please check your API key.")
                            
                    except Exception as e:
                        st.error(f"Error generating problems: {e}")
        
        # Display practice problems
        if 'practice_problems' in st.session_state:
            st.subheader("üìã Practice Problems")
            
            for i, problem in enumerate(st.session_state['practice_problems'], 1):
                with st.expander(f"Problem {i}"):
                    st.write(problem)
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        if st.button(f"üí° Get Hint", key=f"hint_{i}"):
                            hint = f"Try breaking down problem {i} into smaller steps."
                            st.info(hint)
                    
                    with col2:
                        if st.button(f"‚úÖ Show Solution", key=f"solution_{i}"):
                            try:
                                # Determine problem type and solve
                                if '=' in problem:
                                    problem_type = ProblemType.EQUATION
                                elif any(word in problem.lower() for word in ['derivative', 'differentiate']):
                                    problem_type = ProblemType.COMPUTATION
                                else:
                                    problem_type = ProblemType.WORD_PROBLEM
                                
                                solution = tutor.solve_problem(problem, problem_type)
                                
                                if 'error' not in solution:
                                    st.success("Solution generated!")
                                    # Display abbreviated solution
                                    if 'solutions' in solution:
                                        st.write(f"**Answer:** {', '.join(solution['solutions'])}")
                                    elif 'llm_solution' in solution:
                                        # Show first few lines of solution
                                        lines = solution['llm_solution'].split('\n')[:3]
                                        st.write('\n'.join(lines) + "...")
                                else:
                                    st.error("Could not solve this problem.")
                                    
                            except Exception as e:
                                st.error(f"Error: {e}")
        
        # Problem difficulty adjustment
        st.subheader("‚öôÔ∏è Difficulty Settings")
        
        if 'student_profile' in st.session_state:
            current_level = st.session_state['student_profile']['level']
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.write(f"**Current Level:** {current_level.title()}")
                
                if st.button("üìà Increase Difficulty"):
                    st.success("Difficulty increased! Next problems will be more challenging.")
            
            with col2:
                if st.button("üìâ Decrease Difficulty"):
                    st.success("Difficulty decreased! Next problems will be easier.")
                    
                if st.button("üîÑ Reset to Optimal"):
                    st.info("Difficulty reset to optimal level based on performance.")

if __name__ == "__main__":
    main()
````

### Environment Configuration

````python
OPENAI_API_KEY=your_openai_api_key_here
WOLFRAM_ALPHA_APP_ID=your_wolfram_alpha_app_id_here
````

## Project Summary

The AI-Powered Math Tutor represents a comprehensive educational platform that revolutionizes mathematics learning through intelligent, personalized instruction. By combining advanced symbolic computation, LLM reasoning, and adaptive learning algorithms, it provides students with patient, expert-level tutoring that adapts to individual learning styles and progress.

### Key Value Propositions:
- **Step-by-Step Reasoning**: Detailed solution paths that help students understand mathematical thinking processes
- **Adaptive Learning**: Personalized instruction that adjusts to individual student needs and progress
- **Comprehensive Coverage**: Support for mathematics from elementary arithmetic through advanced calculus
- **Visual Learning Tools**: Interactive graphs and visualizations that enhance mathematical understanding
- **Real-Time Assessment**: Continuous evaluation and feedback to optimize learning outcomes

### Technical Highlights:
- SymPy integration for exact symbolic mathematical computation and equation solving
- Advanced NLP for interpreting word problems and converting natural language to mathematical expressions
- LLM-powered explanations that provide contextual, pedagogically sound instruction
- Dynamic visualization system using Plotly for interactive mathematical graphs and demonstrations
- Adaptive algorithms that track student progress and adjust difficulty levels accordingly
- Modular architecture supporting integration with external computational engines like Wolfram Alpha

This system demonstrates how AI can democratize access to high-quality mathematics education, providing every student with a patient, knowledgeable tutor available 24/7 to guide them through their mathematical learning journey.