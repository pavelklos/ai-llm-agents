<small>Claude Sonnet 4 **(Codebase Companion pro v√Ωvoj√°≈ôe - AI-LLM MCP projekt)**</small>
# Codebase Companion for Developers

## 1. N√°zev projektu

**Codebase Companion** - Inteligentn√≠ asistent pro v√Ωvoj√°≈ôe vyu≈æ√≠vaj√≠c√≠ Model Context Protocol (MCP) pro pokroƒçilou anal√Ωzu a interakci s k√≥dem

## 2. Vysvƒõtlen√≠ kl√≠ƒçov√Ωch koncept≈Ø

### **Model Context Protocol (MCP)**
Protokol vyvinut√Ω spoleƒçnost√≠ Anthropic pro standardizovanou komunikaci mezi AI modely a extern√≠mi syst√©my. Umo≈æ≈àuje AI p≈ô√≠stup k lok√°ln√≠m zdroj≈Øm, datab√°z√≠m a slu≈æb√°m bezpeƒçn√Ωm zp≈Øsobem.

### **LangChain**
Framework pro v√Ωvoj aplikac√≠ s velk√Ωmi jazykov√Ωmi modely (LLM). Poskytuje n√°stroje pro ≈ôetƒõzen√≠ operac√≠, spr√°vu pamƒõti a integraci s extern√≠mi syst√©my.

### **RAG (Retrieval-Augmented Generation)**
Technika kombinuj√≠c√≠ vyhled√°v√°n√≠ relevantn√≠ch informac√≠ s generov√°n√≠m odpovƒõd√≠. Umo≈æ≈àuje AI p≈ô√≠stup k aktu√°ln√≠m a specifick√Ωm informac√≠m mimo tr√©ninkov√© data.

### **Embedding Index**
Vektorov√° datab√°ze obsahuj√≠c√≠ numerick√© reprezentace textu (embeddings). Umo≈æ≈àuje s√©mantick√© vyhled√°v√°n√≠ podobnosti v k√≥du a dokumentaci.

### **Git Integration**
Integrace s verzovac√≠m syst√©mem Git pro sledov√°n√≠ zmƒõn, anal√Ωzu historie k√≥du a kontextov√© porozumƒõn√≠ v√Ωvoji projektu.

## 3. Komplexn√≠ vysvƒõtlen√≠ projektu

### **C√≠le projektu**
Vytvo≈ôit inteligentn√≠ho asistenta, kter√Ω hluboko rozum√≠ struktu≈ôe a kontextu v√Ωvoj√°≈ôsk√Ωch projekt≈Ø. Syst√©m vyu≈æ√≠v√° MCP protokol pro bezpeƒçn√Ω p≈ô√≠stup k lok√°ln√≠m soubor≈Øm, Git historii a v√Ωvoj√°≈ôsk√Ωm n√°stroj≈Øm.

### **Hlavn√≠ v√Ωzvy**
- **Kontextov√© porozumƒõn√≠**: Udr≈æen√≠ kontextu nap≈ô√≠ƒç velk√Ωmi k√≥dov√Ωmi b√°zemi
- **V√Ωkonnost**: Rychl√© vyhled√°v√°n√≠ v rozs√°hl√Ωch projektech pomoc√≠ embeddings
- **Bezpeƒçnost**: Bezpeƒçn√Ω p≈ô√≠stup k lok√°ln√≠m soubor≈Øm p≈ôes MCP
- **Integrace**: Seamless integrace s VS Code a Git workflow

### **Dopad projektu**
Revolucionizuje zp≈Øsob, jak√Ωm v√Ωvoj√°≈ôi interaguj√≠ se sv√Ωm k√≥dem. Umo≈æ≈àuje rychlej≈°√≠ onboarding nov√Ωch v√Ωvoj√°≈ô≈Ø, efektivnƒõj≈°√≠ code review a inteligentn√≠ dokumentaci k√≥du.

## 4. Komplexn√≠ p≈ô√≠klad s implementac√≠ v Pythonu

### **Z√°vislosti a instalace**

````python
langchain==0.1.0
chromadb==0.4.22
openai==1.12.0
gitpython==3.1.41
fastapi==0.109.0
uvicorn==0.27.0
pydantic==2.5.3
python-dotenv==1.0.0
sentence-transformers==2.2.2
watchdog==4.0.0
````

### **Hlavn√≠ komponenty syst√©mu**

````python
import os
import json
import asyncio
from typing import List, Dict, Any, Optional
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime

import chromadb
from langchain.embeddings import SentenceTransformerEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document
from langchain.chat_models import ChatOpenAI
from langchain.chains import RetrievalQA
from langchain.vectorstores import Chroma
from git import Repo
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import openai
from dotenv import load_dotenv

load_dotenv()

@dataclass
class CodeContext:
    """Reprezentuje kontext k√≥du s metadaty"""
    file_path: str
    content: str
    language: str
    last_modified: datetime
    git_commit: Optional[str] = None
    dependencies: List[str] = None

class MCPCodebaseManager:
    """Spr√°vce k√≥dov√© b√°ze pou≈æ√≠vaj√≠c√≠ MCP protokol"""
    
    def __init__(self, project_path: str, embedding_model: str = "all-MiniLM-L6-v2"):
        self.project_path = Path(project_path)
        self.embedding_model = SentenceTransformerEmbeddings(
            model_name=embedding_model
        )
        
        # Inicializace Chroma vectorstore
        self.chroma_client = chromadb.PersistentClient(
            path=str(self.project_path / ".codebase_companion" / "chroma_db")
        )
        self.collection = self.chroma_client.get_or_create_collection(
            name="codebase",
            metadata={"description": "K√≥dov√° b√°ze projektu"}
        )
        
        # Git repository
        try:
            self.repo = Repo(self.project_path)
        except:
            self.repo = None
            
        # Text splitter pro chunking
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            separators=["\n\n", "\n", " ", ""]
        )
        
        # LLM pro anal√Ωzu
        self.llm = ChatOpenAI(
            model="gpt-4-turbo",
            temperature=0.1
        )

    async def scan_project(self) -> List[CodeContext]:
        """Naskenuje projekt a vytvo≈ô√≠ kontext pro v≈°echny soubory"""
        contexts = []
        
        # Definice podporovan√Ωch jazyk≈Ø
        language_map = {
            '.py': 'python', '.js': 'javascript', '.ts': 'typescript',
            '.java': 'java', '.cpp': 'cpp', '.c': 'c', '.cs': 'csharp',
            '.go': 'go', '.rs': 'rust', '.php': 'php', '.rb': 'ruby',
            '.md': 'markdown', '.txt': 'text', '.json': 'json',
            '.yml': 'yaml', '.yaml': 'yaml'
        }
        
        for file_path in self.project_path.rglob("*"):
            if (file_path.is_file() and 
                not any(exclude in str(file_path) for exclude in 
                       ['.git', '__pycache__', 'node_modules', '.venv']) and
                file_path.suffix in language_map):
                
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Git kontext
                    git_commit = None
                    if self.repo:
                        try:
                            commits = list(self.repo.iter_commits(
                                paths=str(file_path.relative_to(self.project_path)),
                                max_count=1
                            ))
                            if commits:
                                git_commit = commits[0].hexsha[:8]
                        except:
                            pass
                    
                    context = CodeContext(
                        file_path=str(file_path.relative_to(self.project_path)),
                        content=content,
                        language=language_map[file_path.suffix],
                        last_modified=datetime.fromtimestamp(file_path.stat().st_mtime),
                        git_commit=git_commit,
                        dependencies=await self._extract_dependencies(content, file_path.suffix)
                    )
                    contexts.append(context)
                    
                except Exception as e:
                    print(f"Chyba p≈ôi ƒçten√≠ {file_path}: {e}")
                    
        return contexts

    async def _extract_dependencies(self, content: str, file_extension: str) -> List[str]:
        """Extrahuje z√°vislosti ze souboru"""
        dependencies = []
        
        if file_extension == '.py':
            import re
            imports = re.findall(r'^(?:from\s+(\S+)\s+)?import\s+(\S+)', content, re.MULTILINE)
            for module, item in imports:
                if module:
                    dependencies.append(module)
                else:
                    dependencies.append(item.split('.')[0])
                    
        elif file_extension in ['.js', '.ts']:
            import re
            imports = re.findall(r'import.*?from\s+["\']([^"\']+)["\']', content)
            dependencies.extend(imports)
            
        return list(set(dependencies))

    async def index_codebase(self, contexts: List[CodeContext]):
        """Indexuje k√≥dovou b√°zi do vectorstore"""
        documents = []
        
        for context in contexts:
            # Rozdƒõlen√≠ obsahu na chunky
            chunks = self.text_splitter.split_text(context.content)
            
            for i, chunk in enumerate(chunks):
                metadata = {
                    "file_path": context.file_path,
                    "language": context.language,
                    "chunk_index": i,
                    "last_modified": context.last_modified.isoformat(),
                    "git_commit": context.git_commit or "",
                    "dependencies": json.dumps(context.dependencies or [])
                }
                
                doc = Document(
                    page_content=chunk,
                    metadata=metadata
                )
                documents.append(doc)
        
        # P≈ôid√°n√≠ do Chroma
        if documents:
            vectorstore = Chroma.from_documents(
                documents=documents,
                embedding=self.embedding_model,
                client=self.chroma_client,
                collection_name="codebase"
            )
            
        print(f"Indexov√°no {len(documents)} chunk√≥w z {len(contexts)} soubor≈Ø")

    async def query_codebase(self, query: str, context_type: str = "general") -> Dict[str, Any]:
        """Dotazuje se na k√≥dovou b√°zi"""
        try:
            # Vytvo≈ôen√≠ vectorstore pro vyhled√°v√°n√≠
            vectorstore = Chroma(
                client=self.chroma_client,
                collection_name="codebase",
                embedding_function=self.embedding_model
            )
            
            # Konfigurace retrieval chain
            qa_chain = RetrievalQA.from_chain_type(
                llm=self.llm,
                chain_type="stuff",
                retriever=vectorstore.as_retriever(
                    search_kwargs={"k": 5}
                ),
                return_source_documents=True
            )
            
            # P≈ô√≠prava kontextov√©ho prompt
            context_prompt = self._prepare_context_prompt(query, context_type)
            
            # Proveden√≠ dotazu
            result = await asyncio.get_event_loop().run_in_executor(
                None, qa_chain, {"query": context_prompt}
            )
            
            return {
                "answer": result["result"],
                "sources": [doc.metadata for doc in result["source_documents"]],
                "context_type": context_type
            }
            
        except Exception as e:
            return {
                "error": f"Chyba p≈ôi dotazu: {str(e)}",
                "answer": None,
                "sources": []
            }

    def _prepare_context_prompt(self, query: str, context_type: str) -> str:
        """P≈ôiprav√≠ kontextov√Ω prompt na z√°kladƒõ typu dotazu"""
        base_prompt = f"""
        Jsi expert na anal√Ωzu k√≥du a v√Ωvoj√°≈ôsk√Ω asistent. 
        Odpov√≠dej v ƒçe≈°tinƒõ a poskytni konkr√©tn√≠ a u≈æiteƒçn√© informace.
        
        Dotaz: {query}
        """
        
        if context_type == "architecture":
            return base_prompt + "\nZamƒõ≈ô se na architektonick√© aspekty a design patterns."
        elif context_type == "debugging":
            return base_prompt + "\nZamƒõ≈ô se na mo≈æn√© chyby a debugging techniky."
        elif context_type == "optimization":
            return base_prompt + "\nZamƒõ≈ô se na mo≈ænosti optimalizace a performance."
        else:
            return base_prompt

class FileWatcher(FileSystemEventHandler):
    """Sleduje zmƒõny v souborech pro automatickou reindexaci"""
    
    def __init__(self, codebase_manager: MCPCodebaseManager):
        self.codebase_manager = codebase_manager
        self.pending_updates = set()
        
    def on_modified(self, event):
        if not event.is_directory:
            self.pending_updates.add(event.src_path)
            # Debounce - ƒçek√°n√≠ na stabilizaci zmƒõn
            asyncio.create_task(self._delayed_reindex())
    
    async def _delayed_reindex(self):
        await asyncio.sleep(2)  # ƒåek√°n√≠ 2 sekundy
        if self.pending_updates:
            print(f"Reindexuji {len(self.pending_updates)} zmƒõnƒõn√Ωch soubor≈Ø...")
            # Zde by byla logika pro parci√°ln√≠ reindexaci
            self.pending_updates.clear()

class CodebaseCompanionAPI:
    """API pro Codebase Companion"""
    
    def __init__(self, project_path: str):
        self.manager = MCPCodebaseManager(project_path)
        self.is_indexed = False
        
    async def initialize(self):
        """Inicializuje syst√©m a provede poƒç√°teƒçn√≠ indexaci"""
        print("Inicializuji Codebase Companion...")
        contexts = await self.manager.scan_project()
        await self.manager.index_codebase(contexts)
        self.is_indexed = True
        print("Inicializace dokonƒçena!")
        
    async def ask_question(self, question: str, context_type: str = "general") -> Dict[str, Any]:
        """Polo≈æ√≠ ot√°zku o k√≥dov√© b√°zi"""
        if not self.is_indexed:
            return {"error": "Syst√©m je≈°tƒõ nen√≠ inicializov√°n"}
            
        return await self.manager.query_codebase(question, context_type)
    
    async def get_project_summary(self) -> Dict[str, Any]:
        """Z√≠sk√° p≈ôehled projektu"""
        summary_query = """
        Poskytni mi p≈ôehled tohoto projektu:
        1. Jak√Ω je √∫ƒçel a funkcionalita projektu?
        2. Jak√© technologie a frameworky se pou≈æ√≠vaj√≠?
        3. Jak√° je struktura projektu?
        4. Jak√© jsou hlavn√≠ komponenty a moduly?
        """
        
        return await self.ask_question(summary_query, "architecture")

# P≈ô√≠klad pou≈æit√≠
async def main():
    """Hlavn√≠ funkce pro demonstraci"""
    
    # Vytvo≈ôen√≠ testovac√≠ho projektu
    test_project = Path("./test_codebase")
    test_project.mkdir(exist_ok=True)
    
    # Vytvo≈ôen√≠ uk√°zkov√Ωch soubor≈Ø
    (test_project / "main.py").write_text("""
from fastapi import FastAPI
from typing import List
import uvicorn

app = FastAPI(title="Test API")

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
    """)
    
    (test_project / "models.py").write_text("""
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class User(BaseModel):
    id: int
    name: str
    email: str
    created_at: datetime

class Item(BaseModel):
    id: int
    title: str
    description: Optional[str] = None
    price: float
    user_id: int
    """)
    
    (test_project / "README.md").write_text("""
# Test Codebase Project

Toto je testovac√≠ projekt pro Codebase Companion.

## Funkcionalita
- FastAPI REST API
- Pydantic modely
- Z√°kladn√≠ CRUD operace

## Instalace
```bash
pip install -r requirements.txt
```

## Spu≈°tƒõn√≠
```bash
python main.py
```
    """)
    
    # Inicializace Codebase Companion
    companion = CodebaseCompanionAPI(str(test_project))
    await companion.initialize()
    
    # Testovac√≠ dotazy
    questions = [
        "Jak√© API endpointy tento projekt poskytuje?",
        "Jak√© modely jsou definovan√© v projektu?",
        "Jak spust√≠m tento projekt?",
        "Jak√© z√°vislosti projekt pou≈æ√≠v√°?"
    ]
    
    for question in questions:
        print(f"\nü§î Ot√°zka: {question}")
        result = await companion.ask_question(question)
        if result.get("answer"):
            print(f"üí° Odpovƒõƒè: {result['answer']}")
            print(f"üìÅ Zdroje: {[src['file_path'] for src in result['sources']]}")
        else:
            print(f"‚ùå Chyba: {result.get('error')}")

if __name__ == "__main__":
    asyncio.run(main())
````

### **FastAPI webov√° aplikace**

````python
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import asyncio

from codebase_companion import CodebaseCompanionAPI

app = FastAPI(
    title="Codebase Companion API",
    description="API pro inteligentn√≠ anal√Ωzu k√≥dov√© b√°ze",
    version="1.0.0"
)

# CORS middleware pro frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic modely
class QuestionRequest(BaseModel):
    question: str
    context_type: Optional[str] = "general"
    project_path: Optional[str] = None

class QuestionResponse(BaseModel):
    answer: str
    sources: List[dict]
    context_type: str
    error: Optional[str] = None

# Glob√°ln√≠ instance companion
companion_instances = {}

@app.post("/api/ask", response_model=QuestionResponse)
async def ask_question(request: QuestionRequest):
    """Endpoint pro polo≈æen√≠ ot√°zky o k√≥dov√© b√°zi"""
    
    project_path = request.project_path or "./current_project"
    
    # Z√≠sk√°n√≠ nebo vytvo≈ôen√≠ instance pro projekt
    if project_path not in companion_instances:
        companion_instances[project_path] = CodebaseCompanionAPI(project_path)
        await companion_instances[project_path].initialize()
    
    companion = companion_instances[project_path]
    result = await companion.ask_question(request.question, request.context_type)
    
    return QuestionResponse(**result)

@app.get("/api/project/summary")
async def get_project_summary(project_path: str = "./current_project"):
    """Z√≠sk√° p≈ôehled projektu"""
    
    if project_path not in companion_instances:
        companion_instances[project_path] = CodebaseCompanionAPI(project_path)
        await companion_instances[project_path].initialize()
    
    companion = companion_instances[project_path]
    result = await companion.get_project_summary()
    
    return result

@app.post("/api/project/initialize")
async def initialize_project(project_path: str):
    """Inicializuje nov√Ω projekt"""
    
    try:
        companion = CodebaseCompanionAPI(project_path)
        await companion.initialize()
        companion_instances[project_path] = companion
        
        return {"message": f"Projekt {project_path} byl √∫spƒõ≈°nƒõ inicializov√°n"}
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### **VS Code Extension (TypeScript)**

````typescript
import * as vscode from 'vscode';
import axios from 'axios';

interface CodebaseQuestion {
    question: string;
    contextType?: string;
    projectPath?: string;
}

interface CodebaseResponse {
    answer: string;
    sources: Array<{file_path: string, language: string}>;
    contextType: string;
    error?: string;
}

export function activate(context: vscode.ExtensionContext) {
    console.log('Codebase Companion extension activated');

    // Command pro dotaz na k√≥dovou b√°zi
    let askCommand = vscode.commands.registerCommand('codebaseCompanion.ask', async () => {
        const question = await vscode.window.showInputBox({
            prompt: 'Polo≈æte ot√°zku o va≈°√≠ k√≥dov√© b√°zi',
            placeHolder: 'Nap≈ô√≠klad: Jak funguje autentizace v tomto projektu?'
        });

        if (question) {
            await askCodebaseQuestion(question);
        }
    });

    // Command pro inicializaci projektu
    let initCommand = vscode.commands.registerCommand('codebaseCompanion.initialize', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            vscode.window.showErrorMessage('≈Ω√°dn√Ω workspace nen√≠ otev≈ôen');
            return;
        }

        const projectPath = workspaceFolders[0].uri.fsPath;
        await initializeProject(projectPath);
    });

    // Command pro p≈ôehled projektu
    let summaryCommand = vscode.commands.registerCommand('codebaseCompanion.summary', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            vscode.window.showErrorMessage('≈Ω√°dn√Ω workspace nen√≠ otev≈ôen');
            return;
        }

        const projectPath = workspaceFolders[0].uri.fsPath;
        await getProjectSummary(projectPath);
    });

    context.subscriptions.push(askCommand, initCommand, summaryCommand);
}

async function askCodebaseQuestion(question: string) {
    try {
        vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Zpracov√°v√°m dotaz...",
            cancellable: false
        }, async () => {
            const workspacePath = vscode.workspace.workspaceFolders?.[0].uri.fsPath;
            
            const response = await axios.post<CodebaseResponse>('http://localhost:8000/api/ask', {
                question,
                contextType: 'general',
                projectPath: workspacePath
            });

            if (response.data.error) {
                vscode.window.showErrorMessage(`Chyba: ${response.data.error}`);
                return;
            }

            // Zobrazen√≠ odpovƒõdi v nov√©m dokumentu
            const doc = await vscode.workspace.openTextDocument({
                content: formatResponse(question, response.data),
                language: 'markdown'
            });

            await vscode.window.showTextDocument(doc);
        });

    } catch (error) {
        vscode.window.showErrorMessage(`Chyba p≈ôi komunikaci s API: ${error}`);
    }
}

async function initializeProject(projectPath: string) {
    try {
        vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Inicializuji projekt...",
            cancellable: false
        }, async () => {
            await axios.post('http://localhost:8000/api/project/initialize', null, {
                params: { project_path: projectPath }
            });

            vscode.window.showInformationMessage('Projekt byl √∫spƒõ≈°nƒõ inicializov√°n!');
        });

    } catch (error) {
        vscode.window.showErrorMessage(`Chyba p≈ôi inicializaci: ${error}`);
    }
}

async function getProjectSummary(projectPath: string) {
    try {
        vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Generuji p≈ôehled projektu...",
            cancellable: false
        }, async () => {
            const response = await axios.get<CodebaseResponse>('http://localhost:8000/api/project/summary', {
                params: { project_path: projectPath }
            });

            const doc = await vscode.workspace.openTextDocument({
                content: `# P≈ôehled projektu\n\n${response.data.answer}`,
                language: 'markdown'
            });

            await vscode.window.showTextDocument(doc);
        });

    } catch (error) {
        vscode.window.showErrorMessage(`Chyba p≈ôi generov√°n√≠ p≈ôehledu: ${error}`);
    }
}

function formatResponse(question: string, response: CodebaseResponse): string {
    return `# Dotaz na k√≥dovou b√°zi

## Ot√°zka
${question}

## Odpovƒõƒè
${response.answer}

## Zdroje
${response.sources.map(source => `- **${source.file_path}** (${source.language})`).join('\n')}

---
*Vygenerov√°no pomoc√≠ Codebase Companion*
`;
}

export function deactivate() {}
````

## 5. Shrnut√≠ projektu

**Codebase Companion** p≈ôedstavuje pokroƒçil√Ω AI-powered n√°stroj pro v√Ωvoj√°≈ôe, kter√Ω revolucionizuje zp≈Øsob interakce s k√≥dem. Projekt √∫spƒõ≈°nƒõ kombinuje:

### **Kl√≠ƒçov√© v√Ωhody:**
- **Inteligentn√≠ porozumƒõn√≠ k√≥du** pomoc√≠ embeddings a RAG
- **Bezpeƒçn√Ω p≈ô√≠stup** k lok√°ln√≠m zdroj≈Øm p≈ôes MCP protokol
- **Real-time sledov√°n√≠ zmƒõn** s automatickou reindexac√≠
- **Seamless integrace** s VS Code a Git workflow
- **Kontextov√© odpovƒõdi** zalo≈æen√© na aktu√°ln√≠m stavu projektu

### **Technologick√© inovace:**
- Vyu≈æit√≠ nejmodernƒõj≈°√≠ch LLM model≈Ø (GPT-4-turbo)
- Pokroƒçil√© vektorov√© vyhled√°v√°n√≠ s Chroma DB
- Asynchronn√≠ architektura pro vysok√Ω v√Ωkon
- Modul√°rn√≠ design umo≈æ≈àuj√≠c√≠ snadn√© roz≈°√≠≈ôen√≠

### **Praktick√° hodnota:**
Syst√©m dramaticky zkracuje ƒças pot≈ôebn√Ω pro porozumƒõn√≠ nov√Ωm projekt≈Øm, zlep≈°uje kvalitu code review a umo≈æ≈àuje efektivnƒõj≈°√≠ ≈ôe≈°en√≠ probl√©m≈Ø. Je ide√°ln√≠ pro t√Ωmy pracuj√≠c√≠ na komplexn√≠ch aplikac√≠ch, kde je rychl√© pochopen√≠ kontextu kl√≠ƒçov√© pro produktivitu.

**Codebase Companion** p≈ôedstavuje budoucnost v√Ωvoj√°≈ôsk√Ωch n√°stroj≈Ø - inteligentn√≠ asistent, kter√Ω skuteƒçnƒõ rozum√≠ va≈°emu k√≥du a pom√°h√° v√°m tvo≈ôit lep≈°√≠ software rychleji a efektivnƒõji.