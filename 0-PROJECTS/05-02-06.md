<small>Claude Sonnet 4 **(AI Tutor Agent)**</small>
# AI Tutor Agent

## Key Concepts Explanation

### Curriculum Planning
Intelligent educational pathway design that adapts learning sequences, topics, and difficulty progression based on student performance, learning style preferences, and educational objectives using machine learning algorithms to optimize knowledge acquisition and retention.

### Question Answering
Advanced natural language processing system capable of understanding educational queries, providing accurate explanations, generating contextual examples, and adapting response complexity to match student comprehension levels across multiple academic domains.

### Memory Management
Persistent learning context tracking that maintains student progress, knowledge gaps, learning preferences, and interaction history to provide personalized educational experiences while ensuring continuity across learning sessions.

### Adaptive Learning
Dynamic adjustment of teaching strategies, content difficulty, and learning pace based on real-time assessment of student understanding, engagement levels, and performance metrics to optimize individual learning outcomes.

### Knowledge Assessment
Comprehensive evaluation system that measures student understanding through various question types, identifies knowledge gaps, tracks learning progress, and provides detailed feedback for continuous improvement.

## Comprehensive Project Explanation

### Objectives
The AI Tutor Agent creates personalized educational experiences by combining intelligent curriculum planning, adaptive question answering, and persistent memory to deliver customized learning paths that maximize student engagement and knowledge retention.

### Key Features
- **Intelligent Curriculum Design**: Adaptive learning paths based on student performance and preferences
- **Contextual Question Answering**: Subject-aware responses with explanations and examples
- **Persistent Learning Memory**: Long-term tracking of student progress and preferences
- **Real-time Assessment**: Continuous evaluation and feedback mechanisms
- **Multi-subject Support**: Comprehensive coverage across academic disciplines

### Challenges
- **Personalization Scale**: Adapting to diverse learning styles and preferences
- **Knowledge Verification**: Ensuring accuracy of educational content and explanations
- **Engagement Maintenance**: Keeping students motivated throughout learning journey
- **Progress Measurement**: Accurately assessing learning outcomes and knowledge retention

### Potential Impact
This system can democratize quality education, provide 24/7 tutoring support, adapt to individual learning needs, and scale personalized education to millions of students worldwide.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
chromadb==0.4.18
sentence-transformers==2.2.2
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
spacy==3.7.2
networkx==3.2.1
scikit-learn==1.3.2
datetime
uuid
json
logging
typing
dataclasses
enum
````

### Core Implementation

````python
import uuid
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import networkx as nx
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# AI and ML libraries
import chromadb
from sentence_transformers import SentenceTransformer
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.memory import ConversationBufferWindowMemory
from langchain.schema import BaseMessage, HumanMessage, AIMessage

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DifficultyLevel(Enum):
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"

class LearningStyle(Enum):
    VISUAL = "visual"
    AUDITORY = "auditory"
    KINESTHETIC = "kinesthetic"
    READING_WRITING = "reading_writing"

class SubjectArea(Enum):
    MATHEMATICS = "mathematics"
    SCIENCE = "science"
    PROGRAMMING = "programming"
    LITERATURE = "literature"
    HISTORY = "history"
    LANGUAGES = "languages"

class QuestionType(Enum):
    MULTIPLE_CHOICE = "multiple_choice"
    TRUE_FALSE = "true_false"
    SHORT_ANSWER = "short_answer"
    ESSAY = "essay"
    PROBLEM_SOLVING = "problem_solving"

@dataclass
class LearningObjective:
    objective_id: str
    title: str
    description: str
    subject_area: SubjectArea
    difficulty_level: DifficultyLevel
    prerequisites: List[str] = field(default_factory=list)
    estimated_time_hours: float = 1.0
    keywords: List[str] = field(default_factory=list)

@dataclass
class Question:
    question_id: str
    question_text: str
    question_type: QuestionType
    subject_area: SubjectArea
    difficulty_level: DifficultyLevel
    correct_answer: str
    options: List[str] = field(default_factory=list)
    explanation: str = ""
    hints: List[str] = field(default_factory=list)
    related_objectives: List[str] = field(default_factory=list)

@dataclass
class StudentResponse:
    response_id: str
    question_id: str
    student_answer: str
    is_correct: bool
    time_taken_seconds: float
    timestamp: datetime
    confidence_level: Optional[float] = None

@dataclass
class StudentProfile:
    student_id: str
    name: str
    age: Optional[int] = None
    learning_style: Optional[LearningStyle] = None
    preferred_subjects: List[SubjectArea] = field(default_factory=list)
    current_level: Dict[SubjectArea, DifficultyLevel] = field(default_factory=dict)
    learning_goals: List[str] = field(default_factory=list)
    strengths: List[str] = field(default_factory=list)
    areas_for_improvement: List[str] = field(default_factory=list)

@dataclass
class LearningSession:
    session_id: str
    student_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    topics_covered: List[str] = field(default_factory=list)
    questions_attempted: List[str] = field(default_factory=list)
    responses: List[StudentResponse] = field(default_factory=list)
    performance_score: Optional[float] = None

class KnowledgeBase:
    """Educational knowledge repository with RAG capabilities."""
    
    def __init__(self):
        self.embedding_model = SentenceTransformer('all-MiniLM-L6-v2')
        
        # Initialize ChromaDB
        self.chroma_client = chromadb.Client()
        try:
            self.content_collection = self.chroma_client.get_collection("educational_content")
            self.questions_collection = self.chroma_client.get_collection("questions")
        except:
            self.content_collection = self.chroma_client.create_collection("educational_content")
            self.questions_collection = self.chroma_client.create_collection("questions")
        
        self._initialize_knowledge_base()
    
    def _initialize_knowledge_base(self):
        """Initialize with educational content."""
        # Sample educational content
        content_data = [
            {
                "title": "Introduction to Algebra",
                "content": "Algebra is a branch of mathematics dealing with symbols and rules for manipulating symbols",
                "subject": "mathematics",
                "difficulty": "beginner",
                "concepts": ["variables", "equations", "expressions"]
            },
            {
                "title": "Python Functions",
                "content": "Functions in Python are reusable blocks of code that perform specific tasks",
                "subject": "programming", 
                "difficulty": "beginner",
                "concepts": ["functions", "parameters", "return values"]
            },
            {
                "title": "Photosynthesis Process",
                "content": "Photosynthesis is the process by which plants convert light energy into chemical energy",
                "subject": "science",
                "difficulty": "intermediate",
                "concepts": ["chlorophyll", "glucose", "carbon dioxide"]
            }
        ]
        
        # Store content
        for i, content in enumerate(content_data):
            content_id = f"content_{i}"
            text = f"{content['title']} {content['content']}"
            embedding = self.embedding_model.encode(text).tolist()
            
            try:
                self.content_collection.add(
                    documents=[text],
                    embeddings=[embedding],
                    metadatas=[content],
                    ids=[content_id]
                )
            except Exception as e:
                logger.warning(f"Could not add content {content_id}: {e}")
        
        # Sample questions
        questions_data = [
            {
                "question": "What is a variable in algebra?",
                "answer": "A symbol that represents an unknown value",
                "subject": "mathematics",
                "difficulty": "beginner",
                "type": "short_answer"
            },
            {
                "question": "How do you define a function in Python?",
                "answer": "Using the 'def' keyword followed by function name and parameters",
                "subject": "programming",
                "difficulty": "beginner", 
                "type": "short_answer"
            }
        ]
        
        # Store questions
        for i, question in enumerate(questions_data):
            question_id = f"question_{i}"
            text = f"{question['question']} {question['answer']}"
            embedding = self.embedding_model.encode(text).tolist()
            
            try:
                self.questions_collection.add(
                    documents=[text],
                    embeddings=[embedding],
                    metadatas=[question],
                    ids=[question_id]
                )
            except Exception as e:
                logger.warning(f"Could not add question {question_id}: {e}")
    
    def search_content(self, query: str, subject: Optional[str] = None, n_results: int = 5) -> List[Dict]:
        """Search educational content."""
        return self._search_collection(self.content_collection, query, subject, n_results)
    
    def search_questions(self, query: str, subject: Optional[str] = None, n_results: int = 5) -> List[Dict]:
        """Search questions."""
        return self._search_collection(self.questions_collection, query, subject, n_results)
    
    def _search_collection(self, collection, query: str, subject: Optional[str], n_results: int) -> List[Dict]:
        """Generic search function."""
        try:
            query_embedding = self.embedding_model.encode(query).tolist()
            
            search_params = {
                "query_embeddings": [query_embedding],
                "n_results": n_results
            }
            
            if subject:
                search_params["where"] = {"subject": subject}
            
            results = collection.query(**search_params)
            
            search_results = []
            if results['metadatas']:
                for i, metadata in enumerate(results['metadatas'][0]):
                    search_results.append({
                        'metadata': metadata,
                        'content': results['documents'][0][i] if results['documents'] else "",
                        'similarity': 1 - results['distances'][0][i] if 'distances' in results else 0.0
                    })
            
            return search_results
            
        except Exception as e:
            logger.error(f"Search error: {e}")
            return []

class CurriculumPlanner:
    """Plans and adapts educational curricula."""
    
    def __init__(self, knowledge_base: KnowledgeBase):
        self.knowledge_base = knowledge_base
        self.curriculum_graph = self._build_curriculum_graph()
    
    def _build_curriculum_graph(self) -> nx.DiGraph:
        """Build curriculum dependency graph."""
        G = nx.DiGraph()
        
        # Sample curriculum structure
        topics = {
            "basic_math": {"level": 1, "subject": "mathematics"},
            "algebra": {"level": 2, "subject": "mathematics", "prerequisites": ["basic_math"]},
            "calculus": {"level": 3, "subject": "mathematics", "prerequisites": ["algebra"]},
            "python_basics": {"level": 1, "subject": "programming"},
            "functions": {"level": 2, "subject": "programming", "prerequisites": ["python_basics"]},
            "data_structures": {"level": 3, "subject": "programming", "prerequisites": ["functions"]}
        }
        
        for topic, attrs in topics.items():
            G.add_node(topic, **attrs)
            
            # Add prerequisite edges
            for prereq in attrs.get("prerequisites", []):
                G.add_edge(prereq, topic)
        
        return G
    
    def generate_learning_path(self, student_profile: StudentProfile, 
                             target_subject: SubjectArea,
                             target_level: DifficultyLevel) -> List[LearningObjective]:
        """Generate personalized learning path."""
        try:
            # Get current level
            current_level = student_profile.current_level.get(target_subject, DifficultyLevel.BEGINNER)
            
            # Find relevant topics
            subject_topics = [
                node for node, attrs in self.curriculum_graph.nodes(data=True)
                if attrs.get("subject") == target_subject.value
            ]
            
            # Sort by level and dependencies
            learning_path = []
            covered_topics = set()
            
            for topic in subject_topics:
                attrs = self.curriculum_graph.nodes[topic]
                
                # Check if prerequisites are met
                prerequisites = list(self.curriculum_graph.predecessors(topic))
                if all(prereq in covered_topics for prereq in prerequisites):
                    
                    objective = LearningObjective(
                        objective_id=str(uuid.uuid4()),
                        title=topic.replace("_", " ").title(),
                        description=f"Learn {topic.replace('_', ' ')}",
                        subject_area=target_subject,
                        difficulty_level=self._map_level(attrs.get("level", 1)),
                        prerequisites=prerequisites,
                        estimated_time_hours=2.0
                    )
                    
                    learning_path.append(objective)
                    covered_topics.add(topic)
            
            return learning_path
            
        except Exception as e:
            logger.error(f"Learning path generation error: {e}")
            return []
    
    def _map_level(self, level: int) -> DifficultyLevel:
        """Map numeric level to difficulty enum."""
        mapping = {
            1: DifficultyLevel.BEGINNER,
            2: DifficultyLevel.INTERMEDIATE,
            3: DifficultyLevel.ADVANCED,
            4: DifficultyLevel.EXPERT
        }
        return mapping.get(level, DifficultyLevel.BEGINNER)
    
    def adapt_curriculum(self, student_profile: StudentProfile, 
                        performance_data: List[StudentResponse]) -> Dict[str, Any]:
        """Adapt curriculum based on performance."""
        if not performance_data:
            return {"recommendation": "Continue with current path"}
        
        # Analyze performance
        correct_responses = sum(1 for response in performance_data if response.is_correct)
        total_responses = len(performance_data)
        accuracy = correct_responses / total_responses if total_responses > 0 else 0
        
        # Calculate average time
        avg_time = np.mean([r.time_taken_seconds for r in performance_data])
        
        recommendations = []
        
        if accuracy < 0.6:
            recommendations.append("Review previous topics and practice more")
            recommendations.append("Consider additional exercises at current level")
        elif accuracy > 0.8 and avg_time < 30:
            recommendations.append("Ready to advance to next difficulty level")
        
        return {
            "accuracy": accuracy,
            "average_time": avg_time,
            "recommendations": recommendations
        }

class QuestionAnswering:
    """Handles educational question answering."""
    
    def __init__(self, knowledge_base: KnowledgeBase, llm: Optional[ChatOpenAI] = None):
        self.knowledge_base = knowledge_base
        self.llm = llm
        self._initialize_prompts()
    
    def _initialize_prompts(self):
        """Initialize QA prompts."""
        self.qa_prompt = ChatPromptTemplate.from_template("""
        You are an AI tutor helping a student learn. Answer the following question clearly and provide helpful explanations.
        
        Student Question: {question}
        
        Subject Area: {subject}
        Student Level: {level}
        
        Relevant Content: {context}
        
        Provide:
        1. A clear answer
        2. An explanation appropriate for the student's level
        3. An example if helpful
        4. A follow-up question to check understanding
        
        Keep your response engaging and educational.
        """)
        
        self.explanation_prompt = ChatPromptTemplate.from_template("""
        Explain the following concept to a {level} level student in {subject}:
        
        Concept: {concept}
        
        Make the explanation clear, engaging, and include examples.
        """)
    
    def answer_question(self, question: str, student_profile: StudentProfile,
                       subject: Optional[SubjectArea] = None) -> Dict[str, Any]:
        """Answer student question with context."""
        try:
            # Search for relevant content
            subject_str = subject.value if subject else "general"
            relevant_content = self.knowledge_base.search_content(question, subject_str, 3)
            
            # Prepare context
            context = "\n".join([
                f"- {content['metadata'].get('title', '')}: {content['content'][:200]}..."
                for content in relevant_content
            ])
            
            if self.llm:
                # Generate AI response
                response = self.llm.invoke(
                    self.qa_prompt.format(
                        question=question,
                        subject=subject_str,
                        level=student_profile.current_level.get(subject, DifficultyLevel.BEGINNER).value,
                        context=context
                    )
                )
                answer = response.content
            else:
                # Fallback to simple response
                answer = self._generate_simple_answer(question, relevant_content)
            
            return {
                "question": question,
                "answer": answer,
                "relevant_content": relevant_content,
                "follow_up_suggestions": self._generate_follow_up(question, subject)
            }
            
        except Exception as e:
            logger.error(f"Question answering error: {e}")
            return {
                "question": question,
                "answer": "I apologize, but I'm having trouble answering that question right now.",
                "error": str(e)
            }
    
    def _generate_simple_answer(self, question: str, relevant_content: List[Dict]) -> str:
        """Generate simple answer without LLM."""
        if not relevant_content:
            return "I don't have specific information about that topic in my knowledge base."
        
        best_match = relevant_content[0]
        return f"Based on the content I have: {best_match['content'][:300]}..."
    
    def _generate_follow_up(self, question: str, subject: Optional[SubjectArea]) -> List[str]:
        """Generate follow-up questions."""
        follow_ups = [
            "Would you like me to explain any part in more detail?",
            "Do you have any questions about this topic?",
            "Would you like to try a practice problem?"
        ]
        
        if subject == SubjectArea.MATHEMATICS:
            follow_ups.append("Would you like to see a step-by-step example?")
        elif subject == SubjectArea.PROGRAMMING:
            follow_ups.append("Would you like to see some code examples?")
        
        return follow_ups
    
    def explain_concept(self, concept: str, student_profile: StudentProfile,
                       subject: SubjectArea) -> str:
        """Provide detailed concept explanation."""
        if self.llm:
            level = student_profile.current_level.get(subject, DifficultyLevel.BEGINNER)
            
            response = self.llm.invoke(
                self.explanation_prompt.format(
                    concept=concept,
                    level=level.value,
                    subject=subject.value
                )
            )
            return response.content
        else:
            return f"Here's an explanation of {concept}: [Explanation would be generated here]"

class StudentMemory:
    """Manages student learning memory and progress."""
    
    def __init__(self):
        self.memory_store = {}  # In practice, use persistent storage
        self.interaction_memory = ConversationBufferWindowMemory(k=10)
    
    def save_student_profile(self, profile: StudentProfile):
        """Save student profile."""
        self.memory_store[f"profile_{profile.student_id}"] = profile
    
    def get_student_profile(self, student_id: str) -> Optional[StudentProfile]:
        """Retrieve student profile."""
        return self.memory_store.get(f"profile_{student_id}")
    
    def save_learning_session(self, session: LearningSession):
        """Save learning session."""
        self.memory_store[f"session_{session.session_id}"] = session
    
    def get_student_sessions(self, student_id: str) -> List[LearningSession]:
        """Get all sessions for a student."""
        sessions = []
        for key, value in self.memory_store.items():
            if key.startswith("session_") and isinstance(value, LearningSession):
                if value.student_id == student_id:
                    sessions.append(value)
        return sessions
    
    def update_student_progress(self, student_id: str, subject: SubjectArea,
                              responses: List[StudentResponse]):
        """Update student progress based on responses."""
        profile = self.get_student_profile(student_id)
        if not profile:
            return
        
        # Calculate performance
        correct_count = sum(1 for r in responses if r.is_correct)
        accuracy = correct_count / len(responses) if responses else 0
        
        # Update level if performance is good
        current_level = profile.current_level.get(subject, DifficultyLevel.BEGINNER)
        
        if accuracy > 0.8 and current_level != DifficultyLevel.EXPERT:
            # Advance level
            levels = list(DifficultyLevel)
            current_index = levels.index(current_level)
            if current_index < len(levels) - 1:
                profile.current_level[subject] = levels[current_index + 1]
        
        self.save_student_profile(profile)
    
    def get_learning_analytics(self, student_id: str) -> Dict[str, Any]:
        """Generate learning analytics for student."""
        sessions = self.get_student_sessions(student_id)
        
        if not sessions:
            return {"message": "No learning sessions found"}
        
        # Calculate metrics
        total_time = sum(
            (session.end_time - session.start_time).total_seconds() / 3600
            for session in sessions if session.end_time
        )
        
        all_responses = []
        for session in sessions:
            all_responses.extend(session.responses)
        
        accuracy = np.mean([r.is_correct for r in all_responses]) if all_responses else 0
        avg_time_per_question = np.mean([r.time_taken_seconds for r in all_responses]) if all_responses else 0
        
        # Subject performance
        subject_performance = {}
        for response in all_responses:
            # In a real implementation, you'd track subject per question
            subject = "general"  # Placeholder
            if subject not in subject_performance:
                subject_performance[subject] = {"correct": 0, "total": 0}
            
            subject_performance[subject]["total"] += 1
            if response.is_correct:
                subject_performance[subject]["correct"] += 1
        
        return {
            "total_study_time_hours": total_time,
            "total_questions_answered": len(all_responses),
            "overall_accuracy": accuracy,
            "average_time_per_question": avg_time_per_question,
            "subject_performance": subject_performance,
            "session_count": len(sessions)
        }

class AITutorAgent:
    """Main AI Tutor orchestrating all components."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.knowledge_base = KnowledgeBase()
        self.curriculum_planner = CurriculumPlanner(self.knowledge_base)
        self.student_memory = StudentMemory()
        
        # Initialize LLM
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.7,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self.qa_system = QuestionAnswering(self.knowledge_base, self.llm)
        
        # Current session tracking
        self.current_sessions = {}
    
    def create_student_profile(self, name: str, age: Optional[int] = None,
                             learning_style: Optional[LearningStyle] = None,
                             preferred_subjects: List[SubjectArea] = None) -> StudentProfile:
        """Create new student profile."""
        student_id = str(uuid.uuid4())
        
        profile = StudentProfile(
            student_id=student_id,
            name=name,
            age=age,
            learning_style=learning_style,
            preferred_subjects=preferred_subjects or [],
            current_level={},
            learning_goals=[],
            strengths=[],
            areas_for_improvement=[]
        )
        
        self.student_memory.save_student_profile(profile)
        return profile
    
    def start_learning_session(self, student_id: str) -> LearningSession:
        """Start new learning session."""
        session = LearningSession(
            session_id=str(uuid.uuid4()),
            student_id=student_id,
            start_time=datetime.now()
        )
        
        self.current_sessions[student_id] = session
        return session
    
    def ask_question(self, student_id: str, question: str,
                    subject: Optional[SubjectArea] = None) -> Dict[str, Any]:
        """Handle student question."""
        profile = self.student_memory.get_student_profile(student_id)
        if not profile:
            return {"error": "Student profile not found"}
        
        # Get answer
        response = self.qa_system.answer_question(question, profile, subject)
        
        # Update session if active
        if student_id in self.current_sessions:
            session = self.current_sessions[student_id]
            session.topics_covered.append(question)
        
        return response
    
    def generate_practice_questions(self, student_id: str, subject: SubjectArea,
                                  num_questions: int = 5) -> List[Question]:
        """Generate practice questions for student."""
        profile = self.student_memory.get_student_profile(student_id)
        if not profile:
            return []
        
        level = profile.current_level.get(subject, DifficultyLevel.BEGINNER)
        
        # Search for relevant questions
        questions_data = self.knowledge_base.search_questions(
            f"{subject.value} {level.value}", subject.value, num_questions
        )
        
        questions = []
        for i, q_data in enumerate(questions_data):
            metadata = q_data['metadata']
            
            question = Question(
                question_id=str(uuid.uuid4()),
                question_text=metadata.get('question', f'Sample question {i+1}'),
                question_type=QuestionType.SHORT_ANSWER,
                subject_area=subject,
                difficulty_level=level,
                correct_answer=metadata.get('answer', 'Sample answer'),
                explanation=f"This tests understanding of {subject.value}"
            )
            questions.append(question)
        
        return questions
    
    def submit_answer(self, student_id: str, question_id: str, answer: str,
                     time_taken: float) -> Dict[str, Any]:
        """Process student answer submission."""
        # In a real implementation, you'd retrieve the question and check the answer
        is_correct = True  # Placeholder
        
        response = StudentResponse(
            response_id=str(uuid.uuid4()),
            question_id=question_id,
            student_answer=answer,
            is_correct=is_correct,
            time_taken_seconds=time_taken,
            timestamp=datetime.now()
        )
        
        # Update session
        if student_id in self.current_sessions:
            session = self.current_sessions[student_id]
            session.responses.append(response)
            session.questions_attempted.append(question_id)
        
        # Provide feedback
        feedback = {
            "is_correct": is_correct,
            "explanation": "Good job!" if is_correct else "Let's review this concept.",
            "response": response
        }
        
        return feedback
    
    def end_learning_session(self, student_id: str) -> Dict[str, Any]:
        """End current learning session."""
        if student_id not in self.current_sessions:
            return {"error": "No active session"}
        
        session = self.current_sessions[student_id]
        session.end_time = datetime.now()
        
        # Calculate performance
        if session.responses:
            correct_count = sum(1 for r in session.responses if r.is_correct)
            session.performance_score = correct_count / len(session.responses)
        
        # Save session
        self.student_memory.save_learning_session(session)
        
        # Update student progress
        profile = self.student_memory.get_student_profile(student_id)
        if profile and session.responses:
            # Determine subject from session (simplified)
            subject = SubjectArea.MATHEMATICS  # Placeholder
            self.student_memory.update_student_progress(student_id, subject, session.responses)
        
        # Remove from current sessions
        del self.current_sessions[student_id]
        
        return {
            "session_summary": {
                "duration_minutes": (session.end_time - session.start_time).total_seconds() / 60,
                "questions_attempted": len(session.questions_attempted),
                "performance_score": session.performance_score,
                "topics_covered": session.topics_covered
            }
        }
    
    def get_learning_path(self, student_id: str, subject: SubjectArea) -> List[LearningObjective]:
        """Get personalized learning path."""
        profile = self.student_memory.get_student_profile(student_id)
        if not profile:
            return []
        
        return self.curriculum_planner.generate_learning_path(
            profile, subject, DifficultyLevel.ADVANCED
        )

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="AI Tutor Agent",
        page_icon="ðŸŽ“",
        layout="wide"
    )
    
    st.title("ðŸŽ“ AI Tutor Agent")
    st.markdown("Personalized AI-powered learning assistant")
    
    # Initialize session state
    if 'tutor' not in st.session_state:
        st.session_state['tutor'] = None
    if 'current_student' not in st.session_state:
        st.session_state['current_student'] = None
    if 'active_session' not in st.session_state:
        st.session_state['active_session'] = None
    
    # Sidebar
    with st.sidebar:
        st.header("ðŸ”§ Configuration")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Tutor") or st.session_state['tutor'] is None:
            with st.spinner("Initializing AI tutor..."):
                st.session_state['tutor'] = AITutorAgent(openai_key)
                st.success("AI Tutor ready!")
        
        st.header("ðŸ‘¤ Student Profile")
        
        if st.session_state['current_student'] is None:
            student_name = st.text_input("Student Name")
            student_age = st.number_input("Age", min_value=5, max_value=100, value=16)
            
            learning_style = st.selectbox("Learning Style", [
                "Select...", "Visual", "Auditory", "Kinesthetic", "Reading/Writing"
            ])
            
            preferred_subjects = st.multiselect("Preferred Subjects", [
                "Mathematics", "Science", "Programming", "Literature", "History", "Languages"
            ])
            
            if st.button("Create Profile") and student_name:
                tutor = st.session_state['tutor']
                
                # Convert selections
                style_map = {
                    "Visual": LearningStyle.VISUAL,
                    "Auditory": LearningStyle.AUDITORY,
                    "Kinesthetic": LearningStyle.KINESTHETIC,
                    "Reading/Writing": LearningStyle.READING_WRITING
                }
                
                subject_map = {
                    "Mathematics": SubjectArea.MATHEMATICS,
                    "Science": SubjectArea.SCIENCE,
                    "Programming": SubjectArea.PROGRAMMING,
                    "Literature": SubjectArea.LITERATURE,
                    "History": SubjectArea.HISTORY,
                    "Languages": SubjectArea.LANGUAGES
                }
                
                profile = tutor.create_student_profile(
                    name=student_name,
                    age=student_age,
                    learning_style=style_map.get(learning_style),
                    preferred_subjects=[subject_map[s] for s in preferred_subjects if s in subject_map]
                )
                
                st.session_state['current_student'] = profile
                st.success("Profile created!")
                st.rerun()
        else:
            profile = st.session_state['current_student']
            st.write(f"**Name:** {profile.name}")
            st.write(f"**Age:** {profile.age}")
            if profile.learning_style:
                st.write(f"**Learning Style:** {profile.learning_style.value}")
            
            if st.button("Reset Profile"):
                st.session_state['current_student'] = None
                st.session_state['active_session'] = None
                st.rerun()
    
    if not st.session_state['tutor']:
        st.info("ðŸ‘ˆ Please initialize the AI tutor")
        return
    
    if not st.session_state['current_student']:
        st.info("ðŸ‘ˆ Please create a student profile")
        return
    
    tutor = st.session_state['tutor']
    student = st.session_state['current_student']
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["ðŸ’¬ Ask Questions", "ðŸ“š Learning Path", "ðŸ§ª Practice", "ðŸ“Š Progress", "ðŸŽ¯ Session"])
    
    with tab1:
        st.header("ðŸ’¬ Ask Your Tutor")
        
        subject = st.selectbox("Subject Area", [
            "General", "Mathematics", "Science", "Programming", "Literature", "History", "Languages"
        ])
        
        question = st.text_area("What would you like to learn about?",
                              placeholder="e.g., How do I solve quadratic equations?")
        
        if st.button("Ask Question") and question:
            with st.spinner("Getting answer..."):
                subject_enum = None
                if subject != "General":
                    subject_map = {
                        "Mathematics": SubjectArea.MATHEMATICS,
                        "Science": SubjectArea.SCIENCE,
                        "Programming": SubjectArea.PROGRAMMING,
                        "Literature": SubjectArea.LITERATURE,
                        "History": SubjectArea.HISTORY,
                        "Languages": SubjectArea.LANGUAGES
                    }
                    subject_enum = subject_map.get(subject)
                
                response = tutor.ask_question(student.student_id, question, subject_enum)
                
                if "error" in response:
                    st.error(response["error"])
                else:
                    st.subheader("ðŸ“ Answer")
                    st.write(response["answer"])
                    
                    if response.get("relevant_content"):
                        st.subheader("ðŸ“š Related Content")
                        for content in response["relevant_content"][:2]:
                            st.write(f"â€¢ {content['metadata'].get('title', 'Content')}")
                    
                    if response.get("follow_up_suggestions"):
                        st.subheader("ðŸ¤” Follow-up Questions")
                        for suggestion in response["follow_up_suggestions"]:
                            st.write(f"â€¢ {suggestion}")
    
    with tab2:
        st.header("ðŸ“š Personalized Learning Path")
        
        subject_choice = st.selectbox("Choose Subject for Learning Path", [
            "Mathematics", "Science", "Programming", "Literature", "History", "Languages"
        ], key="learning_path_subject")
        
        if st.button("Generate Learning Path"):
            subject_map = {
                "Mathematics": SubjectArea.MATHEMATICS,
                "Science": SubjectArea.SCIENCE,
                "Programming": SubjectArea.PROGRAMMING,
                "Literature": SubjectArea.LITERATURE,
                "History": SubjectArea.HISTORY,
                "Languages": SubjectArea.LANGUAGES
            }
            
            subject_enum = subject_map[subject_choice]
            learning_path = tutor.get_learning_path(student.student_id, subject_enum)
            
            if learning_path:
                st.subheader(f"ðŸŽ¯ Learning Path for {subject_choice}")
                
                for i, objective in enumerate(learning_path, 1):
                    with st.expander(f"{i}. {objective.title}"):
                        st.write(f"**Description:** {objective.description}")
                        st.write(f"**Difficulty:** {objective.difficulty_level.value}")
                        st.write(f"**Estimated Time:** {objective.estimated_time_hours} hours")
                        
                        if objective.prerequisites:
                            st.write(f"**Prerequisites:** {', '.join(objective.prerequisites)}")
            else:
                st.info("No learning path available for this subject yet.")
    
    with tab3:
        st.header("ðŸ§ª Practice Questions")
        
        practice_subject = st.selectbox("Practice Subject", [
            "Mathematics", "Science", "Programming", "Literature", "History", "Languages"
        ], key="practice_subject")
        
        num_questions = st.slider("Number of Questions", 1, 10, 5)
        
        if st.button("Generate Practice Questions"):
            subject_map = {
                "Mathematics": SubjectArea.MATHEMATICS,
                "Science": SubjectArea.SCIENCE,
                "Programming": SubjectArea.PROGRAMMING,
                "Literature": SubjectArea.LITERATURE,
                "History": SubjectArea.HISTORY,
                "Languages": SubjectArea.LANGUAGES
            }
            
            subject_enum = subject_map[practice_subject]
            questions = tutor.generate_practice_questions(student.student_id, subject_enum, num_questions)
            
            if questions:
                st.session_state['practice_questions'] = questions
                st.success(f"Generated {len(questions)} practice questions!")
        
        # Display practice questions
        if 'practice_questions' in st.session_state:
            questions = st.session_state['practice_questions']
            
            for i, question in enumerate(questions):
                st.subheader(f"Question {i+1}")
                st.write(question.question_text)
                
                answer = st.text_input(f"Your answer for question {i+1}:", key=f"answer_{i}")
                
                if st.button(f"Submit Answer {i+1}", key=f"submit_{i}") and answer:
                    start_time = datetime.now()
                    # Simulate time taken (in real app, track actual time)
                    time_taken = 30.0
                    
                    feedback = tutor.submit_answer(
                        student.student_id, 
                        question.question_id, 
                        answer, 
                        time_taken
                    )
                    
                    if feedback["is_correct"]:
                        st.success("âœ… Correct!")
                    else:
                        st.error("âŒ Incorrect")
                    
                    st.write(feedback["explanation"])
    
    with tab4:
        st.header("ðŸ“Š Learning Progress")
        
        analytics = tutor.student_memory.get_learning_analytics(student.student_id)
        
        if "message" in analytics:
            st.info(analytics["message"])
        else:
            # Display metrics
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Study Time", f"{analytics['total_study_time_hours']:.1f} hrs")
            with col2:
                st.metric("Questions Answered", analytics['total_questions_answered'])
            with col3:
                st.metric("Accuracy", f"{analytics['overall_accuracy']:.1%}")
            with col4:
                st.metric("Avg Time/Question", f"{analytics['average_time_per_question']:.1f}s")
            
            # Progress visualization
            if analytics['total_questions_answered'] > 0:
                st.subheader("ðŸ“ˆ Performance Over Time")
                
                # Mock progress data
                dates = pd.date_range(start="2024-01-01", periods=7, freq="D")
                scores = np.random.uniform(0.6, 0.9, 7)
                
                fig = px.line(x=dates, y=scores, title="Daily Performance", 
                            labels={"x": "Date", "y": "Accuracy"})
                st.plotly_chart(fig, use_container_width=True)
            
            # Subject breakdown
            if analytics['subject_performance']:
                st.subheader("ðŸ“š Subject Performance")
                
                subjects = list(analytics['subject_performance'].keys())
                accuracies = [
                    perf['correct'] / perf['total'] if perf['total'] > 0 else 0
                    for perf in analytics['subject_performance'].values()
                ]
                
                fig = px.bar(x=subjects, y=accuracies, title="Accuracy by Subject")
                st.plotly_chart(fig, use_container_width=True)
    
    with tab5:
        st.header("ðŸŽ¯ Learning Session")
        
        if st.session_state['active_session'] is None:
            if st.button("Start Learning Session"):
                session = tutor.start_learning_session(student.student_id)
                st.session_state['active_session'] = session
                st.success("Learning session started!")
                st.rerun()
        else:
            session = st.session_state['active_session']
            
            st.success("ðŸŸ¢ Learning session active")
            st.write(f"**Started:** {session.start_time.strftime('%H:%M:%S')}")
            st.write(f"**Questions attempted:** {len(session.questions_attempted)}")
            st.write(f"**Topics covered:** {len(session.topics_covered)}")
            
            if st.button("End Learning Session"):
                summary = tutor.end_learning_session(student.student_id)
                st.session_state['active_session'] = None
                
                if "error" in summary:
                    st.error(summary["error"])
                else:
                    st.success("Session completed!")
                    
                    session_data = summary["session_summary"]
                    st.write(f"**Duration:** {session_data['duration_minutes']:.1f} minutes")
                    st.write(f"**Questions:** {session_data['questions_attempted']}")
                    st.write(f"**Performance:** {session_data['performance_score']:.1%}")
                
                st.rerun()

if __name__ == "__main__":
    main()
````

## Project Summary

The AI Tutor Agent represents a comprehensive personalized education system that combines intelligent curriculum planning, adaptive question answering, and persistent memory management to deliver customized learning experiences that adapt to individual student needs and learning patterns.

### Key Value Propositions:
- **Personalized Learning Paths**: Dynamic curriculum generation based on student performance, learning style, and educational objectives using graph-based knowledge modeling
- **Intelligent Question Answering**: Context-aware educational responses with explanations, examples, and follow-up questions tailored to student comprehension levels
- **Persistent Learning Memory**: Comprehensive tracking of student progress, preferences, and interaction history for continuous personalization and learning continuity
- **Adaptive Assessment**: Real-time performance evaluation with difficulty adjustment and targeted practice question generation

### Technical Architecture:
The system employs ChromaDB for educational content storage, NetworkX for curriculum dependency modeling, LangChain for conversational AI capabilities, and comprehensive analytics tracking, creating a scalable tutoring platform that can be extended with additional subjects, learning modalities, and assessment techniques for diverse educational applications.