<small>Claude Sonnet 4 **(Social Media Content Strategy Assistant with RAG)**</small>
# Social Media Content Strategy Assistant

## Project Title

**AI-Powered Social Media Content Strategy Assistant with Retrieval-Augmented Generation**

## Key Concepts Explanation

### **RAG (Retrieval-Augmented Generation)**
A hybrid AI approach that combines information retrieval from knowledge bases with generative AI to create contextually relevant and accurate social media content strategies based on real-time data and historical performance.

### **Trending Topics**
Real-time identification and analysis of popular subjects, hashtags, and conversations across social media platforms, enabling content creators to align their strategies with current audience interests and viral content patterns.

### **Engagement Analytics**
Quantitative measurement and analysis of user interactions (likes, shares, comments, saves) with social media content, providing insights into content performance and audience behavior patterns.

### **Content Templates**
Pre-designed, customizable frameworks for different types of social media posts that maintain brand consistency while allowing for creative variation and platform-specific optimization.

### **Hashtag Research**
Systematic analysis of hashtag performance, relevance, and trending patterns across different platforms to maximize content discoverability and engagement rates.

### **Instagram API**
RESTful web service providing programmatic access to Instagram's data including user profiles, media content, engagement metrics, and business insights for data-driven content strategy development.

### **Influencer Data**
Comprehensive information about social media influencers including audience demographics, engagement rates, content performance, and collaboration opportunities for strategic partnership decisions.

### **Brand Guidelines**
Standardized rules and specifications governing brand voice, visual identity, messaging tone, and content standards to ensure consistent brand representation across all social media platforms.

## Comprehensive Project Explanation

The Social Media Content Strategy Assistant represents an advanced AI-driven platform that revolutionizes how brands and content creators develop, execute, and optimize their social media strategies. This system leverages RAG architecture to combine real-time social media data with comprehensive brand knowledge, creating intelligent recommendations that align with both trending topics and brand identity.

### **Objectives**

1. **Automated Content Strategy Development**: Generate data-driven content strategies that balance trending topics with brand objectives and audience preferences.

2. **Real-time Trend Integration**: Continuously monitor and integrate trending topics, hashtags, and viral content patterns into content recommendations.

3. **Performance-Driven Optimization**: Analyze engagement metrics and content performance to refine strategies and improve future content effectiveness.

4. **Brand Consistency Maintenance**: Ensure all generated content adheres to established brand guidelines while maximizing engagement potential.

5. **Multi-Platform Optimization**: Tailor content strategies for different social media platforms considering their unique algorithms and audience behaviors.

### **Challenges**

1. **Data Volume and Velocity**: Processing massive amounts of real-time social media data while maintaining system performance and response times.

2. **Trend Ephemeral Nature**: Identifying and capitalizing on trending topics before they lose relevance in the fast-paced social media environment.

3. **Brand Voice Consistency**: Balancing creative content generation with strict adherence to brand guidelines and messaging standards.

4. **Multi-Platform Complexity**: Adapting content strategies for different platforms with varying content formats, algorithms, and audience expectations.

5. **Engagement Prediction**: Accurately forecasting content performance based on historical data and current trends.

### **Potential Impact**

- **Enhanced Content Performance**: Data-driven strategies lead to higher engagement rates and improved social media ROI
- **Time Efficiency**: Automated content planning and generation reduces manual effort by up to 70%
- **Brand Consistency**: Standardized content creation ensures cohesive brand messaging across all platforms
- **Competitive Advantage**: Real-time trend integration enables brands to stay ahead of competitors
- **Scalable Content Operations**: Support for multiple brands and campaigns through centralized content management

## Comprehensive Project Example with Python Implementation

````python
langchain==0.1.0
chromadb==0.4.18
openai==1.3.0
requests==2.31.0
pandas==2.1.4
numpy==1.24.3
scikit-learn==1.3.2
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
tweepy==4.14.0
instagrapi==2.0.0
schedule==1.2.0
redis==5.0.1
celery==5.3.4
matplotlib==3.8.2
seaborn==0.13.0
wordcloud==1.9.2
````

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # API Keys
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    INSTAGRAM_ACCESS_TOKEN = os.getenv("INSTAGRAM_ACCESS_TOKEN")
    TWITTER_BEARER_TOKEN = os.getenv("TWITTER_BEARER_TOKEN")
    
    # Database
    CHROMA_PERSIST_DIRECTORY = "./chroma_db"
    REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
    
    # Model Configuration
    EMBEDDING_MODEL = "text-embedding-ada-002"
    CHAT_MODEL = "gpt-4-turbo-preview"
    
    # Application Settings
    MAX_RESULTS = 20
    SIMILARITY_THRESHOLD = 0.75
    TREND_UPDATE_INTERVAL = 300  # 5 minutes
    CONTENT_HISTORY_DAYS = 30
    
    # Platform Settings
    PLATFORMS = ["instagram", "twitter", "linkedin", "tiktok"]
    MAX_HASHTAGS_PER_POST = 10
````

````python
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

class Platform(str, Enum):
    INSTAGRAM = "instagram"
    TWITTER = "twitter"
    LINKEDIN = "linkedin"
    TIKTOK = "tiktok"

class ContentType(str, Enum):
    POST = "post"
    STORY = "story"
    REEL = "reel"
    CAROUSEL = "carousel"
    VIDEO = "video"

class Brand(BaseModel):
    id: str
    name: str
    industry: str
    voice_tone: str
    target_audience: List[str]
    brand_colors: List[str]
    guidelines: Dict[str, Any]
    social_handles: Dict[Platform, str]

class TrendingTopic(BaseModel):
    topic: str
    platform: Platform
    engagement_score: float
    hashtags: List[str]
    mentions_count: int
    sentiment: str
    relevance_score: float
    timestamp: datetime

class ContentTemplate(BaseModel):
    id: str
    name: str
    platform: Platform
    content_type: ContentType
    template: str
    variables: List[str]
    best_times: List[str]
    expected_engagement: float

class EngagementMetrics(BaseModel):
    post_id: str
    platform: Platform
    likes: int
    shares: int
    comments: int
    saves: Optional[int]
    views: Optional[int]
    engagement_rate: float
    reach: int
    timestamp: datetime

class ContentStrategy(BaseModel):
    id: str
    brand_id: str
    platform: Platform
    content_pillars: List[str]
    posting_frequency: int
    best_times: List[str]
    hashtag_strategy: Dict[str, List[str]]
    target_metrics: Dict[str, float]

class ContentRequest(BaseModel):
    brand_id: str
    platform: Platform
    content_type: ContentType
    topic: Optional[str] = None
    target_audience: Optional[List[str]] = None
    include_trending: bool = True
    tone: Optional[str] = None
````

````python
import tweepy
import requests
import json
from typing import List, Dict, Optional
from datetime import datetime, timedelta
from models import TrendingTopic, EngagementMetrics, Platform
from config import Config
import time

class TwitterCollector:
    def __init__(self):
        self.client = tweepy.Client(bearer_token=Config.TWITTER_BEARER_TOKEN)
    
    def get_trending_topics(self, location_id: int = 1) -> List[TrendingTopic]:
        """Get trending topics from Twitter"""
        try:
            trends = self.client.get_place_trends(location_id)
            trending_topics = []
            
            for trend in trends[0]['trends'][:10]:
                # Calculate engagement score based on tweet volume
                engagement_score = min(trend.get('tweet_volume', 0) / 10000, 1.0)
                
                trending_topic = TrendingTopic(
                    topic=trend['name'],
                    platform=Platform.TWITTER,
                    engagement_score=engagement_score,
                    hashtags=[trend['name']] if trend['name'].startswith('#') else [],
                    mentions_count=trend.get('tweet_volume', 0),
                    sentiment="neutral",  # Would need sentiment analysis
                    relevance_score=0.8,
                    timestamp=datetime.now()
                )
                trending_topics.append(trending_topic)
            
            return trending_topics
            
        except Exception as e:
            print(f"Error fetching Twitter trends: {e}")
            return []
    
    def search_hashtag_performance(self, hashtag: str, days: int = 7) -> Dict[str, Any]:
        """Analyze hashtag performance over time"""
        try:
            query = f"#{hashtag} -is:retweet"
            end_time = datetime.now()
            start_time = end_time - timedelta(days=days)
            
            tweets = tweepy.Paginator(
                self.client.search_recent_tweets,
                query=query,
                start_time=start_time,
                end_time=end_time,
                tweet_fields=['public_metrics', 'created_at']
            ).flatten(limit=100)
            
            total_engagement = 0
            tweet_count = 0
            
            for tweet in tweets:
                if hasattr(tweet, 'public_metrics'):
                    metrics = tweet.public_metrics
                    engagement = (
                        metrics['like_count'] + 
                        metrics['retweet_count'] + 
                        metrics['reply_count']
                    )
                    total_engagement += engagement
                    tweet_count += 1
            
            avg_engagement = total_engagement / tweet_count if tweet_count > 0 else 0
            
            return {
                'hashtag': hashtag,
                'average_engagement': avg_engagement,
                'total_posts': tweet_count,
                'performance_score': min(avg_engagement / 100, 1.0)
            }
            
        except Exception as e:
            print(f"Error analyzing hashtag {hashtag}: {e}")
            return {'hashtag': hashtag, 'average_engagement': 0, 'total_posts': 0, 'performance_score': 0}

class InstagramCollector:
    def __init__(self):
        self.access_token = Config.INSTAGRAM_ACCESS_TOKEN
        self.base_url = "https://graph.instagram.com"
    
    def get_hashtag_data(self, hashtag: str) -> Dict[str, Any]:
        """Get hashtag data from Instagram"""
        try:
            # Search for hashtag
            search_url = f"{self.base_url}/ig_hashtag_search"
            params = {
                'user_id': 'YOUR_USER_ID',  # Would need actual user ID
                'q': hashtag,
                'access_token': self.access_token
            }
            
            response = requests.get(search_url, params=params)
            if response.status_code == 200:
                data = response.json()
                if data.get('data'):
                    hashtag_id = data['data'][0]['id']
                    
                    # Get hashtag info
                    info_url = f"{self.base_url}/{hashtag_id}"
                    info_params = {
                        'fields': 'name,media_count',
                        'access_token': self.access_token
                    }
                    
                    info_response = requests.get(info_url, params=info_params)
                    if info_response.status_code == 200:
                        return info_response.json()
            
            return {'name': hashtag, 'media_count': 0}
            
        except Exception as e:
            print(f"Error fetching Instagram hashtag data: {e}")
            return {'name': hashtag, 'media_count': 0}
    
    def get_account_insights(self, account_id: str) -> Dict[str, Any]:
        """Get Instagram account insights"""
        try:
            url = f"{self.base_url}/{account_id}/insights"
            params = {
                'metric': 'impressions,reach,profile_views',
                'period': 'day',
                'access_token': self.access_token
            }
            
            response = requests.get(url, params=params)
            if response.status_code == 200:
                return response.json()
            
            return {}
            
        except Exception as e:
            print(f"Error fetching Instagram insights: {e}")
            return {}

class TrendAnalyzer:
    def __init__(self):
        self.twitter_collector = TwitterCollector()
        self.instagram_collector = InstagramCollector()
    
    def get_cross_platform_trends(self) -> List[TrendingTopic]:
        """Get trending topics across multiple platforms"""
        all_trends = []
        
        # Get Twitter trends
        twitter_trends = self.twitter_collector.get_trending_topics()
        all_trends.extend(twitter_trends)
        
        # Add sample Instagram trends (would need proper API access)
        sample_instagram_trends = [
            TrendingTopic(
                topic="sustainable fashion",
                platform=Platform.INSTAGRAM,
                engagement_score=0.85,
                hashtags=["#sustainablefashion", "#ecofriendly", "#slowfashion"],
                mentions_count=25000,
                sentiment="positive",
                relevance_score=0.9,
                timestamp=datetime.now()
            ),
            TrendingTopic(
                topic="workout motivation",
                platform=Platform.INSTAGRAM,
                engagement_score=0.75,
                hashtags=["#fitness", "#motivation", "#workout"],
                mentions_count=18000,
                sentiment="positive",
                relevance_score=0.8,
                timestamp=datetime.now()
            )
        ]
        all_trends.extend(sample_instagram_trends)
        
        return all_trends
    
    def analyze_hashtag_clusters(self, hashtags: List[str]) -> Dict[str, List[str]]:
        """Group related hashtags into clusters"""
        # Simple clustering based on common words
        clusters = {}
        
        for hashtag in hashtags:
            # Extract key terms
            clean_tag = hashtag.replace('#', '').lower()
            
            # Simple keyword-based clustering
            if any(term in clean_tag for term in ['fitness', 'workout', 'gym', 'health']):
                clusters.setdefault('fitness', []).append(hashtag)
            elif any(term in clean_tag for term in ['fashion', 'style', 'outfit', 'clothes']):
                clusters.setdefault('fashion', []).append(hashtag)
            elif any(term in clean_tag for term in ['food', 'recipe', 'cooking', 'eat']):
                clusters.setdefault('food', []).append(hashtag)
            elif any(term in clean_tag for term in ['travel', 'vacation', 'trip', 'explore']):
                clusters.setdefault('travel', []).append(hashtag)
            else:
                clusters.setdefault('general', []).append(hashtag)
        
        return clusters
````

````python
import chromadb
from chromadb.config import Settings
from langchain.embeddings import OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from typing import List, Dict, Any
from config import Config
import json

class SocialMediaVectorStore:
    def __init__(self):
        self.embeddings = OpenAIEmbeddings(
            openai_api_key=Config.OPENAI_API_KEY,
            model=Config.EMBEDDING_MODEL
        )
        
        self.client = chromadb.PersistentClient(
            path=Config.CHROMA_PERSIST_DIRECTORY,
            settings=Settings(anonymized_telemetry=False)
        )
        
        # Initialize collections
        self.brands_collection = self._get_or_create_collection("brands")
        self.content_templates_collection = self._get_or_create_collection("content_templates")
        self.trending_topics_collection = self._get_or_create_collection("trending_topics")
        self.successful_posts_collection = self._get_or_create_collection("successful_posts")
        self.hashtag_performance_collection = self._get_or_create_collection("hashtag_performance")
    
    def _get_or_create_collection(self, name: str):
        try:
            return self.client.get_collection(name)
        except:
            return self.client.create_collection(name)
    
    def add_brand_profile(self, brand_data: Dict[str, Any]):
        """Add brand profile to vector store"""
        try:
            searchable_text = f"""
            Brand: {brand_data.get('name', '')}
            Industry: {brand_data.get('industry', '')}
            Voice Tone: {brand_data.get('voice_tone', '')}
            Target Audience: {', '.join(brand_data.get('target_audience', []))}
            Brand Guidelines: {json.dumps(brand_data.get('guidelines', {}))}
            """
            
            embedding = self.embeddings.embed_query(searchable_text)
            
            self.brands_collection.add(
                documents=[searchable_text],
                embeddings=[embedding],
                metadatas=[brand_data],
                ids=[brand_data['id']]
            )
            
        except Exception as e:
            print(f"Error adding brand profile: {e}")
    
    def add_content_template(self, template_data: Dict[str, Any]):
        """Add content template to vector store"""
        try:
            searchable_text = f"""
            Template Name: {template_data.get('name', '')}
            Platform: {template_data.get('platform', '')}
            Content Type: {template_data.get('content_type', '')}
            Template: {template_data.get('template', '')}
            Variables: {', '.join(template_data.get('variables', []))}
            Best Times: {', '.join(template_data.get('best_times', []))}
            """
            
            embedding = self.embeddings.embed_query(searchable_text)
            
            self.content_templates_collection.add(
                documents=[searchable_text],
                embeddings=[embedding],
                metadatas=[template_data],
                ids=[template_data['id']]
            )
            
        except Exception as e:
            print(f"Error adding content template: {e}")
    
    def add_trending_topic(self, trend_data: Dict[str, Any]):
        """Add trending topic to vector store"""
        try:
            searchable_text = f"""
            Topic: {trend_data.get('topic', '')}
            Platform: {trend_data.get('platform', '')}
            Hashtags: {', '.join(trend_data.get('hashtags', []))}
            Sentiment: {trend_data.get('sentiment', '')}
            Engagement Score: {trend_data.get('engagement_score', 0)}
            """
            
            embedding = self.embeddings.embed_query(searchable_text)
            
            self.trending_topics_collection.add(
                documents=[searchable_text],
                embeddings=[embedding],
                metadatas=[trend_data],
                ids=[f"{trend_data.get('platform', '')}_{trend_data.get('topic', '').replace(' ', '_')}_{trend_data.get('timestamp', '')}"]
            )
            
        except Exception as e:
            print(f"Error adding trending topic: {e}")
    
    def add_successful_post(self, post_data: Dict[str, Any]):
        """Add successful post data for learning"""
        try:
            searchable_text = f"""
            Content: {post_data.get('content', '')}
            Platform: {post_data.get('platform', '')}
            Hashtags: {', '.join(post_data.get('hashtags', []))}
            Engagement Rate: {post_data.get('engagement_rate', 0)}
            Brand: {post_data.get('brand', '')}
            Content Type: {post_data.get('content_type', '')}
            """
            
            embedding = self.embeddings.embed_query(searchable_text)
            
            self.successful_posts_collection.add(
                documents=[searchable_text],
                embeddings=[embedding],
                metadatas=[post_data],
                ids=[post_data.get('id', f"post_{len(searchable_text)}")]
            )
            
        except Exception as e:
            print(f"Error adding successful post: {e}")
    
    def search_similar(self, query: str, collection_name: str, n_results: int = 5) -> List[Dict]:
        """Search for similar items in specified collection"""
        try:
            collection = getattr(self, f"{collection_name}_collection")
            query_embedding = self.embeddings.embed_query(query)
            
            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results
            )
            
            return [
                {
                    'metadata': metadata,
                    'document': document,
                    'distance': distance
                }
                for metadata, document, distance in zip(
                    results['metadatas'][0],
                    results['documents'][0],
                    results['distances'][0]
                )
            ]
            
        except Exception as e:
            print(f"Error searching vector store: {e}")
            return []
    
    def get_brand_context(self, brand_id: str) -> Dict[str, Any]:
        """Get brand context for content generation"""
        try:
            results = self.brands_collection.get(ids=[brand_id])
            if results['metadatas']:
                return results['metadatas'][0]
            return {}
        except Exception as e:
            print(f"Error getting brand context: {e}")
            return {}
````

````python
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import HumanMessage, SystemMessage
from vector_store import SocialMediaVectorStore
from data_collectors import TrendAnalyzer
from typing import List, Dict, Any, Optional
from config import Config
from models import Platform, ContentType, Brand
import json
import random

class ContentStrategyGenerator:
    def __init__(self):
        self.vector_store = SocialMediaVectorStore()
        self.trend_analyzer = TrendAnalyzer()
        
        self.chat_model = ChatOpenAI(
            openai_api_key=Config.OPENAI_API_KEY,
            model_name=Config.CHAT_MODEL,
            temperature=0.7
        )
    
    def generate_content_strategy(self, brand_id: str, platform: Platform, 
                                content_type: ContentType, topic: Optional[str] = None) -> Dict[str, Any]:
        """Generate comprehensive content strategy"""
        try:
            # Get brand context
            brand_context = self.vector_store.get_brand_context(brand_id)
            
            # Get relevant trending topics
            relevant_trends = self._get_relevant_trends(brand_context, platform, topic)
            
            # Get successful content examples
            successful_examples = self._get_successful_examples(brand_context, platform, content_type)
            
            # Get appropriate templates
            suitable_templates = self._get_suitable_templates(platform, content_type)
            
            # Generate strategy
            strategy = self._generate_strategy_with_rag(
                brand_context, relevant_trends, successful_examples, 
                suitable_templates, platform, content_type, topic
            )
            
            return strategy
            
        except Exception as e:
            print(f"Error generating content strategy: {e}")
            return {}
    
    def _get_relevant_trends(self, brand_context: Dict, platform: Platform, 
                           topic: Optional[str]) -> List[Dict]:
        """Get trending topics relevant to the brand and topic"""
        try:
            # Build search query
            search_parts = []
            if brand_context.get('industry'):
                search_parts.append(brand_context['industry'])
            if topic:
                search_parts.append(topic)
            if brand_context.get('target_audience'):
                search_parts.extend(brand_context['target_audience'])
            
            search_query = " ".join(search_parts)
            
            # Search for relevant trends
            relevant_trends = self.vector_store.search_similar(
                search_query, "trending_topics", n_results=5
            )
            
            # Filter by platform
            platform_trends = [
                trend for trend in relevant_trends 
                if trend['metadata'].get('platform') == platform.value
            ]
            
            return platform_trends[:3]
            
        except Exception as e:
            print(f"Error getting relevant trends: {e}")
            return []
    
    def _get_successful_examples(self, brand_context: Dict, platform: Platform, 
                               content_type: ContentType) -> List[Dict]:
        """Get examples of successful posts"""
        try:
            search_query = f"{brand_context.get('industry', '')} {platform.value} {content_type.value}"
            
            successful_posts = self.vector_store.search_similar(
                search_query, "successful_posts", n_results=3
            )
            
            return successful_posts
            
        except Exception as e:
            print(f"Error getting successful examples: {e}")
            return []
    
    def _get_suitable_templates(self, platform: Platform, content_type: ContentType) -> List[Dict]:
        """Get suitable content templates"""
        try:
            search_query = f"{platform.value} {content_type.value}"
            
            templates = self.vector_store.search_similar(
                search_query, "content_templates", n_results=3
            )
            
            return templates
            
        except Exception as e:
            print(f"Error getting suitable templates: {e}")
            return []
    
    def _generate_strategy_with_rag(self, brand_context: Dict, trends: List[Dict], 
                                  examples: List[Dict], templates: List[Dict],
                                  platform: Platform, content_type: ContentType, 
                                  topic: Optional[str]) -> Dict[str, Any]:
        """Generate content strategy using RAG approach"""
        try:
            # Prepare context
            context = self._prepare_context(brand_context, trends, examples, templates)
            
            # Create prompt
            prompt = self._create_strategy_prompt(
                context, platform, content_type, topic, brand_context
            )
            
            # Generate strategy
            messages = [
                SystemMessage(content=self._get_system_message()),
                HumanMessage(content=prompt)
            ]
            
            response = self.chat_model(messages)
            
            # Parse and structure response
            strategy = self._parse_strategy_response(response.content, brand_context, platform)
            
            return strategy
            
        except Exception as e:
            print(f"Error generating strategy with RAG: {e}")
            return {}
    
    def _prepare_context(self, brand_context: Dict, trends: List[Dict], 
                        examples: List[Dict], templates: List[Dict]) -> str:
        """Prepare context for RAG generation"""
        context_parts = []
        
        # Brand context
        context_parts.append("BRAND INFORMATION:")
        context_parts.append(f"Name: {brand_context.get('name', 'Unknown')}")
        context_parts.append(f"Industry: {brand_context.get('industry', 'Unknown')}")
        context_parts.append(f"Voice Tone: {brand_context.get('voice_tone', 'Professional')}")
        context_parts.append(f"Target Audience: {', '.join(brand_context.get('target_audience', []))}")
        
        # Trending topics
        if trends:
            context_parts.append("\nRELEVANT TRENDING TOPICS:")
            for trend in trends:
                metadata = trend['metadata']
                context_parts.append(f"- {metadata.get('topic', 'Unknown topic')}")
                context_parts.append(f"  Hashtags: {', '.join(metadata.get('hashtags', []))}")
                context_parts.append(f"  Engagement Score: {metadata.get('engagement_score', 0)}")
        
        # Successful examples
        if examples:
            context_parts.append("\nSUCCESSFUL CONTENT EXAMPLES:")
            for example in examples:
                metadata = example['metadata']
                context_parts.append(f"- Content: {metadata.get('content', 'No content')[:100]}...")
                context_parts.append(f"  Engagement Rate: {metadata.get('engagement_rate', 0)}")
                context_parts.append(f"  Hashtags: {', '.join(metadata.get('hashtags', []))}")
        
        # Templates
        if templates:
            context_parts.append("\nAVAILABLE TEMPLATES:")
            for template in templates:
                metadata = template['metadata']
                context_parts.append(f"- {metadata.get('name', 'Unnamed template')}")
                context_parts.append(f"  Template: {metadata.get('template', 'No template')}")
        
        return "\n".join(context_parts)
    
    def _create_strategy_prompt(self, context: str, platform: Platform, 
                              content_type: ContentType, topic: Optional[str], 
                              brand_context: Dict) -> str:
        """Create strategy generation prompt"""
        prompt = f"""
        Based on the provided context, create a comprehensive social media content strategy.
        
        REQUIREMENTS:
        - Platform: {platform.value}
        - Content Type: {content_type.value}
        - Topic: {topic or 'Brand-relevant content'}
        - Must align with brand voice and guidelines
        - Include trending elements where appropriate
        - Provide specific, actionable recommendations
        
        CONTEXT:
        {context}
        
        Please provide a detailed strategy including:
        1. Content ideas (3-5 specific post ideas)
        2. Recommended hashtags
        3. Best posting times
        4. Engagement tactics
        5. Call-to-action suggestions
        6. Visual content recommendations
        7. Performance expectations
        
        Format the response as a structured JSON with clear sections.
        """
        
        return prompt
    
    def _get_system_message(self) -> str:
        """Get system message for content strategy generation"""
        return """You are an expert social media strategist with deep knowledge of platform algorithms, 
        audience behavior, and content optimization. You specialize in creating data-driven content strategies 
        that balance trending topics with brand authenticity. Your recommendations are specific, actionable, 
        and designed to maximize engagement while maintaining brand consistency."""
    
    def _parse_strategy_response(self, response: str, brand_context: Dict, 
                               platform: Platform) -> Dict[str, Any]:
        """Parse and structure the AI response"""
        try:
            # Try to parse as JSON first
            try:
                structured_response = json.loads(response)
                if isinstance(structured_response, dict):
                    return structured_response
            except json.JSONDecodeError:
                pass
            
            # If not JSON, create structured response from text
            strategy = {
                'platform': platform.value,
                'brand_id': brand_context.get('id'),
                'content_ideas': self._extract_content_ideas(response),
                'hashtags': self._extract_hashtags(response),
                'posting_times': self._extract_posting_times(response),
                'engagement_tactics': self._extract_engagement_tactics(response),
                'cta_suggestions': self._extract_cta_suggestions(response),
                'visual_recommendations': self._extract_visual_recommendations(response),
                'performance_expectations': self._extract_performance_expectations(response),
                'full_response': response
            }
            
            return strategy
            
        except Exception as e:
            print(f"Error parsing strategy response: {e}")
            return {'full_response': response, 'error': str(e)}
    
    def _extract_content_ideas(self, response: str) -> List[str]:
        """Extract content ideas from response"""
        ideas = []
        lines = response.split('\n')
        in_content_section = False
        
        for line in lines:
            if 'content idea' in line.lower() or 'post idea' in line.lower():
                in_content_section = True
                continue
            if in_content_section and line.strip().startswith(('-', '•', '1.', '2.', '3.')):
                ideas.append(line.strip().lstrip('-•123456789. '))
            elif in_content_section and line.strip() == '':
                continue
            elif in_content_section and not line.strip().startswith(('-', '•', '1.', '2.', '3.')):
                break
        
        return ideas[:5]  # Return top 5 ideas
    
    def _extract_hashtags(self, response: str) -> List[str]:
        """Extract hashtags from response"""
        import re
        hashtags = re.findall(r'#\w+', response)
        return list(set(hashtags))[:Config.MAX_HASHTAGS_PER_POST]
    
    def _extract_posting_times(self, response: str) -> List[str]:
        """Extract posting times from response"""
        times = []
        lines = response.split('\n')
        
        for line in lines:
            if 'time' in line.lower() and ('best' in line.lower() or 'optimal' in line.lower()):
                # Extract time patterns
                import re
                time_patterns = re.findall(r'\d{1,2}:\d{2}\s*(?:AM|PM|am|pm)', line)
                times.extend(time_patterns)
        
        return times if times else ["9:00 AM", "1:00 PM", "7:00 PM"]
    
    def _extract_engagement_tactics(self, response: str) -> List[str]:
        """Extract engagement tactics from response"""
        tactics = []
        lines = response.split('\n')
        in_engagement_section = False
        
        for line in lines:
            if 'engagement' in line.lower() and ('tactic' in line.lower() or 'strategy' in line.lower()):
                in_engagement_section = True
                continue
            if in_engagement_section and line.strip().startswith(('-', '•')):
                tactics.append(line.strip().lstrip('-• '))
            elif in_engagement_section and line.strip() == '':
                continue
            elif in_engagement_section and not line.strip().startswith(('-', '•')):
                break
        
        return tactics[:5]
    
    def _extract_cta_suggestions(self, response: str) -> List[str]:
        """Extract call-to-action suggestions"""
        ctas = []
        lines = response.split('\n')
        
        for line in lines:
            if 'call-to-action' in line.lower() or 'cta' in line.lower():
                # Look for quoted text or specific CTA phrases
                import re
                quoted_text = re.findall(r'"([^"]*)"', line)
                ctas.extend(quoted_text)
        
        if not ctas:
            ctas = ["Share your thoughts below!", "Tag someone who needs to see this!", "Save this for later!"]
        
        return ctas[:3]
    
    def _extract_visual_recommendations(self, response: str) -> List[str]:
        """Extract visual content recommendations"""
        visuals = []
        lines = response.split('\n')
        
        for line in lines:
            if 'visual' in line.lower() or 'image' in line.lower() or 'video' in line.lower():
                if line.strip().startswith(('-', '•')):
                    visuals.append(line.strip().lstrip('-• '))
        
        return visuals[:3]
    
    def _extract_performance_expectations(self, response: str) -> Dict[str, Any]:
        """Extract performance expectations"""
        expectations = {}
        
        # Look for percentage patterns
        import re
        percentages = re.findall(r'(\d+(?:\.\d+)?)%', response)
        
        if percentages:
            expectations['engagement_rate'] = float(percentages[0]) / 100
        else:
            expectations['engagement_rate'] = 0.05  # Default 5%
        
        expectations['expected_reach'] = 1000  # Default expectation
        expectations['expected_impressions'] = 2000  # Default expectation
        
        return expectations

    def generate_hashtag_strategy(self, brand_id: str, topic: str, platform: Platform) -> Dict[str, Any]:
        """Generate hashtag strategy for specific topic"""
        try:
            brand_context = self.vector_store.get_brand_context(brand_id)
            
            # Get trending hashtags
            trends = self._get_relevant_trends(brand_context, platform, topic)
            trending_hashtags = []
            for trend in trends:
                trending_hashtags.extend(trend['metadata'].get('hashtags', []))
            
            # Generate hashtag mix
            hashtag_strategy = {
                'trending_hashtags': trending_hashtags[:3],
                'brand_hashtags': [f"#{brand_context.get('name', '').replace(' ', '').lower()}"],
                'niche_hashtags': self._generate_niche_hashtags(brand_context, topic),
                'community_hashtags': self._generate_community_hashtags(brand_context),
                'total_recommended': Config.MAX_HASHTAGS_PER_POST
            }
            
            return hashtag_strategy
            
        except Exception as e:
            print(f"Error generating hashtag strategy: {e}")
            return {}
    
    def _generate_niche_hashtags(self, brand_context: Dict, topic: str) -> List[str]:
        """Generate niche-specific hashtags"""
        industry = brand_context.get('industry', '').lower()
        topic_lower = topic.lower()
        
        niche_hashtags = []
        
        # Industry-specific hashtags
        if 'fashion' in industry:
            niche_hashtags.extend(['#fashionista', '#styleinspo', '#ootd'])
        elif 'food' in industry:
            niche_hashtags.extend(['#foodie', '#yummy', '#delicious'])
        elif 'tech' in industry:
            niche_hashtags.extend(['#innovation', '#technology', '#startup'])
        elif 'fitness' in industry:
            niche_hashtags.extend(['#fitnessmotivation', '#workout', '#healthylifestyle'])
        
        # Topic-specific hashtags
        if 'sustainable' in topic_lower:
            niche_hashtags.extend(['#sustainable', '#ecofriendly', '#green'])
        elif 'tips' in topic_lower:
            niche_hashtags.extend(['#tips', '#advice', '#howto'])
        
        return niche_hashtags[:4]
    
    def _generate_community_hashtags(self, brand_context: Dict) -> List[str]:
        """Generate community-building hashtags"""
        community_hashtags = ['#community', '#together', '#share']
        
        target_audience = brand_context.get('target_audience', [])
        for audience in target_audience:
            if 'entrepreneur' in audience.lower():
                community_hashtags.append('#entrepreneurs')
            elif 'parent' in audience.lower():
                community_hashtags.append('#parents')
            elif 'student' in audience.lower():
                community_hashtags.append('#students')
        
        return community_hashtags[:3]
````

````python
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
from content_generator import ContentStrategyGenerator
from data_collectors import TrendAnalyzer
from vector_store import SocialMediaVectorStore
from models import Platform, ContentType, Brand, ContentRequest
import uvicorn
from datetime import datetime

app = FastAPI(title="Social Media Content Strategy Assistant", version="1.0.0")

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize components
content_generator = ContentStrategyGenerator()
trend_analyzer = TrendAnalyzer()
vector_store = SocialMediaVectorStore()

class BrandRegistration(BaseModel):
    name: str
    industry: str
    voice_tone: str
    target_audience: List[str]
    brand_colors: List[str]
    guidelines: Dict[str, Any]
    social_handles: Dict[str, str]

class HashtagRequest(BaseModel):
    brand_id: str
    topic: str
    platform: Platform

@app.on_event("startup")
async def startup_event():
    """Initialize the system on startup"""
    print("Initializing Social Media Content Strategy Assistant...")
    
    # Add sample brand data
    sample_brands = [
        {
            'id': 'eco_fashion_brand',
            'name': 'EcoStyle',
            'industry': 'sustainable fashion',
            'voice_tone': 'friendly and inspiring',
            'target_audience': ['environmentally conscious consumers', 'young professionals', 'fashion enthusiasts'],
            'brand_colors': ['#2E8B57', '#F0E68C', '#DEB887'],
            'guidelines': {
                'messaging': 'Focus on sustainability and ethical fashion',
                'visual_style': 'Natural, earthy tones with clean aesthetics',
                'content_themes': ['sustainability', 'fashion tips', 'behind-the-scenes']
            },
            'social_handles': {
                'instagram': '@ecostyle',
                'twitter': '@ecostyle_brand'
            }
        },
        {
            'id': 'fitness_startup',
            'name': 'FitTech',
            'industry': 'fitness technology',
            'voice_tone': 'motivational and energetic',
            'target_audience': ['fitness enthusiasts', 'tech-savvy millennials', 'busy professionals'],
            'brand_colors': ['#FF6B35', '#004E89', '#FFFFFF'],
            'guidelines': {
                'messaging': 'Empowering fitness through technology',
                'visual_style': 'Bold, dynamic imagery with tech elements',
                'content_themes': ['workout tips', 'tech features', 'success stories']
            },
            'social_handles': {
                'instagram': '@fittech_app',
                'twitter': '@fittech'
            }
        }
    ]
    
    # Add sample templates
    sample_templates = [
        {
            'id': 'instagram_post_template',
            'name': 'Instagram Engagement Post',
            'platform': 'instagram',
            'content_type': 'post',
            'template': '🌟 {hook}\n\n{main_content}\n\n💭 {question}\n\n{hashtags}',
            'variables': ['hook', 'main_content', 'question', 'hashtags'],
            'best_times': ['9:00 AM', '1:00 PM', '7:00 PM'],
            'expected_engagement': 0.06
        },
        {
            'id': 'twitter_thread_template',
            'name': 'Twitter Thread Starter',
            'platform': 'twitter',
            'content_type': 'post',
            'template': '{thread_intro} 🧵\n\n1/{total_tweets}',
            'variables': ['thread_intro', 'total_tweets'],
            'best_times': ['8:00 AM', '12:00 PM', '5:00 PM'],
            'expected_engagement': 0.04
        }
    ]
    
    # Add sample successful posts
    sample_successful_posts = [
        {
            'id': 'post_1',
            'content': 'Sustainable fashion tip: Choose quality over quantity! Invest in timeless pieces that last for years.',
            'platform': 'instagram',
            'hashtags': ['#sustainablefashion', '#ecofriendly', '#minimalism'],
            'engagement_rate': 0.08,
            'brand': 'EcoStyle',
            'content_type': 'post'
        },
        {
            'id': 'post_2',
            'content': 'Your fitness journey is unique. Our AI adapts to YOUR needs, YOUR goals, YOUR schedule. 💪',
            'platform': 'instagram',
            'hashtags': ['#fitness', '#AI', '#personalized', '#workout'],
            'engagement_rate': 0.09,
            'brand': 'FitTech',
            'content_type': 'post'
        }
    ]
    
    # Populate vector store
    for brand in sample_brands:
        vector_store.add_brand_profile(brand)
    
    for template in sample_templates:
        vector_store.add_content_template(template)
    
    for post in sample_successful_posts:
        vector_store.add_successful_post(post)
    
    print("System initialized successfully!")

@app.get("/")
async def root():
    return {"message": "Social Media Content Strategy Assistant API"}

@app.post("/brands/register")
async def register_brand(brand: BrandRegistration):
    """Register a new brand profile"""
    try:
        brand_data = brand.dict()
        brand_data['id'] = brand.name.lower().replace(' ', '_')
        
        vector_store.add_brand_profile(brand_data)
        
        return {
            "message": "Brand registered successfully",
            "brand_id": brand_data['id']
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/content/strategy")
async def generate_content_strategy(request: ContentRequest):
    """Generate content strategy for a brand"""
    try:
        strategy = content_generator.generate_content_strategy(
            brand_id=request.brand_id,
            platform=request.platform,
            content_type=request.content_type,
            topic=request.topic
        )
        
        return {
            "brand_id": request.brand_id,
            "platform": request.platform.value,
            "content_type": request.content_type.value,
            "strategy": strategy,
            "generated_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/hashtags/strategy")
async def generate_hashtag_strategy(request: HashtagRequest):
    """Generate hashtag strategy for specific topic"""
    try:
        strategy = content_generator.generate_hashtag_strategy(
            brand_id=request.brand_id,
            topic=request.topic,
            platform=request.platform
        )
        
        return {
            "brand_id": request.brand_id,
            "topic": request.topic,
            "platform": request.platform.value,
            "hashtag_strategy": strategy,
            "generated_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/trends")
async def get_trending_topics(platform: Optional[str] = None):
    """Get current trending topics"""
    try:
        trends = trend_analyzer.get_cross_platform_trends()
        
        if platform:
            trends = [trend for trend in trends if trend.platform.value == platform]
        
        trend_data = []
        for trend in trends:
            trend_data.append({
                'topic': trend.topic,
                'platform': trend.platform.value,
                'engagement_score': trend.engagement_score,
                'hashtags': trend.hashtags,
                'mentions_count': trend.mentions_count,
                'sentiment': trend.sentiment
            })
        
        return {
            "trends": trend_data,
            "retrieved_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/brands/{brand_id}/context")
async def get_brand_context(brand_id: str):
    """Get brand context and guidelines"""
    try:
        context = vector_store.get_brand_context(brand_id)
        
        if not context:
            raise HTTPException(status_code=404, detail="Brand not found")
        
        return {
            "brand_id": brand_id,
            "context": context
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "Social Media Content Strategy Assistant"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````python
from api import app
from content_generator import ContentStrategyGenerator
from data_collectors import TrendAnalyzer
from models import Platform, ContentType
import asyncio

def demo_content_strategy():
    """Demonstrate the social media content strategy assistant"""
    content_generator = ContentStrategyGenerator()
    trend_analyzer = TrendAnalyzer()
    
    print("="*60)
    print("SOCIAL MEDIA CONTENT STRATEGY ASSISTANT DEMO")
    print("="*60)
    
    # Demo 1: Generate content strategy for sustainable fashion brand
    print("\n1. SUSTAINABLE FASHION BRAND STRATEGY")
    print("-" * 40)
    
    strategy_1 = content_generator.generate_content_strategy(
        brand_id='eco_fashion_brand',
        platform=Platform.INSTAGRAM,
        content_type=ContentType.POST,
        topic='sustainable fashion tips'
    )
    
    print("Brand: EcoStyle")
    print("Platform: Instagram")
    print("Topic: Sustainable Fashion Tips")
    print("\nGenerated Strategy:")
    if strategy_1.get('content_ideas'):
        print("Content Ideas:")
        for i, idea in enumerate(strategy_1['content_ideas'], 1):
            print(f"  {i}. {idea}")
    
    if strategy_1.get('hashtags'):
        print(f"\nRecommended Hashtags: {', '.join(strategy_1['hashtags'][:8])}")
    
    if strategy_1.get('posting_times'):
        print(f"Best Posting Times: {', '.join(strategy_1['posting_times'])}")
    
    # Demo 2: Generate hashtag strategy
    print("\n\n2. HASHTAG STRATEGY GENERATION")
    print("-" * 40)
    
    hashtag_strategy = content_generator.generate_hashtag_strategy(
        brand_id='fitness_startup',
        topic='workout motivation',
        platform=Platform.INSTAGRAM
    )
    
    print("Brand: FitTech")
    print("Topic: Workout Motivation")
    print("Platform: Instagram")
    print("\nHashtag Strategy:")
    
    for category, tags in hashtag_strategy.items():
        if category != 'total_recommended' and isinstance(tags, list):
            print(f"  {category.replace('_', ' ').title()}: {', '.join(tags)}")
    
    # Demo 3: Get trending topics
    print("\n\n3. CURRENT TRENDING TOPICS")
    print("-" * 40)
    
    trends = trend_analyzer.get_cross_platform_trends()
    
    print("Cross-Platform Trending Topics:")
    for i, trend in enumerate(trends[:5], 1):
        print(f"  {i}. {trend.topic} ({trend.platform.value})")
        print(f"     Engagement Score: {trend.engagement_score:.2f}")
        print(f"     Hashtags: {', '.join(trend.hashtags[:3])}")
        print()
    
    # Demo 4: Complete strategy for fitness brand
    print("\n4. COMPLETE FITNESS BRAND STRATEGY")
    print("-" * 40)
    
    strategy_2 = content_generator.generate_content_strategy(
        brand_id='fitness_startup',
        platform=Platform.TWITTER,
        content_type=ContentType.POST,
        topic='fitness technology'
    )
    
    print("Brand: FitTech")
    print("Platform: Twitter")
    print("Topic: Fitness Technology")
    print("\nComplete Strategy Response:")
    print(strategy_2.get('full_response', 'No response generated')[:500] + "...")

def run_api_demo():
    """Run the API server"""
    import uvicorn
    print("\n" + "="*60)
    print("STARTING API SERVER")
    print("="*60)
    print("Visit http://localhost:8000/docs for interactive API documentation")
    print("Available endpoints:")
    print("  - POST /brands/register - Register new brand")
    print("  - POST /content/strategy - Generate content strategy")
    print("  - POST /hashtags/strategy - Generate hashtag strategy")
    print("  - GET /trends - Get trending topics")
    print("  - GET /brands/{brand_id}/context - Get brand context")
    
    uvicorn.run(app, host="0.0.0.0", port=8000)

if __name__ == "__main__":
    # Run content strategy demo
    demo_content_strategy()
    
    # Ask user if they want to start the API server
    response = input("\nWould you like to start the API server? (y/n): ")
    if response.lower() in ['y', 'yes']:
        run_api_demo()
    else:
        print("Demo completed. Thank you!")
````

````python
# OpenAI API Key
OPENAI_API_KEY=your_openai_api_key_here

# Social Media API Keys
INSTAGRAM_ACCESS_TOKEN=your_instagram_access_token_here
TWITTER_BEARER_TOKEN=your_twitter_bearer_token_here

# Database
REDIS_URL=redis://localhost:6379
````

## Project Summary

The **Social Media Content Strategy Assistant** represents a sophisticated application of RAG technology in digital marketing, combining real-time social media data with comprehensive brand knowledge to create intelligent, data-driven content strategies.

### **Key Value Propositions**

1. **AI-Powered Strategy Generation**: Leverages RAG architecture to generate contextually relevant content strategies that balance trending topics with brand authenticity and guidelines.

2. **Real-Time Trend Integration**: Continuously monitors and incorporates trending topics, hashtags, and viral content patterns into strategic recommendations for maximum engagement potential.

3. **Brand Consistency Assurance**: Maintains strict adherence to brand voice, visual guidelines, and messaging standards while optimizing for platform-specific audience behaviors.

4. **Multi-Platform Optimization**: Adapts content strategies for different social media platforms, considering unique algorithms, content formats, and audience engagement patterns.

5. **Performance-Driven Insights**: Analyzes historical engagement data and successful content patterns to inform future strategy development and optimization.

### **Key Takeaways**

- **Advanced RAG Implementation**: Successfully combines structured brand data, real-time trend information, and historical performance metrics in a unified knowledge system
- **Real-World API Integration**: Demonstrates practical integration with major social media APIs (Twitter, Instagram) for live data collection and analysis
- **Scalable Architecture**: Built with modern frameworks (FastAPI, ChromaDB, LangChain) ensuring enterprise-grade scalability and maintainability
- **Intelligent Content Generation**: Provides specific, actionable content strategies rather than generic recommendations, including hashtag strategies, posting times, and engagement tactics
- **Brand-Aware AI**: Maintains brand consistency while maximizing engagement through intelligent balance of trending content and brand identity

This platform showcases how RAG technology can transform traditional social media marketing approaches into intelligent, automated systems that understand both brand identity and market dynamics, enabling businesses to maintain authentic voices while maximizing their social media impact and engagement rates.