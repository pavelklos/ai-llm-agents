<small>Claude Sonnet 4 **(Platforma pro Monitorov√°n√≠ Du≈°evn√≠ho Zdrav√≠ (Mental Health Monitoring Platform))**</small>
# Mental Health Monitoring Platform

## 1. N√°zev Projektu

**Platforma pro Monitorov√°n√≠ Du≈°evn√≠ho Zdrav√≠ s MCP (Model Context Protocol)**

## 2. Vysvƒõtlen√≠ Kl√≠ƒçov√Ωch Koncept≈Ø

### Model Context Protocol (MCP)
Protokol umo≈æ≈àuj√≠c√≠ AI model≈Øm p≈ô√≠stup k extern√≠m datov√Ωm zdroj≈Øm a n√°stroj≈Øm. V kontextu du≈°evn√≠ho zdrav√≠ umo≈æ≈àuje bezpeƒçn√© sd√≠len√≠ dat mezi r≈Øzn√Ωmi syst√©my (nositeln√° za≈ô√≠zen√≠, aplikace, zdravotnick√© syst√©my).

### Sledov√°n√≠ N√°lady (Mood Tracking)
Systematick√© zaznamen√°v√°n√≠ emoƒçn√≠ch stav≈Ø u≈æivatele pomoc√≠ r≈Øzn√Ωch metrik - subjektivn√≠ch hodnocen√≠, fyziologick√Ωch dat a behavioral patterns.

### Behavioral Analysis
Anal√Ωza vzorc≈Ø chov√°n√≠ u≈æivatele pro identifikaci zmƒõn du≈°evn√≠ho stavu. Zahrnuje anal√Ωzu sp√°nku, aktivity, soci√°ln√≠ch interakc√≠ a digit√°ln√≠ho chov√°n√≠.

### Therapy Recommendations
AI-driven doporuƒçen√≠ terapeutick√Ωch aktivit a intervenc√≠ na z√°kladƒõ aktu√°ln√≠ho stavu u≈æivatele a historick√Ωch dat.

### Crisis Intervention
Automatick√° detekce krizov√Ωch stav≈Ø a okam≈æit√© spu≈°tƒõn√≠ interventn√≠ch protokol≈Ø vƒçetnƒõ kontaktov√°n√≠ odborn√≠k≈Ø nebo bl√≠zk√Ωch osob.

### Wearable Devices Integration
Integrace s nositelnou elektronikou pro kontinu√°ln√≠ monitoring fyziologick√Ωch parametr≈Ø (srdeƒçn√≠ tep, variabilita srdeƒçn√≠ frekvence, ko≈æn√≠ vodivost).

## 3. Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Vytvo≈ôen√≠ inteligentn√≠ platformy pro kontinu√°ln√≠ monitoring du≈°evn√≠ho zdrav√≠, kter√° kombinuje subjektivn√≠ hodnocen√≠ u≈æivatele s objektivn√≠mi daty z nositeln√Ωch za≈ô√≠zen√≠. Platforma vyu≈æ√≠v√° AI pro predikci krizov√Ωch stav≈Ø a poskytov√°n√≠ personalizovan√Ωch doporuƒçen√≠.

### V√Ωzvy
- **Ochrana soukrom√≠**: Zpracov√°n√≠ citliv√Ωch zdravotn√≠ch dat
- **P≈ôesnost predikce**: Minimalizace fale≈°n√Ωch poplach≈Ø p≈ôi zachov√°n√≠ citlivosti
- **Interoperabilita**: Integrace r≈Øzn√Ωch zdroj≈Ø dat a za≈ô√≠zen√≠
- **Etick√© aspekty**: Zaji≈°tƒõn√≠ transparentnosti AI rozhodov√°n√≠

### Potenci√°ln√≠ Dopad
- Vƒçasn√° detekce zhor≈°en√≠ du≈°evn√≠ho stavu
- Personalizovan√° p√©ƒçe a doporuƒçen√≠
- Sn√≠≈æen√≠ poƒçtu hospitalizac√≠
- Podpora dlouhodob√© mental health maintenance

## 4. Komplexn√≠ P≈ô√≠klad s Python Implementac√≠

````python
import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import numpy as np
import pandas as pd
from pydantic import BaseModel, Field
from langchain.llms import OpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.memory import ConversationBufferMemory
import sqlite3
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

# Nastaven√≠ logov√°n√≠
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MoodLevel(Enum):
    VERY_LOW = 1
    LOW = 2
    NEUTRAL = 3
    GOOD = 4
    EXCELLENT = 5

class AlertLevel(Enum):
    GREEN = "green"
    YELLOW = "yellow"
    RED = "red"

@dataclass
class WearableData:
    timestamp: datetime
    heart_rate: float
    heart_rate_variability: float
    sleep_quality: float
    activity_level: float
    stress_level: float

@dataclass
class MoodEntry:
    timestamp: datetime
    mood_score: int
    energy_level: int
    anxiety_level: int
    notes: Optional[str] = None

class MCPProtocol:
    """Model Context Protocol pro bezpeƒçn√© sd√≠len√≠ dat"""
    
    def __init__(self):
        self.authorized_sources = set()
        self.data_handlers = {}
    
    def register_data_source(self, source_id: str, handler):
        """Registrace autorizovan√©ho zdroje dat"""
        self.authorized_sources.add(source_id)
        self.data_handlers[source_id] = handler
        logger.info(f"Registered data source: {source_id}")
    
    async def fetch_data(self, source_id: str, query: Dict) -> Any:
        """Bezpeƒçn√© naƒçten√≠ dat ze zdroje"""
        if source_id not in self.authorized_sources:
            raise ValueError(f"Unauthorized data source: {source_id}")
        
        handler = self.data_handlers.get(source_id)
        if handler:
            return await handler(query)
        return None

class DatabaseManager:
    """Spr√°va datab√°ze pro mental health data"""
    
    def __init__(self, db_path: str = "mental_health.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Inicializace datab√°zov√Ωch tabulek"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabulka pro mood entries
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS mood_entries (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                mood_score INTEGER NOT NULL,
                energy_level INTEGER NOT NULL,
                anxiety_level INTEGER NOT NULL,
                notes TEXT
            )
        ''')
        
        # Tabulka pro wearable data
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS wearable_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                heart_rate REAL NOT NULL,
                heart_rate_variability REAL NOT NULL,
                sleep_quality REAL NOT NULL,
                activity_level REAL NOT NULL,
                stress_level REAL NOT NULL
            )
        ''')
        
        # Tabulka pro alerts
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                alert_level TEXT NOT NULL,
                message TEXT NOT NULL,
                resolved BOOLEAN DEFAULT FALSE
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def save_mood_entry(self, entry: MoodEntry):
        """Ulo≈æen√≠ mood entry"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO mood_entries 
            (timestamp, mood_score, energy_level, anxiety_level, notes)
            VALUES (?, ?, ?, ?, ?)
        ''', (
            entry.timestamp.isoformat(),
            entry.mood_score,
            entry.energy_level,
            entry.anxiety_level,
            entry.notes
        ))
        
        conn.commit()
        conn.close()
    
    def save_wearable_data(self, data: WearableData):
        """Ulo≈æen√≠ dat z nositeln√Ωch za≈ô√≠zen√≠"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO wearable_data 
            (timestamp, heart_rate, heart_rate_variability, 
             sleep_quality, activity_level, stress_level)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            data.timestamp.isoformat(),
            data.heart_rate,
            data.heart_rate_variability,
            data.sleep_quality,
            data.activity_level,
            data.stress_level
        ))
        
        conn.commit()
        conn.close()
    
    def get_recent_data(self, days: int = 7) -> Dict:
        """Naƒçten√≠ dat za posledn√≠ch N dn√≠"""
        conn = sqlite3.connect(self.db_path)
        
        since_date = (datetime.now() - timedelta(days=days)).isoformat()
        
        # Mood data
        mood_df = pd.read_sql_query('''
            SELECT * FROM mood_entries 
            WHERE timestamp >= ? 
            ORDER BY timestamp
        ''', conn, params=[since_date])
        
        # Wearable data
        wearable_df = pd.read_sql_query('''
            SELECT * FROM wearable_data 
            WHERE timestamp >= ? 
            ORDER BY timestamp
        ''', conn, params=[since_date])
        
        conn.close()
        
        return {
            'mood_data': mood_df,
            'wearable_data': wearable_df
        }

class BehavioralAnalyzer:
    """Anal√Ωza behavioral patterns pro detekci zmƒõn"""
    
    def __init__(self):
        self.scaler = StandardScaler()
        self.anomaly_detector = IsolationForest(contamination=0.1, random_state=42)
        self.is_trained = False
    
    def prepare_features(self, mood_data: pd.DataFrame, wearable_data: pd.DataFrame) -> np.ndarray:
        """P≈ô√≠prava feature vektor≈Ø pro anal√Ωzu"""
        features = []
        
        if not mood_data.empty:
            # Mood features
            mood_features = [
                mood_data['mood_score'].mean(),
                mood_data['energy_level'].mean(),
                mood_data['anxiety_level'].mean(),
                mood_data['mood_score'].std() if len(mood_data) > 1 else 0
            ]
            features.extend(mood_features)
        else:
            features.extend([3, 3, 3, 0])  # Default values
        
        if not wearable_data.empty:
            # Wearable features
            wearable_features = [
                wearable_data['heart_rate'].mean(),
                wearable_data['heart_rate_variability'].mean(),
                wearable_data['sleep_quality'].mean(),
                wearable_data['activity_level'].mean(),
                wearable_data['stress_level'].mean()
            ]
            features.extend(wearable_features)
        else:
            features.extend([70, 0.5, 0.7, 0.5, 0.3])  # Default values
        
        return np.array(features).reshape(1, -1)
    
    def train_baseline(self, historical_data: Dict):
        """Tr√©nov√°n√≠ baseline modelu na historick√Ωch datech"""
        mood_data = historical_data['mood_data']
        wearable_data = historical_data['wearable_data']
        
        if mood_data.empty and wearable_data.empty:
            logger.warning("No historical data available for training")
            return
        
        # Skupinov√°n√≠ dat po dnech
        daily_features = []
        
        if not mood_data.empty:
            mood_data['date'] = pd.to_datetime(mood_data['timestamp']).dt.date
            mood_daily = mood_data.groupby('date').agg({
                'mood_score': ['mean', 'std'],
                'energy_level': 'mean',
                'anxiety_level': 'mean'
            }).fillna(0)
        
        if not wearable_data.empty:
            wearable_data['date'] = pd.to_datetime(wearable_data['timestamp']).dt.date
            wearable_daily = wearable_data.groupby('date').agg({
                'heart_rate': 'mean',
                'heart_rate_variability': 'mean',
                'sleep_quality': 'mean',
                'activity_level': 'mean',
                'stress_level': 'mean'
            })
        
        # Simulace historick√Ωch dat pro demonstraci
        np.random.seed(42)
        for i in range(30):  # 30 dn√≠ historick√Ωch dat
            features = [
                np.random.normal(3.5, 0.8),  # mood_score
                np.random.normal(3.2, 0.7),  # energy_level
                np.random.normal(2.8, 0.9),  # anxiety_level
                np.random.normal(0.5, 0.2),  # mood_variability
                np.random.normal(72, 8),     # heart_rate
                np.random.normal(0.45, 0.1), # hrv
                np.random.normal(0.75, 0.15), # sleep_quality
                np.random.normal(0.6, 0.2),  # activity_level
                np.random.normal(0.35, 0.15) # stress_level
            ]
            daily_features.append(features)
        
        features_array = np.array(daily_features)
        
        # Tr√©nov√°n√≠ scaler a anomaly detector
        self.scaler.fit(features_array)
        scaled_features = self.scaler.transform(features_array)
        self.anomaly_detector.fit(scaled_features)
        self.is_trained = True
        
        logger.info("Baseline model trained successfully")
    
    def analyze_current_state(self, current_data: Dict) -> Dict:
        """Anal√Ωza aktu√°ln√≠ho stavu u≈æivatele"""
        if not self.is_trained:
            return {
                'alert_level': AlertLevel.GREEN,
                'anomaly_score': 0.0,
                'risk_factors': [],
                'recommendations': ['Nedostatek historick√Ωch dat pro anal√Ωzu']
            }
        
        features = self.prepare_features(
            current_data['mood_data'], 
            current_data['wearable_data']
        )
        
        # Detekce anom√°li√≠
        scaled_features = self.scaler.transform(features)
        anomaly_score = self.anomaly_detector.decision_function(scaled_features)[0]
        is_anomaly = self.anomaly_detector.predict(scaled_features)[0] == -1
        
        # Urƒçen√≠ alert level
        if is_anomaly and anomaly_score < -0.5:
            alert_level = AlertLevel.RED
        elif is_anomaly or anomaly_score < -0.2:
            alert_level = AlertLevel.YELLOW
        else:
            alert_level = AlertLevel.GREEN
        
        # Identifikace risk factors
        risk_factors = []
        recommendations = []
        
        mood_data = current_data['mood_data']
        wearable_data = current_data['wearable_data']
        
        if not mood_data.empty:
            avg_mood = mood_data['mood_score'].mean()
            avg_anxiety = mood_data['anxiety_level'].mean()
            
            if avg_mood < 2.5:
                risk_factors.append("N√≠zk√° n√°lada")
                recommendations.append("Zva≈æte kontaktov√°n√≠ terapeuta")
            
            if avg_anxiety > 3.5:
                risk_factors.append("Vysok√° √∫zkost")
                recommendations.append("Zkuste relaxaƒçn√≠ techniky")
        
        if not wearable_data.empty:
            avg_sleep = wearable_data['sleep_quality'].mean()
            avg_stress = wearable_data['stress_level'].mean()
            
            if avg_sleep < 0.6:
                risk_factors.append("≈†patn√° kvalita sp√°nku")
                recommendations.append("Zlep≈°ete sp√°nkovou hygienu")
            
            if avg_stress > 0.7:
                risk_factors.append("Vysok√Ω stres")
                recommendations.append("Vƒõnujte ƒças odpoƒçinku")
        
        return {
            'alert_level': alert_level,
            'anomaly_score': float(anomaly_score),
            'risk_factors': risk_factors,
            'recommendations': recommendations
        }

class TherapyRecommendationEngine:
    """Engine pro generov√°n√≠ terapeutick√Ωch doporuƒçen√≠"""
    
    def __init__(self, openai_api_key: str = None):
        self.llm = None
        if openai_api_key:
            self.llm = OpenAI(openai_api_key=openai_api_key, temperature=0.7)
        
        self.prompt_template = PromptTemplate(
            input_variables=["mood_state", "risk_factors", "user_preferences"],
            template="""
            Jako AI terapeut, poskytni personalizovan√° doporuƒçen√≠ pro u≈æivatele na z√°kladƒõ:
            
            Aktu√°ln√≠ stav n√°lady: {mood_state}
            Rizikov√© faktory: {risk_factors}
            U≈æivatelsk√© preference: {user_preferences}
            
            Poskytni 3-5 konkr√©tn√≠ch, praktick√Ωch doporuƒçen√≠ v ƒçe≈°tinƒõ:
            """
        )
        
        self.memory = ConversationBufferMemory()
    
    def get_recommendations(self, analysis_result: Dict, user_preferences: Dict = None) -> List[str]:
        """Generov√°n√≠ personalizovan√Ωch doporuƒçen√≠"""
        
        # Fallback doporuƒçen√≠ bez AI
        fallback_recommendations = [
            "Vƒõnujte 10 minut dennƒõ meditaci nebo hlubok√©mu d√Ωch√°n√≠",
            "Udr≈æujte pravideln√Ω sp√°nkov√Ω re≈æim",
            "Cviƒçte m√≠rnou fyzickou aktivitu alespo≈à 30 minut dennƒõ",
            "Veƒète den√≠k vdƒõƒçnosti",
            "Omezte konzumaci kofeinu a alkoholu"
        ]
        
        if not self.llm:
            return fallback_recommendations
        
        try:
            chain = LLMChain(llm=self.llm, prompt=self.prompt_template, memory=self.memory)
            
            mood_state = f"Alert level: {analysis_result['alert_level'].value}"
            risk_factors = ", ".join(analysis_result['risk_factors'])
            preferences = str(user_preferences or {})
            
            response = chain.run(
                mood_state=mood_state,
                risk_factors=risk_factors,
                user_preferences=preferences
            )
            
            recommendations = [line.strip() for line in response.split('\n') if line.strip()]
            return recommendations[:5] if recommendations else fallback_recommendations
            
        except Exception as e:
            logger.error(f"Error generating recommendations: {e}")
            return fallback_recommendations

class CrisisInterventionSystem:
    """Syst√©m pro krizovou intervenci"""
    
    def __init__(self):
        self.emergency_contacts = []
        self.crisis_hotlines = [
            {"name": "Linka bezpeƒç√≠", "number": "116 111"},
            {"name": "Linka d≈Øvƒõry", "number": "221 580 697"},
            {"name": "Zdravotnick√° z√°chrann√° slu≈æba", "number": "155"}
        ]
    
    def add_emergency_contact(self, name: str, phone: str, relationship: str):
        """P≈ôid√°n√≠ kontaktu pro nouzov√© situace"""
        self.emergency_contacts.append({
            'name': name,
            'phone': phone,
            'relationship': relationship
        })
    
    def trigger_crisis_intervention(self, analysis_result: Dict) -> Dict:
        """Spu≈°tƒõn√≠ krizov√© intervence"""
        if analysis_result['alert_level'] != AlertLevel.RED:
            return {'intervention_triggered': False}
        
        intervention_plan = {
            'intervention_triggered': True,
            'timestamp': datetime.now().isoformat(),
            'crisis_level': 'HIGH',
            'immediate_actions': [
                "Kontaktujte okam≈æitƒõ odborn√≠ka",
                "Z≈Østa≈àte v bezpeƒçn√©m prost≈ôed√≠",
                "Kontaktujte d≈Øvƒõryhodnou osobu"
            ],
            'emergency_contacts': self.emergency_contacts,
            'crisis_hotlines': self.crisis_hotlines,
            'follow_up_required': True
        }
        
        logger.critical(f"Crisis intervention triggered: {intervention_plan}")
        return intervention_plan

class MentalHealthPlatform:
    """Hlavn√≠ t≈ô√≠da platformy pro mental health monitoring"""
    
    def __init__(self, openai_api_key: str = None):
        self.mcp = MCPProtocol()
        self.db = DatabaseManager()
        self.analyzer = BehavioralAnalyzer()
        self.recommendation_engine = TherapyRecommendationEngine(openai_api_key)
        self.crisis_system = CrisisInterventionSystem()
        
        # Registrace data sources
        self.mcp.register_data_source("mood_tracker", self._handle_mood_data)
        self.mcp.register_data_source("wearable", self._handle_wearable_data)
        
        # Inicializace s demo daty
        self._initialize_demo_data()
    
    def _initialize_demo_data(self):
        """Inicializace s demo daty"""
        # Generov√°n√≠ demo mood entries
        for i in range(7):
            date = datetime.now() - timedelta(days=i)
            mood_entry = MoodEntry(
                timestamp=date,
                mood_score=np.random.randint(2, 5),
                energy_level=np.random.randint(2, 5),
                anxiety_level=np.random.randint(1, 4),
                notes=f"Demo z√°znam pro den {i+1}"
            )
            self.db.save_mood_entry(mood_entry)
        
        # Generov√°n√≠ demo wearable data
        for i in range(7):
            for hour in range(0, 24, 4):  # Data ka≈æd√© 4 hodiny
                date = datetime.now() - timedelta(days=i, hours=hour)
                wearable_data = WearableData(
                    timestamp=date,
                    heart_rate=np.random.normal(72, 10),
                    heart_rate_variability=np.random.normal(0.45, 0.1),
                    sleep_quality=np.random.normal(0.75, 0.2),
                    activity_level=np.random.normal(0.6, 0.3),
                    stress_level=np.random.normal(0.35, 0.2)
                )
                self.db.save_wearable_data(wearable_data)
        
        # Tr√©nov√°n√≠ baseline modelu
        historical_data = self.db.get_recent_data(days=30)
        self.analyzer.train_baseline(historical_data)
    
    async def _handle_mood_data(self, query: Dict) -> Any:
        """Handler pro mood data"""
        return self.db.get_recent_data(query.get('days', 7))['mood_data']
    
    async def _handle_wearable_data(self, query: Dict) -> Any:
        """Handler pro wearable data"""
        return self.db.get_recent_data(query.get('days', 7))['wearable_data']
    
    def add_mood_entry(self, mood_score: int, energy_level: int, anxiety_level: int, notes: str = None):
        """P≈ôid√°n√≠ nov√©ho mood z√°znamu"""
        entry = MoodEntry(
            timestamp=datetime.now(),
            mood_score=mood_score,
            energy_level=energy_level,
            anxiety_level=anxiety_level,
            notes=notes
        )
        self.db.save_mood_entry(entry)
        logger.info(f"Mood entry added: {entry}")
    
    def add_wearable_data(self, heart_rate: float, hrv: float, sleep_quality: float, 
                         activity_level: float, stress_level: float):
        """P≈ôid√°n√≠ dat z nositeln√Ωch za≈ô√≠zen√≠"""
        data = WearableData(
            timestamp=datetime.now(),
            heart_rate=heart_rate,
            heart_rate_variability=hrv,
            sleep_quality=sleep_quality,
            activity_level=activity_level,
            stress_level=stress_level
        )
        self.db.save_wearable_data(data)
        logger.info(f"Wearable data added: {data}")
    
    async def analyze_mental_health_state(self) -> Dict:
        """Kompletn√≠ anal√Ωza aktu√°ln√≠ho stavu du≈°evn√≠ho zdrav√≠"""
        try:
            # Naƒçten√≠ aktu√°ln√≠ch dat
            recent_data = self.db.get_recent_data(days=3)
            
            # Behavioral anal√Ωza
            analysis_result = self.analyzer.analyze_current_state(recent_data)
            
            # Generov√°n√≠ doporuƒçen√≠
            recommendations = self.recommendation_engine.get_recommendations(analysis_result)
            analysis_result['ai_recommendations'] = recommendations
            
            # Kontrola krizov√© intervence
            if analysis_result['alert_level'] == AlertLevel.RED:
                crisis_plan = self.crisis_system.trigger_crisis_intervention(analysis_result)
                analysis_result['crisis_intervention'] = crisis_plan
            
            return analysis_result
            
        except Exception as e:
            logger.error(f"Error in mental health analysis: {e}")
            return {
                'alert_level': AlertLevel.YELLOW,
                'error': str(e),
                'recommendations': ['Zkuste to znovu pozdƒõji']
            }

# Streamlit UI
def create_streamlit_interface():
    """Vytvo≈ôen√≠ Streamlit rozhran√≠"""
    
    st.set_page_config(
        page_title="Mental Health Monitoring Platform",
        page_icon="üß†",
        layout="wide"
    )
    
    st.title("üß† Platforma pro Monitorov√°n√≠ Du≈°evn√≠ho Zdrav√≠")
    st.markdown("*Vyu≈æ√≠v√° Model Context Protocol (MCP) pro bezpeƒçn√© sd√≠len√≠ dat*")
    
    # Inicializace platformy
    if 'platform' not in st.session_state:
        st.session_state.platform = MentalHealthPlatform()
    
    platform = st.session_state.platform
    
    # Sidebar pro vstup dat
    with st.sidebar:
        st.header("üìä Vstup Dat")
        
        # Mood entry form
        with st.expander("Z√°znam N√°lady", expanded=True):
            mood_score = st.slider("N√°lada (1-5)", 1, 5, 3)
            energy_level = st.slider("Energie (1-5)", 1, 5, 3)
            anxiety_level = st.slider("√özkost (1-5)", 1, 5, 2)
            notes = st.text_area("Pozn√°mky", placeholder="Jak se dnes c√≠t√≠te?")
            
            if st.button("üíæ Ulo≈æit N√°ladu"):
                platform.add_mood_entry(mood_score, energy_level, anxiety_level, notes)
                st.success("N√°lada ulo≈æena!")
                st.rerun()
        
        # Wearable data form
        with st.expander("Data z Nositeln√Ωch Za≈ô√≠zen√≠"):
            heart_rate = st.number_input("Srdeƒçn√≠ tep", value=72.0, min_value=40.0, max_value=200.0)
            hrv = st.number_input("HRV", value=0.45, min_value=0.0, max_value=1.0, step=0.01)
            sleep_quality = st.number_input("Kvalita sp√°nku", value=0.75, min_value=0.0, max_value=1.0, step=0.01)
            activity_level = st.number_input("√örove≈à aktivity", value=0.6, min_value=0.0, max_value=1.0, step=0.01)
            stress_level = st.number_input("√örove≈à stresu", value=0.35, min_value=0.0, max_value=1.0, step=0.01)
            
            if st.button("üì± Ulo≈æit Wearable Data"):
                platform.add_wearable_data(heart_rate, hrv, sleep_quality, activity_level, stress_level)
                st.success("Data ulo≈æena!")
                st.rerun()
    
    # Hlavn√≠ obsah
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.header("üìà Anal√Ωza Du≈°evn√≠ho Zdrav√≠")
        
        # Spu≈°tƒõn√≠ anal√Ωzy
        if st.button("üîç Analyzovat Aktu√°ln√≠ Stav", type="primary"):
            with st.spinner("Prob√≠h√° anal√Ωza..."):
                analysis = asyncio.run(platform.analyze_mental_health_state())
                st.session_state.analysis = analysis
        
        # Zobrazen√≠ v√Ωsledk≈Ø anal√Ωzy
        if 'analysis' in st.session_state:
            analysis = st.session_state.analysis
            
            # Alert level
            alert_color = {
                AlertLevel.GREEN: "üü¢",
                AlertLevel.YELLOW: "üü°", 
                AlertLevel.RED: "üî¥"
            }
            
            st.subheader(f"{alert_color.get(analysis.get('alert_level', AlertLevel.GREEN), '‚ö™')} Status: {analysis.get('alert_level', 'UNKNOWN').value}")
            
            # Anomaly score
            if 'anomaly_score' in analysis:
                st.metric("Anomaly Score", f"{analysis['anomaly_score']:.3f}")
            
            # Risk factors
            if analysis.get('risk_factors'):
                st.subheader("‚ö†Ô∏è Rizikov√© Faktory")
                for factor in analysis['risk_factors']:
                    st.warning(factor)
            
            # AI Recommendations
            if analysis.get('ai_recommendations'):
                st.subheader("ü§ñ AI Doporuƒçen√≠")
                for rec in analysis['ai_recommendations']:
                    st.info(rec)
            
            # Crisis intervention
            if 'crisis_intervention' in analysis:
                st.error("üö® KRIZOV√Å INTERVENCE AKTIVOV√ÅNA")
                crisis = analysis['crisis_intervention']
                
                st.subheader("Okam≈æit√© kroky:")
                for action in crisis.get('immediate_actions', []):
                    st.error(f"‚Ä¢ {action}")
                
                st.subheader("Krizov√© linky:")
                for hotline in crisis.get('crisis_hotlines', []):
                    st.error(f"üìû {hotline['name']}: {hotline['number']}")
        
        # Grafy a vizualizace
        st.header("üìä Vizualizace Dat")
        
        try:
            recent_data = platform.db.get_recent_data(days=7)
            
            if not recent_data['mood_data'].empty:
                # Mood trend chart
                mood_df = recent_data['mood_data'].copy()
                mood_df['timestamp'] = pd.to_datetime(mood_df['timestamp'])
                
                fig = go.Figure()
                fig.add_trace(go.Scatter(
                    x=mood_df['timestamp'], 
                    y=mood_df['mood_score'],
                    mode='lines+markers',
                    name='N√°lada',
                    line=dict(color='blue')
                ))
                fig.add_trace(go.Scatter(
                    x=mood_df['timestamp'], 
                    y=mood_df['energy_level'],
                    mode='lines+markers',
                    name='Energie',
                    line=dict(color='green')
                ))
                fig.add_trace(go.Scatter(
                    x=mood_df['timestamp'], 
                    y=mood_df['anxiety_level'],
                    mode='lines+markers',
                    name='√özkost',
                    line=dict(color='red')
                ))
                
                fig.update_layout(
                    title='Trend N√°lady (7 dn√≠)',
                    xaxis_title='Datum',
                    yaxis_title='Sk√≥re (1-5)',
                    hovermode='x unified'
                )
                
                st.plotly_chart(fig, use_container_width=True)
            
            if not recent_data['wearable_data'].empty:
                # Wearable data chart
                wearable_df = recent_data['wearable_data'].copy()
                wearable_df['timestamp'] = pd.to_datetime(wearable_df['timestamp'])
                
                fig2 = go.Figure()
                fig2.add_trace(go.Scatter(
                    x=wearable_df['timestamp'], 
                    y=wearable_df['sleep_quality'],
                    mode='lines+markers',
                    name='Kvalita sp√°nku',
                    line=dict(color='purple')
                ))
                fig2.add_trace(go.Scatter(
                    x=wearable_df['timestamp'], 
                    y=wearable_df['stress_level'],
                    mode='lines+markers',
                    name='√örove≈à stresu',
                    line=dict(color='orange')
                ))
                
                fig2.update_layout(
                    title='Fyziologick√© Parametry (7 dn√≠)',
                    xaxis_title='Datum',
                    yaxis_title='Hodnota (0-1)',
                    hovermode='x unified'
                )
                
                st.plotly_chart(fig2, use_container_width=True)
                
        except Exception as e:
            st.error(f"Chyba p≈ôi zobrazov√°n√≠ graf≈Ø: {e}")
    
    with col2:
        st.header("‚ÑπÔ∏è Informace o Syst√©mu")
        
        st.info("""
        **Model Context Protocol (MCP)**
        
        Tento syst√©m vyu≈æ√≠v√° MCP pro:
        ‚Ä¢ Bezpeƒçn√© sd√≠len√≠ zdravotn√≠ch dat
        ‚Ä¢ Integrace s nositelnou elektronikou  
        ‚Ä¢ Kontrola p≈ô√≠stupu k dat≈Øm
        ‚Ä¢ Auditovatelnost v≈°ech operac√≠
        """)
        
        st.success("""
        **Funkce Platformy:**
        
        ‚úÖ Sledov√°n√≠ n√°lady
        ‚úÖ Anal√Ωza behavioral patterns
        ‚úÖ AI doporuƒçen√≠
        ‚úÖ Detekce anom√°li√≠
        ‚úÖ Krizov√° intervence
        ‚úÖ Integrace s wearables
        """)
        
        # Emergency contacts
        st.header("üÜò Nouzov√© Kontakty")
        platform.crisis_system.add_emergency_contact("Dr. Nov√°k", "+420 123 456 789", "Terapeut")
        
        for contact in platform.crisis_system.emergency_contacts:
            st.write(f"**{contact['name']}** ({contact['relationship']})")
            st.write(f"üìû {contact['phone']}")
        
        st.header("‚òéÔ∏è Krizov√© Linky")
        for hotline in platform.crisis_system.crisis_hotlines:
            st.write(f"**{hotline['name']}**")
            st.write(f"üìû {hotline['number']}")

if __name__ == "__main__":
    # Spu≈°tƒõn√≠ Streamlit aplikace
    create_streamlit_interface()
````

## 5. Z√°vƒõr Projektu

### Kl√≠ƒçov√© Hodnoty Projektu

**Personalizovan√° P√©ƒçe**: Platforma poskytuje individualizovan√° doporuƒçen√≠ na z√°kladƒõ komplexn√≠ anal√Ωzy dat z r≈Øzn√Ωch zdroj≈Ø.

**Vƒçasn√° Intervence**: Syst√©m umo≈æ≈àuje detekci krizov√Ωch stav≈Ø je≈°tƒõ p≈ôed jejich pln√Ωm rozvojem, co≈æ m≈Ø≈æe p≈ôedej√≠t v√°≈ænƒõj≈°√≠m komplikac√≠m.

**Bezpeƒçnost Dat**: Implementace MCP protokolu zaji≈°≈•uje vysokou √∫rove≈à ochrany citliv√Ωch zdravotn√≠ch dat.

**Integrace Technologi√≠**: Kombinace AI, nositeln√© elektroniky a behavioral analysis poskytuje holistick√Ω pohled na du≈°evn√≠ zdrav√≠.

**Dostupnost**: Platforma je navr≈æena tak, aby byla snadno dostupn√° a pou≈æiteln√° pro bƒõ≈æn√© u≈æivatele.

### Kl√≠ƒçov√© Poznatky

- MCP protokol umo≈æ≈àuje bezpeƒçnou integraci r≈Øzn√Ωch zdravotn√≠ch syst√©m≈Ø
- Kombinace subjektivn√≠ch a objektivn√≠ch dat zvy≈°uje p≈ôesnost anal√Ωzy
- AI-driven doporuƒçen√≠ mohou v√Ωznamnƒõ zlep≈°it adherenci k terapii
- Automatizovan√° krizov√° intervence m≈Ø≈æe zachr√°nit ≈æivoty
- Kontinu√°ln√≠ monitoring umo≈æ≈àuje sledov√°n√≠ dlouhodob√Ωch trend≈Ø

Tato platforma p≈ôedstavuje v√Ωznamn√Ω krok smƒõrem k proaktivn√≠ p√©ƒçi o du≈°evn√≠ zdrav√≠ vyu≈æ√≠vaj√≠c√≠ nejmodernƒõj≈°√≠ technologie p≈ôi zachov√°n√≠ nejvy≈°≈°√≠ch standard≈Ø bezpeƒçnosti a etiky.