<small>Claude Sonnet 4 **(Enterprise Email Summarizer + Action Planner)**</small>
# Enterprise Email Summarizer + Action Planner

## Kl√≠ƒçov√© koncepty

### Model Context Protocol (MCP)
MCP je standardizovan√Ω protokol pro spr√°vu kontextu mezi LLM modely a extern√≠mi syst√©my. Umo≈æ≈àuje dynamick√© naƒç√≠t√°n√≠ kontextu, spr√°vu pamƒõti a koordinaci mezi r≈Øzn√Ωmi AI agenty pro efektivn√≠ zpracov√°n√≠ dlouhodob√Ωch konverzac√≠.

### Context Windows
Okna kontextu definuj√≠ mno≈æstv√≠ informac√≠, kter√© m≈Ø≈æe LLM model zpracovat najednou. Modern√≠ modely jako GPT-4o podporuj√≠ velk√° okna kontextu (128k token≈Ø), co≈æ umo≈æ≈àuje zpracov√°n√≠ rozs√°hl√Ωch dokument≈Ø a udr≈æov√°n√≠ dlouhodob√© pamƒõti.

### Task Memory
Syst√©m pamƒõti √∫kol≈Ø udr≈æuje informace o p≈ôedchoz√≠ch akc√≠ch, rozhodnut√≠ch a kontextu nap≈ô√≠ƒç v√≠ce interakcemi. Vyu≈æ√≠v√° vektorov√© datab√°ze pro efektivn√≠ ukl√°d√°n√≠ a vyhled√°v√°n√≠ relevantn√≠ch informac√≠.

### Prompt Engineering
Technika optimalizace prompt≈Ø pro dosa≈æen√≠ nejlep≈°√≠ch v√Ωsledk≈Ø z LLM model≈Ø. Zahrnuje strukturov√°n√≠ instrukc√≠, poskytov√°n√≠ p≈ô√≠klad≈Ø a ≈ô√≠zen√≠ v√Ωstupu modelu prost≈ôednictv√≠m peƒçlivƒõ navr≈æen√Ωch textov√Ωch vstup≈Ø.

### LLM Agents
Autonomn√≠ AI agenti postaven√≠ na LLM modelech, kte≈ô√≠ mohou vykon√°vat slo≈æit√© √∫koly, rozhodovat se a komunikovat s extern√≠mi syst√©my. Kombinuj√≠ jazykov√© schopnosti s pl√°nov√°n√≠m akc√≠ a spr√°vou workflow.

## Komplexn√≠ vysvƒõtlen√≠ projektu

Enterprise Email Summarizer + Action Planner je pokroƒçil√Ω AI syst√©m navr≈æen√Ω pro automatizaci spr√°vy firemn√≠ch email≈Ø. Projekt ≈ôe≈°√≠ kritick√Ω probl√©m modern√≠ch organizac√≠ - p≈ôet√≠≈æen√≠ informacemi z emailov√© komunikace a neefektivn√≠ spr√°vu √∫kol≈Ø.

### Hlavn√≠ c√≠le:
- **Automatick√© shrnut√≠**: Inteligentn√≠ anal√Ωza a sumarizace emailov√Ωch vl√°ken
- **Extrakce akc√≠**: Identifikace konkr√©tn√≠ch √∫kol≈Ø a term√≠n≈Ø z emailov√© komunikace
- **Pl√°nov√°n√≠ √∫kol≈Ø**: Automatick√© vytv√°≈ôen√≠ strukturovan√Ωch pl√°n≈Ø s prioritami
- **Kontextov√° pamƒõ≈•**: Udr≈æov√°n√≠ dlouhodob√©ho kontextu nap≈ô√≠ƒç projekty a t√Ωmy

### Technick√© v√Ωzvy:
1. **Zpracov√°n√≠ rozs√°hl√Ωch emailov√Ωch vl√°ken** - vyu≈æit√≠ velk√Ωch context windows
2. **Udr≈æov√°n√≠ kontextu** - implementace MCP pro kontinuitu nap≈ô√≠ƒç sezen√≠mi
3. **Extrakce strukturovan√Ωch dat** - precizn√≠ identifikace akc√≠ a term√≠n≈Ø
4. **≈†k√°lovatelnost** - podpora pro tis√≠ce email≈Ø dennƒõ

### Dopad na organizaci:
- Sn√≠≈æen√≠ ƒçasu str√°ven√©ho ƒçten√≠m email≈Ø o 60-80%
- Automatizace task managementu
- Zlep≈°en√≠ sledov√°n√≠ projektov√Ωch z√°vazk≈Ø
- Zv√Ω≈°en√≠ produktivity t√Ωm≈Ø

## Komplexn√≠ p≈ô√≠klad s Python implementac√≠

````python
openai==1.10.0
langchain==0.1.0
langchain-openai==0.0.5
chromadb==0.4.22
pydantic==2.5.0
fastapi==0.108.0
uvicorn==0.25.0
python-multipart==0.0.6
email-parser==0.2.0
python-dateutil==2.8.2
schedule==1.2.0
````

````python
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

class Priority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class ActionItem(BaseModel):
    id: str = Field(..., description="Unik√°tn√≠ identifik√°tor akce")
    title: str = Field(..., description="N√°zev akce")
    description: str = Field(..., description="Detailn√≠ popis akce")
    assignee: Optional[str] = Field(None, description="Osoba odpovƒõdn√° za akci")
    due_date: Optional[datetime] = Field(None, description="Term√≠n splnƒõn√≠")
    priority: Priority = Field(Priority.MEDIUM, description="Priorita akce")
    status: str = Field("open", description="Stav akce")
    source_email_id: str = Field(..., description="ID zdrojov√©ho emailu")
    context: Dict[str, Any] = Field(default_factory=dict, description="Dodateƒçn√Ω kontext")

class EmailSummary(BaseModel):
    email_id: str = Field(..., description="Unik√°tn√≠ identifik√°tor emailu")
    thread_id: Optional[str] = Field(None, description="ID emailov√©ho vl√°kna")
    subject: str = Field(..., description="P≈ôedmƒõt emailu")
    summary: str = Field(..., description="Shrnut√≠ obsahu")
    key_points: List[str] = Field(default_factory=list, description="Kl√≠ƒçov√© body")
    sentiment: str = Field(..., description="Sentiment emailu")
    participants: List[str] = Field(default_factory=list, description="√öƒçastn√≠ci komunikace")
    timestamp: datetime = Field(..., description="ƒåas vytvo≈ôen√≠")
    action_items: List[ActionItem] = Field(default_factory=list, description="Extrahovan√© akce")

class TaskPlan(BaseModel):
    plan_id: str = Field(..., description="ID pl√°nu")
    title: str = Field(..., description="N√°zev pl√°nu")
    description: str = Field(..., description="Popis pl√°nu")
    action_items: List[ActionItem] = Field(..., description="Seznam akc√≠")
    timeline: Dict[str, List[str]] = Field(default_factory=dict, description="ƒåasov√° osa")
    dependencies: Dict[str, List[str]] = Field(default_factory=dict, description="Z√°vislosti")
    created_at: datetime = Field(default_factory=datetime.now)
````

````python
import json
import uuid
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import chromadb
from chromadb.config import Settings
from langchain.schema import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter

class MCPContextManager:
    """Model Context Protocol manager pro spr√°vu kontextu nap≈ô√≠ƒç sezen√≠mi"""
    
    def __init__(self, persist_directory: str = "./chroma_db"):
        self.client = chromadb.PersistentClient(
            path=persist_directory,
            settings=Settings(anonymized_telemetry=False)
        )
        self.email_collection = self.client.get_or_create_collection("emails")
        self.context_collection = self.client.get_or_create_collection("context")
        self.task_collection = self.client.get_or_create_collection("tasks")
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
    
    def store_email_context(self, email_summary: 'EmailSummary') -> str:
        """Ulo≈æen√≠ emailov√©ho kontextu do MCP √∫lo≈æi≈°tƒõ"""
        try:
            context_id = str(uuid.uuid4())
            
            # Vytvo≈ôen√≠ metadat
            metadata = {
                "email_id": email_summary.email_id,
                "thread_id": email_summary.thread_id or "",
                "subject": email_summary.subject,
                "timestamp": email_summary.timestamp.isoformat(),
                "sentiment": email_summary.sentiment,
                "participants": ",".join(email_summary.participants),
                "type": "email_summary"
            }
            
            # Kombinovan√Ω text pro embedding
            combined_text = f"""
            P≈ôedmƒõt: {email_summary.subject}
            Shrnut√≠: {email_summary.summary}
            Kl√≠ƒçov√© body: {'; '.join(email_summary.key_points)}
            Sentiment: {email_summary.sentiment}
            √öƒçastn√≠ci: {', '.join(email_summary.participants)}
            """
            
            self.email_collection.add(
                documents=[combined_text],
                metadatas=[metadata],
                ids=[context_id]
            )
            
            return context_id
            
        except Exception as e:
            print(f"Chyba p≈ôi ukl√°d√°n√≠ emailov√©ho kontextu: {e}")
            return ""
    
    def store_task_context(self, task_plan: 'TaskPlan') -> str:
        """Ulo≈æen√≠ kontextu √∫kol≈Ø"""
        try:
            context_id = str(uuid.uuid4())
            
            # P≈ô√≠prava textu s informacemi o √∫kolech
            tasks_text = f"""
            Pl√°n: {task_plan.title}
            Popis: {task_plan.description}
            Akce: {'; '.join([f"{action.title} - {action.description}" for action in task_plan.action_items])}
            """
            
            metadata = {
                "plan_id": task_plan.plan_id,
                "title": task_plan.title,
                "created_at": task_plan.created_at.isoformat(),
                "action_count": str(len(task_plan.action_items)),
                "type": "task_plan"
            }
            
            self.task_collection.add(
                documents=[tasks_text],
                metadatas=[metadata],
                ids=[context_id]
            )
            
            return context_id
            
        except Exception as e:
            print(f"Chyba p≈ôi ukl√°d√°n√≠ kontextu √∫kol≈Ø: {e}")
            return ""
    
    def retrieve_relevant_context(self, query: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Z√≠sk√°n√≠ relevantn√≠ho kontextu na z√°kladƒõ dotazu"""
        try:
            # Hled√°n√≠ v emailech
            email_results = self.email_collection.query(
                query_texts=[query],
                n_results=n_results
            )
            
            # Hled√°n√≠ v √∫kolech
            task_results = self.task_collection.query(
                query_texts=[query],
                n_results=n_results
            )
            
            combined_results = []
            
            # Zpracov√°n√≠ emailov√Ωch v√Ωsledk≈Ø
            if email_results['documents']:
                for i, doc in enumerate(email_results['documents'][0]):
                    combined_results.append({
                        "content": doc,
                        "metadata": email_results['metadatas'][0][i],
                        "type": "email",
                        "score": email_results['distances'][0][i] if email_results['distances'] else 0
                    })
            
            # Zpracov√°n√≠ √∫kolov√Ωch v√Ωsledk≈Ø
            if task_results['documents']:
                for i, doc in enumerate(task_results['documents'][0]):
                    combined_results.append({
                        "content": doc,
                        "metadata": task_results['metadatas'][0][i],
                        "type": "task",
                        "score": task_results['distances'][0][i] if task_results['distances'] else 0
                    })
            
            # Se≈ôazen√≠ podle sk√≥re
            combined_results.sort(key=lambda x: x['score'])
            
            return combined_results[:n_results]
            
        except Exception as e:
            print(f"Chyba p≈ôi z√≠sk√°v√°n√≠ kontextu: {e}")
            return []
    
    def get_thread_context(self, thread_id: str) -> List[Dict[str, Any]]:
        """Z√≠sk√°n√≠ kompletn√≠ho kontextu emailov√©ho vl√°kna"""
        try:
            results = self.email_collection.get(
                where={"thread_id": thread_id}
            )
            
            context_items = []
            if results['documents']:
                for i, doc in enumerate(results['documents']):
                    context_items.append({
                        "content": doc,
                        "metadata": results['metadatas'][i],
                        "id": results['ids'][i]
                    })
            
            # Se≈ôazen√≠ podle ƒçasov√©ho raz√≠tka
            context_items.sort(key=lambda x: x['metadata'].get('timestamp', ''))
            
            return context_items
            
        except Exception as e:
            print(f"Chyba p≈ôi z√≠sk√°v√°n√≠ kontextu vl√°kna: {e}")
            return []
````

````python
import re
import email
from email import policy
from email.parser import BytesParser
from typing import List, Dict, Any, Optional
from datetime import datetime
import uuid
from models import EmailSummary, ActionItem, Priority

class EmailProcessor:
    """Procesor pro zpracov√°n√≠ a parsov√°n√≠ email≈Ø"""
    
    def __init__(self):
        self.action_keywords = [
            'TODO', '√öKOL', 'AKCE', 'POT≈òEBUJI', 'MUS√çM', 'DEADLINE',
            'TERM√çN', 'DOKONƒåIT', 'SPLNIT', 'ZAJISTIT', 'P≈òIPRAVIT'
        ]
        
    def parse_email_content(self, email_content: str) -> Dict[str, Any]:
        """Parsov√°n√≠ obsahu emailu"""
        try:
            # Simulace parsov√°n√≠ emailu (v re√°ln√© aplikaci by se pou≈æil skuteƒçn√Ω email parser)
            lines = email_content.strip().split('\n')
            
            # Extrakce z√°kladn√≠ch informac√≠
            subject = ""
            sender = ""
            recipients = []
            body = ""
            
            in_body = False
            for line in lines:
                line = line.strip()
                if line.startswith("Subject:"):
                    subject = line.replace("Subject:", "").strip()
                elif line.startswith("From:"):
                    sender = line.replace("From:", "").strip()
                elif line.startswith("To:"):
                    recipients = [r.strip() for r in line.replace("To:", "").split(",")]
                elif line == "" and not in_body:
                    in_body = True
                elif in_body:
                    body += line + "\n"
            
            return {
                "subject": subject,
                "sender": sender,
                "recipients": recipients,
                "body": body.strip(),
                "timestamp": datetime.now()
            }
            
        except Exception as e:
            print(f"Chyba p≈ôi parsov√°n√≠ emailu: {e}")
            return {}
    
    def extract_action_items(self, email_content: str, email_id: str) -> List[ActionItem]:
        """Extrakce action items z obsahu emailu"""
        action_items = []
        
        try:
            lines = email_content.split('\n')
            
            for i, line in enumerate(lines):
                line = line.strip()
                
                # Hled√°n√≠ ≈ô√°dk≈Ø s action keywords
                for keyword in self.action_keywords:
                    if keyword.lower() in line.lower():
                        # Extrakce potenci√°ln√≠ho √∫kolu
                        task_text = line
                        
                        # Pokus o extrakci dal≈°√≠ch detail≈Ø z n√°sleduj√≠c√≠ch ≈ô√°dk≈Ø
                        description = line
                        if i + 1 < len(lines):
                            next_line = lines[i + 1].strip()
                            if next_line and not any(kw in next_line.upper() for kw in self.action_keywords):
                                description += " " + next_line
                        
                        # Extrakce term√≠nu
                        due_date = self._extract_due_date(description)
                        
                        # Extrakce odpovƒõdn√© osoby
                        assignee = self._extract_assignee(description)
                        
                        # Urƒçen√≠ priority
                        priority = self._determine_priority(description)
                        
                        action_item = ActionItem(
                            id=str(uuid.uuid4()),
                            title=self._clean_task_title(line),
                            description=description,
                            assignee=assignee,
                            due_date=due_date,
                            priority=priority,
                            source_email_id=email_id
                        )
                        
                        action_items.append(action_item)
                        break
            
            return action_items
            
        except Exception as e:
            print(f"Chyba p≈ôi extrakci action items: {e}")
            return []
    
    def _extract_due_date(self, text: str) -> Optional[datetime]:
        """Extrakce term√≠nu z textu"""
        # Jednoduch√© regex pro extrakci datum≈Ø
        date_patterns = [
            r'(\d{1,2})\.(\d{1,2})\.(\d{4})',  # DD.MM.YYYY
            r'(\d{1,2})/(\d{1,2})/(\d{4})',   # DD/MM/YYYY
            r'do (\d{1,2})\.(\d{1,2})',       # do DD.MM
        ]
        
        for pattern in date_patterns:
            match = re.search(pattern, text)
            if match:
                try:
                    if len(match.groups()) == 3:
                        day, month, year = match.groups()
                        return datetime(int(year), int(month), int(day))
                    elif len(match.groups()) == 2:
                        day, month = match.groups()
                        current_year = datetime.now().year
                        return datetime(current_year, int(month), int(day))
                except ValueError:
                    continue
        
        return None
    
    def _extract_assignee(self, text: str) -> Optional[str]:
        """Extrakce odpovƒõdn√© osoby"""
        # Hled√°n√≠ jmen nebo email adres
        email_pattern = r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'
        name_patterns = [
            r'@(\w+)',  # @jmeno
            r'pro (\w+)',  # pro jmeno
            r'([A-Z][a-z]+ [A-Z][a-z]+)'  # Jmeno Prijmeni
        ]
        
        # Nejd≈ô√≠ve hled√°n√≠ emailu
        email_match = re.search(email_pattern, text)
        if email_match:
            return email_match.group(1)
        
        # Pak hled√°n√≠ jmen
        for pattern in name_patterns:
            match = re.search(pattern, text)
            if match:
                return match.group(1)
        
        return None
    
    def _determine_priority(self, text: str) -> Priority:
        """Urƒçen√≠ priority √∫kolu"""
        text_lower = text.lower()
        
        if any(word in text_lower for word in ['urgentn√≠', 'nal√©hav√©', 'ihned', 'asap']):
            return Priority.URGENT
        elif any(word in text_lower for word in ['d≈Øle≈æit√©', 'priorita', 'vysok√°']):
            return Priority.HIGH
        elif any(word in text_lower for word in ['n√≠zk√°', 'kdykoliv', 'voliteln√©']):
            return Priority.LOW
        else:
            return Priority.MEDIUM
    
    def _clean_task_title(self, text: str) -> str:
        """Vyƒçi≈°tƒõn√≠ titulku √∫kolu"""
        # Odstranƒõn√≠ keywords a speci√°ln√≠ch znak≈Ø
        cleaned = text
        for keyword in self.action_keywords:
            cleaned = re.sub(keyword, '', cleaned, flags=re.IGNORECASE)
        
        cleaned = re.sub(r'[^\w\s\-√°ƒçƒè√©ƒõ√≠≈à√≥≈ô≈°≈•√∫≈Ø√Ω≈æ]', '', cleaned)
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        
        return cleaned[:100] if len(cleaned) > 100 else cleaned
````

````python
import json
from typing import List, Dict, Any, Optional
from openai import OpenAI
from models import EmailSummary, ActionItem, TaskPlan, Priority
from email_processor import EmailProcessor
from mcp_context_manager import MCPContextManager
import uuid
from datetime import datetime

class LLMOrchestrator:
    """Orchestr√°tor pro koordinaci LLM agent≈Ø"""
    
    def __init__(self, api_key: str):
        self.client = OpenAI(api_key=api_key)
        self.email_processor = EmailProcessor()
        self.context_manager = MCPContextManager()
        
        # Syst√©mov√© prompty pro r≈Øzn√© √∫koly
        self.summarization_prompt = """
        Jsi expert na sumarizaci firemn√≠ch email≈Ø. Tv√Ωm √∫kolem je:
        1. Vytvo≈ôit struƒçn√© a p≈ôesn√© shrnut√≠ obsahu emailu
        2. Identifikovat kl√≠ƒçov√© body a d≈Øle≈æit√© informace
        3. Analyzovat sentiment komunikace
        4. Identifikovat v≈°echny √∫ƒçastn√≠ky
        
        Odpovƒõz ve strukturovan√©m JSON form√°tu s n√°sleduj√≠c√≠mi poli:
        - summary: struƒçn√© shrnut√≠ (max 200 slov)
        - key_points: seznam kl√≠ƒçov√Ωch bod≈Ø
        - sentiment: pozitivn√≠/negativn√≠/neutr√°ln√≠
        - participants: seznam √∫ƒçastn√≠k≈Ø
        """
        
        self.action_extraction_prompt = """
        Jsi expert na extrakci √∫kol≈Ø z firemn√≠ komunikace. Analyzuj n√°sleduj√≠c√≠ text a identifikuj:
        1. Konkr√©tn√≠ akce nebo √∫koly, kter√© je t≈ôeba splnit
        2. Odpovƒõdn√© osoby pro ka≈æd√Ω √∫kol
        3. Term√≠ny nebo deadliny
        4. Prioritu √∫kol≈Ø
        
        Odpovƒõz ve strukturovan√©m JSON form√°tu s polem "actions" obsahuj√≠c√≠m seznam √∫kol≈Ø.
        Ka≈æd√Ω √∫kol mus√≠ obsahovat: title, description, assignee, due_date, priority.
        """
        
        self.planning_prompt = """
        Jsi expert na pl√°nov√°n√≠ √∫kol≈Ø a projektov√Ω management. Na z√°kladƒõ poskytnut√Ωch action items:
        1. Vytvo≈ôte logicky strukturovan√Ω pl√°n
        2. Identifikujte z√°vislosti mezi √∫koly
        3. Navrhnƒõte ƒçasovou osu
        4. Optimalizujte po≈ôad√≠ √∫kol≈Ø podle priorit
        
        Odpovƒõz ve strukturovan√©m JSON form√°tu s pl√°nem √∫kol≈Ø.
        """
    
    def process_email_with_context(self, email_content: str, thread_id: Optional[str] = None) -> EmailSummary:
        """Zpracov√°n√≠ emailu s vyu≈æit√≠m kontextu"""
        try:
            # Parsov√°n√≠ z√°kladn√≠ch informac√≠
            parsed_email = self.email_processor.parse_email_content(email_content)
            email_id = str(uuid.uuid4())
            
            # Z√≠sk√°n√≠ relevantn√≠ho kontextu
            context_info = ""
            if thread_id:
                thread_context = self.context_manager.get_thread_context(thread_id)
                if thread_context:
                    context_info = self._format_context_for_prompt(thread_context)
            
            # P≈ô√≠prava prompta s kontextem
            full_prompt = f"""
            {self.summarization_prompt}
            
            {'KONTEXT Z P≈òEDCHOZ√çCH EMAIL≈Æ:' + context_info if context_info else ''}
            
            EMAIL K ANAL√ùZE:
            P≈ôedmƒõt: {parsed_email.get('subject', '')}
            Od: {parsed_email.get('sender', '')}
            Komu: {', '.join(parsed_email.get('recipients', []))}
            Obsah: {parsed_email.get('body', '')}
            """
            
            # Vol√°n√≠ LLM pro sumarizaci
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Jsi expert na anal√Ωzu firemn√≠ch email≈Ø."},
                    {"role": "user", "content": full_prompt}
                ],
                temperature=0.3,
                max_tokens=1500
            )
            
            # Parsov√°n√≠ odpovƒõdi
            llm_response = response.choices[0].message.content
            summary_data = self._parse_json_response(llm_response)
            
            # Extrakce action items
            action_items = self._extract_actions_with_llm(email_content, email_id)
            
            # Vytvo≈ôen√≠ EmailSummary objektu
            email_summary = EmailSummary(
                email_id=email_id,
                thread_id=thread_id,
                subject=parsed_email.get('subject', ''),
                summary=summary_data.get('summary', ''),
                key_points=summary_data.get('key_points', []),
                sentiment=summary_data.get('sentiment', 'neutr√°ln√≠'),
                participants=summary_data.get('participants', []),
                timestamp=parsed_email.get('timestamp', datetime.now()),
                action_items=action_items
            )
            
            # Ulo≈æen√≠ do MCP kontextu
            self.context_manager.store_email_context(email_summary)
            
            return email_summary
            
        except Exception as e:
            print(f"Chyba p≈ôi zpracov√°n√≠ emailu: {e}")
            # Fallback response
            return EmailSummary(
                email_id=str(uuid.uuid4()),
                thread_id=thread_id,
                subject=parsed_email.get('subject', ''),
                summary="Chyba p≈ôi zpracov√°n√≠ emailu",
                timestamp=datetime.now()
            )
    
    def _extract_actions_with_llm(self, email_content: str, email_id: str) -> List[ActionItem]:
        """Extrakce action items pomoc√≠ LLM"""
        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": self.action_extraction_prompt},
                    {"role": "user", "content": f"EMAIL:\n{email_content}"}
                ],
                temperature=0.2,
                max_tokens=1000
            )
            
            llm_response = response.choices[0].message.content
            actions_data = self._parse_json_response(llm_response)
            
            action_items = []
            for action_data in actions_data.get('actions', []):
                action_item = ActionItem(
                    id=str(uuid.uuid4()),
                    title=action_data.get('title', ''),
                    description=action_data.get('description', ''),
                    assignee=action_data.get('assignee'),
                    due_date=self._parse_date_string(action_data.get('due_date')),
                    priority=Priority(action_data.get('priority', 'medium')),
                    source_email_id=email_id
                )
                action_items.append(action_item)
            
            return action_items
            
        except Exception as e:
            print(f"Chyba p≈ôi extrakci akc√≠: {e}")
            return []
    
    def create_task_plan(self, action_items: List[ActionItem], context_query: str = "") -> TaskPlan:
        """Vytvo≈ôen√≠ pl√°nu √∫kol≈Ø z action items"""
        try:
            # Z√≠sk√°n√≠ relevantn√≠ho kontextu
            relevant_context = self.context_manager.retrieve_relevant_context(context_query)
            context_info = self._format_context_for_prompt(relevant_context)
            
            # P≈ô√≠prava dat pro LLM
            actions_text = "\n".join([
                f"- {action.title}: {action.description} (priorita: {action.priority}, term√≠n: {action.due_date})"
                for action in action_items
            ])
            
            full_prompt = f"""
            {self.planning_prompt}
            
            {'RELEVANTN√ç KONTEXT:' + context_info if context_info else ''}
            
            ACTION ITEMS K NAPL√ÅNOV√ÅN√ç:
            {actions_text}
            """
            
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Jsi expert na projektov√© pl√°nov√°n√≠."},
                    {"role": "user", "content": full_prompt}
                ],
                temperature=0.3,
                max_tokens=2000
            )
            
            llm_response = response.choices[0].message.content
            plan_data = self._parse_json_response(llm_response)
            
            # Vytvo≈ôen√≠ TaskPlan objektu
            task_plan = TaskPlan(
                plan_id=str(uuid.uuid4()),
                title=plan_data.get('title', 'Pl√°n √∫kol≈Ø'),
                description=plan_data.get('description', ''),
                action_items=action_items,
                timeline=plan_data.get('timeline', {}),
                dependencies=plan_data.get('dependencies', {})
            )
            
            # Ulo≈æen√≠ do kontextu
            self.context_manager.store_task_context(task_plan)
            
            return task_plan
            
        except Exception as e:
            print(f"Chyba p≈ôi vytv√°≈ôen√≠ pl√°nu: {e}")
            return TaskPlan(
                plan_id=str(uuid.uuid4()),
                title="Chyba p≈ôi pl√°nov√°n√≠",
                description="Nepoda≈ôilo se vytvo≈ôit pl√°n √∫kol≈Ø",
                action_items=action_items
            )
    
    def _format_context_for_prompt(self, context_items: List[Dict[str, Any]]) -> str:
        """Form√°tov√°n√≠ kontextu pro prompt"""
        if not context_items:
            return ""
        
        formatted_context = "\n"
        for item in context_items[:3]:  # Omezen√≠ na 3 nejrelevantnƒõj≈°√≠ polo≈æky
            formatted_context += f"- {item['content'][:200]}...\n"
        
        return formatted_context
    
    def _parse_json_response(self, response: str) -> Dict[str, Any]:
        """Parsov√°n√≠ JSON odpovƒõdi z LLM"""
        try:
            # Pokus o p≈ô√≠m√© parsov√°n√≠
            return json.loads(response)
        except json.JSONDecodeError:
            # Pokus o extrakci JSON z textu
            import re
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                try:
                    return json.loads(json_match.group())
                except json.JSONDecodeError:
                    pass
            
            # Fallback - pr√°zdn√Ω slovn√≠k
            return {}
    
    def _parse_date_string(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parsov√°n√≠ ≈ôetƒõzce s datem"""
        if not date_str:
            return None
        
        try:
            # R≈Øzn√© form√°ty datum≈Ø
            from dateutil.parser import parse
            return parse(date_str)
        except:
            return None
````

````python
from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import os
from llm_orchestrator import LLMOrchestrator
from models import EmailSummary, TaskPlan, ActionItem

app = FastAPI(title="Enterprise Email Summarizer API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Inicializace orchestr√°toru
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY environment variable not set")

orchestrator = LLMOrchestrator(OPENAI_API_KEY)

class EmailRequest(BaseModel):
    content: str
    thread_id: Optional[str] = None

class PlanRequest(BaseModel):
    action_items: List[ActionItem]
    context_query: Optional[str] = ""

@app.post("/api/process-email", response_model=EmailSummary)
async def process_email(request: EmailRequest):
    """Zpracov√°n√≠ emailu a extrakce informac√≠"""
    try:
        result = orchestrator.process_email_with_context(
            email_content=request.content,
            thread_id=request.thread_id
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba p≈ôi zpracov√°n√≠ emailu: {str(e)}")

@app.post("/api/create-plan", response_model=TaskPlan)
async def create_task_plan(request: PlanRequest):
    """Vytvo≈ôen√≠ pl√°nu √∫kol≈Ø z action items"""
    try:
        result = orchestrator.create_task_plan(
            action_items=request.action_items,
            context_query=request.context_query
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba p≈ôi vytv√°≈ôen√≠ pl√°nu: {str(e)}")

@app.get("/api/context/{query}")
async def get_relevant_context(query: str, limit: int = 5):
    """Z√≠sk√°n√≠ relevantn√≠ho kontextu"""
    try:
        context = orchestrator.context_manager.retrieve_relevant_context(query, limit)
        return {"context": context}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba p≈ôi z√≠sk√°v√°n√≠ kontextu: {str(e)}")

@app.get("/api/thread/{thread_id}")
async def get_thread_context(thread_id: str):
    """Z√≠sk√°n√≠ kontextu emailov√©ho vl√°kna"""
    try:
        context = orchestrator.context_manager.get_thread_context(thread_id)
        return {"thread_context": context}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba p≈ôi z√≠sk√°v√°n√≠ kontextu vl√°kna: {str(e)}")

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "Enterprise Email Summarizer"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````python
import asyncio
import json
from llm_orchestrator import LLMOrchestrator
from models import ActionItem, Priority
import os

# Uk√°zkov√© emaily pro demonstraci
SAMPLE_EMAILS = [
    """
Subject: Projekt XYZ - Akƒçn√≠ body z meetingu
From: manager@firma.cz
To: team@firma.cz

Dobr√Ω den,

po dne≈°n√≠m meetingu ohlednƒõ projektu XYZ bych r√°da shrnula hlavn√≠ akƒçn√≠ body:

1. √öKOL: Jan Nov√°k dokonƒç√≠ anal√Ωzu po≈æadavk≈Ø do 15.12.2024
2. TODO: Marie Svobodov√° p≈ôiprav√≠ n√°vrh architektury do konce t√Ωdne
3. AKCE: T√Ωm v√Ωvoje zah√°j√≠ implementaci prvn√≠ f√°ze od pondƒõl√≠
4. TERM√çN: Kompletn√≠ testov√°n√≠ mus√≠ b√Ωt dokonƒçeno do 20.12.2024

Priorita projektu je VYSOK√Å vzhledem k term√≠nu spu≈°tƒõn√≠ v nov√©m roce.

Pros√≠m o potvrzen√≠ p≈ôijet√≠ √∫kol≈Ø.

S pozdravem,
Jana Mana≈æerka
""",
    """
Subject: URGENTN√ç: Oprava produkƒçn√≠ho serveru
From: admin@firma.cz
To: dev-team@firma.cz

Dobr√Ω den,

na produkƒçn√≠m serveru do≈°lo k z√°va≈æn√© chybƒõ. Pot≈ôebuji okam≈æitou akci:

TODO: Tom√°≈° Dvo≈ô√°k - okam≈æitƒõ analyzovat logy serveru
√öKOL: Petra Nov√° - p≈ôipravit rollback pl√°n pro p≈ô√≠pad nutnosti
AKCE: Cel√Ω t√Ωm - b√Ωt v pohotovosti pro mo≈æn√© nasazen√≠ opravy

Deadline: IHNED - server mus√≠ b√Ωt funkƒçn√≠ do 2 hodin!

Urgentn√≠ priorita!

Admin
""",
    """
Subject: Re: Projekt XYZ - Akƒçn√≠ body z meetingu
From: jan.novak@firma.cz
To: manager@firma.cz

Dobr√Ω den,

potvrzujem p≈ôijet√≠ √∫kolu anal√Ωzy po≈æadavk≈Ø. M√°m ale dotaz ohlednƒõ rozsahu:

1. M√°m analyzovat jen nov√© po≈æadavky nebo i revizi st√°vaj√≠c√≠ch?
2. Pot≈ôebuji p≈ô√≠stup k dokumentaci z√°kazn√≠ka - m≈Ø≈æete mi ho zajistit?

Nav√≠c bych r√°d navrhl roz≈°√≠≈ôen√≠ term√≠nu o 2 dny kv≈Øli slo≈æitosti √∫kolu.

Aktu√°lnƒõ pracuji tak√© na projektu ABC, kter√Ω m√° deadline 18.12.

S pozdravem,
Jan Nov√°k
"""
]

async def demonstrate_email_processing():
    """Demonstrace zpracov√°n√≠ email≈Ø"""
    
    # Inicializace (vy≈æaduje OPENAI_API_KEY v environment)
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("Nastavte OPENAI_API_KEY environment variable")
        return
    
    orchestrator = LLMOrchestrator(api_key)
    
    print("=== ENTERPRISE EMAIL SUMMARIZER + ACTION PLANNER ===\n")
    
    thread_id = "thread_xyz_project"
    all_action_items = []
    
    # Zpracov√°n√≠ email≈Ø v po≈ôad√≠
    for i, email_content in enumerate(SAMPLE_EMAILS, 1):
        print(f"üìß Zpracov√°n√≠ emailu {i}:")
        print("-" * 50)
        
        # Zpracov√°n√≠ emailu s kontextem
        email_summary = orchestrator.process_email_with_context(
            email_content=email_content,
            thread_id=thread_id
        )
        
        print(f"‚úÖ Shrnut√≠: {email_summary.summary}")
        print(f"üéØ Kl√≠ƒçov√© body: {', '.join(email_summary.key_points)}")
        print(f"üòä Sentiment: {email_summary.sentiment}")
        print(f"üë• √öƒçastn√≠ci: {', '.join(email_summary.participants)}")
        
        if email_summary.action_items:
            print(f"üìã Nalezeno {len(email_summary.action_items)} √∫kol≈Ø:")
            for action in email_summary.action_items:
                print(f"  - {action.title} (priorita: {action.priority})")
                if action.assignee:
                    print(f"    üë§ Odpovƒõdn√Ω: {action.assignee}")
                if action.due_date:
                    print(f"    üìÖ Term√≠n: {action.due_date.strftime('%d.%m.%Y')}")
            
            all_action_items.extend(email_summary.action_items)
        
        print("\n")
    
    # Vytvo≈ôen√≠ pl√°nu √∫kol≈Ø
    if all_action_items:
        print("üìã Vytv√°≈ôen√≠ pl√°nu √∫kol≈Ø z v≈°ech action items...")
        print("-" * 50)
        
        task_plan = orchestrator.create_task_plan(
            action_items=all_action_items,
            context_query="projekt XYZ deadline testov√°n√≠"
        )
        
        print(f"üìÑ N√°zev pl√°nu: {task_plan.title}")
        print(f"üìù Popis: {task_plan.description}")
        print(f"üìä Poƒçet √∫kol≈Ø: {len(task_plan.action_items)}")
        
        if task_plan.timeline:
            print("üìÖ ƒåasov√° osa:")
            for period, tasks in task_plan.timeline.items():
                print(f"  {period}: {', '.join(tasks)}")
        
        if task_plan.dependencies:
            print("üîó Z√°vislosti:")
            for task, deps in task_plan.dependencies.items():
                print(f"  {task} z√°vis√≠ na: {', '.join(deps)}")
    
    # Demonstrace vyhled√°v√°n√≠ v kontextu
    print("\nüîç Testov√°n√≠ vyhled√°v√°n√≠ v kontextu:")
    print("-" * 50)
    
    search_queries = [
        "anal√Ωza po≈æadavk≈Ø",
        "term√≠n deadline",
        "urgentn√≠ server"
    ]
    
    for query in search_queries:
        print(f"\nüîé Hled√°m: '{query}'")
        context_results = orchestrator.context_manager.retrieve_relevant_context(query, 2)
        
        for i, result in enumerate(context_results, 1):
            print(f"  {i}. {result['type']}: {result['content'][:100]}...")

def create_sample_data():
    """Vytvo≈ôen√≠ uk√°zkov√Ωch dat pro testov√°n√≠"""
    print("üì¶ Vytv√°≈ôen√≠ uk√°zkov√Ωch dat...")
    
    # Uk√°zka action items
    sample_actions = [
        ActionItem(
            id="action_1",
            title="Dokonƒçen√≠ anal√Ωzy po≈æadavk≈Ø",
            description="Kompletn√≠ anal√Ωza po≈æadavk≈Ø pro projekt XYZ",
            assignee="Jan Nov√°k",
            priority=Priority.HIGH,
            source_email_id="email_1"
        ),
        ActionItem(
            id="action_2", 
            title="Oprava produkƒçn√≠ho serveru",
            description="Urgentn√≠ oprava chyby na produkƒçn√≠m serveru",
            assignee="Tom√°≈° Dvo≈ô√°k",
            priority=Priority.URGENT,
            source_email_id="email_2"
        )
    ]
    
    return sample_actions

if __name__ == "__main__":
    print("üöÄ Spou≈°t√≠m demonstraci Enterprise Email Summarizer...")
    
    # Kontrola API kl√≠ƒçe
    if not os.getenv("OPENAI_API_KEY"):
        print("‚ùå Chyba: Nastavte OPENAI_API_KEY environment variable")
        print("   export OPENAI_API_KEY='v√°≈°-api-kl√≠ƒç'")
        exit(1)
    
    # Spu≈°tƒõn√≠ demonstrace
    asyncio.run(demonstrate_email_processing())
    
    print("\n‚úÖ Demonstrace dokonƒçena!")
    print("\nPro spu≈°tƒõn√≠ API serveru pou≈æijte:")
    print("   python api.py")
    print("\nAPI bude dostupn√© na: http://localhost:8000")
    print("Dokumentace API: http://localhost:8000/docs")
````

````python
import os
import subprocess
import sys

def install_requirements():
    """Instalace z√°vislost√≠"""
    print("üì¶ Instaluji z√°vislosti...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])

def setup_environment():
    """Nastaven√≠ prost≈ôed√≠"""
    print("üîß Nastavuji prost≈ôed√≠...")
    
    # Vytvo≈ôen√≠ adres√°≈ô≈Ø
    os.makedirs("chroma_db", exist_ok=True)
    os.makedirs("logs", exist_ok=True)
    
    print("‚úÖ Prost≈ôed√≠ p≈ôipraveno!")

def check_api_key():
    """Kontrola API kl√≠ƒçe"""
    if not os.getenv("OPENAI_API_KEY"):
        print("‚ö†Ô∏è  OPENAI_API_KEY nen√≠ nastaven!")
        print("   Nastavte promƒõnnou prost≈ôed√≠:")
        print("   export OPENAI_API_KEY='v√°≈°-api-kl√≠ƒç'")
        return False
    return True

if __name__ == "__main__":
    print("üöÄ Enterprise Email Summarizer - Setup")
    print("=" * 50)
    
    try:
        install_requirements()
        setup_environment()
        
        if check_api_key():
            print("\n‚úÖ Setup dokonƒçen √∫spƒõ≈°nƒõ!")
            print("\nSpus≈•te demo:")
            print("   python example_usage.py")
            print("\nNebo API server:")
            print("   python api.py")
        else:
            print("\n‚ùå Setup dokonƒçen s upozornƒõn√≠mi")
            
    except Exception as e:
        print(f"\n‚ùå Chyba bƒõhem setupu: {e}")
        sys.exit(1)
````

## Shrnut√≠ projektu

Enterprise Email Summarizer + Action Planner p≈ôedstavuje pokroƒçil√Ω AI syst√©m, kter√Ω revolucionizuje spr√°vu firemn√≠ emailov√© komunikace pomoc√≠ Model Context Protocol a modern√≠ch LLM technologi√≠.

### Kl√≠ƒçov√© hodnoty projektu:

**üéØ Efektivita**: Automatizace sumarizace a pl√°nov√°n√≠ sni≈æuje manu√°ln√≠ pr√°ci o 60-80%

**üß† Inteligence**: Vyu≈æit√≠ GPT-4o s velk√Ωmi context windows pro hlubok√© porozumƒõn√≠ kontextu

**üíæ Pamƒõ≈•**: MCP implementace zaji≈°≈•uje kontinuitu nap≈ô√≠ƒç dlouhodob√Ωmi projekty

**üîÑ ≈†k√°lovatelnost**: Architektura podporuje tis√≠ce email≈Ø dennƒõ s konzistentn√≠ v√Ωkonnost√≠

**üé® Flexibilita**: Modul√°rn√≠ design umo≈æ≈àuje snadn√© roz≈°√≠≈ôen√≠ o dal≈°√≠ funkcionality

### Technologick√© inovace:

- **Model Context Protocol** pro spr√°vu dlouhodob√© pamƒõti
- **Multi-agent orchestrace** s specializovan√Ωmi LLM agenty
- **Vektorov√© embeddings** pro s√©mantick√© vyhled√°v√°n√≠ kontextu
- **Strukturovan√° extrakce dat** s pokroƒçil√Ωm prompt engineeringem
- **REST API** pro jednoduchou integraci do firemn√≠ch syst√©m≈Ø

Projekt demonstruje praktick√© vyu≈æit√≠ nejmodernƒõj≈°√≠ch AI technologi√≠ pro ≈ôe≈°en√≠ re√°ln√Ωch business probl√©m≈Ø v oblasti produktivity a komunikace.