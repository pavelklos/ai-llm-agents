<small>Claude Sonnet 4 **(Enterprise Email Summarizer + Action Planner)**</small>
# Enterprise Email Summarizer + Action Planner

## Klíčové koncepty

### Model Context Protocol (MCP)
MCP je standardizovaný protokol pro správu kontextu mezi LLM modely a externími systémy. Umožňuje dynamické načítání kontextu, správu paměti a koordinaci mezi různými AI agenty pro efektivní zpracování dlouhodobých konverzací.

### Context Windows
Okna kontextu definují množství informací, které může LLM model zpracovat najednou. Moderní modely jako GPT-4o podporují velká okna kontextu (128k tokenů), což umožňuje zpracování rozsáhlých dokumentů a udržování dlouhodobé paměti.

### Task Memory
Systém paměti úkolů udržuje informace o předchozích akcích, rozhodnutích a kontextu napříč více interakcemi. Využívá vektorové databáze pro efektivní ukládání a vyhledávání relevantních informací.

### Prompt Engineering
Technika optimalizace promptů pro dosažení nejlepších výsledků z LLM modelů. Zahrnuje strukturování instrukcí, poskytování příkladů a řízení výstupu modelu prostřednictvím pečlivě navržených textových vstupů.

### LLM Agents
Autonomní AI agenti postavení na LLM modelech, kteří mohou vykonávat složité úkoly, rozhodovat se a komunikovat s externími systémy. Kombinují jazykové schopnosti s plánováním akcí a správou workflow.

## Komplexní vysvětlení projektu

Enterprise Email Summarizer + Action Planner je pokročilý AI systém navržený pro automatizaci správy firemních emailů. Projekt řeší kritický problém moderních organizací - přetížení informacemi z emailové komunikace a neefektivní správu úkolů.

### Hlavní cíle:
- **Automatické shrnutí**: Inteligentní analýza a sumarizace emailových vláken
- **Extrakce akcí**: Identifikace konkrétních úkolů a termínů z emailové komunikace
- **Plánování úkolů**: Automatické vytváření strukturovaných plánů s prioritami
- **Kontextová paměť**: Udržování dlouhodobého kontextu napříč projekty a týmy

### Technické výzvy:
1. **Zpracování rozsáhlých emailových vláken** - využití velkých context windows
2. **Udržování kontextu** - implementace MCP pro kontinuitu napříč sezeními
3. **Extrakce strukturovaných dat** - precizní identifikace akcí a termínů
4. **Škálovatelnost** - podpora pro tisíce emailů denně

### Dopad na organizaci:
- Snížení času stráveného čtením emailů o 60-80%
- Automatizace task managementu
- Zlepšení sledování projektových závazků
- Zvýšení produktivity týmů

## Komplexní příklad s Python implementací

````python
openai==1.10.0
langchain==0.1.0
langchain-openai==0.0.5
chromadb==0.4.22
pydantic==2.5.0
fastapi==0.108.0
uvicorn==0.25.0
python-multipart==0.0.6
email-parser==0.2.0
python-dateutil==2.8.2
schedule==1.2.0
````

````python
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

class Priority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class ActionItem(BaseModel):
    id: str = Field(..., description="Unikátní identifikátor akce")
    title: str = Field(..., description="Název akce")
    description: str = Field(..., description="Detailní popis akce")
    assignee: Optional[str] = Field(None, description="Osoba odpovědná za akci")
    due_date: Optional[datetime] = Field(None, description="Termín splnění")
    priority: Priority = Field(Priority.MEDIUM, description="Priorita akce")
    status: str = Field("open", description="Stav akce")
    source_email_id: str = Field(..., description="ID zdrojového emailu")
    context: Dict[str, Any] = Field(default_factory=dict, description="Dodatečný kontext")

class EmailSummary(BaseModel):
    email_id: str = Field(..., description="Unikátní identifikátor emailu")
    thread_id: Optional[str] = Field(None, description="ID emailového vlákna")
    subject: str = Field(..., description="Předmět emailu")
    summary: str = Field(..., description="Shrnutí obsahu")
    key_points: List[str] = Field(default_factory=list, description="Klíčové body")
    sentiment: str = Field(..., description="Sentiment emailu")
    participants: List[str] = Field(default_factory=list, description="Účastníci komunikace")
    timestamp: datetime = Field(..., description="Čas vytvoření")
    action_items: List[ActionItem] = Field(default_factory=list, description="Extrahované akce")

class TaskPlan(BaseModel):
    plan_id: str = Field(..., description="ID plánu")
    title: str = Field(..., description="Název plánu")
    description: str = Field(..., description="Popis plánu")
    action_items: List[ActionItem] = Field(..., description="Seznam akcí")
    timeline: Dict[str, List[str]] = Field(default_factory=dict, description="Časová osa")
    dependencies: Dict[str, List[str]] = Field(default_factory=dict, description="Závislosti")
    created_at: datetime = Field(default_factory=datetime.now)
````

````python
import json
import uuid
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import chromadb
from chromadb.config import Settings
from langchain.schema import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter

class MCPContextManager:
    """Model Context Protocol manager pro správu kontextu napříč sezeními"""
    
    def __init__(self, persist_directory: str = "./chroma_db"):
        self.client = chromadb.PersistentClient(
            path=persist_directory,
            settings=Settings(anonymized_telemetry=False)
        )
        self.email_collection = self.client.get_or_create_collection("emails")
        self.context_collection = self.client.get_or_create_collection("context")
        self.task_collection = self.client.get_or_create_collection("tasks")
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
    
    def store_email_context(self, email_summary: 'EmailSummary') -> str:
        """Uložení emailového kontextu do MCP úložiště"""
        try:
            context_id = str(uuid.uuid4())
            
            # Vytvoření metadat
            metadata = {
                "email_id": email_summary.email_id,
                "thread_id": email_summary.thread_id or "",
                "subject": email_summary.subject,
                "timestamp": email_summary.timestamp.isoformat(),
                "sentiment": email_summary.sentiment,
                "participants": ",".join(email_summary.participants),
                "type": "email_summary"
            }
            
            # Kombinovaný text pro embedding
            combined_text = f"""
            Předmět: {email_summary.subject}
            Shrnutí: {email_summary.summary}
            Klíčové body: {'; '.join(email_summary.key_points)}
            Sentiment: {email_summary.sentiment}
            Účastníci: {', '.join(email_summary.participants)}
            """
            
            self.email_collection.add(
                documents=[combined_text],
                metadatas=[metadata],
                ids=[context_id]
            )
            
            return context_id
            
        except Exception as e:
            print(f"Chyba při ukládání emailového kontextu: {e}")
            return ""
    
    def store_task_context(self, task_plan: 'TaskPlan') -> str:
        """Uložení kontextu úkolů"""
        try:
            context_id = str(uuid.uuid4())
            
            # Příprava textu s informacemi o úkolech
            tasks_text = f"""
            Plán: {task_plan.title}
            Popis: {task_plan.description}
            Akce: {'; '.join([f"{action.title} - {action.description}" for action in task_plan.action_items])}
            """
            
            metadata = {
                "plan_id": task_plan.plan_id,
                "title": task_plan.title,
                "created_at": task_plan.created_at.isoformat(),
                "action_count": str(len(task_plan.action_items)),
                "type": "task_plan"
            }
            
            self.task_collection.add(
                documents=[tasks_text],
                metadatas=[metadata],
                ids=[context_id]
            )
            
            return context_id
            
        except Exception as e:
            print(f"Chyba při ukládání kontextu úkolů: {e}")
            return ""
    
    def retrieve_relevant_context(self, query: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Získání relevantního kontextu na základě dotazu"""
        try:
            # Hledání v emailech
            email_results = self.email_collection.query(
                query_texts=[query],
                n_results=n_results
            )
            
            # Hledání v úkolech
            task_results = self.task_collection.query(
                query_texts=[query],
                n_results=n_results
            )
            
            combined_results = []
            
            # Zpracování emailových výsledků
            if email_results['documents']:
                for i, doc in enumerate(email_results['documents'][0]):
                    combined_results.append({
                        "content": doc,
                        "metadata": email_results['metadatas'][0][i],
                        "type": "email",
                        "score": email_results['distances'][0][i] if email_results['distances'] else 0
                    })
            
            # Zpracování úkolových výsledků
            if task_results['documents']:
                for i, doc in enumerate(task_results['documents'][0]):
                    combined_results.append({
                        "content": doc,
                        "metadata": task_results['metadatas'][0][i],
                        "type": "task",
                        "score": task_results['distances'][0][i] if task_results['distances'] else 0
                    })
            
            # Seřazení podle skóre
            combined_results.sort(key=lambda x: x['score'])
            
            return combined_results[:n_results]
            
        except Exception as e:
            print(f"Chyba při získávání kontextu: {e}")
            return []
    
    def get_thread_context(self, thread_id: str) -> List[Dict[str, Any]]:
        """Získání kompletního kontextu emailového vlákna"""
        try:
            results = self.email_collection.get(
                where={"thread_id": thread_id}
            )
            
            context_items = []
            if results['documents']:
                for i, doc in enumerate(results['documents']):
                    context_items.append({
                        "content": doc,
                        "metadata": results['metadatas'][i],
                        "id": results['ids'][i]
                    })
            
            # Seřazení podle časového razítka
            context_items.sort(key=lambda x: x['metadata'].get('timestamp', ''))
            
            return context_items
            
        except Exception as e:
            print(f"Chyba při získávání kontextu vlákna: {e}")
            return []
````

````python
import re
import email
from email import policy
from email.parser import BytesParser
from typing import List, Dict, Any, Optional
from datetime import datetime
import uuid
from models import EmailSummary, ActionItem, Priority

class EmailProcessor:
    """Procesor pro zpracování a parsování emailů"""
    
    def __init__(self):
        self.action_keywords = [
            'TODO', 'ÚKOL', 'AKCE', 'POTŘEBUJI', 'MUSÍM', 'DEADLINE',
            'TERMÍN', 'DOKONČIT', 'SPLNIT', 'ZAJISTIT', 'PŘIPRAVIT'
        ]
        
    def parse_email_content(self, email_content: str) -> Dict[str, Any]:
        """Parsování obsahu emailu"""
        try:
            # Simulace parsování emailu (v reálné aplikaci by se použil skutečný email parser)
            lines = email_content.strip().split('\n')
            
            # Extrakce základních informací
            subject = ""
            sender = ""
            recipients = []
            body = ""
            
            in_body = False
            for line in lines:
                line = line.strip()
                if line.startswith("Subject:"):
                    subject = line.replace("Subject:", "").strip()
                elif line.startswith("From:"):
                    sender = line.replace("From:", "").strip()
                elif line.startswith("To:"):
                    recipients = [r.strip() for r in line.replace("To:", "").split(",")]
                elif line == "" and not in_body:
                    in_body = True
                elif in_body:
                    body += line + "\n"
            
            return {
                "subject": subject,
                "sender": sender,
                "recipients": recipients,
                "body": body.strip(),
                "timestamp": datetime.now()
            }
            
        except Exception as e:
            print(f"Chyba při parsování emailu: {e}")
            return {}
    
    def extract_action_items(self, email_content: str, email_id: str) -> List[ActionItem]:
        """Extrakce action items z obsahu emailu"""
        action_items = []
        
        try:
            lines = email_content.split('\n')
            
            for i, line in enumerate(lines):
                line = line.strip()
                
                # Hledání řádků s action keywords
                for keyword in self.action_keywords:
                    if keyword.lower() in line.lower():
                        # Extrakce potenciálního úkolu
                        task_text = line
                        
                        # Pokus o extrakci dalších detailů z následujících řádků
                        description = line
                        if i + 1 < len(lines):
                            next_line = lines[i + 1].strip()
                            if next_line and not any(kw in next_line.upper() for kw in self.action_keywords):
                                description += " " + next_line
                        
                        # Extrakce termínu
                        due_date = self._extract_due_date(description)
                        
                        # Extrakce odpovědné osoby
                        assignee = self._extract_assignee(description)
                        
                        # Určení priority
                        priority = self._determine_priority(description)
                        
                        action_item = ActionItem(
                            id=str(uuid.uuid4()),
                            title=self._clean_task_title(line),
                            description=description,
                            assignee=assignee,
                            due_date=due_date,
                            priority=priority,
                            source_email_id=email_id
                        )
                        
                        action_items.append(action_item)
                        break
            
            return action_items
            
        except Exception as e:
            print(f"Chyba při extrakci action items: {e}")
            return []
    
    def _extract_due_date(self, text: str) -> Optional[datetime]:
        """Extrakce termínu z textu"""
        # Jednoduché regex pro extrakci datumů
        date_patterns = [
            r'(\d{1,2})\.(\d{1,2})\.(\d{4})',  # DD.MM.YYYY
            r'(\d{1,2})/(\d{1,2})/(\d{4})',   # DD/MM/YYYY
            r'do (\d{1,2})\.(\d{1,2})',       # do DD.MM
        ]
        
        for pattern in date_patterns:
            match = re.search(pattern, text)
            if match:
                try:
                    if len(match.groups()) == 3:
                        day, month, year = match.groups()
                        return datetime(int(year), int(month), int(day))
                    elif len(match.groups()) == 2:
                        day, month = match.groups()
                        current_year = datetime.now().year
                        return datetime(current_year, int(month), int(day))
                except ValueError:
                    continue
        
        return None
    
    def _extract_assignee(self, text: str) -> Optional[str]:
        """Extrakce odpovědné osoby"""
        # Hledání jmen nebo email adres
        email_pattern = r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'
        name_patterns = [
            r'@(\w+)',  # @jmeno
            r'pro (\w+)',  # pro jmeno
            r'([A-Z][a-z]+ [A-Z][a-z]+)'  # Jmeno Prijmeni
        ]
        
        # Nejdříve hledání emailu
        email_match = re.search(email_pattern, text)
        if email_match:
            return email_match.group(1)
        
        # Pak hledání jmen
        for pattern in name_patterns:
            match = re.search(pattern, text)
            if match:
                return match.group(1)
        
        return None
    
    def _determine_priority(self, text: str) -> Priority:
        """Určení priority úkolu"""
        text_lower = text.lower()
        
        if any(word in text_lower for word in ['urgentní', 'naléhavé', 'ihned', 'asap']):
            return Priority.URGENT
        elif any(word in text_lower for word in ['důležité', 'priorita', 'vysoká']):
            return Priority.HIGH
        elif any(word in text_lower for word in ['nízká', 'kdykoliv', 'volitelné']):
            return Priority.LOW
        else:
            return Priority.MEDIUM
    
    def _clean_task_title(self, text: str) -> str:
        """Vyčištění titulku úkolu"""
        # Odstranění keywords a speciálních znaků
        cleaned = text
        for keyword in self.action_keywords:
            cleaned = re.sub(keyword, '', cleaned, flags=re.IGNORECASE)
        
        cleaned = re.sub(r'[^\w\s\-áčďéěíňóřšťúůýž]', '', cleaned)
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        
        return cleaned[:100] if len(cleaned) > 100 else cleaned
````

````python
import json
from typing import List, Dict, Any, Optional
from openai import OpenAI
from models import EmailSummary, ActionItem, TaskPlan, Priority
from email_processor import EmailProcessor
from mcp_context_manager import MCPContextManager
import uuid
from datetime import datetime

class LLMOrchestrator:
    """Orchestrátor pro koordinaci LLM agentů"""
    
    def __init__(self, api_key: str):
        self.client = OpenAI(api_key=api_key)
        self.email_processor = EmailProcessor()
        self.context_manager = MCPContextManager()
        
        # Systémové prompty pro různé úkoly
        self.summarization_prompt = """
        Jsi expert na sumarizaci firemních emailů. Tvým úkolem je:
        1. Vytvořit stručné a přesné shrnutí obsahu emailu
        2. Identifikovat klíčové body a důležité informace
        3. Analyzovat sentiment komunikace
        4. Identifikovat všechny účastníky
        
        Odpověz ve strukturovaném JSON formátu s následujícími poli:
        - summary: stručné shrnutí (max 200 slov)
        - key_points: seznam klíčových bodů
        - sentiment: pozitivní/negativní/neutrální
        - participants: seznam účastníků
        """
        
        self.action_extraction_prompt = """
        Jsi expert na extrakci úkolů z firemní komunikace. Analyzuj následující text a identifikuj:
        1. Konkrétní akce nebo úkoly, které je třeba splnit
        2. Odpovědné osoby pro každý úkol
        3. Termíny nebo deadliny
        4. Prioritu úkolů
        
        Odpověz ve strukturovaném JSON formátu s polem "actions" obsahujícím seznam úkolů.
        Každý úkol musí obsahovat: title, description, assignee, due_date, priority.
        """
        
        self.planning_prompt = """
        Jsi expert na plánování úkolů a projektový management. Na základě poskytnutých action items:
        1. Vytvořte logicky strukturovaný plán
        2. Identifikujte závislosti mezi úkoly
        3. Navrhněte časovou osu
        4. Optimalizujte pořadí úkolů podle priorit
        
        Odpověz ve strukturovaném JSON formátu s plánem úkolů.
        """
    
    def process_email_with_context(self, email_content: str, thread_id: Optional[str] = None) -> EmailSummary:
        """Zpracování emailu s využitím kontextu"""
        try:
            # Parsování základních informací
            parsed_email = self.email_processor.parse_email_content(email_content)
            email_id = str(uuid.uuid4())
            
            # Získání relevantního kontextu
            context_info = ""
            if thread_id:
                thread_context = self.context_manager.get_thread_context(thread_id)
                if thread_context:
                    context_info = self._format_context_for_prompt(thread_context)
            
            # Příprava prompta s kontextem
            full_prompt = f"""
            {self.summarization_prompt}
            
            {'KONTEXT Z PŘEDCHOZÍCH EMAILŮ:' + context_info if context_info else ''}
            
            EMAIL K ANALÝZE:
            Předmět: {parsed_email.get('subject', '')}
            Od: {parsed_email.get('sender', '')}
            Komu: {', '.join(parsed_email.get('recipients', []))}
            Obsah: {parsed_email.get('body', '')}
            """
            
            # Volání LLM pro sumarizaci
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Jsi expert na analýzu firemních emailů."},
                    {"role": "user", "content": full_prompt}
                ],
                temperature=0.3,
                max_tokens=1500
            )
            
            # Parsování odpovědi
            llm_response = response.choices[0].message.content
            summary_data = self._parse_json_response(llm_response)
            
            # Extrakce action items
            action_items = self._extract_actions_with_llm(email_content, email_id)
            
            # Vytvoření EmailSummary objektu
            email_summary = EmailSummary(
                email_id=email_id,
                thread_id=thread_id,
                subject=parsed_email.get('subject', ''),
                summary=summary_data.get('summary', ''),
                key_points=summary_data.get('key_points', []),
                sentiment=summary_data.get('sentiment', 'neutrální'),
                participants=summary_data.get('participants', []),
                timestamp=parsed_email.get('timestamp', datetime.now()),
                action_items=action_items
            )
            
            # Uložení do MCP kontextu
            self.context_manager.store_email_context(email_summary)
            
            return email_summary
            
        except Exception as e:
            print(f"Chyba při zpracování emailu: {e}")
            # Fallback response
            return EmailSummary(
                email_id=str(uuid.uuid4()),
                thread_id=thread_id,
                subject=parsed_email.get('subject', ''),
                summary="Chyba při zpracování emailu",
                timestamp=datetime.now()
            )
    
    def _extract_actions_with_llm(self, email_content: str, email_id: str) -> List[ActionItem]:
        """Extrakce action items pomocí LLM"""
        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": self.action_extraction_prompt},
                    {"role": "user", "content": f"EMAIL:\n{email_content}"}
                ],
                temperature=0.2,
                max_tokens=1000
            )
            
            llm_response = response.choices[0].message.content
            actions_data = self._parse_json_response(llm_response)
            
            action_items = []
            for action_data in actions_data.get('actions', []):
                action_item = ActionItem(
                    id=str(uuid.uuid4()),
                    title=action_data.get('title', ''),
                    description=action_data.get('description', ''),
                    assignee=action_data.get('assignee'),
                    due_date=self._parse_date_string(action_data.get('due_date')),
                    priority=Priority(action_data.get('priority', 'medium')),
                    source_email_id=email_id
                )
                action_items.append(action_item)
            
            return action_items
            
        except Exception as e:
            print(f"Chyba při extrakci akcí: {e}")
            return []
    
    def create_task_plan(self, action_items: List[ActionItem], context_query: str = "") -> TaskPlan:
        """Vytvoření plánu úkolů z action items"""
        try:
            # Získání relevantního kontextu
            relevant_context = self.context_manager.retrieve_relevant_context(context_query)
            context_info = self._format_context_for_prompt(relevant_context)
            
            # Příprava dat pro LLM
            actions_text = "\n".join([
                f"- {action.title}: {action.description} (priorita: {action.priority}, termín: {action.due_date})"
                for action in action_items
            ])
            
            full_prompt = f"""
            {self.planning_prompt}
            
            {'RELEVANTNÍ KONTEXT:' + context_info if context_info else ''}
            
            ACTION ITEMS K NAPLÁNOVÁNÍ:
            {actions_text}
            """
            
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Jsi expert na projektové plánování."},
                    {"role": "user", "content": full_prompt}
                ],
                temperature=0.3,
                max_tokens=2000
            )
            
            llm_response = response.choices[0].message.content
            plan_data = self._parse_json_response(llm_response)
            
            # Vytvoření TaskPlan objektu
            task_plan = TaskPlan(
                plan_id=str(uuid.uuid4()),
                title=plan_data.get('title', 'Plán úkolů'),
                description=plan_data.get('description', ''),
                action_items=action_items,
                timeline=plan_data.get('timeline', {}),
                dependencies=plan_data.get('dependencies', {})
            )
            
            # Uložení do kontextu
            self.context_manager.store_task_context(task_plan)
            
            return task_plan
            
        except Exception as e:
            print(f"Chyba při vytváření plánu: {e}")
            return TaskPlan(
                plan_id=str(uuid.uuid4()),
                title="Chyba při plánování",
                description="Nepodařilo se vytvořit plán úkolů",
                action_items=action_items
            )
    
    def _format_context_for_prompt(self, context_items: List[Dict[str, Any]]) -> str:
        """Formátování kontextu pro prompt"""
        if not context_items:
            return ""
        
        formatted_context = "\n"
        for item in context_items[:3]:  # Omezení na 3 nejrelevantnější položky
            formatted_context += f"- {item['content'][:200]}...\n"
        
        return formatted_context
    
    def _parse_json_response(self, response: str) -> Dict[str, Any]:
        """Parsování JSON odpovědi z LLM"""
        try:
            # Pokus o přímé parsování
            return json.loads(response)
        except json.JSONDecodeError:
            # Pokus o extrakci JSON z textu
            import re
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                try:
                    return json.loads(json_match.group())
                except json.JSONDecodeError:
                    pass
            
            # Fallback - prázdný slovník
            return {}
    
    def _parse_date_string(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parsování řetězce s datem"""
        if not date_str:
            return None
        
        try:
            # Různé formáty datumů
            from dateutil.parser import parse
            return parse(date_str)
        except:
            return None
````

````python
from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import os
from llm_orchestrator import LLMOrchestrator
from models import EmailSummary, TaskPlan, ActionItem

app = FastAPI(title="Enterprise Email Summarizer API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Inicializace orchestrátoru
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY environment variable not set")

orchestrator = LLMOrchestrator(OPENAI_API_KEY)

class EmailRequest(BaseModel):
    content: str
    thread_id: Optional[str] = None

class PlanRequest(BaseModel):
    action_items: List[ActionItem]
    context_query: Optional[str] = ""

@app.post("/api/process-email", response_model=EmailSummary)
async def process_email(request: EmailRequest):
    """Zpracování emailu a extrakce informací"""
    try:
        result = orchestrator.process_email_with_context(
            email_content=request.content,
            thread_id=request.thread_id
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba při zpracování emailu: {str(e)}")

@app.post("/api/create-plan", response_model=TaskPlan)
async def create_task_plan(request: PlanRequest):
    """Vytvoření plánu úkolů z action items"""
    try:
        result = orchestrator.create_task_plan(
            action_items=request.action_items,
            context_query=request.context_query
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba při vytváření plánu: {str(e)}")

@app.get("/api/context/{query}")
async def get_relevant_context(query: str, limit: int = 5):
    """Získání relevantního kontextu"""
    try:
        context = orchestrator.context_manager.retrieve_relevant_context(query, limit)
        return {"context": context}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba při získávání kontextu: {str(e)}")

@app.get("/api/thread/{thread_id}")
async def get_thread_context(thread_id: str):
    """Získání kontextu emailového vlákna"""
    try:
        context = orchestrator.context_manager.get_thread_context(thread_id)
        return {"thread_context": context}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba při získávání kontextu vlákna: {str(e)}")

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "Enterprise Email Summarizer"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````python
import asyncio
import json
from llm_orchestrator import LLMOrchestrator
from models import ActionItem, Priority
import os

# Ukázkové emaily pro demonstraci
SAMPLE_EMAILS = [
    """
Subject: Projekt XYZ - Akční body z meetingu
From: manager@firma.cz
To: team@firma.cz

Dobrý den,

po dnešním meetingu ohledně projektu XYZ bych ráda shrnula hlavní akční body:

1. ÚKOL: Jan Novák dokončí analýzu požadavků do 15.12.2024
2. TODO: Marie Svobodová připraví návrh architektury do konce týdne
3. AKCE: Tým vývoje zahájí implementaci první fáze od pondělí
4. TERMÍN: Kompletní testování musí být dokončeno do 20.12.2024

Priorita projektu je VYSOKÁ vzhledem k termínu spuštění v novém roce.

Prosím o potvrzení přijetí úkolů.

S pozdravem,
Jana Manažerka
""",
    """
Subject: URGENTNÍ: Oprava produkčního serveru
From: admin@firma.cz
To: dev-team@firma.cz

Dobrý den,

na produkčním serveru došlo k závažné chybě. Potřebuji okamžitou akci:

TODO: Tomáš Dvořák - okamžitě analyzovat logy serveru
ÚKOL: Petra Nová - připravit rollback plán pro případ nutnosti
AKCE: Celý tým - být v pohotovosti pro možné nasazení opravy

Deadline: IHNED - server musí být funkční do 2 hodin!

Urgentní priorita!

Admin
""",
    """
Subject: Re: Projekt XYZ - Akční body z meetingu
From: jan.novak@firma.cz
To: manager@firma.cz

Dobrý den,

potvrzujem přijetí úkolu analýzy požadavků. Mám ale dotaz ohledně rozsahu:

1. Mám analyzovat jen nové požadavky nebo i revizi stávajících?
2. Potřebuji přístup k dokumentaci zákazníka - můžete mi ho zajistit?

Navíc bych rád navrhl rozšíření termínu o 2 dny kvůli složitosti úkolu.

Aktuálně pracuji také na projektu ABC, který má deadline 18.12.

S pozdravem,
Jan Novák
"""
]

async def demonstrate_email_processing():
    """Demonstrace zpracování emailů"""
    
    # Inicializace (vyžaduje OPENAI_API_KEY v environment)
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("Nastavte OPENAI_API_KEY environment variable")
        return
    
    orchestrator = LLMOrchestrator(api_key)
    
    print("=== ENTERPRISE EMAIL SUMMARIZER + ACTION PLANNER ===\n")
    
    thread_id = "thread_xyz_project"
    all_action_items = []
    
    # Zpracování emailů v pořadí
    for i, email_content in enumerate(SAMPLE_EMAILS, 1):
        print(f"📧 Zpracování emailu {i}:")
        print("-" * 50)
        
        # Zpracování emailu s kontextem
        email_summary = orchestrator.process_email_with_context(
            email_content=email_content,
            thread_id=thread_id
        )
        
        print(f"✅ Shrnutí: {email_summary.summary}")
        print(f"🎯 Klíčové body: {', '.join(email_summary.key_points)}")
        print(f"😊 Sentiment: {email_summary.sentiment}")
        print(f"👥 Účastníci: {', '.join(email_summary.participants)}")
        
        if email_summary.action_items:
            print(f"📋 Nalezeno {len(email_summary.action_items)} úkolů:")
            for action in email_summary.action_items:
                print(f"  - {action.title} (priorita: {action.priority})")
                if action.assignee:
                    print(f"    👤 Odpovědný: {action.assignee}")
                if action.due_date:
                    print(f"    📅 Termín: {action.due_date.strftime('%d.%m.%Y')}")
            
            all_action_items.extend(email_summary.action_items)
        
        print("\n")
    
    # Vytvoření plánu úkolů
    if all_action_items:
        print("📋 Vytváření plánu úkolů z všech action items...")
        print("-" * 50)
        
        task_plan = orchestrator.create_task_plan(
            action_items=all_action_items,
            context_query="projekt XYZ deadline testování"
        )
        
        print(f"📄 Název plánu: {task_plan.title}")
        print(f"📝 Popis: {task_plan.description}")
        print(f"📊 Počet úkolů: {len(task_plan.action_items)}")
        
        if task_plan.timeline:
            print("📅 Časová osa:")
            for period, tasks in task_plan.timeline.items():
                print(f"  {period}: {', '.join(tasks)}")
        
        if task_plan.dependencies:
            print("🔗 Závislosti:")
            for task, deps in task_plan.dependencies.items():
                print(f"  {task} závisí na: {', '.join(deps)}")
    
    # Demonstrace vyhledávání v kontextu
    print("\n🔍 Testování vyhledávání v kontextu:")
    print("-" * 50)
    
    search_queries = [
        "analýza požadavků",
        "termín deadline",
        "urgentní server"
    ]
    
    for query in search_queries:
        print(f"\n🔎 Hledám: '{query}'")
        context_results = orchestrator.context_manager.retrieve_relevant_context(query, 2)
        
        for i, result in enumerate(context_results, 1):
            print(f"  {i}. {result['type']}: {result['content'][:100]}...")

def create_sample_data():
    """Vytvoření ukázkových dat pro testování"""
    print("📦 Vytváření ukázkových dat...")
    
    # Ukázka action items
    sample_actions = [
        ActionItem(
            id="action_1",
            title="Dokončení analýzy požadavků",
            description="Kompletní analýza požadavků pro projekt XYZ",
            assignee="Jan Novák",
            priority=Priority.HIGH,
            source_email_id="email_1"
        ),
        ActionItem(
            id="action_2", 
            title="Oprava produkčního serveru",
            description="Urgentní oprava chyby na produkčním serveru",
            assignee="Tomáš Dvořák",
            priority=Priority.URGENT,
            source_email_id="email_2"
        )
    ]
    
    return sample_actions

if __name__ == "__main__":
    print("🚀 Spouštím demonstraci Enterprise Email Summarizer...")
    
    # Kontrola API klíče
    if not os.getenv("OPENAI_API_KEY"):
        print("❌ Chyba: Nastavte OPENAI_API_KEY environment variable")
        print("   export OPENAI_API_KEY='váš-api-klíč'")
        exit(1)
    
    # Spuštění demonstrace
    asyncio.run(demonstrate_email_processing())
    
    print("\n✅ Demonstrace dokončena!")
    print("\nPro spuštění API serveru použijte:")
    print("   python api.py")
    print("\nAPI bude dostupné na: http://localhost:8000")
    print("Dokumentace API: http://localhost:8000/docs")
````

````python
import os
import subprocess
import sys

def install_requirements():
    """Instalace závislostí"""
    print("📦 Instaluji závislosti...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])

def setup_environment():
    """Nastavení prostředí"""
    print("🔧 Nastavuji prostředí...")
    
    # Vytvoření adresářů
    os.makedirs("chroma_db", exist_ok=True)
    os.makedirs("logs", exist_ok=True)
    
    print("✅ Prostředí připraveno!")

def check_api_key():
    """Kontrola API klíče"""
    if not os.getenv("OPENAI_API_KEY"):
        print("⚠️  OPENAI_API_KEY není nastaven!")
        print("   Nastavte proměnnou prostředí:")
        print("   export OPENAI_API_KEY='váš-api-klíč'")
        return False
    return True

if __name__ == "__main__":
    print("🚀 Enterprise Email Summarizer - Setup")
    print("=" * 50)
    
    try:
        install_requirements()
        setup_environment()
        
        if check_api_key():
            print("\n✅ Setup dokončen úspěšně!")
            print("\nSpusťte demo:")
            print("   python example_usage.py")
            print("\nNebo API server:")
            print("   python api.py")
        else:
            print("\n❌ Setup dokončen s upozorněními")
            
    except Exception as e:
        print(f"\n❌ Chyba během setupu: {e}")
        sys.exit(1)
````

## Shrnutí projektu

Enterprise Email Summarizer + Action Planner představuje pokročilý AI systém, který revolucionizuje správu firemní emailové komunikace pomocí Model Context Protocol a moderních LLM technologií.

### Klíčové hodnoty projektu:

**🎯 Efektivita**: Automatizace sumarizace a plánování snižuje manuální práci o 60-80%

**🧠 Inteligence**: Využití GPT-4o s velkými context windows pro hluboké porozumění kontextu

**💾 Paměť**: MCP implementace zajišťuje kontinuitu napříč dlouhodobými projekty

**🔄 Škálovatelnost**: Architektura podporuje tisíce emailů denně s konzistentní výkonností

**🎨 Flexibilita**: Modulární design umožňuje snadné rozšíření o další funkcionality

### Technologické inovace:

- **Model Context Protocol** pro správu dlouhodobé paměti
- **Multi-agent orchestrace** s specializovanými LLM agenty
- **Vektorové embeddings** pro sémantické vyhledávání kontextu
- **Strukturovaná extrakce dat** s pokročilým prompt engineeringem
- **REST API** pro jednoduchou integraci do firemních systémů

Projekt demonstruje praktické využití nejmodernějších AI technologií pro řešení reálných business problémů v oblasti produktivity a komunikace.