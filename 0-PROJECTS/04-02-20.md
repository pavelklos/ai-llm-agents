<small>Claude Sonnet 4 **(AI Dungeon Master for Tabletop RPGs)**</small>
# AI Dungeon Master for Tabletop RPGs

## Key Concepts Explanation

### Procedural World-Building Engine
Dynamic system that generates coherent fantasy worlds, including geography, politics, cultures, and histories using rule-based algorithms and AI-generated content. Creates interconnected locations, NPCs, and factions with persistent relationships and evolving storylines that respond to player actions while maintaining internal consistency and narrative coherence.

### Rule-Following Game Engine
Intelligent system that understands and enforces tabletop RPG rules (D&D 5e, Pathfinder, etc.) including combat mechanics, skill checks, character progression, and spell effects. Automatically calculates dice rolls, applies modifiers, tracks resources, and ensures fair gameplay while adapting to house rules and campaign-specific modifications.

### Real-Time Story Generation
Advanced narrative AI that creates compelling storylines, dialogue, and plot developments on-the-fly based on player actions, character backgrounds, and world state. Maintains narrative consistency, dramatic pacing, and character development while responding dynamically to unexpected player choices and emergent gameplay scenarios.

### Agent-Based NPC System
Multi-agent framework where each NPC operates as an autonomous agent with distinct personalities, motivations, goals, and knowledge bases. NPCs can interact with each other, pursue independent objectives, form relationships, and react authentically to world events and player actions.

### Dynamic Campaign Management
Comprehensive system for tracking campaign state, including character sheets, inventory, world changes, NPC relationships, ongoing quests, and narrative threads. Maintains consistency across sessions while allowing for player-driven story evolution and unexpected narrative developments.

### Adaptive Difficulty Scaling
Intelligent system that monitors player engagement, challenge level, and party capabilities to dynamically adjust encounter difficulty, puzzle complexity, and story pacing to maintain optimal challenge without overwhelming or boring players.

## Comprehensive Project Explanation

### Objectives
The AI Dungeon Master aims to revolutionize tabletop RPG experiences by providing intelligent, adaptive game mastering that handles complex rule systems, creates immersive worlds, and generates compelling narratives while supporting both novice and experienced players in rich, collaborative storytelling experiences.

### Key Features
- **Intelligent World Generation**: Procedurally creates detailed fantasy worlds with interconnected locations, cultures, and histories
- **Rule-Aware Game Management**: Understands and enforces complex RPG rule systems with automatic calculations and consistency checking
- **Dynamic NPC Interactions**: Multi-agent NPCs with persistent personalities, motivations, and relationships
- **Adaptive Storytelling**: Real-time narrative generation that responds to player actions while maintaining dramatic pacing
- **Campaign Continuity**: Persistent world state tracking across multiple sessions with consequence management
- **Multi-System Support**: Compatible with various RPG systems (D&D 5e, Pathfinder, custom systems)

### Challenges
- **Rule Complexity**: Managing intricate RPG rule systems with numerous edge cases and interactions
- **Narrative Consistency**: Maintaining coherent storylines while allowing for player agency and unexpected developments
- **NPC Authenticity**: Creating believable, consistent NPC behaviors across multiple interactions and contexts
- **World Persistence**: Tracking complex world state changes and their cascading effects over time
- **Balance Management**: Ensuring fair, challenging gameplay without being too difficult or too easy
- **Player Agency**: Respecting player choices while maintaining narrative structure and pacing

### Potential Impact
This system can democratize game mastering, enable solo RPG experiences, assist new GMs with complex rule management, provide consistent availability for gaming groups, and create new forms of collaborative storytelling that blend human creativity with AI capabilities.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
langchain-community==0.0.10
streamlit==1.29.0
chromadb==0.4.18
sentence-transformers==2.2.2
pandas==2.1.4
numpy==1.24.3
pydantic==2.5.0
python-dotenv==1.0.0
sqlalchemy==2.0.23
redis==5.0.1
networkx==3.2.1
plotly==5.17.0
noise==1.2.2
pillow==10.1.0
matplotlib==3.8.2
seaborn==0.12.2
random
math
json
datetime
uuid
logging
typing
dataclasses
enum
asyncio
threading
time
````

### Core Implementation

````python
import os
import json
import random
import math
import uuid
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import asyncio
import threading
import time

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import seaborn as sns

# LangChain components
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.memory import ConversationBufferMemory
from langchain.callbacks.base import BaseCallbackHandler

# Vector database
import chromadb
from sentence_transformers import SentenceTransformer

# World generation
import noise
from PIL import Image, ImageDraw

# Graph for relationships
import networkx as nx

# Database
from sqlalchemy import create_engine, Column, String, Integer, Float, Text, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Caching
import redis

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DiceType(Enum):
    D4 = 4
    D6 = 6
    D8 = 8
    D10 = 10
    D12 = 12
    D20 = 20
    D100 = 100

class CreatureType(Enum):
    HUMANOID = "humanoid"
    BEAST = "beast"
    DRAGON = "dragon"
    UNDEAD = "undead"
    FIEND = "fiend"
    CELESTIAL = "celestial"
    ELEMENTAL = "elemental"
    FEY = "fey"

class LocationType(Enum):
    CITY = "city"
    VILLAGE = "village"
    DUNGEON = "dungeon"
    WILDERNESS = "wilderness"
    CASTLE = "castle"
    TEMPLE = "temple"
    TAVERN = "tavern"
    SHOP = "shop"

class QuestType(Enum):
    MAIN = "main"
    SIDE = "side"
    PERSONAL = "personal"
    RANDOM = "random"

@dataclass
class DiceRoll:
    dice_count: int
    dice_type: DiceType
    modifier: int = 0
    advantage: bool = False
    disadvantage: bool = False
    
    def roll(self) -> Tuple[int, List[int]]:
        """Perform dice roll and return total and individual rolls."""
        rolls = []
        
        if self.advantage or self.disadvantage:
            # Roll twice for advantage/disadvantage
            for _ in range(2):
                roll_set = [random.randint(1, self.dice_type.value) for _ in range(self.dice_count)]
                rolls.append(sum(roll_set))
            
            if self.advantage:
                total = max(rolls) + self.modifier
            else:  # disadvantage
                total = min(rolls) + self.modifier
            
            return total, rolls
        else:
            # Normal roll
            individual_rolls = [random.randint(1, self.dice_type.value) for _ in range(self.dice_count)]
            total = sum(individual_rolls) + self.modifier
            return total, individual_rolls

@dataclass
class Character:
    character_id: str
    name: str
    race: str
    character_class: str
    level: int
    hit_points: int
    max_hit_points: int
    armor_class: int
    stats: Dict[str, int]  # STR, DEX, CON, INT, WIS, CHA
    skills: Dict[str, int] = field(default_factory=dict)
    equipment: List[str] = field(default_factory=list)
    background: str = ""
    personality_traits: List[str] = field(default_factory=list)
    inventory: Dict[str, int] = field(default_factory=dict)
    experience_points: int = 0
    is_player: bool = True
    location_id: Optional[str] = None

@dataclass
class NPC:
    npc_id: str
    name: str
    race: str
    occupation: str
    personality: str
    motivations: List[str]
    relationships: Dict[str, str]  # character_id -> relationship_type
    location_id: str
    dialogue_history: List[str] = field(default_factory=list)
    quest_giver: bool = False
    vendor: bool = False
    inventory: Dict[str, int] = field(default_factory=dict)
    disposition: int = 0  # -10 to 10, negative is hostile
    knowledge: Dict[str, str] = field(default_factory=dict)

@dataclass
class Location:
    location_id: str
    name: str
    location_type: LocationType
    description: str
    connections: List[str]  # Connected location IDs
    npcs: List[str]  # NPC IDs present
    items: Dict[str, int] = field(default_factory=dict)
    secrets: List[str] = field(default_factory=list)
    encounter_chance: float = 0.1
    coordinates: Tuple[int, int] = (0, 0)
    climate: str = "temperate"
    terrain: str = "plains"

@dataclass
class Quest:
    quest_id: str
    title: str
    description: str
    quest_type: QuestType
    giver_id: Optional[str]
    target_location_id: Optional[str]
    objectives: List[str]
    rewards: List[str]
    prerequisites: List[str] = field(default_factory=list)
    completed: bool = False
    progress: Dict[str, bool] = field(default_factory=dict)
    expiry_date: Optional[datetime] = None

@dataclass
class WorldEvent:
    event_id: str
    title: str
    description: str
    location_id: Optional[str]
    affected_npcs: List[str]
    consequences: Dict[str, Any]
    trigger_conditions: List[str]
    triggered: bool = False
    timestamp: datetime = field(default_factory=datetime.now)

class DiceEngine:
    """Handles all dice rolling and probability calculations."""
    
    @staticmethod
    def roll_dice(dice_notation: str) -> Tuple[int, str]:
        """
        Parse dice notation (e.g., "2d6+3") and return result.
        Returns (total, description)
        """
        try:
            # Parse dice notation
            parts = dice_notation.lower().replace(" ", "")
            
            # Handle modifier
            modifier = 0
            if '+' in parts:
                dice_part, mod_part = parts.split('+')
                modifier = int(mod_part)
            elif '-' in parts:
                dice_part, mod_part = parts.split('-')
                modifier = -int(mod_part)
            else:
                dice_part = parts
            
            # Parse dice
            if 'd' in dice_part:
                count_str, sides_str = dice_part.split('d')
                dice_count = int(count_str) if count_str else 1
                dice_sides = int(sides_str)
            else:
                # Just a number
                return int(dice_part) + modifier, f"{dice_part} + {modifier}" if modifier else dice_part
            
            # Roll dice
            rolls = [random.randint(1, dice_sides) for _ in range(dice_count)]
            total = sum(rolls) + modifier
            
            # Create description
            rolls_str = ", ".join(map(str, rolls))
            if modifier != 0:
                mod_str = f" + {modifier}" if modifier > 0 else f" - {abs(modifier)}"
                description = f"({rolls_str}){mod_str} = {total}"
            else:
                description = f"({rolls_str}) = {total}"
            
            return total, description
            
        except Exception as e:
            logger.error(f"Error parsing dice notation '{dice_notation}': {e}")
            return 1, "1"
    
    @staticmethod
    def ability_check(stat_modifier: int, difficulty_class: int, 
                     advantage: bool = False, disadvantage: bool = False) -> Tuple[bool, int, str]:
        """
        Perform ability check against DC.
        Returns (success, total_roll, description)
        """
        if advantage and disadvantage:
            advantage = disadvantage = False
        
        if advantage:
            roll1 = random.randint(1, 20)
            roll2 = random.randint(1, 20)
            d20_roll = max(roll1, roll2)
            description = f"Advantage: max({roll1}, {roll2}) = {d20_roll}"
        elif disadvantage:
            roll1 = random.randint(1, 20)
            roll2 = random.randint(1, 20)
            d20_roll = min(roll1, roll2)
            description = f"Disadvantage: min({roll1}, {roll2}) = {d20_roll}"
        else:
            d20_roll = random.randint(1, 20)
            description = f"Roll: {d20_roll}"
        
        total = d20_roll + stat_modifier
        success = total >= difficulty_class
        
        description += f" + {stat_modifier} = {total} vs DC {difficulty_class}"
        description += " (Success)" if success else " (Failure)"
        
        return success, total, description

class WorldGenerator:
    """Generates fantasy worlds with locations, NPCs, and interconnections."""
    
    def __init__(self):
        self.world_size = 100  # 100x100 grid
        self.location_names = [
            "Goldbrook", "Ironhold", "Mysticfall", "Dragonrest", "Thornwall",
            "Silverdale", "Blackstone", "Rosewood", "Grimdale", "Brightwater"
        ]
        self.terrain_types = ["plains", "forest", "mountains", "desert", "swamp", "coast"]
        self.climate_types = ["temperate", "cold", "hot", "tropical", "arid"]
    
    def generate_world_map(self, seed: int = None) -> np.ndarray:
        """Generate a heightmap for the world using Perlin noise."""
        if seed:
            random.seed(seed)
            np.random.seed(seed)
        
        # Generate heightmap using noise
        world_map = np.zeros((self.world_size, self.world_size))
        
        for i in range(self.world_size):
            for j in range(self.world_size):
                # Multiple octaves of noise for realistic terrain
                value = 0
                value += 0.5 * noise.pnoise2(i/50.0, j/50.0, octaves=4)
                value += 0.25 * noise.pnoise2(i/25.0, j/25.0, octaves=8)
                value += 0.125 * noise.pnoise2(i/12.5, j/12.5, octaves=16)
                
                world_map[i][j] = value
        
        # Normalize to 0-1 range
        world_map = (world_map - world_map.min()) / (world_map.max() - world_map.min())
        
        return world_map
    
    def generate_locations(self, world_map: np.ndarray, num_locations: int = 20) -> List[Location]:
        """Generate locations based on world map."""
        locations = []
        
        # Find suitable locations (avoid water/extreme terrain)
        suitable_coords = []
        for i in range(self.world_size):
            for j in range(self.world_size):
                height = world_map[i][j]
                if 0.2 < height < 0.8:  # Not too low (water) or high (mountains)
                    suitable_coords.append((i, j))
        
        # Select random locations
        selected_coords = random.sample(suitable_coords, min(num_locations, len(suitable_coords)))
        
        for i, (x, y) in enumerate(selected_coords):
            location_id = str(uuid.uuid4())
            name = random.choice(self.location_names) + f" {i+1}"
            
            # Determine location type based on terrain
            height = world_map[x][y]
            if height > 0.6:
                location_type = random.choice([LocationType.CASTLE, LocationType.TEMPLE])
                terrain = "mountains"
            elif height < 0.3:
                location_type = LocationType.VILLAGE
                terrain = "swamp"
            else:
                location_type = random.choice([LocationType.CITY, LocationType.VILLAGE])
                terrain = random.choice(self.terrain_types)
            
            # Generate description
            description = self._generate_location_description(name, location_type, terrain)
            
            location = Location(
                location_id=location_id,
                name=name,
                location_type=location_type,
                description=description,
                connections=[],  # Will be populated later
                npcs=[],
                coordinates=(x, y),
                terrain=terrain,
                climate=random.choice(self.climate_types)
            )
            
            locations.append(location)
        
        # Generate connections between nearby locations
        self._generate_connections(locations)
        
        return locations
    
    def _generate_location_description(self, name: str, location_type: LocationType, terrain: str) -> str:
        """Generate description for a location."""
        descriptions = {
            LocationType.CITY: [
                f"{name} is a bustling city with towering walls and busy marketplaces.",
                f"The great city of {name} stands as a beacon of civilization in the {terrain}.",
                f"{name} sprawls across the {terrain}, its spires reaching toward the sky."
            ],
            LocationType.VILLAGE: [
                f"{name} is a quiet village nestled in the {terrain}.",
                f"The humble village of {name} sits peacefully among the {terrain}.",
                f"{name} is a small settlement where travelers often stop to rest."
            ],
            LocationType.CASTLE: [
                f"{name} is an imposing fortress built upon the {terrain}.",
                f"The ancient castle of {name} overlooks the surrounding {terrain}.",
                f"{name} stands as a mighty stronghold commanding the {terrain}."
            ]
        }
        
        return random.choice(descriptions.get(location_type, [f"{name} is located in the {terrain}."]))
    
    def _generate_connections(self, locations: List[Location]):
        """Generate connections between nearby locations."""
        for i, location1 in enumerate(locations):
            for j, location2 in enumerate(locations):
                if i != j:
                    # Calculate distance
                    x1, y1 = location1.coordinates
                    x2, y2 = location2.coordinates
                    distance = math.sqrt((x2-x1)**2 + (y2-y1)**2)
                    
                    # Connect if within reasonable distance
                    if distance < 25:  # Adjust threshold as needed
                        location1.connections.append(location2.location_id)

class NPCManager:
    """Manages NPCs with personalities, relationships, and behaviors."""
    
    def __init__(self):
        self.personality_traits = [
            "cheerful", "grumpy", "mysterious", "helpful", "suspicious",
            "wise", "foolish", "brave", "cowardly", "greedy", "generous"
        ]
        
        self.occupations = [
            "blacksmith", "merchant", "guard", "innkeeper", "priest",
            "farmer", "scholar", "thief", "noble", "beggar"
        ]
        
        self.motivations = [
            "wealth", "power", "knowledge", "revenge", "love",
            "duty", "survival", "redemption", "adventure", "peace"
        ]
        
        self.races = [
            "human", "elf", "dwarf", "halfling", "gnome",
            "half-elf", "half-orc", "tiefling", "dragonborn"
        ]
    
    def generate_npc(self, location_id: str, quest_giver: bool = False) -> NPC:
        """Generate a random NPC for a location."""
        npc_id = str(uuid.uuid4())
        
        npc = NPC(
            npc_id=npc_id,
            name=self._generate_name(),
            race=random.choice(self.races),
            occupation=random.choice(self.occupations),
            personality=random.choice(self.personality_traits),
            motivations=random.sample(self.motivations, random.randint(1, 3)),
            relationships={},
            location_id=location_id,
            quest_giver=quest_giver,
            vendor=random.choice([True, False]) if not quest_giver else False,
            disposition=random.randint(-2, 8)  # Mostly neutral to friendly
        )
        
        # Generate knowledge based on occupation
        npc.knowledge = self._generate_npc_knowledge(npc)
        
        return npc
    
    def _generate_name(self) -> str:
        """Generate a random fantasy name."""
        first_names = [
            "Aldric", "Bronwen", "Caelum", "Dara", "Ewan", "Fiona",
            "Gareth", "Hilda", "Ivan", "Jora", "Kael", "Luna"
        ]
        
        last_names = [
            "Ironforge", "Goldleaf", "Stormwind", "Brightblade", "Darkwood",
            "Silverstone", "Redwood", "Blackthorne", "Greenhill", "Whitehaven"
        ]
        
        return f"{random.choice(first_names)} {random.choice(last_names)}"
    
    def _generate_npc_knowledge(self, npc: NPC) -> Dict[str, str]:
        """Generate knowledge based on NPC's occupation and background."""
        knowledge = {}
        
        # Base knowledge everyone has
        knowledge["local_area"] = f"Knows about the local area around their location"
        knowledge["general_rumors"] = f"Has heard various rumors and gossip"
        
        # Occupation-specific knowledge
        if npc.occupation == "merchant":
            knowledge["trade_routes"] = "Knows about trade routes and prices"
            knowledge["distant_cities"] = "Has knowledge of distant cities and their goods"
        elif npc.occupation == "guard":
            knowledge["local_threats"] = "Aware of local dangers and security issues"
            knowledge["law_enforcement"] = "Knows local laws and enforcement"
        elif npc.occupation == "priest":
            knowledge["religious_lore"] = "Deep knowledge of religious matters"
            knowledge["healing"] = "Knows about healing and medicine"
        elif npc.occupation == "scholar":
            knowledge["history"] = "Extensive knowledge of historical events"
            knowledge["arcane_lore"] = "Understanding of magical phenomena"
        
        return knowledge

class QuestGenerator:
    """Generates and manages quests and storylines."""
    
    def __init__(self):
        self.quest_templates = {
            QuestType.MAIN: [
                "Defeat the ancient evil threatening the realm",
                "Recover the lost artifact of power",
                "Unite the warring factions",
                "Prevent the summoning of a dark entity"
            ],
            QuestType.SIDE: [
                "Retrieve stolen goods from bandits",
                "Escort a merchant to safety",
                "Investigate mysterious disappearances",
                "Clear monsters from a location"
            ],
            QuestType.PERSONAL: [
                "Find information about character's family",
                "Seek revenge against a wrongdoer",
                "Prove worthiness to a mentor",
                "Atone for past mistakes"
            ]
        }
        
        self.reward_types = [
            "gold pieces", "magical item", "information", "reputation",
            "skill training", "property deed", "noble title", "spell scroll"
        ]
    
    def generate_quest(self, quest_type: QuestType, giver_npc: NPC = None, 
                      target_location: Location = None) -> Quest:
        """Generate a quest based on type and context."""
        quest_id = str(uuid.uuid4())
        
        # Select quest template
        template = random.choice(self.quest_templates[quest_type])
        
        # Customize based on giver and location
        if giver_npc:
            # Incorporate NPC's motivations
            if "revenge" in giver_npc.motivations:
                template = template.replace("ancient evil", f"the one who wronged {giver_npc.name}")
            elif "wealth" in giver_npc.motivations:
                template = template.replace("stolen goods", "valuable treasure")
        
        quest = Quest(
            quest_id=quest_id,
            title=self._generate_quest_title(template),
            description=template,
            quest_type=quest_type,
            giver_id=giver_npc.npc_id if giver_npc else None,
            target_location_id=target_location.location_id if target_location else None,
            objectives=self._generate_objectives(template),
            rewards=self._generate_rewards(quest_type)
        )
        
        return quest
    
    def _generate_quest_title(self, description: str) -> str:
        """Generate a title based on quest description."""
        if "defeat" in description.lower():
            return "The Dark Threat"
        elif "retrieve" in description.lower():
            return "Recovery Mission"
        elif "escort" in description.lower():
            return "Safe Passage"
        elif "investigate" in description.lower():
            return "Mystery Investigation"
        else:
            return "Important Task"
    
    def _generate_objectives(self, description: str) -> List[str]:
        """Generate specific objectives for the quest."""
        objectives = []
        
        if "defeat" in description.lower():
            objectives = [
                "Gather information about the threat",
                "Find the enemy's weakness",
                "Confront and defeat the enemy"
            ]
        elif "retrieve" in description.lower():
            objectives = [
                "Locate the stolen items",
                "Defeat or negotiate with the thieves",
                "Return the items safely"
            ]
        elif "escort" in description.lower():
            objectives = [
                "Meet the person to be escorted",
                "Safely travel to the destination",
                "Deal with any threats encountered"
            ]
        else:
            objectives = ["Complete the requested task"]
        
        return objectives
    
    def _generate_rewards(self, quest_type: QuestType) -> List[str]:
        """Generate appropriate rewards for quest type."""
        num_rewards = 1 if quest_type == QuestType.SIDE else random.randint(2, 3)
        rewards = random.sample(self.reward_types, num_rewards)
        
        # Add specific amounts for quantifiable rewards
        for i, reward in enumerate(rewards):
            if reward == "gold pieces":
                amount = random.randint(50, 500) if quest_type == QuestType.SIDE else random.randint(500, 2000)
                rewards[i] = f"{amount} gold pieces"
        
        return rewards

class StoryEngine:
    """Generates and manages narrative content and story progression."""
    
    def __init__(self, openai_api_key: str):
        self.llm = ChatOpenAI(
            temperature=0.7,
            model_name="gpt-4",
            openai_api_key=openai_api_key
        )
        
        self.story_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are an expert Dungeon Master for tabletop RPGs. Your role is to create engaging, 
            immersive narratives that respond to player actions while maintaining consistency.
            
            GUIDELINES:
            1. Create vivid, descriptive scenes that engage the senses
            2. Maintain consistency with established world lore and character backstories
            3. Respond dynamically to player choices and actions
            4. Balance drama, humor, and tension appropriately
            5. Include opportunities for roleplay and character development
            6. Respect player agency while guiding the narrative
            
            TONE: Engaging, descriptive, and appropriate for fantasy adventure
            
            Always describe:
            - What the characters see, hear, smell, and feel
            - NPC reactions and dialogue
            - Consequences of player actions
            - Opportunities for further interaction
            """),
            ("human", """
            Current Situation:
            Location: {current_location}
            Present NPCs: {present_npcs}
            Active Quests: {active_quests}
            Recent Player Action: {player_action}
            World State: {world_state}
            
            Generate a narrative response that:
            1. Describes the scene and consequences of the player action
            2. Provides NPC reactions and dialogue if appropriate
            3. Presents new opportunities or challenges
            4. Maintains immersion and encourages further play
            
            Response (200-400 words):
            """)
        ])
    
    def generate_narrative(self, context: Dict[str, Any]) -> str:
        """Generate narrative response based on current context."""
        try:
            response = self.llm.invoke(self.story_prompt.format(**context))
            return response.content
        except Exception as e:
            logger.error(f"Error generating narrative: {e}")
            return "The world seems to pause momentarily as ancient forces gather their thoughts..."

class CampaignManager:
    """Main campaign management system."""
    
    def __init__(self, openai_api_key: str):
        self.campaign_id = str(uuid.uuid4())
        self.world_generator = WorldGenerator()
        self.npc_manager = NPCManager()
        self.quest_generator = QuestGenerator()
        self.story_engine = StoryEngine(openai_api_key)
        self.dice_engine = DiceEngine()
        
        # Campaign state
        self.world_map = None
        self.locations: Dict[str, Location] = {}
        self.npcs: Dict[str, NPC] = {}
        self.characters: Dict[str, Character] = {}
        self.quests: Dict[str, Quest] = {}
        self.world_events: List[WorldEvent] = []
        self.campaign_log: List[str] = []
        self.current_session = 1
        
        # Initialize world
        self._initialize_world()
    
    def _initialize_world(self):
        """Initialize the campaign world."""
        logger.info("Initializing campaign world...")
        
        # Generate world map
        self.world_map = self.world_generator.generate_world_map()
        
        # Generate locations
        locations_list = self.world_generator.generate_locations(self.world_map, 15)
        for location in locations_list:
            self.locations[location.location_id] = location
            
            # Generate NPCs for each location
            num_npcs = random.randint(2, 6)
            for i in range(num_npcs):
                npc = self.npc_manager.generate_npc(
                    location.location_id,
                    quest_giver=(i == 0 and random.random() < 0.3)
                )
                self.npcs[npc.npc_id] = npc
                location.npcs.append(npc.npc_id)
        
        # Generate initial quests
        quest_giver_npcs = [npc for npc in self.npcs.values() if npc.quest_giver]
        for npc in quest_giver_npcs:
            quest = self.quest_generator.generate_quest(
                random.choice([QuestType.MAIN, QuestType.SIDE]),
                npc,
                random.choice(list(self.locations.values()))
            )
            self.quests[quest.quest_id] = quest
        
        logger.info(f"World initialized with {len(self.locations)} locations, "
                   f"{len(self.npcs)} NPCs, and {len(self.quests)} quests")
    
    def add_player_character(self, character: Character) -> str:
        """Add a player character to the campaign."""
        self.characters[character.character_id] = character
        
        # Place in starting location if not specified
        if not character.location_id:
            starting_location = list(self.locations.values())[0]
            character.location_id = starting_location.location_id
        
        logger.info(f"Added player character: {character.name}")
        return character.character_id
    
    def process_player_action(self, character_id: str, action: str) -> Dict[str, Any]:
        """Process a player action and return results."""
        try:
            character = self.characters.get(character_id)
            if not character:
                return {"error": "Character not found"}
            
            current_location = self.locations.get(character.location_id)
            if not current_location:
                return {"error": "Invalid location"}
            
            # Get context for story generation
            context = self._build_narrative_context(character, current_location, action)
            
            # Generate narrative response
            narrative = self.story_engine.generate_narrative(context)
            
            # Process action effects
            action_results = self._process_action_effects(character, action, current_location)
            
            # Log action
            log_entry = f"Session {self.current_session}: {character.name} - {action}"
            self.campaign_log.append(log_entry)
            
            return {
                "narrative": narrative,
                "action_results": action_results,
                "character_state": character,
                "location_state": current_location
            }
            
        except Exception as e:
            logger.error(f"Error processing player action: {e}")
            return {"error": f"Failed to process action: {str(e)}"}
    
    def _build_narrative_context(self, character: Character, location: Location, action: str) -> Dict[str, Any]:
        """Build context for narrative generation."""
        # Get NPCs in location
        present_npcs = []
        for npc_id in location.npcs:
            npc = self.npcs.get(npc_id)
            if npc:
                present_npcs.append(f"{npc.name} ({npc.occupation})")
        
        # Get active quests
        active_quests = []
        for quest in self.quests.values():
            if not quest.completed:
                active_quests.append(quest.title)
        
        return {
            "current_location": f"{location.name}: {location.description}",
            "present_npcs": ", ".join(present_npcs) if present_npcs else "None",
            "active_quests": ", ".join(active_quests) if active_quests else "None",
            "player_action": action,
            "world_state": f"Session {self.current_session}, {len(self.campaign_log)} actions taken"
        }
    
    def _process_action_effects(self, character: Character, action: str, location: Location) -> Dict[str, Any]:
        """Process the mechanical effects of player actions."""
        results = {"dice_rolls": [], "state_changes": []}
        
        action_lower = action.lower()
        
        # Handle different action types
        if any(word in action_lower for word in ["attack", "fight", "combat"]):
            # Combat action
            attack_roll, description = self.dice_engine.roll_dice("1d20+5")
            results["dice_rolls"].append(f"Attack roll: {description}")
            
            if attack_roll >= 15:  # Hit
                damage_roll, damage_desc = self.dice_engine.roll_dice("1d8+3")
                results["dice_rolls"].append(f"Damage: {damage_desc}")
                results["state_changes"].append("Enemy takes damage")
            else:
                results["state_changes"].append("Attack misses")
        
        elif any(word in action_lower for word in ["search", "investigate", "look"]):
            # Investigation action
            investigation_roll, description = self.dice_engine.roll_dice("1d20+2")
            results["dice_rolls"].append(f"Investigation: {description}")
            
            if investigation_roll >= 15:
                results["state_changes"].append("Discovers hidden information")
            else:
                results["state_changes"].append("Finds nothing of interest")
        
        elif any(word in action_lower for word in ["talk", "speak", "conversation"]):
            # Social interaction
            persuasion_roll, description = self.dice_engine.roll_dice("1d20+3")
            results["dice_rolls"].append(f"Persuasion: {description}")
            
            # Update NPC relationships based on roll
            if persuasion_roll >= 15:
                results["state_changes"].append("NPC becomes more friendly")
            elif persuasion_roll <= 5:
                results["state_changes"].append("NPC becomes less friendly")
        
        return results
    
    def get_campaign_summary(self) -> Dict[str, Any]:
        """Get summary of current campaign state."""
        return {
            "campaign_id": self.campaign_id,
            "session": self.current_session,
            "total_locations": len(self.locations),
            "total_npcs": len(self.npcs),
            "total_characters": len(self.characters),
            "active_quests": len([q for q in self.quests.values() if not q.completed]),
            "completed_quests": len([q for q in self.quests.values() if q.completed]),
            "actions_taken": len(self.campaign_log)
        }
    
    def save_campaign_state(self) -> Dict[str, Any]:
        """Save campaign state for persistence."""
        return {
            "campaign_id": self.campaign_id,
            "locations": {k: v.__dict__ for k, v in self.locations.items()},
            "npcs": {k: v.__dict__ for k, v in self.npcs.items()},
            "characters": {k: v.__dict__ for k, v in self.characters.items()},
            "quests": {k: v.__dict__ for k, v in self.quests.items()},
            "campaign_log": self.campaign_log,
            "current_session": self.current_session
        }

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="AI Dungeon Master",
        page_icon="ðŸŽ²",
        layout="wide"
    )
    
    st.title("ðŸŽ² AI Dungeon Master - Tabletop RPG Assistant")
    st.markdown("Experience immersive tabletop RPG adventures powered by AI")
    
    # Sidebar
    with st.sidebar:
        st.header("âš™ï¸ Configuration")
        openai_api_key = st.text_input("OpenAI API Key", type="password")
        
        st.header("ðŸŽ® Campaign Settings")
        campaign_name = st.text_input("Campaign Name", value="The Lost Realms")
        difficulty = st.selectbox("Difficulty", ["Easy", "Normal", "Hard"])
        
        st.header("ðŸŽ­ Current Session")
        if 'campaign' in st.session_state:
            summary = st.session_state['campaign'].get_campaign_summary()
            st.write(f"**Session:** {summary['session']}")
            st.write(f"**Actions:** {summary['actions_taken']}")
            st.write(f"**Active Quests:** {summary['active_quests']}")
    
    if not openai_api_key:
        st.warning("Please enter your OpenAI API key to begin your adventure.")
        return
    
    # Initialize campaign
    if 'campaign' not in st.session_state:
        with st.spinner("Creating your fantasy world..."):
            st.session_state['campaign'] = CampaignManager(openai_api_key)
            st.success("World created! Your adventure awaits.")
    
    campaign = st.session_state['campaign']
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "ðŸ—¡ï¸ Adventure",
        "ðŸ‘¥ Characters & NPCs",
        "ðŸ—ºï¸ World Map",
        "ðŸ“œ Quests & Lore",
        "ðŸŽ² Dice & Tools"
    ])
    
    with tab1:
        st.header("ðŸ—¡ï¸ Adventure Interface")
        
        # Character selection
        if st.session_state['campaign'].characters:
            character_names = [f"{char.name} ({char.character_class})" 
                             for char in st.session_state['campaign'].characters.values()]
            selected_char = st.selectbox("Select Character", character_names)
            
            if selected_char:
                char_id = list(st.session_state['campaign'].characters.keys())[character_names.index(selected_char)]
                character = st.session_state['campaign'].characters[char_id]
                
                # Character status
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Level", character.level)
                with col2:
                    st.metric("HP", f"{character.hit_points}/{character.max_hit_points}")
                with col3:
                    st.metric("AC", character.armor_class)
                with col4:
                    current_location = st.session_state['campaign'].locations.get(character.location_id)
                    st.write(f"**Location:** {current_location.name if current_location else 'Unknown'}")
                
                # Action input
                st.subheader("ðŸŽ¬ Take Action")
                
                # Quick actions
                st.write("**Quick Actions:**")
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    if st.button("ðŸ” Look Around"):
                        action = "Look around and observe the surroundings carefully"
                        st.session_state['current_action'] = action
                
                with col2:
                    if st.button("ðŸ’¬ Talk to NPCs"):
                        action = "Approach and talk to the people nearby"
                        st.session_state['current_action'] = action
                
                with col3:
                    if st.button("ðŸšª Explore"):
                        action = "Explore the area and look for interesting locations"
                        st.session_state['current_action'] = action
                
                with col4:
                    if st.button("ðŸŽ’ Check Inventory"):
                        action = "Check inventory and equipment"
                        st.session_state['current_action'] = action
                
                # Custom action
                custom_action = st.text_input("Or describe your action:")
                
                if st.button("ðŸŽ² Take Action", type="primary"):
                    action = custom_action if custom_action else st.session_state.get('current_action', '')
                    
                    if action:
                        with st.spinner("Processing your action..."):
                            result = campaign.process_player_action(char_id, action)
                            
                            if 'error' not in result:
                                # Display narrative
                                st.subheader("ðŸ“– What Happens...")
                                st.write(result['narrative'])
                                
                                # Display action results
                                if result['action_results']['dice_rolls']:
                                    st.subheader("ðŸŽ² Dice Rolls")
                                    for roll in result['action_results']['dice_rolls']:
                                        st.write(f"â€¢ {roll}")
                                
                                if result['action_results']['state_changes']:
                                    st.subheader("âš¡ Effects")
                                    for change in result['action_results']['state_changes']:
                                        st.write(f"â€¢ {change}")
                                
                                # Store result for history
                                if 'action_history' not in st.session_state:
                                    st.session_state['action_history'] = []
                                
                                st.session_state['action_history'].append({
                                    'action': action,
                                    'result': result,
                                    'timestamp': datetime.now()
                                })
                            else:
                                st.error(result['error'])
                    else:
                        st.warning("Please select a quick action or describe a custom action.")
                
                # Action history
                if 'action_history' in st.session_state and st.session_state['action_history']:
                    st.subheader("ðŸ“œ Recent Actions")
                    
                    for i, entry in enumerate(reversed(st.session_state['action_history'][-5:])):
                        with st.expander(f"Action {len(st.session_state['action_history']) - i}: {entry['action'][:50]}..."):
                            st.write(f"**Time:** {entry['timestamp'].strftime('%H:%M:%S')}")
                            st.write(f"**Narrative:** {entry['result']['narrative'][:200]}...")
        else:
            # Create new character
            st.subheader("ðŸŽ­ Create Your Character")
            
            with st.form("character_creation"):
                char_name = st.text_input("Character Name")
                char_race = st.selectbox("Race", ["Human", "Elf", "Dwarf", "Halfling", "Gnome"])
                char_class = st.selectbox("Class", ["Fighter", "Rogue", "Wizard", "Cleric", "Ranger"])
                char_background = st.text_area("Background Story")
                
                if st.form_submit_button("Create Character"):
                    if char_name:
                        # Create character with random stats
                        character = Character(
                            character_id=str(uuid.uuid4()),
                            name=char_name,
                            race=char_race,
                            character_class=char_class,
                            level=1,
                            hit_points=random.randint(8, 12),
                            max_hit_points=random.randint(8, 12),
                            armor_class=random.randint(12, 16),
                            stats={
                                "STR": random.randint(8, 15),
                                "DEX": random.randint(8, 15),
                                "CON": random.randint(8, 15),
                                "INT": random.randint(8, 15),
                                "WIS": random.randint(8, 15),
                                "CHA": random.randint(8, 15)
                            },
                            background=char_background
                        )
                        
                        campaign.add_player_character(character)
                        st.success(f"Welcome, {char_name} the {char_race} {char_class}!")
                        st.rerun()
                    else:
                        st.error("Please enter a character name.")
    
    with tab2:
        st.header("ðŸ‘¥ Characters & NPCs")
        
        # Player characters
        if campaign.characters:
            st.subheader("ðŸ¦¸ Player Characters")
            
            for character in campaign.characters.values():
                with st.expander(f"ðŸŽ­ {character.name} - Level {character.level} {character.race} {character.character_class}"):
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.write(f"**HP:** {character.hit_points}/{character.max_hit_points}")
                        st.write(f"**AC:** {character.armor_class}")
                        st.write(f"**XP:** {character.experience_points}")
                        
                        # Current location
                        location = campaign.locations.get(character.location_id)
                        st.write(f"**Location:** {location.name if location else 'Unknown'}")
                    
                    with col2:
                        st.write("**Ability Scores:**")
                        for stat, value in character.stats.items():
                            modifier = (value - 10) // 2
                            modifier_str = f"+{modifier}" if modifier >= 0 else str(modifier)
                            st.write(f"â€¢ {stat}: {value} ({modifier_str})")
                    
                    if character.background:
                        st.write(f"**Background:** {character.background}")
        
        # NPCs
        st.subheader("ðŸ¤– Notable NPCs")
        
        # Group NPCs by location
        npcs_by_location = {}
        for npc in campaign.npcs.values():
            location_id = npc.location_id
            if location_id not in npcs_by_location:
                npcs_by_location[location_id] = []
            npcs_by_location[location_id].append(npc)
        
        for location_id, npcs in npcs_by_location.items():
            location = campaign.locations.get(location_id)
            location_name = location.name if location else "Unknown Location"
            
            with st.expander(f"ðŸ“ {location_name} ({len(npcs)} NPCs)"):
                for npc in npcs:
                    st.write(f"**{npc.name}** - {npc.race} {npc.occupation}")
                    st.write(f"â€¢ Personality: {npc.personality}")
                    st.write(f"â€¢ Motivations: {', '.join(npc.motivations)}")
                    
                    if npc.quest_giver:
                        st.write("ðŸŽ¯ **Quest Giver**")
                    if npc.vendor:
                        st.write("ðŸ›’ **Merchant**")
                    
                    # Disposition
                    if npc.disposition > 5:
                        disposition_text = "ðŸ˜Š Friendly"
                    elif npc.disposition > 0:
                        disposition_text = "ðŸ˜ Neutral"
                    else:
                        disposition_text = "ðŸ˜  Hostile"
                    
                    st.write(f"â€¢ Disposition: {disposition_text}")
                    st.write("---")
    
    with tab3:
        st.header("ðŸ—ºï¸ World Map & Locations")
        
        # World map visualization
        st.subheader("ðŸŒ World Overview")
        
        if campaign.world_map is not None:
            # Create a simple visualization of the world map
            fig, ax = plt.subplots(figsize=(10, 10))
            im = ax.imshow(campaign.world_map, cmap='terrain', origin='lower')
            
            # Plot locations
            for location in campaign.locations.values():
                x, y = location.coordinates
                color = 'red' if location.location_type == LocationType.CITY else 'blue'
                ax.plot(x, y, 'o', color=color, markersize=8)
                ax.annotate(location.name, (x, y), xytext=(5, 5), 
                           textcoords='offset points', fontsize=8)
            
            ax.set_title("Campaign World Map")
            ax.set_xlabel("X Coordinate")
            ax.set_ylabel("Y Coordinate")
            
            # Legend
            ax.plot([], [], 'ro', label='Cities')
            ax.plot([], [], 'bo', label='Other Locations')
            ax.legend()
            
            st.pyplot(fig)
        
        # Location details
        st.subheader("ðŸ° Location Details")
        
        location_names = [f"{loc.name} ({loc.location_type.value})" for loc in campaign.locations.values()]
        selected_location = st.selectbox("Select Location", location_names)
        
        if selected_location:
            location_id = list(campaign.locations.keys())[location_names.index(selected_location)]
            location = campaign.locations[location_id]
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.write(f"**Type:** {location.location_type.value.title()}")
                st.write(f"**Terrain:** {location.terrain}")
                st.write(f"**Climate:** {location.climate}")
                st.write(f"**Coordinates:** {location.coordinates}")
                
            with col2:
                st.write(f"**NPCs Present:** {len(location.npcs)}")
                st.write(f"**Connections:** {len(location.connections)}")
                encounter_text = f"{location.encounter_chance*100:.0f}%"
                st.write(f"**Encounter Chance:** {encounter_text}")
            
            st.write(f"**Description:** {location.description}")
            
            # Connected locations
            if location.connections:
                st.write("**Connected Locations:**")
                for conn_id in location.connections:
                    conn_location = campaign.locations.get(conn_id)
                    if conn_location:
                        st.write(f"â€¢ {conn_location.name}")
    
    with tab4:
        st.header("ðŸ“œ Quests & Lore")
        
        # Active quests
        active_quests = [q for q in campaign.quests.values() if not q.completed]
        completed_quests = [q for q in campaign.quests.values() if q.completed]
        
        st.subheader(f"âš¡ Active Quests ({len(active_quests)})")
        
        for quest in active_quests:
            with st.expander(f"ðŸ“‹ {quest.title} ({quest.quest_type.value.title()})"):
                st.write(f"**Description:** {quest.description}")
                
                # Quest giver
                if quest.giver_id:
                    giver = campaign.npcs.get(quest.giver_id)
                    if giver:
                        st.write(f"**Quest Giver:** {giver.name}")
                
                # Objectives
                st.write("**Objectives:**")
                for obj in quest.objectives:
                    completed = quest.progress.get(obj, False)
                    status = "âœ…" if completed else "â³"
                    st.write(f"â€¢ {status} {obj}")
                
                # Rewards
                st.write("**Rewards:**")
                for reward in quest.rewards:
                    st.write(f"â€¢ {reward}")
        
        # Completed quests
        if completed_quests:
            st.subheader(f"âœ… Completed Quests ({len(completed_quests)})")
            
            for quest in completed_quests:
                with st.expander(f"âœ… {quest.title}"):
                    st.write(f"**Description:** {quest.description}")
                    st.write("**Status:** Completed")
        
        # Campaign log
        st.subheader("ðŸ“– Campaign Journal")
        
        if campaign.campaign_log:
            for entry in reversed(campaign.campaign_log[-10:]):  # Last 10 entries
                st.write(f"â€¢ {entry}")
        else:
            st.write("*No entries yet. Start your adventure!*")
    
    with tab5:
        st.header("ðŸŽ² Dice & Tools")
        
        # Dice roller
        st.subheader("ðŸŽ² Dice Roller")
        
        col1, col2 = st.columns(2)
        
        with col1:
            dice_notation = st.text_input("Dice Notation", value="1d20", 
                                        help="Examples: 1d20, 2d6+3, 1d8-1")
            
            if st.button("ðŸŽ² Roll Dice"):
                total, description = campaign.dice_engine.roll_dice(dice_notation)
                st.success(f"**Result:** {description}")
        
        with col2:
            st.write("**Quick Rolls:**")
            
            quick_rolls = ["1d4", "1d6", "1d8", "1d10", "1d12", "1d20", "2d6", "1d100"]
            
            for dice in quick_rolls:
                if st.button(dice, key=f"quick_{dice}"):
                    total, description = campaign.dice_engine.roll_dice(dice)
                    st.write(f"{dice}: {description}")
        
        # Ability check calculator
        st.subheader("ðŸ“Š Ability Check")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            ability_modifier = st.number_input("Ability Modifier", min_value=-5, max_value=10, value=2)
        
        with col2:
            difficulty_class = st.number_input("Difficulty Class", min_value=5, max_value=30, value=15)
        
        with col3:
            advantage = st.checkbox("Advantage")
            disadvantage = st.checkbox("Disadvantage")
        
        if st.button("ðŸŽ¯ Make Check"):
            success, total, description = campaign.dice_engine.ability_check(
                ability_modifier, difficulty_class, advantage, disadvantage
            )
            
            result_text = "âœ… Success!" if success else "âŒ Failure"
            st.write(f"**{result_text}**")
            st.write(description)
        
        # Campaign statistics
        st.subheader("ðŸ“Š Campaign Statistics")
        
        summary = campaign.get_campaign_summary()
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Locations", summary['total_locations'])
            st.metric("NPCs", summary['total_npcs'])
        
        with col2:
            st.metric("Characters", summary['total_characters'])
            st.metric("Active Quests", summary['active_quests'])
        
        with col3:
            st.metric("Completed Quests", summary['completed_quests'])
            st.metric("Actions Taken", summary['actions_taken'])

if __name__ == "__main__":
    main()
````

### Environment Configuration

````python
OPENAI_API_KEY=your_openai_api_key_here
````

## Project Summary

The AI Dungeon Master for Tabletop RPGs represents a revolutionary approach to collaborative storytelling and game management that combines procedural world generation, intelligent NPC systems, and real-time narrative creation to provide immersive tabletop RPG experiences enhanced by artificial intelligence.

### Key Value Propositions:
- **Intelligent World Generation**: Procedural creation of coherent fantasy worlds with interconnected locations, cultures, and persistent relationships using noise-based terrain generation and rule-based content creation
- **Agent-Based NPC System**: Multi-agent framework where NPCs operate as autonomous entities with distinct personalities, motivations, and knowledge bases that persist across sessions
- **Real-Time Story Generation**: Dynamic narrative creation that responds to player actions while maintaining consistency, dramatic pacing, and character development opportunities
- **Rule-Aware Game Engine**: Intelligent system that understands and enforces complex RPG mechanics including dice rolling, skill checks, and combat resolution with automatic calculations
- **Adaptive Campaign Management**: Comprehensive tracking of world state, character progression, and narrative threads with consequence management across multiple sessions

### Technical Highlights:
- LangChain-powered narrative generation with context-aware prompting for consistent storytelling and character interactions
- Perlin noise-based world map generation creating realistic terrain with logical location placement and connection algorithms
- NetworkX graph structures managing complex relationships between NPCs, locations, and quest dependencies
- Advanced dice rolling engine supporting complex notation, advantage/disadvantage mechanics, and probability calculations
- Streamlit interface providing comprehensive campaign management tools including character sheets, world maps, and quest tracking
- Modular architecture enabling easy extension of rule systems, world generation algorithms, and narrative templates

This system demonstrates how AI can enhance rather than replace human creativity in collaborative storytelling, providing intelligent assistance for game masters while preserving the collaborative, improvisational nature that makes tabletop RPGs uniquely engaging experiences.