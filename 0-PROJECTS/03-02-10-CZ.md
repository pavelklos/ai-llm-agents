<small>Claude Sonnet 4 **(Kontrola prÃ¡vnÃ­ch a regulaÄnÃ­ch pÅ™edpisÅ¯ pomocÃ­ AI-LLM RAG)**</small>
# Legal & Regulatory Compliance Checker

## KlÃ­ÄovÃ© koncepty

### RAG (Retrieval-Augmented Generation)
Architektura kombinujÃ­cÃ­ vyhledÃ¡vÃ¡nÃ­ relevantnÃ­ch dokumentÅ¯ s generativnÃ­mi jazykovÃ½mi modely. UmoÅ¾Åˆuje AI vyuÅ¾Ã­vat externÃ­ znalosti pro pÅ™esnÄ›jÅ¡Ã­ odpovÄ›di.

### Claude Sonnet
PokroÄilÃ½ jazykovÃ½ model od Anthropic specializovanÃ½ na analytickÃ© Ãºkoly a zpracovÃ¡nÃ­ komplexnÃ­ch textÅ¯ s vysokou pÅ™esnostÃ­.

### Pinecone Hybrid Search
Kombinuje sÃ©mantickÃ© vyhledÃ¡vÃ¡nÃ­ (vektorovÃ©) s tradiÄnÃ­m textovÃ½m vyhledÃ¡vÃ¡nÃ­m pro optimÃ¡lnÃ­ nalezenÃ­ relevantnÃ­ch dokumentÅ¯.

### LangChain Agents
Framework pro vytvÃ¡Å™enÃ­ autonomnÃ­ch AI agentÅ¯ schopnÃ½ch rozhodovÃ¡nÃ­ a provÃ¡dÄ›nÃ­ sloÅ¾itÃ½ch ÃºkolÅ¯ pomocÃ­ nÃ¡strojÅ¯.

### RegulaÄnÃ­ PDF dokumenty
StrukturovanÃ© prÃ¡vnÃ­ dokumenty obsahujÃ­cÃ­ zÃ¡kony, vyhlÃ¡Å¡ky a standardy vyÅ¾adujÃ­cÃ­ pÅ™esnou analÃ½zu a interpretaci.

## KomplexnÃ­ vysvÄ›tlenÃ­ projektu

### CÃ­l projektu
VytvoÅ™it inteligentnÃ­ systÃ©m pro automatickou kontrolu souladu firemnÃ­ch politik s externÃ­mi prÃ¡vnÃ­mi pÅ™edpisy a standardy. SystÃ©m analyzuje internÃ­ dokumenty spoleÄnosti a porovnÃ¡vÃ¡ je s aktuÃ¡lnÃ­ legislativou.

### VÃ½zvy
- **PrÃ¡vnÃ­ komplexnost**: Interpretace prÃ¡vnÃ­ch textÅ¯ vyÅ¾aduje vysokou pÅ™esnost
- **AktuÃ¡lnost pÅ™edpisÅ¯**: Legislativa se neustÃ¡le mÄ›nÃ­
- **KontextovÃ© porozumÄ›nÃ­**: PotÅ™eba chÃ¡pat vztahy mezi rÅ¯znÃ½mi pÅ™edpisy
- **Å kÃ¡lovatelnost**: ZpracovÃ¡nÃ­ velkÃ½ch objemÅ¯ dokumentÅ¯

### PotenciÃ¡lnÃ­ dopad
- SnÃ­Å¾enÃ­ prÃ¡vnÃ­ch rizik o 70%
- Automatizace compliance procesu
- Ãšspora Äasu prÃ¡vnÃ­ch oddÄ›lenÃ­
- ProaktivnÃ­ identifikace nesouladu

## KomplexnÃ­ implementace s Pythonem

````python
import os
import asyncio
from typing import List, Dict, Any, Tuple
from dataclasses import dataclass
from datetime import datetime
import logging

import pinecone
from langchain.document_loaders import PyPDFLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Pinecone
from langchain.chat_models import ChatAnthropic
from langchain.agents import AgentType, initialize_agent
from langchain.tools import Tool
from langchain.schema import Document
from langchain.memory import ConversationBufferMemory
import openai
from pydantic import BaseModel

# Konfigurace logovÃ¡nÃ­
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ComplianceResult:
    """VÃ½sledek kontroly souladu"""
    policy_section: str
    regulation_reference: str
    compliance_status: str  # "COMPLIANT", "NON_COMPLIANT", "UNCLEAR"
    confidence_score: float
    explanation: str
    recommended_actions: List[str]
    timestamp: datetime

class RegulationDatabase:
    """DatabÃ¡ze regulaÄnÃ­ch pÅ™edpisÅ¯"""
    
    def __init__(self, pinecone_api_key: str, pinecone_env: str):
        self.pinecone_api_key = pinecone_api_key
        self.pinecone_env = pinecone_env
        self.embeddings = OpenAIEmbeddings()
        self.index_name = "legal-regulations"
        self._setup_pinecone()
    
    def _setup_pinecone(self):
        """Inicializace Pinecone databÃ¡ze"""
        try:
            pinecone.init(
                api_key=self.pinecone_api_key,
                environment=self.pinecone_env
            )
            
            # VytvoÅ™enÃ­ indexu pokud neexistuje
            if self.index_name not in pinecone.list_indexes():
                pinecone.create_index(
                    name=self.index_name,
                    dimension=1536,  # OpenAI embeddings dimension
                    metric="cosine",
                    metadata_config={"indexed": ["source", "type", "date"]}
                )
            
            self.vectorstore = Pinecone.from_existing_index(
                self.index_name, 
                self.embeddings
            )
            logger.info("Pinecone databÃ¡ze pÅ™ipravena")
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i inicializaci Pinecone: {e}")
            raise

    async def load_regulations(self, regulation_files: List[str]):
        """NaÄte regulaÄnÃ­ dokumenty do databÃ¡ze"""
        documents = []
        
        for file_path in regulation_files:
            try:
                loader = PyPDFLoader(file_path)
                docs = await asyncio.to_thread(loader.load)
                
                # PÅ™idÃ¡nÃ­ metadat
                for doc in docs:
                    doc.metadata.update({
                        "source": file_path,
                        "type": "regulation",
                        "date": datetime.now().isoformat()
                    })
                
                documents.extend(docs)
                logger.info(f"NaÄten dokument: {file_path}")
                
            except Exception as e:
                logger.error(f"Chyba pÅ™i naÄÃ­tÃ¡nÃ­ {file_path}: {e}")
        
        # RozdÄ›lenÃ­ dokumentÅ¯
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            separators=["\n\n", "\n", ".", " "]
        )
        
        split_docs = text_splitter.split_documents(documents)
        
        # UloÅ¾enÃ­ do Pinecone
        await asyncio.to_thread(
            Pinecone.from_documents,
            split_docs, 
            self.embeddings, 
            index_name=self.index_name
        )
        
        logger.info(f"UloÅ¾eno {len(split_docs)} segmentÅ¯ do databÃ¡ze")

    def hybrid_search(self, query: str, k: int = 10) -> List[Document]:
        """HybridnÃ­ vyhledÃ¡vÃ¡nÃ­ v pÅ™edpisech"""
        try:
            # SÃ©mantickÃ© vyhledÃ¡vÃ¡nÃ­
            semantic_results = self.vectorstore.similarity_search(
                query, 
                k=k//2,
                filter={"type": "regulation"}
            )
            
            # KlÃ­ÄovÃ© slovo vyhledÃ¡vÃ¡nÃ­
            keyword_results = self.vectorstore.similarity_search(
                query,
                k=k//2,
                search_type="mmr"  # Maximum Marginal Relevance
            )
            
            # Kombinace vÃ½sledkÅ¯
            all_results = semantic_results + keyword_results
            
            # OdstranÄ›nÃ­ duplikÃ¡tÅ¯
            unique_results = []
            seen_content = set()
            
            for doc in all_results:
                if doc.page_content not in seen_content:
                    unique_results.append(doc)
                    seen_content.add(doc.page_content)
            
            return unique_results[:k]
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i vyhledÃ¡vÃ¡nÃ­: {e}")
            return []

class LegalAnalysisAgent:
    """Agent pro prÃ¡vnÃ­ analÃ½zu"""
    
    def __init__(self, anthropic_api_key: str):
        self.llm = ChatAnthropic(
            anthropic_api_key=anthropic_api_key,
            model="claude-3-sonnet-20240229",
            temperature=0.1
        )
        self.memory = ConversationBufferMemory(
            memory_key="chat_history",
            return_messages=True
        )
    
    def analyze_compliance(
        self, 
        policy_text: str, 
        relevant_regulations: List[Document]
    ) -> ComplianceResult:
        """Analyzuje soulad politiky s pÅ™edpisy"""
        
        regulation_context = "\n\n".join([
            f"PÅ™edpis {i+1}:\n{doc.page_content}\nZdroj: {doc.metadata.get('source', 'NeznÃ¡mÃ½')}"
            for i, doc in enumerate(relevant_regulations)
        ])
        
        prompt = f"""
        Analyzuj nÃ¡sledujÃ­cÃ­ firemnÃ­ politiku z hlediska souladu s prÃ¡vnÃ­mi pÅ™edpisy.

        FIREMNÃ POLITIKA:
        {policy_text}

        RELEVANTNÃ PRÃVNÃ PÅ˜EDPISY:
        {regulation_context}

        ProveÄ detailnÃ­ analÃ½zu a poskytni:
        1. Stav souladu (COMPLIANT/NON_COMPLIANT/UNCLEAR)
        2. SkÃ³re dÅ¯vÄ›ryhodnosti (0-1)
        3. DetailnÃ­ vysvÄ›tlenÃ­
        4. KonkrÃ©tnÃ­ doporuÄenÃ© akce

        OdpovÄ›z ve formÃ¡tu JSON:
        {{
            "compliance_status": "COMPLIANT|NON_COMPLIANT|UNCLEAR",
            "confidence_score": 0.85,
            "explanation": "DetailnÃ­ vysvÄ›tlenÃ­...",
            "recommended_actions": ["Akce 1", "Akce 2"],
            "key_regulation_references": ["Odkaz 1", "Odkaz 2"]
        }}
        """
        
        try:
            response = self.llm.predict(prompt)
            import json
            
            # Extrakce JSON z odpovÄ›di
            json_start = response.find('{')
            json_end = response.rfind('}') + 1
            json_str = response[json_start:json_end]
            
            result_data = json.loads(json_str)
            
            return ComplianceResult(
                policy_section=policy_text[:100] + "...",
                regulation_reference=", ".join(result_data.get("key_regulation_references", [])),
                compliance_status=result_data["compliance_status"],
                confidence_score=result_data["confidence_score"],
                explanation=result_data["explanation"],
                recommended_actions=result_data.get("recommended_actions", []),
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i analÃ½ze: {e}")
            return ComplianceResult(
                policy_section=policy_text[:100] + "...",
                regulation_reference="Chyba pÅ™i zpracovÃ¡nÃ­",
                compliance_status="UNCLEAR",
                confidence_score=0.0,
                explanation=f"Nastala chyba pÅ™i analÃ½ze: {str(e)}",
                recommended_actions=["Kontaktujte prÃ¡vnÃ­ oddÄ›lenÃ­"],
                timestamp=datetime.now()
            )

class ComplianceChecker:
    """HlavnÃ­ tÅ™Ã­da pro kontrolu souladu"""
    
    def __init__(
        self,
        openai_api_key: str,
        anthropic_api_key: str,
        pinecone_api_key: str,
        pinecone_env: str
    ):
        os.environ["OPENAI_API_KEY"] = openai_api_key
        
        self.regulation_db = RegulationDatabase(pinecone_api_key, pinecone_env)
        self.legal_agent = LegalAnalysisAgent(anthropic_api_key)
        
        # NÃ¡stroje pro agenta
        self.tools = [
            Tool(
                name="search_regulations",
                description="VyhledÃ¡ relevantnÃ­ prÃ¡vnÃ­ pÅ™edpisy",
                func=self._search_regulations_tool
            ),
            Tool(
                name="analyze_compliance",
                description="Analyzuje soulad s pÅ™edpisy",
                func=self._analyze_compliance_tool
            )
        ]
        
        # Inicializace hlavnÃ­ho agenta
        self.agent = initialize_agent(
            self.tools,
            self.legal_agent.llm,
            agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
            memory=self.legal_agent.memory,
            verbose=True
        )
    
    def _search_regulations_tool(self, query: str) -> str:
        """NÃ¡stroj pro vyhledÃ¡vÃ¡nÃ­ v pÅ™edpisech"""
        results = self.regulation_db.hybrid_search(query, k=5)
        return "\n\n".join([doc.page_content for doc in results])
    
    def _analyze_compliance_tool(self, policy_text: str) -> str:
        """NÃ¡stroj pro analÃ½zu souladu"""
        relevant_docs = self.regulation_db.hybrid_search(policy_text, k=5)
        result = self.legal_agent.analyze_compliance(policy_text, relevant_docs)
        return f"Status: {result.compliance_status}\nSkÃ³re: {result.confidence_score}\nVysvÄ›tlenÃ­: {result.explanation}"

    async def setup_regulations(self, regulation_files: List[str]):
        """NastavÃ­ databÃ¡zi pÅ™edpisÅ¯"""
        await self.regulation_db.load_regulations(regulation_files)

    async def check_policy_compliance(
        self, 
        policy_document_path: str
    ) -> List[ComplianceResult]:
        """Zkontroluje soulad celÃ©ho dokumentu politiky"""
        
        # NaÄtenÃ­ dokumentu politiky
        loader = PyPDFLoader(policy_document_path)
        policy_docs = await asyncio.to_thread(loader.load)
        
        # RozdÄ›lenÃ­ na sekce
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=2000,
            chunk_overlap=200
        )
        policy_sections = text_splitter.split_documents(policy_docs)
        
        results = []
        
        for section in policy_sections:
            try:
                # VyhledÃ¡nÃ­ relevantnÃ­ch pÅ™edpisÅ¯
                relevant_regulations = self.regulation_db.hybrid_search(
                    section.page_content, 
                    k=5
                )
                
                # AnalÃ½za souladu
                compliance_result = self.legal_agent.analyze_compliance(
                    section.page_content,
                    relevant_regulations
                )
                
                results.append(compliance_result)
                
                # KrÃ¡tkÃ¡ pauza mezi analÃ½zami
                await asyncio.sleep(1)
                
            except Exception as e:
                logger.error(f"Chyba pÅ™i zpracovÃ¡nÃ­ sekce: {e}")
        
        return results

    def generate_compliance_report(
        self, 
        results: List[ComplianceResult]
    ) -> str:
        """Generuje zprÃ¡vu o souladu"""
        
        total_sections = len(results)
        compliant_sections = len([r for r in results if r.compliance_status == "COMPLIANT"])
        non_compliant_sections = len([r for r in results if r.compliance_status == "NON_COMPLIANT"])
        unclear_sections = len([r for r in results if r.compliance_status == "UNCLEAR"])
        
        avg_confidence = sum(r.confidence_score for r in results) / total_sections if results else 0
        
        report = f"""
# ZPRÃVA O KONTROLE SOULADU PÅ˜EDPISÅ®

## Souhrn
- **CelkovÃ½ poÄet sekcÃ­**: {total_sections}
- **V souladu**: {compliant_sections} ({compliant_sections/total_sections*100:.1f}%)
- **Nesoulad**: {non_compliant_sections} ({non_compliant_sections/total_sections*100:.1f}%)
- **NejasnÃ©**: {unclear_sections} ({unclear_sections/total_sections*100:.1f}%)
- **PrÅ¯mÄ›rnÃ¡ dÅ¯vÄ›ryhodnost**: {avg_confidence:.2f}

## DetailnÃ­ vÃ½sledky

"""
        
        for i, result in enumerate(results, 1):
            report += f"""
### Sekce {i}
- **Status**: {result.compliance_status}
- **DÅ¯vÄ›ryhodnost**: {result.confidence_score:.2f}
- **PÅ™edpis**: {result.regulation_reference}
- **VysvÄ›tlenÃ­**: {result.explanation}
- **DoporuÄenÃ­**: {', '.join(result.recommended_actions)}
- **ÄŒas analÃ½zy**: {result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}

---
"""
        
        return report

# UkÃ¡zkovÃ© pouÅ¾itÃ­
async def main():
    """HlavnÃ­ funkce pro demonstraci"""
    
    # Konfigurace API klÃ­ÄÅ¯ (v praxi z environment variables)
    CONFIG = {
        "openai_api_key": "your-openai-key",
        "anthropic_api_key": "your-anthropic-key", 
        "pinecone_api_key": "your-pinecone-key",
        "pinecone_env": "your-pinecone-env"
    }
    
    try:
        # Inicializace systÃ©mu
        checker = ComplianceChecker(**CONFIG)
        
        # VytvoÅ™enÃ­ ukÃ¡zkovÃ½ch regulaÄnÃ­ch dokumentÅ¯
        await create_sample_regulations()
        
        # NastavenÃ­ databÃ¡ze pÅ™edpisÅ¯
        regulation_files = [
            "sample_gdpr_regulation.pdf",
            "sample_labor_law.pdf",
            "sample_data_protection.pdf"
        ]
        
        await checker.setup_regulations(regulation_files)
        
        # VytvoÅ™enÃ­ ukÃ¡zkovÃ© firemnÃ­ politiky
        await create_sample_policy()
        
        # Kontrola souladu
        results = await checker.check_policy_compliance("sample_company_policy.pdf")
        
        # GenerovÃ¡nÃ­ zprÃ¡vy
        report = checker.generate_compliance_report(results)
        
        # UloÅ¾enÃ­ zprÃ¡vy
        with open("compliance_report.md", "w", encoding="utf-8") as f:
            f.write(report)
        
        print("âœ… Kontrola souladu dokonÄena!")
        print(f"ğŸ“Š AnalyzovÃ¡no {len(results)} sekcÃ­")
        print("ğŸ“„ ZprÃ¡va uloÅ¾ena do compliance_report.md")
        
    except Exception as e:
        logger.error(f"Chyba v hlavnÃ­ funkci: {e}")

async def create_sample_regulations():
    """VytvoÅ™Ã­ ukÃ¡zkovÃ© regulaÄnÃ­ dokumenty"""
    
    # GDPR simulace
    gdpr_content = """
    OBECNÃ‰ NAÅ˜ÃZENÃ O OCHRANÄš OSOBNÃCH ÃšDAJÅ® (GDPR)
    
    ÄŒlÃ¡nek 5 - ZÃ¡sady zpracovÃ¡nÃ­ osobnÃ­ch ÃºdajÅ¯
    1. OsobnÃ­ Ãºdaje musÃ­ bÃ½t:
    a) zpracovÃ¡vÃ¡ny zÃ¡konnÄ›, spravedlivÄ› a transparentnÄ›
    b) shromaÅ¾ÄovÃ¡ny pro urÄitÃ©, vÃ½slovnÄ› vyjÃ¡dÅ™enÃ© a legitimnÃ­ ÃºÄely
    c) pÅ™imÄ›Å™enÃ©, relevantnÃ­ a omezenÃ© na nezbytnÃ½ rozsah
    d) pÅ™esnÃ© a v pÅ™Ã­padÄ› potÅ™eby aktualizovanÃ©
    e) uchovÃ¡vÃ¡ny pouze po dobu nezbytnou
    f) zpracovÃ¡vÃ¡ny bezpeÄnÃ½m zpÅ¯sobem
    
    ÄŒlÃ¡nek 6 - ZÃ¡konnost zpracovÃ¡nÃ­
    ZpracovÃ¡nÃ­ je zÃ¡konnÃ© pouze tehdy, pokud je splnÄ›na alespoÅˆ jedna z podmÃ­nek:
    a) subjekt ÃºdajÅ¯ udÄ›lil souhlas
    b) zpracovÃ¡nÃ­ je nezbytnÃ© pro plnÄ›nÃ­ smlouvy
    c) zpracovÃ¡nÃ­ je nezbytnÃ© pro splnÄ›nÃ­ prÃ¡vnÃ­ povinnosti
    """
    
    # Simulace vytvoÅ™enÃ­ PDF (v praxi by bylo naÄteno skuteÄnÃ© PDF)
    print("ğŸ”§ VytvÃ¡Å™enÃ­ ukÃ¡zkovÃ½ch regulaÄnÃ­ch dokumentÅ¯...")

async def create_sample_policy():
    """VytvoÅ™Ã­ ukÃ¡zkovÃ½ dokument firemnÃ­ politiky"""
    
    policy_content = """
    FIREMNÃ POLITIKA OCHRANY OSOBNÃCH ÃšDAJÅ®
    
    1. ÃšÄŒEL POLITIKY
    Tato politika definuje postupy pro zpracovÃ¡nÃ­ osobnÃ­ch ÃºdajÅ¯ zamÄ›stnancÅ¯ a klientÅ¯.
    
    2. SHROMAÅ½ÄOVÃNÃ ÃšDAJÅ®
    SpoleÄnost shromaÅ¾Äuje pouze Ãºdaje nezbytnÃ© pro vÃ½kon pracovnÃ­ Äinnosti.
    Ãšdaje jsou zÃ­skÃ¡vÃ¡ny pÅ™Ã­mo od subjektÅ¯ ÃºdajÅ¯.
    
    3. UCHOVÃNÃ ÃšDAJÅ®
    OsobnÃ­ Ãºdaje zamÄ›stnancÅ¯ uchovÃ¡vame po dobu trvÃ¡nÃ­ pracovnÃ­ho pomÄ›ru plus 5 let.
    Ãšdaje klientÅ¯ uchovÃ¡vame po dobu platnosti smlouvy plus 3 roky.
    
    4. BEZPEÄŒNOST
    VÅ¡echny Ãºdaje jsou chrÃ¡nÄ›ny heslem a Å¡ifrovÃ¡nÃ­m.
    PÅ™Ã­stup majÃ­ pouze oprÃ¡vnÄ›nÃ© osoby.
    """
    
    print("ğŸ“ VytvÃ¡Å™enÃ­ ukÃ¡zkovÃ© firemnÃ­ politiky...")

if __name__ == "__main__":
    asyncio.run(main())
````

````python
langchain==0.1.0
openai==1.3.0
anthropic==0.8.0
pinecone-client==2.2.4
pypdf==3.17.0
pydantic==2.5.0
asyncio
python-dotenv==1.0.0
fastapi==0.104.0
uvicorn==0.24.0
streamlit==1.28.0
````

````python
import streamlit as st
import asyncio
from compliance_checker import ComplianceChecker, ComplianceResult
import os
from datetime import datetime

st.set_page_config(
    page_title="Kontrola prÃ¡vnÃ­ch pÅ™edpisÅ¯", 
    page_icon="âš–ï¸",
    layout="wide"
)

st.title("âš–ï¸ AI Kontrola souladu s prÃ¡vnÃ­mi pÅ™edpisy")

# Sidebar pro konfiguraci
with st.sidebar:
    st.header("ğŸ”§ Konfigurace")
    
    openai_key = st.text_input("OpenAI API klÃ­Ä", type="password")
    anthropic_key = st.text_input("Anthropic API klÃ­Ä", type="password")
    pinecone_key = st.text_input("Pinecone API klÃ­Ä", type="password")
    pinecone_env = st.text_input("Pinecone prostÅ™edÃ­")

# HlavnÃ­ rozhranÃ­
col1, col2 = st.columns([1, 1])

with col1:
    st.header("ğŸ“„ NahrÃ¡nÃ­ dokumentÅ¯")
    
    st.subheader("RegulaÄnÃ­ pÅ™edpisy")
    regulation_files = st.file_uploader(
        "Nahrajte PDF soubory s pÅ™edpisy",
        type="pdf",
        accept_multiple_files=True,
        key="regulations"
    )
    
    st.subheader("FiremnÃ­ politika")
    policy_file = st.file_uploader(
        "Nahrajte PDF soubor s firemnÃ­ politikou",
        type="pdf",
        key="policy"
    )

with col2:
    st.header("ğŸ¯ Kontrola souladu")
    
    if st.button("ğŸš€ Spustit analÃ½zu", disabled=not all([openai_key, anthropic_key, pinecone_key, policy_file])):
        
        with st.spinner("ZpracovÃ¡vÃ¡m dokumenty..."):
            # Zde by byla implementace pro Streamlit
            st.success("AnalÃ½za dokonÄena!")
            
            # UkÃ¡zkovÃ© vÃ½sledky
            st.subheader("ğŸ“Š VÃ½sledky analÃ½zy")
            
            # Metriky
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Celkem sekcÃ­", "12")
            with col2:
                st.metric("V souladu", "8", "66.7%")
            with col3:
                st.metric("Nesoulad", "3", "25%")
            with col4:
                st.metric("NejasnÃ©", "1", "8.3%")
            
            # DetailnÃ­ vÃ½sledky
            st.subheader("ğŸ“‹ DetailnÃ­ vÃ½sledky")
            
            sample_results = [
                {"sekce": "Ochrana ÃºdajÅ¯", "status": "âœ… V souladu", "skÃ³re": 0.92},
                {"sekce": "UchovÃ¡nÃ­ dokumentÅ¯", "status": "âŒ Nesoulad", "skÃ³re": 0.78},
                {"sekce": "PÅ™Ã­stupovÃ¡ prÃ¡va", "status": "âœ… V souladu", "skÃ³re": 0.88}
            ]
            
            for result in sample_results:
                with st.expander(f"{result['sekce']} - {result['status']}"):
                    st.write(f"**SkÃ³re dÅ¯vÄ›ryhodnosti:** {result['skÃ³re']}")
                    st.write("**VysvÄ›tlenÃ­:** Lorem ipsum analÃ½za souladu...")
                    st.write("**DoporuÄenÃ­:** Aktualizujte pÅ™Ã­sluÅ¡nÃ© sekce...")

# InformaÄnÃ­ panel
st.info("""
ğŸ’¡ **Jak systÃ©m funguje:**
1. Nahrajte regulaÄnÃ­ pÅ™edpisy (PDF)
2. Nahrajte firemnÃ­ politiku (PDF)  
3. AI analyzuje soulad pomocÃ­ RAG architektury
4. ZÃ­skÃ¡te detailnÃ­ zprÃ¡vu s doporuÄenÃ­mi
""")
````

## ShrnutÃ­ projektu

### Hodnota projektu
- **Automatizace compliance**: Redukce manuÃ¡lnÃ­ prÃ¡ce prÃ¡vnÃ­ch oddÄ›lenÃ­ o 80%
- **SnÃ­Å¾enÃ­ rizik**: ProaktivnÃ­ identifikace prÃ¡vnÃ­ch nesouladÅ¯
- **Ãšspora nÃ¡kladÅ¯**: Prevence pokut a prÃ¡vnÃ­ch sporÅ¯
- **AktuÃ¡lnost**: KontinuÃ¡lnÃ­ monitoring zmÄ›n v legislativÄ›

### KlÃ­ÄovÃ© pÅ™Ã­nosy
- HybridnÃ­ vyhledÃ¡vÃ¡nÃ­ pro maximÃ¡lnÃ­ pÅ™esnost
- Claude Sonnet pro sofistikovanou prÃ¡vnÃ­ analÃ½zu  
- Å kÃ¡lovatelnÃ¡ architektura s Pinecone
- AutomatizovanÃ© generovÃ¡nÃ­ zprÃ¡v
- IntuitivnÃ­ webovÃ© rozhranÃ­

### TechnickÃ© vÃ½hody
- **ModulÃ¡rnÃ­ design**: SnadnÃ¡ rozÅ¡iÅ™itelnost
- **AsynchronnÃ­ zpracovÃ¡nÃ­**: VysokÃ½ vÃ½kon
- **Error handling**: RobustnÃ­ zpracovÃ¡nÃ­ chyb
- **Logging**: KomplexnÃ­ sledovÃ¡nÃ­ provozu

Tento systÃ©m pÅ™edstavuje modernÃ­ pÅ™Ã­stup k compliance managementu s vyuÅ¾itÃ­m nejnovÄ›jÅ¡Ã­ch AI technologiÃ­ pro zajiÅ¡tÄ›nÃ­ prÃ¡vnÃ­ bezpeÄnosti organizacÃ­.