<small>Claude Sonnet 4 **(AI-LLM FinanÄnÃ­ ObchodnÃ­ Asistent)**</small>
# Financial Trading Assistant

## KlÃ­ÄovÃ© Koncepty

### Model Context Protocol (MCP)
**MCP** je standardizovanÃ½ protokol pro komunikaci mezi AI modely a externÃ­mi systÃ©my. UmoÅ¾Åˆuje AI agentÅ¯m bezpeÄnÄ› pÅ™istupovat k rÅ¯znÃ½m datovÃ½m zdrojÅ¯m a nÃ¡strojÅ¯m v kontrolovanÃ©m prostÅ™edÃ­.

### Market Data APIs
**Market Data APIs** poskytujÃ­ real-time a historickÃ¡ data o finanÄnÃ­ch trzÃ­ch vÄetnÄ› cen akciÃ­, mÄ›novÃ½ch kurzÅ¯, komodit a derivÃ¡tÅ¯. KlÃ­ÄovÃ© zdroje zahrnujÃ­ Bloomberg API, Alpha Vantage, Yahoo Finance.

### Portfolio Management
**SprÃ¡va portfolia** zahrnuje optimalizaci alokace aktiv, sledovÃ¡nÃ­ vÃ½konnosti, rebalancovÃ¡nÃ­ a Å™Ã­zenÃ­ rizik s cÃ­lem maximalizovat vÃ½nosy pÅ™i minimalizaci rizika.

### Risk Analysis
**AnalÃ½za rizik** pouÅ¾Ã­vÃ¡ kvantitativnÃ­ metody jako Value at Risk (VaR), Monte Carlo simulace a stress testing k hodnocenÃ­ potenciÃ¡lnÃ­ch ztrÃ¡t portfolia.

### Trading Strategies
**ObchodnÃ­ strategie** jsou algoritmickÃ© pÅ™Ã­stupy k rozhodovÃ¡nÃ­ o nÃ¡kupu/prodeji zaloÅ¾enÃ© na technickÃ© analÃ½ze, fundamentÃ¡lnÃ­ analÃ½ze nebo kvantitativnÃ­ch modelech.

## KomplexnÃ­ VysvÄ›tlenÃ­ Projektu

### CÃ­le Projektu
Tento projekt vytvÃ¡Å™Ã­ inteligentnÃ­ho finanÄnÃ­ho asistenta vyuÅ¾Ã­vajÃ­cÃ­ho MCP protokol pro integraci s rÅ¯znÃ½mi finanÄnÃ­mi API. SystÃ©m poskytuje:

- Real-time analÃ½zu trhÅ¯ a portfolia
- AutomatizovanÃ© generovÃ¡nÃ­ obchodnÃ­ch signÃ¡lÅ¯
- PokroÄilou analÃ½zu rizik
- PersonalizovanÃ© investiÄnÃ­ doporuÄenÃ­
- Backtesting obchodnÃ­ch strategiÃ­

### VÃ½zvy
- **Latence dat**: ZpracovÃ¡nÃ­ real-time dat s minimÃ¡lnÃ­m zpoÅ¾dÄ›nÃ­m
- **Spolehlivost**: ZajiÅ¡tÄ›nÃ­ vysokÃ© dostupnosti systÃ©mu bÄ›hem obchodnÃ­ch hodin
- **BezpeÄnost**: Ochrana citlivÃ½ch finanÄnÃ­ch dat a obchodnÃ­ch pozic
- **Regulace**: DodrÅ¾ovÃ¡nÃ­ finanÄnÃ­ch pÅ™edpisÅ¯ a compliance poÅ¾adavkÅ¯
- **Å kÃ¡lovatelnost**: ZpracovÃ¡nÃ­ velkÃ½ch objemÅ¯ dat a souÄasnÃ½ch uÅ¾ivatelÅ¯

### PotenciÃ¡lnÃ­ Dopad
SystÃ©m mÅ¯Å¾e revolucionalizovat osobnÃ­ investovÃ¡nÃ­ poskytnutÃ­m profesionÃ¡lnÃ­ch analytickÃ½ch nÃ¡strojÅ¯ bÄ›Å¾nÃ½m investorÅ¯m, demokratizovat pÅ™Ã­stup k sofistikovanÃ½m obchodnÃ­m strategiÃ¡m a vÃ½znamnÄ› snÃ­Å¾it nÃ¡klady na finanÄnÃ­ poradenstvÃ­.

## KomplexnÃ­ Implementace v Pythonu

````python
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
numpy==1.24.3
pandas==2.0.3
yfinance==0.2.28
alpha-vantage==2.3.1
langchain==0.1.0
openai==1.3.0
redis==5.0.1
celery==5.3.4
plotly==5.17.0
scipy==1.11.4
scikit-learn==1.3.2
````

````python
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

class AssetType(str, Enum):
    STOCK = "stock"
    CRYPTO = "crypto"
    FOREX = "forex"
    COMMODITY = "commodity"

class MarketData(BaseModel):
    symbol: str
    price: float
    timestamp: datetime
    volume: Optional[float] = None
    change_percent: Optional[float] = None
    asset_type: AssetType

class Portfolio(BaseModel):
    user_id: str
    positions: Dict[str, float]  # symbol -> quantity
    cash_balance: float
    total_value: float
    last_updated: datetime

class TradingSignal(BaseModel):
    symbol: str
    action: str  # BUY, SELL, HOLD
    confidence: float = Field(ge=0, le=1)
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    reasoning: str
    timestamp: datetime

class RiskMetrics(BaseModel):
    portfolio_var: float  # Value at Risk
    expected_return: float
    volatility: float
    sharpe_ratio: float
    max_drawdown: float
    beta: Optional[float] = None
````

````python
import asyncio
import json
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import yfinance as yf
import pandas as pd
import numpy as np
from alpha_vantage.timeseries import TimeSeries
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
import redis
from fastapi import FastAPI, HTTPException
from contextlib import asynccontextmanager

class FinancialMCPServer:
    def __init__(self, alpha_vantage_key: str, openai_key: str, redis_url: str = "redis://localhost:6379"):
        self.av_key = alpha_vantage_key
        self.ts = TimeSeries(key=alpha_vantage_key, output_format='pandas')
        self.llm = OpenAI(api_key=openai_key, temperature=0.1)
        self.redis_client = redis.from_url(redis_url)
        self.cache_ttl = 300  # 5 minut
        
    async def get_market_data(self, symbol: str, period: str = "1d") -> Dict[str, Any]:
        """ZÃ­skÃ¡nÃ­ trÅ¾nÃ­ch dat s cache mechanismem"""
        cache_key = f"market_data:{symbol}:{period}"
        
        try:
            # Zkontrolovat cache
            cached_data = self.redis_client.get(cache_key)
            if cached_data:
                return json.loads(cached_data)
            
            # ZÃ­skat data z Yahoo Finance
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period=period)
            
            if hist.empty:
                raise HTTPException(status_code=404, detail=f"Data pro symbol {symbol} nenalezena")
            
            latest = hist.iloc[-1]
            data = {
                "symbol": symbol,
                "price": float(latest['Close']),
                "volume": float(latest['Volume']),
                "change_percent": float(((latest['Close'] - hist.iloc[-2]['Close']) / hist.iloc[-2]['Close']) * 100),
                "timestamp": datetime.now().isoformat(),
                "high_52w": float(hist['High'].max()),
                "low_52w": float(hist['Low'].min())
            }
            
            # UloÅ¾it do cache
            self.redis_client.setex(cache_key, self.cache_ttl, json.dumps(data))
            return data
            
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Chyba pÅ™i zÃ­skÃ¡vÃ¡nÃ­ dat: {str(e)}")
    
    async def calculate_portfolio_metrics(self, portfolio_data: Dict[str, float]) -> Dict[str, float]:
        """VÃ½poÄet klÃ­ÄovÃ½ch metrik portfolia"""
        try:
            symbols = list(portfolio_data.keys())
            if not symbols:
                return {}
            
            # ZÃ­skat historickÃ¡ data pro vÅ¡echny symboly
            returns_data = []
            for symbol in symbols:
                ticker = yf.Ticker(symbol)
                hist = ticker.history(period="1y")
                if not hist.empty:
                    returns = hist['Close'].pct_change().dropna()
                    returns_data.append(returns)
            
            if not returns_data:
                raise ValueError("Nelze zÃ­skat dostateÄnÃ¡ data pro vÃ½poÄet metrik")
            
            # Spojit data a vypoÄÃ­tat portfolio returns
            portfolio_returns = pd.concat(returns_data, axis=1, keys=symbols)
            weights = np.array(list(portfolio_data.values()))
            weights = weights / weights.sum()  # Normalizace vah
            
            portfolio_daily_returns = (portfolio_returns * weights).sum(axis=1)
            
            # VÃ½poÄet metrik
            annual_return = portfolio_daily_returns.mean() * 252
            annual_vol = portfolio_daily_returns.std() * np.sqrt(252)
            sharpe_ratio = annual_return / annual_vol if annual_vol > 0 else 0
            
            # Value at Risk (95% confidence)
            var_95 = np.percentile(portfolio_daily_returns, 5)
            
            # Maximum Drawdown
            cumulative_returns = (1 + portfolio_daily_returns).cumprod()
            rolling_max = cumulative_returns.expanding().max()
            drawdown = (cumulative_returns - rolling_max) / rolling_max
            max_drawdown = drawdown.min()
            
            return {
                "expected_annual_return": float(annual_return),
                "annual_volatility": float(annual_vol),
                "sharpe_ratio": float(sharpe_ratio),
                "var_95": float(var_95),
                "max_drawdown": float(max_drawdown)
            }
            
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Chyba pÅ™i vÃ½poÄtu metrik: {str(e)}")
    
    async def generate_trading_signal(self, symbol: str, analysis_period: str = "3mo") -> Dict[str, Any]:
        """GenerovÃ¡nÃ­ obchodnÃ­ho signÃ¡lu pomocÃ­ AI analÃ½zy"""
        try:
            # ZÃ­skat trÅ¾nÃ­ data
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period=analysis_period)
            info = ticker.info
            
            if hist.empty:
                raise ValueError(f"Nelze zÃ­skat data pro {symbol}")
            
            # TechnickÃ¡ analÃ½za
            hist['SMA_20'] = hist['Close'].rolling(window=20).mean()
            hist['SMA_50'] = hist['Close'].rolling(window=50).mean()
            hist['RSI'] = self._calculate_rsi(hist['Close'])
            
            latest = hist.iloc[-1]
            prev = hist.iloc[-2]
            
            # PÅ™ipravit data pro AI analÃ½zu
            technical_summary = {
                "current_price": float(latest['Close']),
                "sma_20": float(latest['SMA_20']),
                "sma_50": float(latest['SMA_50']),
                "rsi": float(latest['RSI']),
                "volume_trend": "increasing" if latest['Volume'] > prev['Volume'] else "decreasing",
                "price_vs_sma20": "above" if latest['Close'] > latest['SMA_20'] else "below",
                "price_vs_sma50": "above" if latest['Close'] > latest['SMA_50'] else "below"
            }
            
            # AI prompt pro analÃ½zu
            prompt = PromptTemplate(
                input_variables=["symbol", "technical_data", "market_info"],
                template="""
                Analyzuj nÃ¡sledujÃ­cÃ­ technickÃ© Ãºdaje pro akci {symbol}:
                
                TechnickÃ¡ data: {technical_data}
                Informace o spoleÄnosti: {market_info}
                
                Na zÃ¡kladÄ› tÃ©to analÃ½zy poskytni:
                1. DoporuÄenÃ­ (BUY/SELL/HOLD)
                2. MÃ­ru dÅ¯vÄ›ry (0-1)
                3. CÃ­lovou cenu
                4. Stop-loss ÃºroveÅˆ
                5. OdÅ¯vodnÄ›nÃ­ v 2-3 vÄ›tÃ¡ch
                
                OdpovÄ›z ve formÃ¡tu JSON.
                """
            )
            
            market_info = {
                "sector": info.get("sector", "N/A"),
                "market_cap": info.get("marketCap", "N/A"),
                "pe_ratio": info.get("trailingPE", "N/A")
            }
            
            response = await self.llm.agenerate([
                prompt.format(
                    symbol=symbol,
                    technical_data=json.dumps(technical_summary),
                    market_info=json.dumps(market_info)
                )
            ])
            
            # Parsovat AI odpovÄ›Ä
            try:
                ai_analysis = json.loads(response.generations[0][0].text)
            except:
                # Fallback na zÃ¡kladnÃ­ technickou analÃ½zu
                ai_analysis = self._basic_technical_analysis(technical_summary)
            
            return {
                "symbol": symbol,
                "signal": ai_analysis,
                "technical_data": technical_summary,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Chyba pÅ™i generovÃ¡nÃ­ signÃ¡lu: {str(e)}")
    
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> pd.Series:
        """VÃ½poÄet Relative Strength Index"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def _basic_technical_analysis(self, technical_data: Dict) -> Dict:
        """ZÃ¡kladnÃ­ technickÃ¡ analÃ½za jako fallback"""
        rsi = technical_data["rsi"]
        price_vs_sma20 = technical_data["price_vs_sma20"]
        
        if rsi < 30 and price_vs_sma20 == "below":
            signal = "BUY"
            confidence = 0.7
        elif rsi > 70 and price_vs_sma20 == "above":
            signal = "SELL"
            confidence = 0.7
        else:
            signal = "HOLD"
            confidence = 0.5
        
        return {
            "recommendation": signal,
            "confidence": confidence,
            "target_price": technical_data["current_price"] * 1.05 if signal == "BUY" else technical_data["current_price"] * 0.95,
            "stop_loss": technical_data["current_price"] * 0.95 if signal == "BUY" else technical_data["current_price"] * 1.05,
            "reasoning": f"TechnickÃ¡ analÃ½za zaloÅ¾enÃ¡ na RSI ({rsi:.1f}) a pozici vÅ¯Äi SMA20"
        }

    async def backtest_strategy(self, symbol: str, strategy_params: Dict) -> Dict[str, Any]:
        """Backtesting obchodnÃ­ strategie"""
        try:
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period="2y")
            
            if hist.empty:
                raise ValueError(f"Nelze zÃ­skat data pro backtesting {symbol}")
            
            # Implementace jednoduchÃ© SMA crossover strategie
            short_window = strategy_params.get("short_sma", 20)
            long_window = strategy_params.get("long_sma", 50)
            
            hist['SMA_short'] = hist['Close'].rolling(window=short_window).mean()
            hist['SMA_long'] = hist['Close'].rolling(window=long_window).mean()
            
            # GenerovÃ¡nÃ­ signÃ¡lÅ¯
            hist['Signal'] = 0
            hist['Signal'][short_window:] = np.where(
                hist['SMA_short'][short_window:] > hist['SMA_long'][short_window:], 1, 0
            )
            hist['Position'] = hist['Signal'].diff()
            
            # VÃ½poÄet vÃ½nosÅ¯
            hist['Strategy_Return'] = hist['Close'].pct_change() * hist['Signal'].shift(1)
            hist['Cumulative_Strategy_Return'] = (1 + hist['Strategy_Return']).cumprod()
            hist['Cumulative_Market_Return'] = (1 + hist['Close'].pct_change()).cumprod()
            
            # Metriky vÃ½konnosti
            total_strategy_return = hist['Cumulative_Strategy_Return'].iloc[-1] - 1
            total_market_return = hist['Cumulative_Market_Return'].iloc[-1] - 1
            
            strategy_volatility = hist['Strategy_Return'].std() * np.sqrt(252)
            strategy_sharpe = (hist['Strategy_Return'].mean() * 252) / strategy_volatility if strategy_volatility > 0 else 0
            
            # Maximum drawdown
            rolling_max = hist['Cumulative_Strategy_Return'].expanding().max()
            drawdown = (hist['Cumulative_Strategy_Return'] - rolling_max) / rolling_max
            max_drawdown = drawdown.min()
            
            return {
                "symbol": symbol,
                "strategy_params": strategy_params,
                "total_strategy_return": float(total_strategy_return),
                "total_market_return": float(total_market_return),
                "strategy_sharpe_ratio": float(strategy_sharpe),
                "max_drawdown": float(max_drawdown),
                "number_of_trades": int(hist['Position'].abs().sum()),
                "win_rate": float(len(hist[hist['Strategy_Return'] > 0]) / len(hist[hist['Strategy_Return'] != 0])) if len(hist[hist['Strategy_Return'] != 0]) > 0 else 0
            }
            
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Chyba pÅ™i backtestingu: {str(e)}")
````

````python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Dict, List, Optional
import os
from datetime import datetime
import asyncio

from src.mcp.financial_mcp_server import FinancialMCPServer
from src.models.market_data import Portfolio, TradingSignal, RiskMetrics

app = FastAPI(
    title="AI FinanÄnÃ­ ObchodnÃ­ Asistent",
    description="MCP-based finanÄnÃ­ asistent pro analÃ½zu trhÅ¯ a sprÃ¡vu portfolia",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# GlobÃ¡lnÃ­ instance MCP serveru
mcp_server = None

@app.on_event("startup")
async def startup_event():
    global mcp_server
    alpha_vantage_key = os.getenv("ALPHA_VANTAGE_KEY", "demo")
    openai_key = os.getenv("OPENAI_API_KEY", "")
    redis_url = os.getenv("REDIS_URL", "redis://localhost:6379")
    
    mcp_server = FinancialMCPServer(
        alpha_vantage_key=alpha_vantage_key,
        openai_key=openai_key,
        redis_url=redis_url
    )

class MarketDataRequest(BaseModel):
    symbols: List[str]
    period: str = "1d"

class PortfolioAnalysisRequest(BaseModel):
    portfolio: Dict[str, float]  # symbol -> weight/quantity

class TradingSignalRequest(BaseModel):
    symbol: str
    analysis_period: str = "3mo"

class BacktestRequest(BaseModel):
    symbol: str
    strategy_params: Dict
    
@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

@app.post("/api/market-data")
async def get_market_data(request: MarketDataRequest):
    """ZÃ­skÃ¡nÃ­ trÅ¾nÃ­ch dat pro zadanÃ© symboly"""
    try:
        results = {}
        for symbol in request.symbols:
            data = await mcp_server.get_market_data(symbol, request.period)
            results[symbol] = data
        
        return {
            "status": "success",
            "data": results,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/portfolio/analyze")
async def analyze_portfolio(request: PortfolioAnalysisRequest):
    """AnalÃ½za rizik a vÃ½konnosti portfolia"""
    try:
        metrics = await mcp_server.calculate_portfolio_metrics(request.portfolio)
        
        return {
            "status": "success",
            "portfolio_metrics": metrics,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/trading/signal")
async def generate_trading_signal(request: TradingSignalRequest):
    """GenerovÃ¡nÃ­ obchodnÃ­ho signÃ¡lu pro akci"""
    try:
        signal = await mcp_server.generate_trading_signal(
            request.symbol, 
            request.analysis_period
        )
        
        return {
            "status": "success",
            "trading_signal": signal,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/strategy/backtest")
async def backtest_strategy(request: BacktestRequest):
    """Backtesting obchodnÃ­ strategie"""
    try:
        results = await mcp_server.backtest_strategy(
            request.symbol,
            request.strategy_params
        )
        
        return {
            "status": "success",
            "backtest_results": results,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/watchlist/{user_id}")
async def get_user_watchlist(user_id: str):
    """ZÃ­skÃ¡nÃ­ watchlistu uÅ¾ivatele"""
    try:
        # V reÃ¡lnÃ© aplikaci by se data naÄÃ­tala z databÃ¡ze
        sample_watchlist = ["AAPL", "GOOGL", "MSFT", "TSLA", "NVDA"]
        
        watchlist_data = {}
        for symbol in sample_watchlist:
            data = await mcp_server.get_market_data(symbol, "1d")
            watchlist_data[symbol] = data
        
        return {
            "status": "success",
            "user_id": user_id,
            "watchlist": watchlist_data,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
````

````python
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import Tool
from langchain.schema import SystemMessage
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.llms import OpenAI
from typing import Dict, List, Any
import json
import asyncio

class FinancialAdvisorAgent:
    def __init__(self, mcp_server, openai_key: str):
        self.mcp_server = mcp_server
        self.llm = OpenAI(api_key=openai_key, temperature=0.2)
        self.tools = self._create_tools()
        self.agent = self._create_agent()
        
    def _create_tools(self) -> List[Tool]:
        """VytvoÅ™enÃ­ nÃ¡strojÅ¯ pro finanÄnÃ­ho agenta"""
        return [
            Tool(
                name="get_market_data",
                description="ZÃ­skÃ¡ aktuÃ¡lnÃ­ trÅ¾nÃ­ data pro zadanÃ½ symbol",
                func=self._get_market_data_tool
            ),
            Tool(
                name="analyze_portfolio",
                description="Analyzuje portfolio a vypoÄÃ­tÃ¡ rizikovÃ© metriky",
                func=self._analyze_portfolio_tool
            ),
            Tool(
                name="generate_trading_signal",
                description="Generuje obchodnÃ­ signÃ¡l pro zadanÃ½ symbol",
                func=self._generate_signal_tool
            ),
            Tool(
                name="backtest_strategy",
                description="Provede backtesting obchodnÃ­ strategie",
                func=self._backtest_tool
            )
        ]
    
    def _create_agent(self):
        """VytvoÅ™enÃ­ AI agenta s finanÄnÃ­mi nÃ¡stroji"""
        system_message = SystemMessage(content="""
        Jsi zkuÅ¡enÃ½ finanÄnÃ­ poradce a analytik. TvÃ½m Ãºkolem je:
        
        1. Analyzovat finanÄnÃ­ data a poskytovat pÅ™esnÃ© informace
        2. DoporuÄovat investiÄnÃ­ strategie zaloÅ¾enÃ© na datech
        3. VysvÄ›tlovat sloÅ¾itÃ© finanÄnÃ­ koncepty srozumitelnÄ›
        4. UpozorÅˆovat na rizika a poskytovat vyvÃ¡Å¾enÃ¡ doporuÄenÃ­
        5. Nikdy nezaruÄovat vÃ½nosy - vÅ¾dy pÅ™ipomÃ­nat, Å¾e investovÃ¡nÃ­ nese rizika
        
        PouÅ¾Ã­vej dostupnÃ© nÃ¡stroje pro zÃ­skÃ¡nÃ­ aktuÃ¡lnÃ­ch dat a analÃ½z.
        OdpovÃ­dej v ÄeÅ¡tinÄ› a buÄ konkrÃ©tnÃ­ ve svÃ½ch doporuÄenÃ­ch.
        """)
        
        prompt = ChatPromptTemplate.from_messages([
            system_message,
            MessagesPlaceholder(variable_name="chat_history"),
            ("user", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad")
        ])
        
        agent = create_openai_functions_agent(
            llm=self.llm,
            tools=self.tools,
            prompt=prompt
        )
        
        return AgentExecutor(
            agent=agent,
            tools=self.tools,
            verbose=True,
            max_iterations=3
        )
    
    def _get_market_data_tool(self, symbol: str) -> str:
        """NÃ¡stroj pro zÃ­skÃ¡nÃ­ trÅ¾nÃ­ch dat"""
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            data = loop.run_until_complete(self.mcp_server.get_market_data(symbol))
            return json.dumps(data, ensure_ascii=False)
        except Exception as e:
            return f"Chyba pÅ™i zÃ­skÃ¡vÃ¡nÃ­ dat: {str(e)}"
    
    def _analyze_portfolio_tool(self, portfolio_json: str) -> str:
        """NÃ¡stroj pro analÃ½zu portfolia"""
        try:
            portfolio = json.loads(portfolio_json)
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            metrics = loop.run_until_complete(
                self.mcp_server.calculate_portfolio_metrics(portfolio)
            )
            return json.dumps(metrics, ensure_ascii=False)
        except Exception as e:
            return f"Chyba pÅ™i analÃ½ze portfolia: {str(e)}"
    
    def _generate_signal_tool(self, symbol: str) -> str:
        """NÃ¡stroj pro generovÃ¡nÃ­ obchodnÃ­ch signÃ¡lÅ¯"""
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            signal = loop.run_until_complete(
                self.mcp_server.generate_trading_signal(symbol)
            )
            return json.dumps(signal, ensure_ascii=False)
        except Exception as e:
            return f"Chyba pÅ™i generovÃ¡nÃ­ signÃ¡lu: {str(e)}"
    
    def _backtest_tool(self, params_json: str) -> str:
        """NÃ¡stroj pro backtesting"""
        try:
            params = json.loads(params_json)
            symbol = params["symbol"]
            strategy_params = params["strategy_params"]
            
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            results = loop.run_until_complete(
                self.mcp_server.backtest_strategy(symbol, strategy_params)
            )
            return json.dumps(results, ensure_ascii=False)
        except Exception as e:
            return f"Chyba pÅ™i backtestingu: {str(e)}"
    
    async def process_query(self, user_query: str, chat_history: List = None) -> str:
        """ZpracovÃ¡nÃ­ dotazu uÅ¾ivatele"""
        try:
            if chat_history is None:
                chat_history = []
            
            response = await self.agent.ainvoke({
                "input": user_query,
                "chat_history": chat_history
            })
            
            return response["output"]
        except Exception as e:
            return f"OmlouvÃ¡m se, doÅ¡lo k chybÄ› pÅ™i zpracovÃ¡nÃ­ vaÅ¡eho dotazu: {str(e)}"

# PÅ™Ã­klad pouÅ¾itÃ­ agenta
async def demo_agent_usage():
    """Demonstrace pouÅ¾itÃ­ finanÄnÃ­ho agenta"""
    mcp_server = FinancialMCPServer(
        alpha_vantage_key="demo",
        openai_key="your-openai-key"
    )
    
    agent = FinancialAdvisorAgent(mcp_server, "your-openai-key")
    
    # PÅ™Ã­klady dotazÅ¯
    queries = [
        "JakÃ¡ je aktuÃ¡lnÃ­ cena akciÃ­ Apple a tvÃ© doporuÄenÃ­?",
        "Analyzuj portfolio sloÅ¾enÃ© z 50% AAPL, 30% GOOGL, 20% MSFT",
        "Navrhni obchodnÃ­ strategii pro Tesla na zÃ¡kladÄ› technickÃ© analÃ½zy",
        "ProveÄ backtest SMA crossover strategie pro Microsoft"
    ]
    
    for query in queries:
        print(f"Dotaz: {query}")
        response = await agent.process_query(query)
        print(f"OdpovÄ›Ä: {response}\n")

if __name__ == "__main__":
    asyncio.run(demo_agent_usage())
````

````python
import asyncio
import json
from src.mcp.financial_mcp_server import FinancialMCPServer
from src.agents.financial_advisor_agent import FinancialAdvisorAgent

async def demonstrate_financial_assistant():
    """KompletnÃ­ demonstrace finanÄnÃ­ho asistenta"""
    
    print("ğŸš€ SpouÅ¡tÄ›nÃ­ AI FinanÄnÃ­ho ObchodnÃ­ho Asistenta")
    print("=" * 50)
    
    # Inicializace MCP serveru
    mcp_server = FinancialMCPServer(
        alpha_vantage_key="demo",  # V produkci pouÅ¾ijte skuteÄnÃ½ klÃ­Ä
        openai_key="your-openai-key"  # NahraÄte svÃ½m OpenAI klÃ­Äem
    )
    
    # 1. ZÃ­skÃ¡nÃ­ trÅ¾nÃ­ch dat
    print("\nğŸ“Š 1. ZÃ­skÃ¡vÃ¡nÃ­ trÅ¾nÃ­ch dat")
    print("-" * 30)
    
    symbols = ["AAPL", "GOOGL", "MSFT", "TSLA"]
    for symbol in symbols:
        try:
            data = await mcp_server.get_market_data(symbol)
            print(f"{symbol}: ${data['price']:.2f} ({data['change_percent']:+.2f}%)")
        except Exception as e:
            print(f"Chyba pro {symbol}: {e}")
    
    # 2. AnalÃ½za portfolia
    print("\nğŸ’¼ 2. AnalÃ½za portfolia")
    print("-" * 30)
    
    portfolio = {
        "AAPL": 0.4,   # 40% vÃ¡ha
        "GOOGL": 0.3,  # 30% vÃ¡ha
        "MSFT": 0.2,   # 20% vÃ¡ha
        "TSLA": 0.1    # 10% vÃ¡ha
    }
    
    try:
        metrics = await mcp_server.calculate_portfolio_metrics(portfolio)
        print(f"OÄekÃ¡vanÃ½ roÄnÃ­ vÃ½nos: {metrics.get('expected_annual_return', 0)*100:.2f}%")
        print(f"RoÄnÃ­ volatilita: {metrics.get('annual_volatility', 0)*100:.2f}%")
        print(f"Sharpe ratio: {metrics.get('sharpe_ratio', 0):.3f}")
        print(f"VaR (95%): {metrics.get('var_95', 0)*100:.2f}%")
        print(f"Max drawdown: {metrics.get('max_drawdown', 0)*100:.2f}%")
    except Exception as e:
        print(f"Chyba pÅ™i analÃ½ze portfolia: {e}")
    
    # 3. GenerovÃ¡nÃ­ obchodnÃ­ch signÃ¡lÅ¯
    print("\nğŸ“ˆ 3. ObchodnÃ­ signÃ¡ly")
    print("-" * 30)
    
    for symbol in ["AAPL", "TSLA"]:
        try:
            signal = await mcp_server.generate_trading_signal(symbol)
            signal_data = signal.get('signal', {})
            print(f"\n{symbol}:")
            print(f"  DoporuÄenÃ­: {signal_data.get('recommendation', 'N/A')}")
            print(f"  DÅ¯vÄ›ra: {signal_data.get('confidence', 0)*100:.1f}%")
            print(f"  CÃ­lovÃ¡ cena: ${signal_data.get('target_price', 0):.2f}")
            print(f"  OdÅ¯vodnÄ›nÃ­: {signal_data.get('reasoning', 'N/A')}")
        except Exception as e:
            print(f"Chyba pÅ™i generovÃ¡nÃ­ signÃ¡lu pro {symbol}: {e}")
    
    # 4. Backtesting strategie
    print("\nğŸ”„ 4. Backtesting strategie")
    print("-" * 30)
    
    strategy_params = {
        "short_sma": 20,
        "long_sma": 50
    }
    
    try:
        backtest = await mcp_server.backtest_strategy("AAPL", strategy_params)
        print(f"VÃ½nos strategie: {backtest.get('total_strategy_return', 0)*100:.2f}%")
        print(f"VÃ½nos trhu: {backtest.get('total_market_return', 0)*100:.2f}%")
        print(f"Sharpe ratio: {backtest.get('strategy_sharpe_ratio', 0):.3f}")
        print(f"PoÄet obchodÅ¯: {backtest.get('number_of_trades', 0)}")
        print(f"ÃšspÄ›Å¡nost: {backtest.get('win_rate', 0)*100:.1f}%")
    except Exception as e:
        print(f"Chyba pÅ™i backtestingu: {e}")
    
    # 5. Interakce s AI agentem
    print("\nğŸ¤– 5. AI FinanÄnÃ­ Poradce")
    print("-" * 30)
    
    # agent = FinancialAdvisorAgent(mcp_server, "your-openai-key")
    
    # sample_queries = [
    #     "DoporuÄ mi diverzifikovanÃ© portfolio pro konzervativnÃ­ho investora",
    #     "JakÃ© jsou aktuÃ¡lnÃ­ trendy v technologickÃ½ch akciÃ­ch?",
    #     "VysvÄ›tli mi rizika investovÃ¡nÃ­ do rÅ¯stovÃ½ch akciÃ­"
    # ]
    
    # for query in sample_queries:
    #     print(f"\nDotaz: {query}")
    #     try:
    #         response = await agent.process_query(query)
    #         print(f"OdpovÄ›Ä: {response}")
    #     except Exception as e:
    #         print(f"Chyba pÅ™i komunikaci s agentem: {e}")
    
    print("\nâœ… Demonstrace dokonÄena!")
    print("ğŸ’¡ Pro produkÄnÃ­ pouÅ¾itÃ­ nastavte sprÃ¡vnÃ© API klÃ­Äe a databÃ¡zovÃ© pÅ™ipojenÃ­")

if __name__ == "__main__":
    asyncio.run(demonstrate_financial_assistant())
````

````bash
#!/bin/bash

echo "ğŸš€ NastavenÃ­ AI FinanÄnÃ­ho ObchodnÃ­ho Asistenta"

# VytvoÅ™enÃ­ virtuÃ¡lnÃ­ho prostÅ™edÃ­
python -m venv financial_assistant_env
source financial_assistant_env/bin/activate  # Linux/Mac
# financial_assistant_env\Scripts\activate  # Windows

# Instalace zÃ¡vislostÃ­
pip install -r requirements.txt

# NastavenÃ­ promÄ›nnÃ½ch prostÅ™edÃ­
echo "Nastavte nÃ¡sledujÃ­cÃ­ promÄ›nnÃ© prostÅ™edÃ­:"
echo "export ALPHA_VANTAGE_KEY='your_alpha_vantage_key'"
echo "export OPENAI_API_KEY='your_openai_key'"
echo "export REDIS_URL='redis://localhost:6379'"

# SpuÅ¡tÄ›nÃ­ Redis serveru (je-li potÅ™eba)
echo "UjistÄ›te se, Å¾e Redis server bÄ›Å¾Ã­:"
echo "redis-server"

echo "âœ… NastavenÃ­ dokonÄeno!"
echo "SpusÅ¥te aplikaci: python -m uvicorn src.api.main:app --reload"
````

## ShrnutÃ­ Projektu

### KlÃ­ÄovÃ© VÃ½hody
- **KomplexnÃ­ finanÄnÃ­ analÃ½za**: Real-time trÅ¾nÃ­ data, technickÃ¡ a fundamentÃ¡lnÃ­ analÃ½za
- **AI-powered doporuÄenÃ­**: VyuÅ¾itÃ­ pokroÄilÃ½ch jazykovÃ½ch modelÅ¯ pro investiÄnÃ­ rady
- **Å kÃ¡lovatelnÃ¡ architektura**: MCP protokol umoÅ¾Åˆuje snadnÃ© rozÅ¡Ã­Å™enÃ­ o dalÅ¡Ã­ datovÃ© zdroje
- **Risk management**: PokroÄilÃ© metriky rizika vÄetnÄ› VaR a stress testingu
- **Backtesting**: OvÄ›Å™enÃ­ strategiÃ­ na historickÃ½ch datech

### TechnologickÃ¡ Hodnota
Projekt demonstruje integraci modernÃ­ch AI technologiÃ­ s finanÄnÃ­mi trhy, vyuÅ¾Ã­vÃ¡ MCP protokol pro bezpeÄnÃ½ pÅ™Ã­stup k datÅ¯m a poskytuje Å¡kÃ¡lovatelnou platformu pro finanÄnÃ­ sluÅ¾by. Kombinace LangChain agentÅ¯ s real-time daty vytvÃ¡Å™Ã­ vÃ½konnÃ½ nÃ¡stroj pro demokratizaci finanÄnÃ­ho poradenstvÃ­.

### BudoucÃ­ RozÅ¡Ã­Å™enÃ­
- Integrace s brokerskÃ½mi API pro automatickÃ© obchodovÃ¡nÃ­
- PokroÄilÃ© machine learning modely pro predikci trhÅ¯
- MultijazyÄnÃ¡ podpora a globÃ¡lnÃ­ trhy
- MobilnÃ­ aplikace pro retail investory
- InstitucionÃ¡lnÃ­ dashboard pro portfolio manaÅ¾ery