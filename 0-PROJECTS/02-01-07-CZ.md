<small>Claude Sonnet 4 **(Syst√©m Multi-Agent≈Ø pro Zdravotnickou Diagnostiku a Pl√°nov√°n√≠ L√©ƒçby)**</small>
# Healthcare Diagnosis and Treatment Planning

## 1. N√°zev Projektu

**AI-LLM Multi-Agent Healthcare Diagnosis and Treatment Planning System**
*Inteligentn√≠ multi-agentn√≠ syst√©m pro zdravotnickou diagnostiku a pl√°nov√°n√≠ l√©ƒçby s integracemi l√©ka≈ôsk√Ωch znalost√≠*

## 2. Vysvƒõtlen√≠ Kl√≠ƒçov√Ωch Koncept≈Ø

### Medical Knowledge Integration (Integrace L√©ka≈ôsk√Ωch Znalost√≠)
Proces zaƒçlenƒõn√≠ rozs√°hl√Ωch medic√≠nsk√Ωch datab√°z√≠, klinick√Ωch guidelines, farmakologick√Ωch informac√≠ a evidence-based medicine do AI syst√©mu. Zahrnuje strukturovan√° data z ICD-10, l√©kov√Ωch datab√°z√≠, klinick√Ωch protokol≈Ø a vƒõdeck√Ωch publikac√≠.

### Symptom Analysis (Anal√Ωza Symptom≈Ø)
Sofistikovan√° anal√Ωza pacientsk√Ωch symptom≈Ø pomoc√≠ NLP a pattern recognition. Syst√©m rozpozn√°v√° p≈ôiznaky, hodnot√≠ jejich z√°va≈ænost, identifikuje vz√°jemn√© souvislosti a vytv√°≈ô√≠ diferenci√°ln√≠ diagnostiku.

### Treatment Recommendation (Doporuƒçen√≠ L√©ƒçby)
AI-≈ô√≠zen√Ω proces generov√°n√≠ personalizovan√Ωch l√©ƒçebn√Ωch doporuƒçen√≠ na z√°kladƒõ diagn√≥zy, pacientovy anamn√©zy, aktu√°ln√≠ch guidelines a evidence-based medicine.

### Drug Interaction Checking (Kontrola L√©kov√Ωch Interakc√≠)
Automatizovan√° kontrola potenci√°ln√≠ch interakc√≠ mezi l√©ky, kontraindikac√≠, alergick√Ωch reakc√≠ a adjustace d√°vkov√°n√≠ na z√°kladƒõ pacientov√Ωch charakteristik.

### Clinical Decision Support (Podpora Klinick√©ho Rozhodov√°n√≠)
Komplexn√≠ syst√©m poskytuj√≠c√≠ l√©ka≈ô≈Øm real-time podporu p≈ôi diagnostick√Ωch a terapeutick√Ωch rozhodnut√≠ch s vyu≈æit√≠m AI anal√Ωzy a aktu√°ln√≠ch klinick√Ωch dat.

## 3. Komplexn√≠ Vysvƒõtlen√≠ Projektu

### Popis a C√≠le
Tento projekt p≈ôedstavuje pokroƒçil√Ω multi-agentn√≠ syst√©m vyu≈æ√≠vaj√≠c√≠ velk√© jazykov√© modely pro podporu zdravotnick√Ωch pracovn√≠k≈Ø p≈ôi diagnostice a pl√°nov√°n√≠ l√©ƒçby. Syst√©m integruje rozs√°hl√© medic√≠nsk√© znalosti s AI technologiemi pro poskytov√°n√≠ evidence-based doporuƒçen√≠.

### Hlavn√≠ V√Ωzvy
- **Komplexnost medic√≠nsk√Ωch dat**: Integrace heterogenn√≠ch zdroj≈Ø medic√≠nsk√Ωch informac√≠
- **Bezpeƒçnost a p≈ôesnost**: Kritick√© po≈æadavky na spolehlivost v healthcare dom√©nƒõ
- **Regulatorn√≠ compliance**: Dodr≈æov√°n√≠ GDPR, HIPAA a dal≈°√≠ch zdravotnick√Ωch standard≈Ø
- **Real-time processing**: Rychl√° anal√Ωza pro podporu okam≈æit√©ho rozhodov√°n√≠
- **Personalizace**: P≈ôizp≈Øsoben√≠ doporuƒçen√≠ individu√°ln√≠m pacientsk√Ωm charakteristik√°m

### Potenci√°ln√≠ Dopad
- Zlep≈°en√≠ diagnostick√© p≈ôesnosti o 15-25%
- Redukce l√©kov√Ωch chyb o 40-60%
- Urychlen√≠ diagnostick√©ho procesu o 30-50%
- Standardizace klinick√Ωch postup≈Ø
- Podpora m√©nƒõ zku≈°en√Ωch l√©ka≈ô≈Ø

## 4. Komplexn√≠ P≈ô√≠klad s Python Implementac√≠

### Instalace Z√°vislost√≠

````python
# requirements.txt
langchain==0.1.0
langchain-openai==0.0.5
chromadb==0.4.18
faiss-cpu==1.7.4
pandas==2.1.4
numpy==1.24.3
scikit-learn==1.3.2
python-dotenv==1.0.0
pydantic==2.5.2
fastapi==0.104.1
uvicorn==0.24.0
streamlit==1.29.0
requests==2.31.0
````

### Implementace Multi-Agent Syst√©mu

````python
import os
import json
import pandas as pd
import numpy as np
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

from langchain.agents import initialize_agent, AgentType
from langchain.tools import BaseTool
from langchain.llms import OpenAI
from langchain.memory import ConversationBufferMemory
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma, FAISS
from langchain.document_loaders import TextLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document
from pydantic import BaseModel, Field
import chromadb

# Konfigurace a datov√© modely
@dataclass
class PatientData:
    patient_id: str
    age: int
    gender: str
    symptoms: List[str]
    medical_history: List[str]
    current_medications: List[str]
    allergies: List[str]
    vital_signs: Dict[str, float]

@dataclass
class DiagnosisResult:
    primary_diagnosis: str
    differential_diagnoses: List[str]
    confidence_score: float
    supporting_evidence: List[str]

@dataclass
class TreatmentPlan:
    medications: List[Dict]
    procedures: List[str]
    lifestyle_recommendations: List[str]
    follow_up_schedule: List[str]
    warnings: List[str]

class SeverityLevel(Enum):
    LOW = "low"
    MODERATE = "moderate"
    HIGH = "high"
    CRITICAL = "critical"

# Inicializace medic√≠nsk√Ωch dat
class MedicalKnowledgeBase:
    def __init__(self):
        self.symptoms_db = self._create_symptoms_database()
        self.diseases_db = self._create_diseases_database()
        self.medications_db = self._create_medications_database()
        self.interactions_db = self._create_interactions_database()
        
    def _create_symptoms_database(self) -> Dict:
        return {
            "fever": {"severity": "moderate", "common_causes": ["infection", "inflammation"]},
            "headache": {"severity": "low", "common_causes": ["tension", "migraine", "hypertension"]},
            "chest_pain": {"severity": "high", "common_causes": ["cardiac", "pulmonary", "musculoskeletal"]},
            "shortness_of_breath": {"severity": "high", "common_causes": ["cardiac", "pulmonary", "anxiety"]},
            "abdominal_pain": {"severity": "moderate", "common_causes": ["gastric", "appendicitis", "gallbladder"]},
            "fatigue": {"severity": "low", "common_causes": ["anemia", "depression", "thyroid"]},
            "nausea": {"severity": "low", "common_causes": ["gastric", "medication", "pregnancy"]},
            "dizziness": {"severity": "moderate", "common_causes": ["hypotension", "dehydration", "vestibular"]}
        }
    
    def _create_diseases_database(self) -> Dict:
        return {
            "hypertension": {
                "symptoms": ["headache", "dizziness", "chest_pain"],
                "treatment": ["ACE inhibitors", "lifestyle changes"],
                "severity": "moderate"
            },
            "diabetes_type2": {
                "symptoms": ["fatigue", "frequent_urination", "increased_thirst"],
                "treatment": ["metformin", "dietary changes", "exercise"],
                "severity": "moderate"
            },
            "pneumonia": {
                "symptoms": ["fever", "chest_pain", "shortness_of_breath", "cough"],
                "treatment": ["antibiotics", "rest", "fluids"],
                "severity": "high"
            },
            "appendicitis": {
                "symptoms": ["abdominal_pain", "fever", "nausea"],
                "treatment": ["surgery", "antibiotics"],
                "severity": "critical"
            }
        }
    
    def _create_medications_database(self) -> Dict:
        return {
            "lisinopril": {
                "class": "ACE inhibitor",
                "indications": ["hypertension", "heart_failure"],
                "contraindications": ["pregnancy", "angioedema_history"],
                "side_effects": ["dry_cough", "hyperkalemia"],
                "dosage": "10-40mg daily"
            },
            "metformin": {
                "class": "biguanide",
                "indications": ["diabetes_type2"],
                "contraindications": ["kidney_disease", "liver_disease"],
                "side_effects": ["nausea", "diarrhea"],
                "dosage": "500-2000mg daily"
            },
            "amoxicillin": {
                "class": "penicillin antibiotic",
                "indications": ["pneumonia", "bronchitis"],
                "contraindications": ["penicillin_allergy"],
                "side_effects": ["nausea", "rash"],
                "dosage": "500mg every 8 hours"
            }
        }
    
    def _create_interactions_database(self) -> Dict:
        return {
            ("lisinopril", "potassium_supplements"): {
                "severity": "high",
                "description": "Risk of hyperkalemia"
            },
            ("metformin", "contrast_dye"): {
                "severity": "high", 
                "description": "Risk of lactic acidosis"
            },
            ("amoxicillin", "warfarin"): {
                "severity": "moderate",
                "description": "Increased bleeding risk"
            }
        }

# Agent pro anal√Ωzu symptom≈Ø
class SymptomAnalysisAgent:
    def __init__(self, knowledge_base: MedicalKnowledgeBase):
        self.kb = knowledge_base
        self.embeddings = OpenAIEmbeddings()
        
    def analyze_symptoms(self, patient: PatientData) -> Dict:
        """Analyzuje pacientovy symptomy a vrac√≠ strukturovan√© v√Ωsledky"""
        symptom_analysis = {}
        
        for symptom in patient.symptoms:
            if symptom in self.kb.symptoms_db:
                symptom_data = self.kb.symptoms_db[symptom]
                symptom_analysis[symptom] = {
                    "severity": symptom_data["severity"],
                    "possible_causes": symptom_data["common_causes"],
                    "urgency_score": self._calculate_urgency_score(symptom_data["severity"])
                }
        
        # Kombinovan√© hodnocen√≠
        overall_severity = self._assess_overall_severity(symptom_analysis)
        
        return {
            "individual_symptoms": symptom_analysis,
            "overall_severity": overall_severity,
            "recommended_urgency": self._determine_urgency_level(overall_severity),
            "red_flags": self._identify_red_flags(patient.symptoms)
        }
    
    def _calculate_urgency_score(self, severity: str) -> int:
        severity_scores = {"low": 1, "moderate": 2, "high": 3, "critical": 4}
        return severity_scores.get(severity, 1)
    
    def _assess_overall_severity(self, symptom_analysis: Dict) -> str:
        if not symptom_analysis:
            return "low"
        
        max_urgency = max([data["urgency_score"] for data in symptom_analysis.values()])
        severity_map = {1: "low", 2: "moderate", 3: "high", 4: "critical"}
        return severity_map[max_urgency]
    
    def _determine_urgency_level(self, severity: str) -> str:
        urgency_map = {
            "low": "routine",
            "moderate": "same_day",
            "high": "urgent",
            "critical": "emergency"
        }
        return urgency_map[severity]
    
    def _identify_red_flags(self, symptoms: List[str]) -> List[str]:
        red_flag_symptoms = ["chest_pain", "shortness_of_breath", "severe_headache"]
        return [symptom for symptom in symptoms if symptom in red_flag_symptoms]

# Agent pro diagnostiku
class DiagnosticAgent:
    def __init__(self, knowledge_base: MedicalKnowledgeBase):
        self.kb = knowledge_base
        
    def generate_diagnosis(self, patient: PatientData, symptom_analysis: Dict) -> DiagnosisResult:
        """Generuje diferenci√°ln√≠ diagnostiku na z√°kladƒõ symptom≈Ø a anamn√©zy"""
        
        # Algoritmus pro matching symptom≈Ø s nemocemi
        disease_scores = {}
        
        for disease, disease_data in self.kb.diseases_db.items():
            score = self._calculate_disease_probability(
                patient.symptoms, 
                disease_data["symptoms"],
                patient.medical_history
            )
            disease_scores[disease] = score
        
        # Se≈ôazen√≠ podle pravdƒõpodobnosti
        sorted_diseases = sorted(disease_scores.items(), key=lambda x: x[1], reverse=True)
        
        primary_diagnosis = sorted_diseases[0][0] if sorted_diseases else "unknown"
        differential_diagnoses = [disease for disease, score in sorted_diseases[1:4]]
        
        return DiagnosisResult(
            primary_diagnosis=primary_diagnosis,
            differential_diagnoses=differential_diagnoses,
            confidence_score=sorted_diseases[0][1] if sorted_diseases else 0.0,
            supporting_evidence=self._generate_supporting_evidence(patient, primary_diagnosis)
        )
    
    def _calculate_disease_probability(self, patient_symptoms: List[str], 
                                    disease_symptoms: List[str], 
                                    medical_history: List[str]) -> float:
        """Poƒç√≠t√° pravdƒõpodobnost nemoci na z√°kladƒõ p≈ôekr√Ωvaj√≠c√≠ch se symptom≈Ø"""
        if not disease_symptoms:
            return 0.0
        
        matching_symptoms = len(set(patient_symptoms) & set(disease_symptoms))
        symptom_score = matching_symptoms / len(disease_symptoms)
        
        # Bonus za relevantn√≠ anamn√©zu
        history_bonus = 0.1 if any(condition in medical_history for condition in ["diabetes", "hypertension"]) else 0.0
        
        return min(symptom_score + history_bonus, 1.0)
    
    def _generate_supporting_evidence(self, patient: PatientData, diagnosis: str) -> List[str]:
        """Generuje podp≈Ørn√© d≈Økazy pro diagn√≥zu"""
        evidence = []
        
        if diagnosis in self.kb.diseases_db:
            disease_data = self.kb.diseases_db[diagnosis]
            matching_symptoms = set(patient.symptoms) & set(disease_data["symptoms"])
            
            for symptom in matching_symptoms:
                evidence.append(f"Pacient vykazuje {symptom}, co≈æ je konzistentn√≠ s {diagnosis}")
        
        return evidence

# Agent pro pl√°nov√°n√≠ l√©ƒçby
class TreatmentPlanningAgent:
    def __init__(self, knowledge_base: MedicalKnowledgeBase):
        self.kb = knowledge_base
        
    def create_treatment_plan(self, patient: PatientData, 
                            diagnosis: DiagnosisResult) -> TreatmentPlan:
        """Vytv√°≈ô√≠ personalizovan√Ω l√©ƒçebn√Ω pl√°n"""
        
        primary_diagnosis = diagnosis.primary_diagnosis
        
        if primary_diagnosis not in self.kb.diseases_db:
            return self._create_generic_plan()
        
        disease_data = self.kb.diseases_db[primary_diagnosis]
        
        # V√Ωbƒõr vhodn√Ωch l√©k≈Ø
        recommended_medications = self._select_medications(
            disease_data["treatment"], 
            patient.allergies,
            patient.current_medications
        )
        
        # Generov√°n√≠ kompletn√≠ho pl√°nu
        return TreatmentPlan(
            medications=recommended_medications,
            procedures=self._recommend_procedures(primary_diagnosis),
            lifestyle_recommendations=self._generate_lifestyle_recommendations(primary_diagnosis),
            follow_up_schedule=self._create_follow_up_schedule(primary_diagnosis),
            warnings=self._generate_warnings(patient, recommended_medications)
        )
    
    def _select_medications(self, treatments: List[str], 
                          allergies: List[str], 
                          current_meds: List[str]) -> List[Dict]:
        """Vyb√≠r√° vhodn√© l√©ky s kontrolou alergi√≠ a interakc√≠"""
        selected_medications = []
        
        for treatment in treatments:
            for med_name, med_data in self.kb.medications_db.items():
                if treatment in med_data["indications"]:
                    # Kontrola alergi√≠
                    if not self._check_allergies(med_name, allergies):
                        continue
                    
                    # Kontrola interakc√≠
                    interactions = self._check_drug_interactions(med_name, current_meds)
                    
                    selected_medications.append({
                        "name": med_name,
                        "dosage": med_data["dosage"],
                        "class": med_data["class"],
                        "side_effects": med_data["side_effects"],
                        "interactions": interactions
                    })
                    break
        
        return selected_medications
    
    def _check_allergies(self, medication: str, allergies: List[str]) -> bool:
        """Kontroluje alergie na l√©ky"""
        if medication in self.kb.medications_db:
            med_data = self.kb.medications_db[medication]
            return not any(allergy in med_data["contraindications"] for allergy in allergies)
        return True
    
    def _check_drug_interactions(self, new_medication: str, 
                               current_medications: List[str]) -> List[Dict]:
        """Kontroluje l√©kov√© interakce"""
        interactions = []
        
        for current_med in current_medications:
            interaction_key = (new_medication, current_med)
            reverse_key = (current_med, new_medication)
            
            if interaction_key in self.kb.interactions_db:
                interactions.append(self.kb.interactions_db[interaction_key])
            elif reverse_key in self.kb.interactions_db:
                interactions.append(self.kb.interactions_db[reverse_key])
        
        return interactions
    
    def _recommend_procedures(self, diagnosis: str) -> List[str]:
        """Doporuƒçuje procedury na z√°kladƒõ diagn√≥zy"""
        procedure_map = {
            "hypertension": ["Blood pressure monitoring", "ECG", "Blood tests"],
            "diabetes_type2": ["HbA1c test", "Blood glucose monitoring", "Eye exam"],
            "pneumonia": ["Chest X-ray", "Blood culture", "Pulse oximetry"],
            "appendicitis": ["CT scan", "Blood tests", "Surgical consultation"]
        }
        return procedure_map.get(diagnosis, ["Basic physical examination"])
    
    def _generate_lifestyle_recommendations(self, diagnosis: str) -> List[str]:
        """Generuje doporuƒçen√≠ pro zmƒõny ≈æivotn√≠ho stylu"""
        lifestyle_map = {
            "hypertension": ["Reduce sodium intake", "Regular exercise", "Weight management"],
            "diabetes_type2": ["Diabetic diet", "Regular exercise", "Blood sugar monitoring"],
            "pneumonia": ["Rest", "Increase fluid intake", "Avoid smoking"],
            "appendicitis": ["Fasting before surgery", "Gradual return to normal diet"]
        }
        return lifestyle_map.get(diagnosis, ["Maintain healthy lifestyle"])
    
    def _create_follow_up_schedule(self, diagnosis: str) -> List[str]:
        """Vytv√°≈ô√≠ pl√°n follow-up kontrol"""
        schedule_map = {
            "hypertension": ["2 weeks", "1 month", "3 months"],
            "diabetes_type2": ["1 week", "1 month", "3 months"],
            "pneumonia": ["3 days", "1 week", "2 weeks"],
            "appendicitis": ["1 week post-op", "2 weeks post-op", "6 weeks post-op"]
        }
        return schedule_map.get(diagnosis, ["1 month"])
    
    def _generate_warnings(self, patient: PatientData, medications: List[Dict]) -> List[str]:
        """Generuje varov√°n√≠ a upozornƒõn√≠"""
        warnings = []
        
        for med in medications:
            if med["interactions"]:
                for interaction in med["interactions"]:
                    warnings.append(f"Pozor na interakci {med['name']}: {interaction['description']}")
        
        # Vƒõkovƒõ specifick√° varov√°n√≠
        if patient.age > 65:
            warnings.append("Star≈°√≠ pacient - zv√Ω≈°en√© riziko ne≈æ√°douc√≠ch √∫ƒçink≈Ø")
        
        return warnings
    
    def _create_generic_plan(self) -> TreatmentPlan:
        """Vytv√°≈ô√≠ obecn√Ω pl√°n pro nezn√°m√© diagn√≥zy"""
        return TreatmentPlan(
            medications=[],
            procedures=["Dal≈°√≠ diagnostick√© vy≈°et≈ôen√≠"],
            lifestyle_recommendations=["Konzultace se specialistou"],
            follow_up_schedule=["1 t√Ωden"],
            warnings=["Nezn√°m√° diagn√≥za - nutn√° dal≈°√≠ diagnostika"]
        )

# Agent pro kontrolu l√©kov√Ωch interakc√≠
class DrugInteractionAgent:
    def __init__(self, knowledge_base: MedicalKnowledgeBase):
        self.kb = knowledge_base
        
    def comprehensive_interaction_check(self, medications: List[Dict], 
                                      patient: PatientData) -> Dict:
        """Prov√°d√≠ komplexn√≠ kontrolu l√©kov√Ωch interakc√≠"""
        
        results = {
            "drug_interactions": [],
            "contraindications": [],
            "dosage_adjustments": [],
            "monitoring_requirements": []
        }
        
        # Kontrola p√°rov√Ωch interakc√≠
        med_names = [med["name"] for med in medications]
        
        for i, med1 in enumerate(med_names):
            for j, med2 in enumerate(med_names[i+1:], i+1):
                interaction = self._check_pair_interaction(med1, med2)
                if interaction:
                    results["drug_interactions"].append(interaction)
        
        # Kontrola kontraindikac√≠
        for med in medications:
            contraindications = self._check_contraindications(med, patient)
            results["contraindications"].extend(contraindications)
        
        # Doporuƒçen√≠ pro adjustaci d√°vek
        dosage_adjustments = self._assess_dosage_adjustments(medications, patient)
        results["dosage_adjustments"] = dosage_adjustments
        
        # Po≈æadavky na monitoring
        monitoring = self._determine_monitoring_requirements(medications, patient)
        results["monitoring_requirements"] = monitoring
        
        return results
    
    def _check_pair_interaction(self, med1: str, med2: str) -> Optional[Dict]:
        """Kontroluje interakci mezi dvƒõma l√©ky"""
        interaction_key = (med1, med2)
        reverse_key = (med2, med1)
        
        if interaction_key in self.kb.interactions_db:
            return {
                "medications": [med1, med2],
                "interaction": self.kb.interactions_db[interaction_key]
            }
        elif reverse_key in self.kb.interactions_db:
            return {
                "medications": [med1, med2],
                "interaction": self.kb.interactions_db[reverse_key]
            }
        
        return None
    
    def _check_contraindications(self, medication: Dict, patient: PatientData) -> List[Dict]:
        """Kontroluje kontraindikace l√©ku pro konkr√©tn√≠ho pacienta"""
        contraindications = []
        med_name = medication["name"]
        
        if med_name in self.kb.medications_db:
            med_data = self.kb.medications_db[med_name]
            
            for contraindication in med_data["contraindications"]:
                if contraindication in patient.allergies or contraindication in patient.medical_history:
                    contraindications.append({
                        "medication": med_name,
                        "contraindication": contraindication,
                        "reason": f"Pacient m√° v anamn√©ze: {contraindication}"
                    })
        
        return contraindications
    
    def _assess_dosage_adjustments(self, medications: List[Dict], 
                                 patient: PatientData) -> List[Dict]:
        """Posuzuje pot≈ôebu adjustace d√°vek"""
        adjustments = []
        
        # Adjustace podle vƒõku
        if patient.age > 65:
            for med in medications:
                adjustments.append({
                    "medication": med["name"],
                    "adjustment": "Sn√≠≈æit d√°vku o 25-50% u star≈°√≠ch pacient≈Ø",
                    "reason": "Vƒõk > 65 let"
                })
        
        return adjustments
    
    def _determine_monitoring_requirements(self, medications: List[Dict], 
                                         patient: PatientData) -> List[Dict]:
        """Urƒçuje po≈æadavky na monitoring"""
        monitoring = []
        
        for med in medications:
            med_name = med["name"]
            
            # Specifick√© monitoring pro r≈Øzn√© l√©ky
            if med_name == "metformin":
                monitoring.append({
                    "medication": med_name,
                    "parameter": "Kidney function",
                    "frequency": "Every 6 months",
                    "reason": "Risk of lactic acidosis"
                })
            elif med_name == "lisinopril":
                monitoring.append({
                    "medication": med_name,
                    "parameter": "Potassium levels",
                    "frequency": "Every 3 months",
                    "reason": "Risk of hyperkalemia"
                })
        
        return monitoring

# Hlavn√≠ orchestr√°tor syst√©mu
class HealthcareMultiAgentSystem:
    def __init__(self):
        self.knowledge_base = MedicalKnowledgeBase()
        self.symptom_agent = SymptomAnalysisAgent(self.knowledge_base)
        self.diagnostic_agent = DiagnosticAgent(self.knowledge_base)
        self.treatment_agent = TreatmentPlanningAgent(self.knowledge_base)
        self.interaction_agent = DrugInteractionAgent(self.knowledge_base)
        
    def process_patient_case(self, patient: PatientData) -> Dict:
        """Zpracov√°v√° kompletn√≠ pacientsk√Ω p≈ô√≠pad"""
        
        try:
            # Krok 1: Anal√Ωza symptom≈Ø
            print(f"Analyzuji symptomy pro pacienta {patient.patient_id}...")
            symptom_analysis = self.symptom_agent.analyze_symptoms(patient)
            
            # Krok 2: Diagnostika
            print("Generuji diferenci√°ln√≠ diagnostiku...")
            diagnosis = self.diagnostic_agent.generate_diagnosis(patient, symptom_analysis)
            
            # Krok 3: Pl√°nov√°n√≠ l√©ƒçby
            print("Vytv√°≈ô√≠m l√©ƒçebn√Ω pl√°n...")
            treatment_plan = self.treatment_agent.create_treatment_plan(patient, diagnosis)
            
            # Krok 4: Kontrola l√©kov√Ωch interakc√≠
            print("Kontroluji l√©kov√© interakce...")
            interaction_check = self.interaction_agent.comprehensive_interaction_check(
                treatment_plan.medications, patient
            )
            
            # Krok 5: Fin√°ln√≠ doporuƒçen√≠
            final_recommendations = self._generate_final_recommendations(
                symptom_analysis, diagnosis, treatment_plan, interaction_check
            )
            
            return {
                "patient_id": patient.patient_id,
                "timestamp": datetime.now().isoformat(),
                "symptom_analysis": symptom_analysis,
                "diagnosis": diagnosis,
                "treatment_plan": treatment_plan,
                "interaction_check": interaction_check,
                "final_recommendations": final_recommendations,
                "status": "completed"
            }
            
        except Exception as e:
            return {
                "patient_id": patient.patient_id,
                "timestamp": datetime.now().isoformat(),
                "error": str(e),
                "status": "failed"
            }
    
    def _generate_final_recommendations(self, symptom_analysis: Dict, 
                                      diagnosis: DiagnosisResult,
                                      treatment_plan: TreatmentPlan,
                                      interaction_check: Dict) -> Dict:
        """Generuje fin√°ln√≠ doporuƒçen√≠"""
        
        recommendations = {
            "immediate_actions": [],
            "medication_changes": [],
            "follow_up_priorities": [],
            "patient_education": []
        }
        
        # Okam≈æit√© akce na z√°kladƒõ z√°va≈ænosti
        if symptom_analysis["overall_severity"] in ["high", "critical"]:
            recommendations["immediate_actions"].append("Urgentn√≠ l√©ka≈ôsk√© vy≈°et≈ôen√≠")
        
        # Zmƒõny medikace na z√°kladƒõ interakc√≠
        if interaction_check["drug_interactions"]:
            recommendations["medication_changes"].append("Revize medikace kv≈Øli interakc√≠m")
        
        # Priority follow-up
        recommendations["follow_up_priorities"] = treatment_plan.follow_up_schedule[:2]
        
        # Edukace pacienta
        recommendations["patient_education"] = treatment_plan.lifestyle_recommendations
        
        return recommendations

# Demonstraƒçn√≠ pou≈æit√≠
def main():
    """Demonstrace funkcionalnosti syst√©mu"""
    
    # Inicializace syst√©mu
    system = HealthcareMultiAgentSystem()
    
    # Testovac√≠ pacientsk√Ω p≈ô√≠pad
    test_patient = PatientData(
        patient_id="PAT_001",
        age=45,
        gender="male",
        symptoms=["chest_pain", "shortness_of_breath", "fatigue"],
        medical_history=["hypertension", "smoking"],
        current_medications=["lisinopril"],
        allergies=["penicillin"],
        vital_signs={
            "blood_pressure_systolic": 150,
            "blood_pressure_diastolic": 95,
            "heart_rate": 85,
            "temperature": 36.8,
            "oxygen_saturation": 97
        }
    )
    
    # Zpracov√°n√≠ p≈ô√≠padu
    print("=== HEALTHCARE MULTI-AGENT SYSTEM ===")
    print(f"Zpracov√°v√°m p≈ô√≠pad pacienta: {test_patient.patient_id}")
    print(f"Vƒõk: {test_patient.age}, Pohlav√≠: {test_patient.gender}")
    print(f"Symptomy: {', '.join(test_patient.symptoms)}")
    print("=" * 50)
    
    results = system.process_patient_case(test_patient)
    
    # V√Ωpis v√Ωsledk≈Ø
    if results["status"] == "completed":
        print("\nüìä ANAL√ùZA SYMPTOM≈Æ:")
        symptom_analysis = results["symptom_analysis"]
        print(f"Celkov√° z√°va≈ænost: {symptom_analysis['overall_severity']}")
        print(f"Doporuƒçen√° urgence: {symptom_analysis['recommended_urgency']}")
        print(f"Red flags: {symptom_analysis['red_flags']}")
        
        print("\nüîç DIAGNOSTICK√â V√ùSLEDKY:")
        diagnosis = results["diagnosis"]
        print(f"Prim√°rn√≠ diagn√≥za: {diagnosis.primary_diagnosis}")
        print(f"Spolehlivost: {diagnosis.confidence_score:.2f}")
        print(f"Diferenci√°ln√≠ dg.: {', '.join(diagnosis.differential_diagnoses)}")
        
        print("\nüíä L√âƒåEBN√ù PL√ÅN:")
        treatment = results["treatment_plan"]
        print("Medikace:")
        for med in treatment.medications:
            print(f"  - {med['name']} ({med['dosage']})")
        
        print("\n‚ö†Ô∏è KONTROLA INTERAKC√ç:")
        interactions = results["interaction_check"]
        if interactions["drug_interactions"]:
            for interaction in interactions["drug_interactions"]:
                print(f"  - {interaction['interaction']['description']}")
        else:
            print("  - ≈Ω√°dn√© v√Ωznamn√© interakce")
        
        print("\nüìã FIN√ÅLN√ç DOPORUƒåEN√ç:")
        final_recs = results["final_recommendations"]
        for category, items in final_recs.items():
            if items:
                print(f"  {category}: {', '.join(items)}")
    
    else:
        print(f"‚ùå Chyba p≈ôi zpracov√°n√≠: {results.get('error', 'Nezn√°m√° chyba')}")

if __name__ == "__main__":
    main()
````

### API Rozhran√≠ s FastAPI

````python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Optional
import uvicorn
from healthcare_agent_system import HealthcareMultiAgentSystem, PatientData

app = FastAPI(
    title="Healthcare Multi-Agent System API",
    description="AI-powered healthcare diagnosis and treatment planning",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Glob√°ln√≠ instance syst√©mu
healthcare_system = HealthcareMultiAgentSystem()

# Pydantic modely pro API
class PatientRequest(BaseModel):
    patient_id: str
    age: int
    gender: str
    symptoms: List[str]
    medical_history: List[str] = []
    current_medications: List[str] = []
    allergies: List[str] = []
    vital_signs: Dict[str, float] = {}

class HealthcareResponse(BaseModel):
    patient_id: str
    timestamp: str
    symptom_analysis: Dict
    diagnosis: Dict
    treatment_plan: Dict
    interaction_check: Dict
    final_recommendations: Dict
    status: str

@app.get("/")
async def root():
    return {"message": "Healthcare Multi-Agent System API", "version": "1.0.0"}

@app.post("/analyze-patient", response_model=HealthcareResponse)
async def analyze_patient(patient_request: PatientRequest):
    """Analyzuje pacientsk√Ω p≈ô√≠pad pomoc√≠ multi-agent syst√©mu"""
    
    try:
        # Konverze na intern√≠ datov√Ω model
        patient = PatientData(
            patient_id=patient_request.patient_id,
            age=patient_request.age,
            gender=patient_request.gender,
            symptoms=patient_request.symptoms,
            medical_history=patient_request.medical_history,
            current_medications=patient_request.current_medications,
            allergies=patient_request.allergies,
            vital_signs=patient_request.vital_signs
        )
        
        # Zpracov√°n√≠ pomoc√≠ multi-agent syst√©mu
        results = healthcare_system.process_patient_case(patient)
        
        if results["status"] == "failed":
            raise HTTPException(status_code=500, detail=results.get("error"))
        
        return HealthcareResponse(**results)
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "healthcare-agent-system"}

@app.get("/knowledge-base/symptoms")
async def get_symptoms():
    """Vrac√≠ dostupn√© symptomy v datab√°zi"""
    return {"symptoms": list(healthcare_system.knowledge_base.symptoms_db.keys())}

@app.get("/knowledge-base/diseases")
async def get_diseases():
    """Vrac√≠ dostupn√© nemoci v datab√°zi"""
    return {"diseases": list(healthcare_system.knowledge_base.diseases_db.keys())}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### Streamlit Dashboard

````python
import streamlit as st
import requests
import json
import pandas as pd
from datetime import datetime
from healthcare_agent_system import PatientData, HealthcareMultiAgentSystem

# Konfigurace str√°nky
st.set_page_config(
    page_title="Healthcare Multi-Agent System",
    page_icon="üè•",
    layout="wide"
)

# Inicializace syst√©mu
@st.cache_resource
def get_healthcare_system():
    return HealthcareMultiAgentSystem()

def main():
    st.title("üè• Healthcare Multi-Agent System")
    st.subtitle("AI-powered Diagnosis and Treatment Planning")
    
    # Sidebar pro vstupn√≠ data
    with st.sidebar:
        st.header("üìù Patient Information")
        
        patient_id = st.text_input("Patient ID", value="PAT_001")
        age = st.number_input("Age", min_value=1, max_value=120, value=45)
        gender = st.selectbox("Gender", ["male", "female", "other"])
        
        st.subheader("Symptoms")
        available_symptoms = [
            "fever", "headache", "chest_pain", "shortness_of_breath",
            "abdominal_pain", "fatigue", "nausea", "dizziness"
        ]
        selected_symptoms = st.multiselect("Select symptoms", available_symptoms)
        
        st.subheader("Medical History")
        medical_history = st.text_area("Medical history (comma-separated)")
        medical_history_list = [item.strip() for item in medical_history.split(",") if item.strip()]
        
        st.subheader("Current Medications")
        current_meds = st.text_area("Current medications (comma-separated)")
        current_meds_list = [item.strip() for item in current_meds.split(",") if item.strip()]
        
        st.subheader("Allergies")
        allergies = st.text_area("Allergies (comma-separated)")
        allergies_list = [item.strip() for item in allergies.split(",") if item.strip()]
        
        st.subheader("Vital Signs")
        bp_systolic = st.number_input("BP Systolic", value=120)
        bp_diastolic = st.number_input("BP Diastolic", value=80)
        heart_rate = st.number_input("Heart Rate", value=75)
        temperature = st.number_input("Temperature (¬∞C)", value=36.5)
        o2_saturation = st.number_input("O2 Saturation (%)", value=98)
        
        analyze_button = st.button("üîç Analyze Patient", type="primary")
    
    # Hlavn√≠ obsah
    if analyze_button and selected_symptoms:
        # P≈ô√≠prava dat
        patient_data = PatientData(
            patient_id=patient_id,
            age=age,
            gender=gender,
            symptoms=selected_symptoms,
            medical_history=medical_history_list,
            current_medications=current_meds_list,
            allergies=allergies_list,
            vital_signs={
                "blood_pressure_systolic": bp_systolic,
                "blood_pressure_diastolic": bp_diastolic,
                "heart_rate": heart_rate,
                "temperature": temperature,
                "oxygen_saturation": o2_saturation
            }
        )
        
        # Anal√Ωza pomoc√≠ syst√©mu
        with st.spinner("Analyzing patient case..."):
            system = get_healthcare_system()
            results = system.process_patient_case(patient_data)
        
        if results["status"] == "completed":
            # V√Ωsledky v tab layoutu
            tab1, tab2, tab3, tab4, tab5 = st.tabs([
                "üìä Symptom Analysis", 
                "üîç Diagnosis", 
                "üíä Treatment Plan",
                "‚ö†Ô∏è Drug Interactions",
                "üìã Recommendations"
            ])
            
            with tab1:
                st.header("Symptom Analysis Results")
                symptom_analysis = results["symptom_analysis"]
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Overall Severity", symptom_analysis["overall_severity"])
                with col2:
                    st.metric("Recommended Urgency", symptom_analysis["recommended_urgency"])
                with col3:
                    st.metric("Red Flags", len(symptom_analysis["red_flags"]))
                
                if symptom_analysis["red_flags"]:
                    st.error(f"‚ö†Ô∏è Red flags detected: {', '.join(symptom_analysis['red_flags'])}")
                
                # Detail symptom≈Ø
                st.subheader("Individual Symptom Analysis")
                symptom_df = pd.DataFrame.from_dict(
                    symptom_analysis["individual_symptoms"], 
                    orient="index"
                )
                st.dataframe(symptom_df)
            
            with tab2:
                st.header("Diagnostic Results")
                diagnosis = results["diagnosis"]
                
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("Primary Diagnosis", diagnosis.primary_diagnosis)
                    st.metric("Confidence Score", f"{diagnosis.confidence_score:.2%}")
                
                with col2:
                    st.subheader("Differential Diagnoses")
                    for i, dd in enumerate(diagnosis.differential_diagnoses, 1):
                        st.write(f"{i}. {dd}")
                
                st.subheader("Supporting Evidence")
                for evidence in diagnosis.supporting_evidence:
                    st.write(f"‚Ä¢ {evidence}")
            
            with tab3:
                st.header("Treatment Plan")
                treatment = results["treatment_plan"]
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üíä Medications")
                    for med in treatment.medications:
                        st.write(f"**{med['name']}**")
                        st.write(f"- Dosage: {med['dosage']}")
                        st.write(f"- Class: {med['class']}")
                        st.write("---")
                    
                    st.subheader("üî¨ Procedures")
                    for proc in treatment.procedures:
                        st.write(f"‚Ä¢ {proc}")
                
                with col2:
                    st.subheader("üèÉ Lifestyle Recommendations")
                    for rec in treatment.lifestyle_recommendations:
                        st.write(f"‚Ä¢ {rec}")
                    
                    st.subheader("üìÖ Follow-up Schedule")
                    for follow_up in treatment.follow_up_schedule:
                        st.write(f"‚Ä¢ {follow_up}")
                
                if treatment.warnings:
                    st.subheader("‚ö†Ô∏è Warnings")
                    for warning in treatment.warnings:
                        st.warning(warning)
            
            with tab4:
                st.header("Drug Interaction Analysis")
                interactions = results["interaction_check"]
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Drug-Drug Interactions")
                    if interactions["drug_interactions"]:
                        for interaction in interactions["drug_interactions"]:
                            interaction_data = interaction["interaction"]
                            severity = interaction_data["severity"]
                            description = interaction_data["description"]
                            
                            if severity == "high":
                                st.error(f"üî¥ {description}")
                            elif severity == "moderate":
                                st.warning(f"üü° {description}")
                            else:
                                st.info(f"üîµ {description}")
                    else:
                        st.success("‚úÖ No significant drug interactions found")
                    
                    st.subheader("Contraindications")
                    if interactions["contraindications"]:
                        for contra in interactions["contraindications"]:
                            st.error(f"‚ùå {contra['medication']}: {contra['reason']}")
                    else:
                        st.success("‚úÖ No contraindications found")
                
                with col2:
                    st.subheader("Dosage Adjustments")
                    if interactions["dosage_adjustments"]:
                        for adjustment in interactions["dosage_adjustments"]:
                            st.info(f"üìè {adjustment['medication']}: {adjustment['adjustment']}")
                    
                    st.subheader("Monitoring Requirements")
                    if interactions["monitoring_requirements"]:
                        for monitor in interactions["monitoring_requirements"]:
                            st.write(f"**{monitor['medication']}**")
                            st.write(f"- Parameter: {monitor['parameter']}")
                            st.write(f"- Frequency: {monitor['frequency']}")
                            st.write(f"- Reason: {monitor['reason']}")
                            st.write("---")
            
            with tab5:
                st.header("Final Recommendations")
                final_recs = results["final_recommendations"]
                
                for category, items in final_recs.items():
                    if items:
                        st.subheader(category.replace("_", " ").title())
                        for item in items:
                            st.write(f"‚Ä¢ {item}")
                
                # Download results
                st.subheader("üì• Export Results")
                results_json = json.dumps(results, indent=2, default=str)
                st.download_button(
                    label="Download Results (JSON)",
                    data=results_json,
                    file_name=f"healthcare_analysis_{patient_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                    mime="application/json"
                )
        
        else:
            st.error(f"‚ùå Analysis failed: {results.get('error', 'Unknown error')}")
    
    elif analyze_button and not selected_symptoms:
        st.warning("‚ö†Ô∏è Please select at least one symptom to analyze.")
    
    # Informaƒçn√≠ sekce
    if not analyze_button:
        st.header("ü§ñ About Healthcare Multi-Agent System")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.subheader("Symptom Analysis")
            st.write("AI-powered analysis of patient symptoms with severity assessment and urgency determination.")
        
        with col2:
            st.subheader("Diagnostic Support")
            st.write("Evidence-based differential diagnosis generation using medical knowledge bases.")
        
        with col3:
            st.subheader("Treatment Planning")
            st.write("Personalized treatment recommendations with drug interaction checking and safety monitoring.")
        
        st.header("üîß System Features")
        
        features = {
            "Multi-Agent Architecture": "Specialized agents for different medical domains",
            "Drug Interaction Checking": "Comprehensive medication safety analysis",
            "Evidence-Based Medicine": "Integration of clinical guidelines and research",
            "Personalized Care": "Patient-specific recommendations and contraindications",
            "Real-time Processing": "Fast analysis for clinical decision support",
            "Safety Monitoring": "Continuous risk assessment and warning generation"
        }
        
        for feature, description in features.items():
            st.write(f"**{feature}**: {description}")

if __name__ == "__main__":
    main()
````

## 5. Shrnut√≠ Projektu

### Hodnota Projektu
Healthcare Multi-Agent System p≈ôedstavuje revoluƒçn√≠ p≈ô√≠stup k podpo≈ôe klinick√©ho rozhodov√°n√≠ pomoc√≠ umƒõl√© inteligence. Syst√©m kombinuje s√≠lu specializovan√Ωch AI agent≈Ø s rozs√°hl√Ωmi medic√≠nsk√Ωmi znalostmi pro poskytov√°n√≠ evidence-based doporuƒçen√≠.

### Kl√≠ƒçov√© P≈ô√≠nosy
- **Zlep≈°en√≠ diagnostick√© p≈ôesnosti**: AI-powered anal√Ωza symptom≈Ø a diferenci√°ln√≠ diagnostika
- **Bezpeƒçnost medikace**: Komplexn√≠ kontrola l√©kov√Ωch interakc√≠ a kontraindikac√≠  
- **Personalizovan√° p√©ƒçe**: Individualizovan√© l√©ƒçebn√© pl√°ny na z√°kladƒõ pacientsk√Ωch charakteristik
- **Efektivita**: Urychlen√≠ diagnostick√Ωch a terapeutick√Ωch proces≈Ø
- **Vzdƒõl√°v√°n√≠**: Podpora m√©nƒõ zku≈°en√Ωch l√©ka≈ô≈Ø s evidenc√≠ a od≈Øvodnƒõn√≠m

### Technologick√© Inovace
- **Multi-agent architektura** pro specializovan√© medic√≠nsk√© dom√©ny
- **Knowledge base integration** s medic√≠nskimi datab√°zemi
- **Real-time safety monitoring** pro kontinu√°ln√≠ rizikov√© hodnocen√≠
- **Scalable vector databases** pro efektivn√≠ vyhled√°v√°n√≠ medic√≠nsk√Ωch informac√≠
- **API-first design** pro snadnou integraci do existuj√≠c√≠ch healthcare syst√©m≈Ø

### Budouc√≠ Smƒõ≈ôov√°n√≠
Syst√©m p≈ôedstavuje z√°klad pro pokroƒçilej≈°√≠ healthcare AI aplikace vƒçetnƒõ prediktivn√≠ anal√Ωzy, populaƒçn√≠ho zdrav√≠ a precision medicine. Integrace s elektronick√Ωmi zdravotn√≠mi z√°znamy a IoT za≈ô√≠zen√≠mi otev√≠r√° mo≈ænosti pro kontinu√°ln√≠ monitoring a preventivn√≠ p√©ƒçi.