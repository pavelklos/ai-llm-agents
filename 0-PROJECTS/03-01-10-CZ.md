<small>Claude Sonnet 4 **(Syst√©m Inteligence Realitn√≠ch Nemovitost√≠ (Real Estate Property Intelligence System))**</small>
# Real Estate Property Intelligence System

## Kl√≠ƒçov√© Koncepty

### RAG (Retrieval-Augmented Generation)
Architektura kombinuj√≠c√≠ vyhled√°v√°n√≠ relevantn√≠ch informac√≠ z datab√°ze znalost√≠ s generativn√≠ AI pro vytv√°≈ôen√≠ p≈ôesn√Ωch a kontextu√°ln√≠ch odpovƒõd√≠ na dotazy o nemovitostech.

### Property Listings (V√Ωpisy Nemovitost√≠)
Strukturovan√° data o nemovitostech obsahuj√≠c√≠ informace jako cena, lokace, velikost, typ, vybaven√≠ a historick√© √∫daje o prodeji.

### Market Reports (Tr≈æn√≠ Zpr√°vy)
Analytick√© dokumenty poskytuj√≠c√≠ p≈ôehledy o trendech trhu nemovitost√≠, cenov√Ωch zmƒõn√°ch a progn√≥z√°ch pro r≈Øzn√© oblasti.

### Neighborhood Data (Data o ƒåtvrt√≠ch)
Demografick√©, ekonomick√© a soci√°ln√≠ informace o lokalit√°ch, vƒçetnƒõ ≈°kol, dopravy, bezpeƒçnosti a slu≈æeb.

### Geospatial Search (Geoprostorov√© Vyhled√°v√°n√≠)
Vyhled√°v√°n√≠ zalo≈æen√© na geografick√Ωch sou≈ôadnic√≠ch umo≈æ≈àuj√≠c√≠ nalezen√≠ nemovitost√≠ podle vzd√°lenosti, oblasti nebo prostorov√Ωch vztah≈Ø.

### PostGIS
PostgreSQL roz≈°√≠≈ôen√≠ pro pr√°ci s geoprostorov√Ωmi daty, umo≈æ≈àuj√≠c√≠ efektivn√≠ ukl√°d√°n√≠ a dotazov√°n√≠ geografick√Ωch informac√≠.

### Location Embeddings (Lokaƒçn√≠ Vektorov√© Reprezentace)
Vektorov√© reprezentace geografick√Ωch lokac√≠ zachycuj√≠c√≠ s√©mantick√© vztahy mezi m√≠sty pro podobnostn√≠ vyhled√°v√°n√≠.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

Syst√©m Inteligence Realitn√≠ch Nemovitost√≠ je pokroƒçil√° RAG aplikace navr≈æen√° pro poskytov√°n√≠ komplexn√≠ch a kontextu√°ln√≠ch informac√≠ o realitn√≠m trhu. Projekt ≈ôe≈°√≠ hlavn√≠ v√Ωzvy v oblasti nemovitost√≠:

**Hlavn√≠ C√≠le:**
- Centralizace fragmentovan√Ωch realitn√≠ch dat
- Poskytov√°n√≠ inteligentn√≠ch doporuƒçen√≠ zalo≈æen√Ωch na AI
- Geoprostorov√° anal√Ωza a vizualizace trh≈Ø
- Prediktivn√≠ anal√Ωza cenov√Ωch trend≈Ø

**Kl√≠ƒçov√© V√Ωzvy:**
- Integrace heterogenn√≠ch datov√Ωch zdroj≈Ø
- Zpracov√°n√≠ geoprostorov√Ωch dat ve velk√©m mƒõ≈ô√≠tku
- Zaji≈°tƒõn√≠ aktu√°lnosti a p≈ôesnosti informac√≠
- ≈†k√°lovatelnost pro miliony nemovitost√≠

**Potenci√°ln√≠ Dopad:**
- Urychlen√≠ rozhodovac√≠ch proces≈Ø p≈ôi n√°kupu/prodeji
- Demokratizace p≈ô√≠stupu k pokroƒçil√Ωm tr≈æn√≠m anal√Ωz√°m
- Zlep≈°en√≠ transparentnosti realitn√≠ho trhu

## Komplexn√≠ Implementace v Pythonu

````python
langchain==0.1.0
langchain-openai==0.0.5
langchain-community==0.0.12
chromadb==0.4.22
psycopg2-binary==2.9.9
geopandas==0.14.2
folium==0.15.1
requests==2.31.0
pandas==2.1.4
numpy==1.24.3
streamlit==1.29.0
plotly==5.17.0
scikit-learn==1.3.2
openai==1.6.1
python-dotenv==1.0.0
fastapi==0.104.1
uvicorn==0.24.0
````

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    POSTGRES_URL = os.getenv("POSTGRES_URL", "postgresql://user:password@localhost:5432/realestate")
    CHROMA_PERSIST_DIR = "./chroma_db"
    ZILLOW_API_KEY = os.getenv("ZILLOW_API_KEY")
    
    # Geoprostorov√© nastaven√≠
    DEFAULT_RADIUS_KM = 5.0
    MAX_PROPERTIES_RETURN = 100
    
    # Embedding model
    EMBEDDING_MODEL = "text-embedding-3-small"
    CHAT_MODEL = "gpt-4-turbo-preview"

settings = Settings()
````

````python
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from geoalchemy2 import Geometry
import datetime

Base = declarative_base()

class Property(Base):
    __tablename__ = 'properties'
    
    id = Column(Integer, primary_key=True)
    address = Column(String(255), nullable=False)
    city = Column(String(100), nullable=False)
    state = Column(String(50), nullable=False)
    zip_code = Column(String(20))
    price = Column(Float)
    bedrooms = Column(Integer)
    bathrooms = Column(Float)
    square_feet = Column(Integer)
    property_type = Column(String(50))
    year_built = Column(Integer)
    listing_date = Column(DateTime, default=datetime.datetime.utcnow)
    description = Column(Text)
    geom = Column(Geometry('POINT'))
    is_active = Column(Boolean, default=True)

class Neighborhood(Base):
    __tablename__ = 'neighborhoods'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    city = Column(String(100), nullable=False)
    median_income = Column(Float)
    population = Column(Integer)
    crime_rate = Column(Float)
    school_rating = Column(Float)
    walkability_score = Column(Integer)
    geom = Column(Geometry('POLYGON'))

class MarketReport(Base):
    __tablename__ = 'market_reports'
    
    id = Column(Integer, primary_key=True)
    area = Column(String(100), nullable=False)
    report_date = Column(DateTime, default=datetime.datetime.utcnow)
    median_price = Column(Float)
    price_change_1m = Column(Float)
    price_change_6m = Column(Float)
    price_change_1y = Column(Float)
    inventory_count = Column(Integer)
    days_on_market = Column(Float)
    content = Column(Text)
````

````python
import pandas as pd
import numpy as np
import random
from datetime import datetime, timedelta
import json

class SampleDataGenerator:
    def __init__(self):
        self.cities = [
            {"name": "Praha", "lat": 50.0755, "lon": 14.4378},
            {"name": "Brno", "lat": 49.1951, "lon": 16.6068},
            {"name": "Ostrava", "lat": 49.8209, "lon": 18.2625},
            {"name": "Plze≈à", "lat": 49.7384, "lon": 13.3736},
            {"name": "Liberec", "lat": 50.7663, "lon": 15.0543}
        ]
        
        self.property_types = ["Byt", "Rodinn√Ω d≈Øm", "Kancel√°≈ô", "Obchodn√≠ prostor", "Gar√°≈æ"]
        self.neighborhoods = ["Centrum", "S√≠dli≈°tƒõ", "P≈ôedmƒõst√≠", "Nov√© mƒõsto", "Historick√© centrum"]
    
    def generate_properties(self, count=1000):
        properties = []
        
        for i in range(count):
            city = random.choice(self.cities)
            # N√°hodn√° pozice v okol√≠ mƒõsta (¬±0.1 stupnƒõ)
            lat = city["lat"] + random.uniform(-0.1, 0.1)
            lon = city["lon"] + random.uniform(-0.1, 0.1)
            
            property_type = random.choice(self.property_types)
            bedrooms = random.randint(1, 5) if property_type in ["Byt", "Rodinn√Ω d≈Øm"] else 0
            bathrooms = random.randint(1, 3) if property_type in ["Byt", "Rodinn√Ω d≈Øm"] else 1
            
            # Cena podle typu a lokace
            base_price = {
                "Byt": random.randint(2000000, 8000000),
                "Rodinn√Ω d≈Øm": random.randint(4000000, 15000000),
                "Kancel√°≈ô": random.randint(3000000, 12000000),
                "Obchodn√≠ prostor": random.randint(2500000, 10000000),
                "Gar√°≈æ": random.randint(300000, 800000)
            }[property_type]
            
            # Praha je dra≈æ≈°√≠
            if city["name"] == "Praha":
                base_price *= 1.5
            
            properties.append({
                "id": i + 1,
                "address": f"{random.choice(['Hlavn√≠', '≈†koln√≠', 'N√°dra≈æn√≠', 'Kosteln√≠', 'Zahradn√≠'])} {random.randint(1, 200)}",
                "city": city["name"],
                "state": "ƒåesk√° republika",
                "zip_code": f"{random.randint(100, 999)}{random.randint(10, 99)}",
                "price": base_price,
                "bedrooms": bedrooms,
                "bathrooms": bathrooms,
                "square_feet": random.randint(30, 300),
                "property_type": property_type,
                "year_built": random.randint(1960, 2023),
                "listing_date": datetime.now() - timedelta(days=random.randint(1, 90)),
                "description": f"Kr√°sn√Ω {property_type.lower()} v {city['name']}. V√Ωborn√° lokalita s dobrou dostupnost√≠.",
                "latitude": lat,
                "longitude": lon,
                "is_active": True
            })
        
        return pd.DataFrame(properties)
    
    def generate_neighborhoods(self):
        neighborhoods = []
        
        for city in self.cities:
            for i, neighborhood in enumerate(self.neighborhoods):
                neighborhoods.append({
                    "id": len(neighborhoods) + 1,
                    "name": neighborhood,
                    "city": city["name"],
                    "median_income": random.randint(25000, 80000),
                    "population": random.randint(5000, 50000),
                    "crime_rate": random.uniform(0.5, 5.0),
                    "school_rating": random.uniform(6.0, 10.0),
                    "walkability_score": random.randint(50, 100),
                    "latitude": city["lat"] + random.uniform(-0.05, 0.05),
                    "longitude": city["lon"] + random.uniform(-0.05, 0.05)
                })
        
        return pd.DataFrame(neighborhoods)
    
    def generate_market_reports(self):
        reports = []
        
        for city in self.cities:
            for i in range(6):  # 6 mƒõs√≠c≈Ø dat
                date = datetime.now() - timedelta(days=30 * i)
                median_price = random.randint(3000000, 8000000)
                
                if city["name"] == "Praha":
                    median_price *= 1.5
                
                content = f"""
                Tr≈æn√≠ zpr√°va pro {city['name']} - {date.strftime('%B %Y')}
                
                Medi√°nov√° cena nemovitost√≠ dos√°hla {median_price:,.0f} Kƒç, co≈æ p≈ôedstavuje 
                {"r≈Øst" if random.random() > 0.5 else "pokles"} oproti p≈ôedchoz√≠mu mƒõs√≠ci.
                
                Kl√≠ƒçov√© trendy:
                - Zv√Ω≈°en√° popt√°vka po energeticky √∫sporn√Ωch nemovitostech
                - Rostouc√≠ z√°jem o p≈ôedmƒõstsk√© lokality
                - Stabiln√≠ √∫rokov√© sazby podporuj√≠ investice
                
                Progn√≥za: Oƒçek√°v√°me {random.choice(["m√≠rn√Ω r≈Øst", "stabilitu", "korekci"])} 
                cen v p≈ô√≠≈°t√≠ch 3 mƒõs√≠c√≠ch.
                """
                
                reports.append({
                    "id": len(reports) + 1,
                    "area": city["name"],
                    "report_date": date,
                    "median_price": median_price,
                    "price_change_1m": random.uniform(-5.0, 8.0),
                    "price_change_6m": random.uniform(-10.0, 15.0),
                    "price_change_1y": random.uniform(-15.0, 25.0),
                    "inventory_count": random.randint(500, 3000),
                    "days_on_market": random.uniform(30, 120),
                    "content": content.strip()
                })
        
        return pd.DataFrame(reports)
    
    def save_all_data(self):
        """Generuje a ulo≈æ√≠ v≈°echna uk√°zkov√° data"""
        properties_df = self.generate_properties(1000)
        neighborhoods_df = self.generate_neighborhoods()
        reports_df = self.generate_market_reports()
        
        properties_df.to_csv("data/properties.csv", index=False)
        neighborhoods_df.to_csv("data/neighborhoods.csv", index=False)
        reports_df.to_csv("data/market_reports.csv", index=False)
        
        print("Uk√°zkov√° data byla √∫spƒõ≈°nƒõ vygenerov√°na a ulo≈æena!")
        return properties_df, neighborhoods_df, reports_df

if __name__ == "__main__":
    generator = SampleDataGenerator()
    generator.save_all_data()
````

````python
import chromadb
from chromadb.config import Settings as ChromaSettings
from langchain_openai import OpenAIEmbeddings
from langchain_community.vectorstores import Chroma
from langchain.schema import Document
import pandas as pd
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)

class PropertyVectorStore:
    def __init__(self, persist_directory: str, collection_name: str = "properties"):
        self.persist_directory = persist_directory
        self.collection_name = collection_name
        self.embeddings = OpenAIEmbeddings(model="text-embedding-3-small")
        self.vectorstore = None
        self._initialize_vectorstore()
    
    def _initialize_vectorstore(self):
        """Inicializuje Chroma vector store"""
        try:
            client_settings = ChromaSettings(
                persist_directory=self.persist_directory,
                is_persistent=True
            )
            
            self.vectorstore = Chroma(
                collection_name=self.collection_name,
                embedding_function=self.embeddings,
                persist_directory=self.persist_directory,
                client_settings=client_settings
            )
            logger.info("Vector store √∫spƒõ≈°nƒõ inicializov√°n")
        except Exception as e:
            logger.error(f"Chyba p≈ôi inicializaci vector store: {e}")
            raise
    
    def add_properties(self, properties_df: pd.DataFrame):
        """P≈ôid√° nemovitosti do vector store"""
        documents = []
        
        for _, property_data in properties_df.iterrows():
            # Vytvo≈ôen√≠ textov√© reprezentace nemovitosti
            content = self._create_property_text(property_data)
            
            metadata = {
                "property_id": str(property_data["id"]),
                "city": property_data["city"],
                "property_type": property_data["property_type"],
                "price": float(property_data["price"]),
                "bedrooms": int(property_data.get("bedrooms", 0)),
                "bathrooms": float(property_data.get("bathrooms", 0)),
                "square_feet": int(property_data.get("square_feet", 0)),
                "latitude": float(property_data.get("latitude", 0)),
                "longitude": float(property_data.get("longitude", 0))
            }
            
            doc = Document(page_content=content, metadata=metadata)
            documents.append(doc)
        
        # P≈ôid√°n√≠ dokument≈Ø do vector store
        self.vectorstore.add_documents(documents)
        logger.info(f"P≈ôid√°no {len(documents)} nemovitost√≠ do vector store")
    
    def add_market_reports(self, reports_df: pd.DataFrame):
        """P≈ôid√° tr≈æn√≠ zpr√°vy do vector store"""
        documents = []
        
        for _, report in reports_df.iterrows():
            content = f"""
            Tr≈æn√≠ zpr√°va: {report['area']}
            Datum: {report['report_date']}
            Medi√°nov√° cena: {report['median_price']:,.0f} Kƒç
            
            {report['content']}
            """
            
            metadata = {
                "type": "market_report",
                "area": report["area"],
                "report_date": str(report["report_date"]),
                "median_price": float(report["median_price"])
            }
            
            doc = Document(page_content=content.strip(), metadata=metadata)
            documents.append(doc)
        
        self.vectorstore.add_documents(documents)
        logger.info(f"P≈ôid√°no {len(documents)} tr≈æn√≠ch zpr√°v do vector store")
    
    def _create_property_text(self, property_data: Dict[str, Any]) -> str:
        """Vytvo≈ô√≠ textovou reprezentaci nemovitosti pro embedding"""
        text = f"""
        Adresa: {property_data['address']}, {property_data['city']}
        Typ nemovitosti: {property_data['property_type']}
        Cena: {property_data['price']:,.0f} Kƒç
        Pokoje: {property_data.get('bedrooms', 'N/A')}
        Koupelny: {property_data.get('bathrooms', 'N/A')}
        Plocha: {property_data.get('square_feet', 'N/A')} m¬≤
        Rok stavby: {property_data.get('year_built', 'N/A')}
        
        Popis: {property_data.get('description', 'Bez popisu')}
        """
        return text.strip()
    
    def similarity_search(self, query: str, k: int = 5, filters: Dict[str, Any] = None) -> List[Document]:
        """Vyhled√° podobn√© nemovitosti podle dotazu"""
        if filters:
            return self.vectorstore.similarity_search(query, k=k, filter=filters)
        return self.vectorstore.similarity_search(query, k=k)
    
    def similarity_search_with_location(self, query: str, lat: float, lon: float, 
                                      radius_km: float = 5.0, k: int = 5) -> List[Document]:
        """Vyhled√° nemovitosti s geografick√Ωm filtrem"""
        # Chroma nativnƒõ nepodporuje geografick√© dotazy, 
        # implementujeme jednoduch√Ω filtr vzd√°lenosti
        all_results = self.vectorstore.similarity_search(query, k=k*3)
        
        filtered_results = []
        for doc in all_results:
            if len(filtered_results) >= k:
                break
                
            doc_lat = doc.metadata.get("latitude", 0)
            doc_lon = doc.metadata.get("longitude", 0)
            
            distance = self._calculate_distance(lat, lon, doc_lat, doc_lon)
            if distance <= radius_km:
                doc.metadata["distance_km"] = distance
                filtered_results.append(doc)
        
        return filtered_results
    
    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """V√Ωpoƒçet vzd√°lenosti mezi dvƒõma body (Haversine formula)"""
        import math
        
        R = 6371  # polomƒõr Zemƒõ v km
        
        lat1_rad = math.radians(lat1)
        lat2_rad = math.radians(lat2)
        delta_lat = math.radians(lat2 - lat1)
        delta_lon = math.radians(lon2 - lon1)
        
        a = (math.sin(delta_lat/2) * math.sin(delta_lat/2) +
             math.cos(lat1_rad) * math.cos(lat2_rad) *
             math.sin(delta_lon/2) * math.sin(delta_lon/2))
        
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        distance = R * c
        
        return distance
````

````python
from langchain_openai import ChatOpenAI
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate
from langchain.schema import Document
from typing import List, Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

class RealEstateRAGEngine:
    def __init__(self, vector_store, model_name: str = "gpt-4-turbo-preview"):
        self.vector_store = vector_store
        self.llm = ChatOpenAI(model=model_name, temperature=0.1)
        self.qa_chain = self._create_qa_chain()
    
    def _create_qa_chain(self):
        """Vytvo≈ô√≠ QA ≈ôetƒõzec s custom promptem"""
        template = """
        Jste expertn√≠ realitn√≠ poradce s p≈ô√≠stupem k aktu√°ln√≠ datab√°zi nemovitost√≠ a tr≈æn√≠ch zpr√°v.
        Odpov√≠dejte v ƒçe≈°tinƒõ a poskytnƒõte konkr√©tn√≠, praktick√© a u≈æiteƒçn√© informace.
        
        Kontext: {context}
        
        Ot√°zka: {question}
        
        Instrukce:
        1. Analyzujte poskytnut√Ω kontext a identifikujte relevantn√≠ nemovitosti nebo informace
        2. Poskytnƒõte konkr√©tn√≠ doporuƒçen√≠ s uveden√≠m cen, lokalit a vlastnost√≠
        3. Pokud je to relevantn√≠, zahr≈àte tr≈æn√≠ trendy a progn√≥zy
        4. Buƒète konkr√©tn√≠ ohlednƒõ v√Ωhod a nev√Ωhod jednotliv√Ωch mo≈ænost√≠
        5. Pokud nem√°te dostatek informac√≠, jasnƒõ to uveƒète
        
        Odpovƒõƒè:
        """
        
        prompt = PromptTemplate(
            template=template,
            input_variables=["context", "question"]
        )
        
        return RetrievalQA.from_chain_type(
            llm=self.llm,
            chain_type="stuff",
            retriever=self.vector_store.vectorstore.as_retriever(search_kwargs={"k": 5}),
            chain_type_kwargs={"prompt": prompt},
            return_source_documents=True
        )
    
    def query(self, question: str, filters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Zpracuje dotaz pomoc√≠ RAG"""
        try:
            # Pokud jsou poskytnuty filtry, pou≈æije je pro vyhled√°v√°n√≠
            if filters:
                relevant_docs = self.vector_store.similarity_search(
                    question, k=5, filters=filters
                )
                context = "\n\n".join([doc.page_content for doc in relevant_docs])
                
                # Ruƒçn√≠ vytvo≈ôen√≠ odpovƒõdi s kontextem
                response = self._generate_response_with_context(question, context, relevant_docs)
            else:
                # Pou≈æit√≠ standardn√≠ho QA ≈ôetƒõzce
                result = self.qa_chain({"query": question})
                response = {
                    "answer": result["result"],
                    "source_documents": result["source_documents"]
                }
            
            return response
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi zpracov√°n√≠ dotazu: {e}")
            return {
                "answer": "Omlouv√°me se, p≈ôi zpracov√°n√≠ va≈°eho dotazu do≈°lo k chybƒõ.",
                "source_documents": []
            }
    
    def query_with_location(self, question: str, lat: float, lon: float, 
                          radius_km: float = 5.0) -> Dict[str, Any]:
        """Zpracuje geograficky omezen√Ω dotaz"""
        try:
            relevant_docs = self.vector_store.similarity_search_with_location(
                question, lat, lon, radius_km, k=5
            )
            
            context = "\n\n".join([doc.page_content for doc in relevant_docs])
            response = self._generate_response_with_context(question, context, relevant_docs)
            
            # P≈ôid√°n√≠ informace o geografick√©m omezen√≠
            if relevant_docs:
                distances = [doc.metadata.get("distance_km", 0) for doc in relevant_docs]
                response["geographic_info"] = {
                    "search_center": {"lat": lat, "lon": lon},
                    "radius_km": radius_km,
                    "found_properties": len(relevant_docs),
                    "closest_distance_km": min(distances) if distances else None
                }
            
            return response
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi geografick√©m dotazu: {e}")
            return {
                "answer": "Omlouv√°me se, p≈ôi zpracov√°n√≠ va≈°eho geografick√©ho dotazu do≈°lo k chybƒõ.",
                "source_documents": []
            }
    
    def _generate_response_with_context(self, question: str, context: str, 
                                      source_docs: List[Document]) -> Dict[str, Any]:
        """Generuje odpovƒõƒè s dan√Ωm kontextem"""
        prompt = f"""
        Jste expertn√≠ realitn√≠ poradce. Na z√°kladƒõ n√°sleduj√≠c√≠ho kontextu odpovƒõzte na ot√°zku v ƒçe≈°tinƒõ.
        
        Kontext:
        {context}
        
        Ot√°zka: {question}
        
        Poskytnƒõte konkr√©tn√≠, praktick√© doporuƒçen√≠ s uveden√≠m cen, lokalit a vlastnost√≠ nemovitost√≠.
        """
        
        response = self.llm.invoke(prompt)
        
        return {
            "answer": response.content,
            "source_documents": source_docs
        }
    
    def get_market_summary(self, city: str) -> Dict[str, Any]:
        """Z√≠sk√° shrnut√≠ trhu pro konkr√©tn√≠ mƒõsto"""
        question = f"Jak√° je aktu√°ln√≠ situace na realitn√≠m trhu v {city}? Poskytnƒõte shrnut√≠ cen, trend≈Ø a progn√≥z."
        
        filters = {"area": city}
        return self.query(question, filters)
    
    def find_similar_properties(self, property_description: str, max_price: Optional[float] = None) -> Dict[str, Any]:
        """Najde podobn√© nemovitosti podle popisu"""
        question = f"Najdƒõte nemovitosti podobn√© tomuto popisu: {property_description}"
        
        if max_price:
            question += f" s maxim√°ln√≠ cenou {max_price:,.0f} Kƒç"
        
        return self.query(question)
    
    def get_investment_advice(self, budget: float, investment_type: str = "dlouhodob√°") -> Dict[str, Any]:
        """Poskytne investiƒçn√≠ doporuƒçen√≠"""
        question = f"""
        Hled√°m investiƒçn√≠ p≈ô√≠le≈æitosti s rozpoƒçtem {budget:,.0f} Kƒç pro {investment_type} investici.
        Jak√© nemovitosti byste doporuƒçili a proƒç? Zahr≈àte anal√Ωzu v√Ωnosnosti a rizik.
        """
        
        return self.query(question)
````

````python
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
import uvicorn
import logging
from pathlib import Path
import sys

# P≈ôid√°n√≠ root slo≈æky do cesty
sys.path.append(str(Path(__file__).parent.parent))

from core.vector_store import PropertyVectorStore
from core.rag_engine import RealEstateRAGEngine
from data.sample_data_generator import SampleDataGenerator
from config.settings import settings
import pandas as pd

# Konfigurace logov√°n√≠
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Real Estate Intelligence API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Glob√°ln√≠ promƒõnn√©
vector_store = None
rag_engine = None

class PropertyQuery(BaseModel):
    question: str
    city: Optional[str] = None
    max_price: Optional[float] = None
    property_type: Optional[str] = None

class LocationQuery(BaseModel):
    question: str
    latitude: float
    longitude: float
    radius_km: float = 5.0

class InvestmentQuery(BaseModel):
    budget: float
    investment_type: str = "dlouhodob√°"
    preferred_cities: Optional[List[str]] = None

@app.on_event("startup")
async def startup_event():
    """Inicializace aplikace p≈ôi startu"""
    global vector_store, rag_engine
    
    try:
        logger.info("Inicializace Real Estate Intelligence API...")
        
        # Inicializace vector store
        vector_store = PropertyVectorStore(
            persist_directory=settings.CHROMA_PERSIST_DIR,
            collection_name="real_estate"
        )
        
        # Kontrola existence dat
        if not Path("data/properties.csv").exists():
            logger.info("Generov√°n√≠ uk√°zkov√Ωch dat...")
            generator = SampleDataGenerator()
            generator.save_all_data()
        
        # Naƒçten√≠ dat do vector store
        try:
            # Test, zda u≈æ jsou data v vector store
            test_search = vector_store.similarity_search("test", k=1)
            if not test_search:
                raise Exception("Pr√°zdn√Ω vector store")
        except:
            logger.info("Naƒç√≠t√°n√≠ dat do vector store...")
            properties_df = pd.read_csv("data/properties.csv")
            reports_df = pd.read_csv("data/market_reports.csv")
            
            vector_store.add_properties(properties_df)
            vector_store.add_market_reports(reports_df)
        
        # Inicializace RAG engine
        rag_engine = RealEstateRAGEngine(vector_store)
        
        logger.info("API √∫spƒõ≈°nƒõ inicializov√°no!")
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi inicializaci API: {e}")
        raise

@app.get("/")
async def root():
    """Z√°kladn√≠ endpoint"""
    return {
        "message": "Real Estate Intelligence API",
        "version": "1.0.0",
        "status": "running"
    }

@app.post("/query/")
async def query_properties(query: PropertyQuery):
    """Obecn√Ω dotaz na nemovitosti"""
    try:
        # Vytvo≈ôen√≠ filtr≈Ø
        filters = {}
        if query.city:
            filters["city"] = query.city
        if query.max_price:
            filters["price"] = {"$lte": query.max_price}
        if query.property_type:
            filters["property_type"] = query.property_type
        
        result = rag_engine.query(query.question, filters if filters else None)
        
        return {
            "success": True,
            "answer": result["answer"],
            "sources_count": len(result["source_documents"]),
            "query_params": {
                "city": query.city,
                "max_price": query.max_price,
                "property_type": query.property_type
            }
        }
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi zpracov√°n√≠ dotazu: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/query/location/")
async def query_by_location(query: LocationQuery):
    """Geograficky omezen√Ω dotaz"""
    try:
        result = rag_engine.query_with_location(
            question=query.question,
            lat=query.latitude,
            lon=query.longitude,
            radius_km=query.radius_km
        )
        
        return {
            "success": True,
            "answer": result["answer"],
            "sources_count": len(result["source_documents"]),
            "geographic_info": result.get("geographic_info", {}),
            "query_params": {
                "latitude": query.latitude,
                "longitude": query.longitude,
                "radius_km": query.radius_km
            }
        }
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi geografick√©m dotazu: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/market/{city}")
async def get_market_summary(city: str):
    """Z√≠sk√°n√≠ tr≈æn√≠ho shrnut√≠ pro mƒõsto"""
    try:
        result = rag_engine.get_market_summary(city)
        
        return {
            "success": True,
            "city": city,
            "market_summary": result["answer"],
            "sources_count": len(result["source_documents"])
        }
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ tr≈æn√≠ho shrnut√≠: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/investment/advice/")
async def get_investment_advice(query: InvestmentQuery):
    """Z√≠sk√°n√≠ investiƒçn√≠ho poradenstv√≠"""
    try:
        result = rag_engine.get_investment_advice(
            budget=query.budget,
            investment_type=query.investment_type
        )
        
        return {
            "success": True,
            "budget": query.budget,
            "investment_type": query.investment_type,
            "advice": result["answer"],
            "sources_count": len(result["source_documents"])
        }
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi poskytov√°n√≠ investiƒçn√≠ho poradenstv√≠: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/properties/search/")
async def search_properties(
    q: str = Query(..., description="Vyhled√°vac√≠ dotaz"),
    city: Optional[str] = Query(None, description="Mƒõsto"),
    min_price: Optional[float] = Query(None, description="Minim√°ln√≠ cena"),
    max_price: Optional[float] = Query(None, description="Maxim√°ln√≠ cena"),
    property_type: Optional[str] = Query(None, description="Typ nemovitosti"),
    limit: int = Query(5, description="Poƒçet v√Ωsledk≈Ø")
):
    """Vyhled√°v√°n√≠ nemovitost√≠ s filtry"""
    try:
        # Vytvo≈ôen√≠ filtr≈Ø
        filters = {}
        if city:
            filters["city"] = city
        if property_type:
            filters["property_type"] = property_type
        
        # Vyhled√°n√≠ podobn√Ωch nemovitost√≠
        documents = vector_store.similarity_search(q, k=limit, filters=filters if filters else None)
        
        # Filtrov√°n√≠ podle ceny
        filtered_docs = []
        for doc in documents:
            price = doc.metadata.get("price", 0)
            if min_price and price < min_price:
                continue
            if max_price and price > max_price:
                continue
            filtered_docs.append(doc)
        
        # Form√°tov√°n√≠ v√Ωsledk≈Ø
        results = []
        for doc in filtered_docs:
            results.append({
                "property_id": doc.metadata.get("property_id"),
                "city": doc.metadata.get("city"),
                "property_type": doc.metadata.get("property_type"),
                "price": doc.metadata.get("price"),
                "bedrooms": doc.metadata.get("bedrooms"),
                "bathrooms": doc.metadata.get("bathrooms"),
                "square_feet": doc.metadata.get("square_feet"),
                "description": doc.page_content[:200] + "..." if len(doc.page_content) > 200 else doc.page_content
            })
        
        return {
            "success": True,
            "query": q,
            "filters": {
                "city": city,
                "min_price": min_price,
                "max_price": max_price,
                "property_type": property_type
            },
            "results_count": len(results),
            "results": results
        }
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi vyhled√°v√°n√≠ nemovitost√≠: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health/")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "vector_store": "initialized" if vector_store else "not_initialized",
        "rag_engine": "initialized" if rag_engine else "not_initialized"
    }

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````python
import streamlit as st
import requests
import pandas as pd
import folium
from streamlit_folium import folium_static
import plotly.express as px
import plotly.graph_objects as go
from typing import Dict, Any
import logging

# Konfigurace str√°nky
st.set_page_config(
    page_title="Real Estate Intelligence",
    page_icon="üè†",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Konfigurace API
API_BASE_URL = "http://localhost:8000"

class RealEstateApp:
    def __init__(self):
        self.setup_sidebar()
    
    def setup_sidebar(self):
        """Nastaven√≠ postrann√≠ho panelu"""
        st.sidebar.title("üè† Real Estate Intelligence")
        st.sidebar.markdown("---")
        
        self.page = st.sidebar.selectbox(
            "Vyberte str√°nku:",
            ["üîç Vyhled√°v√°n√≠ nemovitost√≠", "üìä Tr≈æn√≠ anal√Ωza", "üí∞ Investiƒçn√≠ poradenstv√≠", "üó∫Ô∏è Geografick√© vyhled√°v√°n√≠"]
        )
    
    def run(self):
        """Hlavn√≠ metoda aplikace"""
        if self.page == "üîç Vyhled√°v√°n√≠ nemovitost√≠":
            self.property_search_page()
        elif self.page == "üìä Tr≈æn√≠ anal√Ωza":
            self.market_analysis_page()
        elif self.page == "üí∞ Investiƒçn√≠ poradenstv√≠":
            self.investment_advice_page()
        elif self.page == "üó∫Ô∏è Geografick√© vyhled√°v√°n√≠":
            self.geographic_search_page()
    
    def property_search_page(self):
        """Str√°nka pro vyhled√°v√°n√≠ nemovitost√≠"""
        st.title("üîç Vyhled√°v√°n√≠ nemovitost√≠")
        st.markdown("Zadejte sv≈Øj dotaz a najdƒõte ide√°ln√≠ nemovitost pomoc√≠ AI asistenta.")
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            question = st.text_area(
                "V√°≈° dotaz:",
                placeholder="Nap≈ô: Hled√°m dvoupokojov√Ω byt v Praze do 5 milion≈Ø korun s balkonem",
                height=100
            )
        
        with col2:
            st.subheader("Filtry")
            city = st.selectbox("Mƒõsto:", ["", "Praha", "Brno", "Ostrava", "Plze≈à", "Liberec"])
            max_price = st.number_input("Max. cena (Kƒç):", min_value=0, value=0, step=100000)
            property_type = st.selectbox("Typ nemovitosti:", ["", "Byt", "Rodinn√Ω d≈Øm", "Kancel√°≈ô", "Obchodn√≠ prostor", "Gar√°≈æ"])
        
        if st.button("üîç Vyhledat", type="primary"):
            if question:
                with st.spinner("Hled√°m nemovitosti..."):
                    response = self.search_properties(question, city, max_price, property_type)
                    self.display_search_results(response)
            else:
                st.error("Zadejte pros√≠m v√°≈° dotaz.")
    
    def market_analysis_page(self):
        """Str√°nka pro tr≈æn√≠ anal√Ωzu"""
        st.title("üìä Tr≈æn√≠ anal√Ωza")
        st.markdown("Z√≠skejte aktu√°ln√≠ p≈ôehled o realitn√≠m trhu ve vybran√Ωch mƒõstech.")
        
        col1, col2 = st.columns([1, 2])
        
        with col1:
            selected_city = st.selectbox("Vyberte mƒõsto:", ["Praha", "Brno", "Ostrava", "Plze≈à", "Liberec"])
            
            if st.button("üìà Z√≠skat tr≈æn√≠ anal√Ωzu", type="primary"):
                with st.spinner("Z√≠sk√°v√°m tr≈æn√≠ data..."):
                    response = self.get_market_summary(selected_city)
                    
                    if response and response.get("success"):
                        st.success(f"Tr≈æn√≠ anal√Ωza pro {selected_city}")
                        st.markdown(response["market_summary"])
                    else:
                        st.error("Nepoda≈ôilo se z√≠skat tr≈æn√≠ anal√Ωzu.")
        
        with col2:
            st.subheader("üìä Uk√°zkov√© grafy")
            # Uk√°zkov√Ω graf cenov√Ωch trend≈Ø
            self.display_sample_charts()
    
    def investment_advice_page(self):
        """Str√°nka pro investiƒçn√≠ poradenstv√≠"""
        st.title("üí∞ Investiƒçn√≠ poradenstv√≠")
        st.markdown("Z√≠skejte personalizovan√© investiƒçn√≠ doporuƒçen√≠ na z√°kladƒõ va≈°eho rozpoƒçtu a c√≠l≈Ø.")
        
        col1, col2 = st.columns([1, 1])
        
        with col1:
            budget = st.number_input("Rozpoƒçet (Kƒç):", min_value=100000, value=3000000, step=100000)
            investment_type = st.selectbox("Typ investice:", ["dlouhodob√°", "kr√°tkodob√°", "pron√°jem", "renovace"])
            
            preferred_cities = st.multiselect(
                "Preferovan√° mƒõsta:",
                ["Praha", "Brno", "Ostrava", "Plze≈à", "Liberec"]
            )
        
        with col2:
            st.subheader("‚ÑπÔ∏è Informace o investic√≠ch")
            st.info("""
            **Dlouhodob√° investice**: N√°kup pro dr≈æbu 5+ let
            **Kr√°tkodob√° investice**: Rychl√Ω prodej do 2 let
            **Pron√°jem**: Nemovitost pro v√Ωnosov√Ω pron√°jem
            **Renovace**: N√°kup k rekonstrukci a prodeji
            """)
        
        if st.button("üí° Z√≠skat doporuƒçen√≠", type="primary"):
            with st.spinner("Analyzujem investiƒçn√≠ p≈ô√≠le≈æitosti..."):
                response = self.get_investment_advice(budget, investment_type)
                
                if response and response.get("success"):
                    st.success("Investiƒçn√≠ doporuƒçen√≠")
                    st.markdown(response["advice"])
                else:
                    st.error("Nepoda≈ôilo se z√≠skat investiƒçn√≠ doporuƒçen√≠.")
    
    def geographic_search_page(self):
        """Str√°nka pro geografick√© vyhled√°v√°n√≠"""
        st.title("üó∫Ô∏è Geografick√© vyhled√°v√°n√≠")
        st.markdown("Vyhledejte nemovitosti v konkr√©tn√≠ oblasti na mapƒõ.")
        
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.subheader("Parametry vyhled√°v√°n√≠")
            latitude = st.number_input("Zemƒõpisn√° ≈°√≠≈ôka:", value=50.0755, format="%.6f")
            longitude = st.number_input("Zemƒõpisn√° d√©lka:", value=14.4378, format="%.6f")
            radius = st.slider("Polomƒõr vyhled√°v√°n√≠ (km):", min_value=1, max_value=20, value=5)
            
            question = st.text_area(
                "Dotaz:",
                placeholder="Nap≈ô: Najdƒõte byty vhodn√© pro mladou rodinu",
                height=80
            )
            
            if st.button("üó∫Ô∏è Vyhledat v oblasti", type="primary"):
                if question:
                    with st.spinner("Vyhled√°v√°m v zadan√© oblasti..."):
                        response = self.search_by_location(question, latitude, longitude, radius)
                        self.display_location_search_results(response, latitude, longitude, radius)
                else:
                    st.error("Zadejte pros√≠m v√°≈° dotaz.")
        
        with col2:
            st.subheader("üó∫Ô∏è Mapa vyhled√°v√°n√≠")
            # Vytvo≈ôen√≠ z√°kladn√≠ mapy
            m = folium.Map(location=[latitude, longitude], zoom_start=12)
            
            # P≈ôid√°n√≠ kruhu oznaƒçuj√≠c√≠ho oblast vyhled√°v√°n√≠
            folium.Circle(
                location=[latitude, longitude],
                radius=radius * 1000,  # p≈ôevod na metry
                popup=f"Oblast vyhled√°v√°n√≠ ({radius} km)",
                color="blue",
                fill=True,
                opacity=0.3
            ).add_to(m)
            
            # P≈ôid√°n√≠ markeru pro st≈ôed
            folium.Marker(
                location=[latitude, longitude],
                popup="St≈ôed vyhled√°v√°n√≠",
                icon=folium.Icon(color="red", icon="info-sign")
            ).add_to(m)
            
            folium_static(m, width=400, height=300)
    
    def search_properties(self, question: str, city: str = None, max_price: float = None, property_type: str = None) -> Dict[str, Any]:
        """Vyhled√°v√°n√≠ nemovitost√≠ p≈ôes API"""
        try:
            payload = {"question": question}
            if city:
                payload["city"] = city
            if max_price and max_price > 0:
                payload["max_price"] = max_price
            if property_type:
                payload["property_type"] = property_type
            
            response = requests.post(f"{API_BASE_URL}/query/", json=payload)
            return response.json() if response.status_code == 200 else None
        except Exception as e:
            st.error(f"Chyba p≈ôi komunikaci s API: {e}")
            return None
    
    def get_market_summary(self, city: str) -> Dict[str, Any]:
        """Z√≠sk√°n√≠ tr≈æn√≠ho shrnut√≠ p≈ôes API"""
        try:
            response = requests.get(f"{API_BASE_URL}/market/{city}")
            return response.json() if response.status_code == 200 else None
        except Exception as e:
            st.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ tr≈æn√≠ch dat: {e}")
            return None
    
    def get_investment_advice(self, budget: float, investment_type: str) -> Dict[str, Any]:
        """Z√≠sk√°n√≠ investiƒçn√≠ho poradenstv√≠ p≈ôes API"""
        try:
            payload = {
                "budget": budget,
                "investment_type": investment_type
            }
            response = requests.post(f"{API_BASE_URL}/investment/advice/", json=payload)
            return response.json() if response.status_code == 200 else None
        except Exception as e:
            st.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ investiƒçn√≠ho poradenstv√≠: {e}")
            return None
    
    def search_by_location(self, question: str, lat: float, lon: float, radius: float) -> Dict[str, Any]:
        """Geografick√© vyhled√°v√°n√≠ p≈ôes API"""
        try:
            payload = {
                "question": question,
                "latitude": lat,
                "longitude": lon,
                "radius_km": radius
            }
            response = requests.post(f"{API_BASE_URL}/query/location/", json=payload)
            return response.json() if response.status_code == 200 else None
        except Exception as e:
            st.error(f"Chyba p≈ôi geografick√©m vyhled√°v√°n√≠: {e}")
            return None
    
    def display_search_results(self, response: Dict[str, Any]):
        """Zobrazen√≠ v√Ωsledk≈Ø vyhled√°v√°n√≠"""
        if response and response.get("success"):
            st.success("‚úÖ V√Ωsledky vyhled√°v√°n√≠")
            st.markdown(response["answer"])
            
            if response.get("sources_count", 0) > 0:
                st.info(f"üìÑ Nalezeno {response['sources_count']} relevantn√≠ch nemovitost√≠")
        else:
            st.error("‚ùå Nepoda≈ôilo se naj√≠t ≈æ√°dn√© nemovitosti odpov√≠daj√≠c√≠ va≈°im krit√©ri√≠m.")
    
    def display_location_search_results(self, response: Dict[str, Any], lat: float, lon: float, radius: float):
        """Zobrazen√≠ v√Ωsledk≈Ø geografick√©ho vyhled√°v√°n√≠"""
        if response and response.get("success"):
            st.success("‚úÖ V√Ωsledky geografick√©ho vyhled√°v√°n√≠")
            st.markdown(response["answer"])
            
            geographic_info = response.get("geographic_info", {})
            if geographic_info:
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Nalezen√© nemovitosti", geographic_info.get("found_properties", 0))
                with col2:
                    st.metric("Polomƒõr (km)", geographic_info.get("radius_km", 0))
                with col3:
                    closest_distance = geographic_info.get("closest_distance_km")
                    if closest_distance:
                        st.metric("Nejbli≈æ≈°√≠ (km)", f"{closest_distance:.1f}")
        else:
            st.error("‚ùå Nepoda≈ôilo se naj√≠t ≈æ√°dn√© nemovitosti v zadan√© oblasti.")
    
    def display_sample_charts(self):
        """Zobrazen√≠ uk√°zkov√Ωch graf≈Ø"""
        # Uk√°zkov√° data pro grafy
        months = ["Leden", "√önor", "B≈ôezen", "Duben", "Kvƒõten", "ƒåerven"]
        prices = [4500000, 4600000, 4750000, 4800000, 4900000, 5000000]
        
        # Graf cenov√Ωch trend≈Ø
        fig = px.line(
            x=months, 
            y=prices,
            title="V√Ωvoj medi√°nov√Ωch cen nemovitost√≠",
            labels={"x": "Mƒõs√≠c", "y": "Cena (Kƒç)"}
        )
        fig.update_traces(line_color="blue", line_width=3)
        st.plotly_chart(fig, use_container_width=True)
        
        # Graf distribuce typ≈Ø nemovitost√≠
        property_types = ["Byt", "Rodinn√Ω d≈Øm", "Kancel√°≈ô", "Obchodn√≠ prostor"]
        counts = [450, 230, 120, 80]
        
        fig2 = px.pie(
            values=counts,
            names=property_types,
            title="Distribuce typ≈Ø nemovitost√≠ na trhu"
        )
        st.plotly_chart(fig2, use_container_width=True)

def main():
    """Hlavn√≠ funkce aplikace"""
    try:
        # Kontrola dostupnosti API
        response = requests.get(f"{API_BASE_URL}/health/")
        if response.status_code != 200:
            st.error("‚ö†Ô∏è API server nen√≠ dostupn√Ω. Spus≈•te pros√≠m API server na portu 8000.")
            st.code("python api/main.py")
            return
    except requests.exceptions.ConnectionError:
        st.error("‚ö†Ô∏è Nepoda≈ôilo se p≈ôipojit k API serveru. Ujistƒõte se, ≈æe bƒõ≈æ√≠ na http://localhost:8000")
        st.code("python api/main.py")
        return
    
    # Spu≈°tƒõn√≠ aplikace
    app = RealEstateApp()
    app.run()

if __name__ == "__main__":
    main()
````

````python
import subprocess
import sys
import time
import os
from pathlib import Path

def check_requirements():
    """Kontrola a instalace po≈æadovan√Ωch bal√≠ƒçk≈Ø"""
    print("üîç Kontrolujem po≈æadovan√© bal√≠ƒçky...")
    
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])
        print("‚úÖ V≈°echny bal√≠ƒçky jsou nainstalov√°ny")
    except subprocess.CalledProcessError:
        print("‚ùå Chyba p≈ôi instalaci bal√≠ƒçk≈Ø")
        return False
    
    return True

def setup_environment():
    """Nastaven√≠ prost≈ôed√≠"""
    print("üîß Nastavujem prost≈ôed√≠...")
    
    # Vytvo≈ôen√≠ slo≈æek
    os.makedirs("data", exist_ok=True)
    os.makedirs("chroma_db", exist_ok=True)
    
    # Kontrola .env souboru
    if not Path(".env").exists():
        print("üìù Vytv√°≈ô√≠m .env soubor...")
        with open(".env", "w") as f:
            f.write("""# Real Estate Intelligence System Configuration
OPENAI_API_KEY=your_openai_api_key_here
POSTGRES_URL=postgresql://user:password@localhost:5432/realestate
ZILLOW_API_KEY=your_zillow_api_key_here
""")
        print("‚ö†Ô∏è  Nastavte pros√≠m v√°≈° OpenAI API kl√≠ƒç v souboru .env")
    
    print("‚úÖ Prost≈ôed√≠ je nastaveno")

def generate_sample_data():
    """Generov√°n√≠ uk√°zkov√Ωch dat"""
    if not Path("data/properties.csv").exists():
        print("üìä Generujem uk√°zkov√° data...")
        try:
            from data.sample_data_generator import SampleDataGenerator
            generator = SampleDataGenerator()
            generator.save_all_data()
            print("‚úÖ Uk√°zkov√° data byla vygenerov√°na")
        except Exception as e:
            print(f"‚ùå Chyba p≈ôi generov√°n√≠ dat: {e}")
            return False
    else:
        print("‚úÖ Uk√°zkov√° data ji≈æ existuj√≠")
    
    return True

def start_api_server():
    """Spu≈°tƒõn√≠ API serveru"""
    print("üöÄ Spou≈°t√≠m API server...")
    
    try:
        # Spu≈°tƒõn√≠ v nov√©m procesu
        process = subprocess.Popen([
            sys.executable, "-m", "uvicorn", "api.main:app",
            "--host", "0.0.0.0", "--port", "8000", "--reload"
        ])
        
        # Poƒçk√°n√≠ na spu≈°tƒõn√≠
        time.sleep(5)
        
        print("‚úÖ API server bƒõ≈æ√≠ na http://localhost:8000")
        return process
    
    except Exception as e:
        print(f"‚ùå Chyba p≈ôi spu≈°tƒõn√≠ API serveru: {e}")
        return None

def start_streamlit_app():
    """Spu≈°tƒõn√≠ Streamlit aplikace"""
    print("üé® Spou≈°t√≠m Streamlit aplikaci...")
    
    try:
        subprocess.run([sys.executable, "-m", "streamlit", "run", "streamlit_app.py"])
    except KeyboardInterrupt:
        print("\nüëã Aplikace byla ukonƒçena")
    except Exception as e:
        print(f"‚ùå Chyba p≈ôi spu≈°tƒõn√≠ Streamlit aplikace: {e}")

def main():
    """Hlavn√≠ funkce pro spu≈°tƒõn√≠ cel√©ho syst√©mu"""
    print("üè† Real Estate Intelligence System")
    print("=" * 50)
    
    # Kontrola po≈æadavk≈Ø
    if not check_requirements():
        print("‚ùå Instalace bal√≠ƒçk≈Ø selhala")
        return
    
    # Nastaven√≠ prost≈ôed√≠
    setup_environment()
    
    # Generov√°n√≠ dat
    if not generate_sample_data():
        print("‚ùå Generov√°n√≠ dat selhalo")
        return
    
    # Spu≈°tƒõn√≠ API serveru
    api_process = start_api_server()
    if not api_process:
        print("‚ùå Spu≈°tƒõn√≠ API serveru selhalo")
        return
    
    try:
        # Spu≈°tƒõn√≠ Streamlit aplikace
        start_streamlit_app()
    finally:
        # Ukonƒçen√≠ API serveru
        if api_process:
            print("üõë Ukonƒçujem API server...")
            api_process.terminate()

if __name__ == "__main__":
    main()
````

## Shrnut√≠ Projektu

Syst√©m Inteligence Realitn√≠ch Nemovitost√≠ p≈ôedstavuje pokroƒçil√© RAG ≈ôe≈°en√≠, kter√© revolutionizuje zp≈Øsob, jak√Ωm lid√© hledaj√≠ a analyzuj√≠ nemovitosti. Projekt √∫spƒõ≈°nƒõ kombinuje:

**Kl√≠ƒçov√© Technologie:**
- **LangChain** pro orchestraci RAG workflow
- **ChromaDB** pro vektorov√© ukl√°d√°n√≠ a vyhled√°v√°n√≠
- **OpenAI GPT-4** pro generov√°n√≠ inteligentn√≠ch odpovƒõd√≠
- **FastAPI** pro ≈°k√°lovateln√© API rozhran√≠
- **Streamlit** pro intuitivn√≠ u≈æivatelsk√© rozhran√≠
- **PostGIS koncepty** pro geoprostorov√© operace

**Hodnota ≈òe≈°en√≠:**
- **Centralizace dat**: Sjednocuje fragmentovan√© realitn√≠ informace
- **AI-powered anal√Ωzy**: Poskytuje inteligentn√≠ doporuƒçen√≠ a progn√≥zy
- **Geografick√© vyhled√°v√°n√≠**: Umo≈æ≈àuje prostorov√© dotazy a anal√Ωzy
- **≈†k√°lovatelnost**: P≈ôipraveno pro miliony nemovitost√≠ a u≈æivatel≈Ø

**Praktick√© P≈ô√≠nosy:**
- Dramatick√© urychlen√≠ rozhodovac√≠ch proces≈Ø
- Demokratizace p≈ô√≠stupu k pokroƒçil√Ωm tr≈æn√≠m anal√Ωz√°m  
- Zlep≈°en√≠ transparentnosti a efektivity realitn√≠ho trhu
- Personalizovan√© investiƒçn√≠ poradenstv√≠ zalo≈æen√© na datech

Syst√©m p≈ôedstavuje kompletn√≠ ≈ôe≈°en√≠ pro modern√≠ realitn√≠ trh, kter√© vyu≈æ√≠v√° nejnovƒõj≈°√≠ AI technologie pro poskytov√°n√≠ ≈°piƒçkov√Ωch slu≈æeb v oblasti nemovitost√≠.