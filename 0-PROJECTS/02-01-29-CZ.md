<small>Claude Sonnet 4 **(Autonomní Hub pro Patentový Výzkum a Inovace)**</small>
# Autonomous Patent Research and Innovation Hub

## 1. Název Projektu

**Autonomní Hub pro Patentový Výzkum a Inovace s Multi-Agent Systémy**

## 2. Vysvětlení Klíčových Konceptů

### Multi-Agent Systems (Multi-agentní systémy)
Systémy složené z více autonomních agentů, kteří spolupracují na řešení komplexních úloh. Každý agent má specifickou roli a schopnosti.

### Prior Art Discovery (Objevování předchozího stavu techniky)
Proces identifikace existujících patentů, publikací a technologií relevantních k nové vynálezu nebo inovaci.

### Invention Analysis (Analýza vynálezů)
Systematické hodnocení technických řešení, jejich novosti, užitečnosti a patentovatelnosti.

### Patent Landscape Mapping (Mapování patentové krajiny)
Vizualizace a analýza patentového prostoru v konkrétní technologické oblasti pro identifikaci trendů a příležitostí.

### Innovation Opportunity Identification (Identifikace inovačních příležitostí)
Proces nalézání mezer na trhu a technologických oblastí s potenciálem pro nové vynálezy.

### IP Strategy Development (Vývoj strategie duševního vlastnictví)
Plánování a implementace strategie pro ochranu a komercializaci duševního vlastnictví.

## 3. Komplexní Vysvětlení Projektu

### Cíle Projektu

Vytvořit inteligentní systém využívající multi-agentní architekturu pro komplexní analýzu patentového prostředí. Systém automatizuje výzkum prior art, analyzuje vynálezy, mapuje patentovou krajinu a identifikuje inovační příležitosti.

### Hlavní Výzvy

1. **Komplexnost patentových dat** - Strukturované i nestrukturované informace
2. **Objektivní hodnocení novosti** - Automatické posouzení patentovatelnosti
3. **Scalabilita analýzy** - Zpracování velkých objemů patentových dokumentů
4. **Interdisciplinární znalosti** - Propojení technických a právních aspektů

### Potenciální Dopad

- Urychlení inovačních procesů
- Snížení rizika porušení patentů
- Optimalizace IP strategií
- Podpora výzkumu a vývoje

## 4. Komplexní Příklad s Python Implementací

````python
import asyncio
import json
import logging
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import KMeans
from sklearn.metrics.pairwise import cosine_similarity
import networkx as nx
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import requests
from bs4 import BeautifulSoup
import openai
from langchain.llms import OpenAI
from langchain.agents import initialize_agent, Tool
from langchain.memory import ConversationBufferMemory
from langchain.schema import BaseOutputParser
import chromadb
from chromadb.config import Settings
import warnings
warnings.filterwarnings('ignore')

# Konfigurace logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class Patent:
    """Datová struktura pro patent"""
    id: str
    title: str
    abstract: str
    inventors: List[str]
    assignee: str
    filing_date: datetime
    publication_date: datetime
    classification_codes: List[str]
    claims: List[str]
    description: str
    
@dataclass
class PriorArtResult:
    """Výsledek prior art analýzy"""
    query: str
    relevant_patents: List[Patent]
    similarity_scores: List[float]
    analysis_summary: str
    
@dataclass
class InnovationOpportunity:
    """Identifikovaná inovační příležitost"""
    technology_area: str
    gap_description: str
    market_potential: float
    technical_feasibility: float
    patent_freedom: float
    recommended_approach: str

class PatentDatabase:
    """Simulovaná patentová databáze"""
    
    def __init__(self):
        self.patents = self._generate_sample_patents()
        self.vectorizer = TfidfVectorizer(max_features=1000, stop_words='english')
        self.patent_vectors = None
        self._build_vectors()
        
    def _generate_sample_patents(self) -> List[Patent]:
        """Generuje ukázková patentová data"""
        sample_patents = [
            Patent(
                id="US10123456",
                title="Machine Learning System for Autonomous Vehicle Navigation",
                abstract="A machine learning system that enables autonomous vehicles to navigate complex urban environments using deep neural networks and sensor fusion.",
                inventors=["John Smith", "Alice Johnson"],
                assignee="TechCorp Inc.",
                filing_date=datetime(2020, 3, 15),
                publication_date=datetime(2021, 9, 15),
                classification_codes=["G06N3/08", "B60W30/00"],
                claims=["A navigation system comprising neural networks", "Sensor fusion algorithms"],
                description="Detailed description of ML-based navigation system..."
            ),
            Patent(
                id="US10234567",
                title="Quantum Computing Architecture for Optimization Problems",
                abstract="Novel quantum computing architecture specifically designed for solving complex optimization problems in logistics and supply chain management.",
                inventors=["Bob Wilson", "Carol Brown"],
                assignee="QuantumTech Ltd.",
                filing_date=datetime(2019, 8, 20),
                publication_date=datetime(2021, 2, 20),
                classification_codes=["G06N10/00", "G06Q10/04"],
                claims=["Quantum gate configuration", "Optimization algorithm implementation"],
                description="Comprehensive description of quantum optimization architecture..."
            ),
            Patent(
                id="US10345678",
                title="Blockchain-based Supply Chain Transparency System",
                abstract="A blockchain platform that provides end-to-end transparency and traceability in global supply chains using smart contracts.",
                inventors=["David Lee", "Emma Davis"],
                assignee="BlockChain Solutions",
                filing_date=datetime(2021, 1, 10),
                publication_date=datetime(2022, 7, 10),
                classification_codes=["G06Q20/38", "G06Q10/08"],
                claims=["Smart contract execution", "Supply chain tracking mechanism"],
                description="Detailed implementation of blockchain supply chain system..."
            )
        ]
        return sample_patents
    
    def _build_vectors(self):
        """Vytváří vektorové reprezentace patentů"""
        texts = [f"{p.title} {p.abstract} {p.description}" for p in self.patents]
        self.patent_vectors = self.vectorizer.fit_transform(texts)
    
    def search_patents(self, query: str, top_k: int = 5) -> List[tuple]:
        """Vyhledává relevantní patenty"""
        query_vector = self.vectorizer.transform([query])
        similarities = cosine_similarity(query_vector, self.patent_vectors).flatten()
        
        # Získání top-k nejrelevantějších patentů
        top_indices = np.argsort(similarities)[-top_k:][::-1]
        results = [(self.patents[i], similarities[i]) for i in top_indices]
        return results

class PriorArtAgent:
    """Agent pro objevování prior art"""
    
    def __init__(self, patent_db: PatentDatabase):
        self.patent_db = patent_db
        self.name = "PriorArtAgent"
        
    async def discover_prior_art(self, invention_description: str) -> PriorArtResult:
        """Objevuje relevantní prior art"""
        logger.info(f"{self.name}: Začínám prior art analýzu")
        
        # Vyhledání relevantních patentů
        results = self.patent_db.search_patents(invention_description, top_k=10)
        
        relevant_patents = [patent for patent, score in results if score > 0.1]
        similarity_scores = [score for patent, score in results if score > 0.1]
        
        # Generování analýzy
        analysis_summary = self._generate_analysis_summary(
            invention_description, relevant_patents, similarity_scores
        )
        
        return PriorArtResult(
            query=invention_description,
            relevant_patents=relevant_patents,
            similarity_scores=similarity_scores,
            analysis_summary=analysis_summary
        )
    
    def _generate_analysis_summary(self, query: str, patents: List[Patent], scores: List[float]) -> str:
        """Generuje shrnutí prior art analýzy"""
        if not patents:
            return "Nebyly nalezeny žádné relevantní předchozí patenty."
        
        avg_similarity = np.mean(scores) if scores else 0
        
        summary = f"""
        Prior Art Analýza:
        - Počet relevantních patentů: {len(patents)}
        - Průměrná podobnost: {avg_similarity:.3f}
        - Nejrelevantější patent: {patents[0].title if patents else 'N/A'}
        
        Doporučení: {'Vysoké riziko překrývání s existujícími patenty' if avg_similarity > 0.7 else 'Středně riziko překrývání' if avg_similarity > 0.4 else 'Nízké riziko překrývání'}
        """
        
        return summary.strip()

class InventionAnalysisAgent:
    """Agent pro analýzu vynálezů"""
    
    def __init__(self):
        self.name = "InventionAnalysisAgent"
        
    async def analyze_invention(self, invention_description: str, prior_art: PriorArtResult) -> Dict[str, Any]:
        """Analyzuje vynález"""
        logger.info(f"{self.name}: Analyzuji vynález")
        
        # Posouzení novosti
        novelty_score = self._assess_novelty(invention_description, prior_art)
        
        # Posouzení užitečnosti
        utility_score = self._assess_utility(invention_description)
        
        # Posouzení nesamozřejmosti
        non_obviousness_score = self._assess_non_obviousness(invention_description, prior_art)
        
        # Celkové skóre patentovatelnosti
        patentability_score = (novelty_score + utility_score + non_obviousness_score) / 3
        
        analysis = {
            "novelty_score": novelty_score,
            "utility_score": utility_score,
            "non_obviousness_score": non_obviousness_score,
            "patentability_score": patentability_score,
            "recommendation": self._generate_recommendation(patentability_score),
            "key_features": self._extract_key_features(invention_description),
            "potential_claims": self._suggest_patent_claims(invention_description)
        }
        
        return analysis
    
    def _assess_novelty(self, invention: str, prior_art: PriorArtResult) -> float:
        """Posuzuje novost vynálezu"""
        if not prior_art.similarity_scores:
            return 0.9
        
        max_similarity = max(prior_art.similarity_scores)
        novelty = 1.0 - max_similarity
        return max(0.0, novelty)
    
    def _assess_utility(self, invention: str) -> float:
        """Posuzuje užitečnost vynálezu"""
        utility_keywords = [
            "efficient", "improved", "enhanced", "optimized", "faster",
            "secure", "reliable", "cost-effective", "scalable"
        ]
        
        score = sum(1 for keyword in utility_keywords if keyword.lower() in invention.lower())
        return min(1.0, score / len(utility_keywords) * 2)
    
    def _assess_non_obviousness(self, invention: str, prior_art: PriorArtResult) -> float:
        """Posuzuje nesamozřejmost vynálezu"""
        if len(prior_art.relevant_patents) == 0:
            return 0.8
        
        # Jednoduché hodnocení na základě kombinace konceptů
        invention_words = set(invention.lower().split())
        
        combinations = 0
        for patent in prior_art.relevant_patents:
            patent_words = set(f"{patent.title} {patent.abstract}".lower().split())
            overlap = len(invention_words.intersection(patent_words))
            if overlap > 0:
                combinations += 1
        
        # Více kombinací naznačuje větší nesamozřejmost
        non_obviousness = min(1.0, combinations / len(prior_art.relevant_patents))
        return non_obviousness
    
    def _generate_recommendation(self, score: float) -> str:
        """Generuje doporučení na základě skóre"""
        if score >= 0.7:
            return "Vysoká patentovatelnost - doporučeno podat přihlášku"
        elif score >= 0.5:
            return "Střední patentovatelnost - vyžaduje další analýzu"
        else:
            return "Nízká patentovatelnost - nutné významné úpravy"
    
    def _extract_key_features(self, invention: str) -> List[str]:
        """Extrahuje klíčové rysy vynálezu"""
        # Jednoduchá extrakce klíčových slov
        important_words = []
        words = invention.split()
        
        for i, word in enumerate(words):
            if len(word) > 6 and word.lower() not in ['system', 'method', 'device']:
                important_words.append(word)
        
        return important_words[:5]
    
    def _suggest_patent_claims(self, invention: str) -> List[str]:
        """Navrhuje patentové nároky"""
        claims = [
            f"A system comprising: {invention[:100]}...",
            f"A method for implementing: {invention[:100]}...",
            f"A computer-readable medium storing instructions for: {invention[:80]}..."
        ]
        return claims

class PatentLandscapeAgent:
    """Agent pro mapování patentové krajiny"""
    
    def __init__(self, patent_db: PatentDatabase):
        self.patent_db = patent_db
        self.name = "PatentLandscapeAgent"
        
    async def map_landscape(self, technology_area: str) -> Dict[str, Any]:
        """Mapuje patentovou krajinu"""
        logger.info(f"{self.name}: Mapuji patentovou krajinu pro {technology_area}")
        
        # Získání relevantních patentů
        relevant_patents = self.patent_db.search_patents(technology_area, top_k=20)
        patents = [patent for patent, score in relevant_patents]
        
        # Clusterová analýza
        clusters = self._perform_clustering(patents)
        
        # Analýza trendů
        trends = self._analyze_trends(patents)
        
        # Identifikace lídrů
        leaders = self._identify_leaders(patents)
        
        # Analýza mezer
        gaps = self._identify_gaps(patents, technology_area)
        
        landscape_map = {
            "technology_area": technology_area,
            "total_patents": len(patents),
            "clusters": clusters,
            "trends": trends,
            "market_leaders": leaders,
            "identified_gaps": gaps,
            "competitive_density": self._calculate_competitive_density(patents)
        }
        
        return landscape_map
    
    def _perform_clustering(self, patents: List[Patent]) -> Dict[str, Any]:
        """Provádí clusterovou analýzu patentů"""
        if len(patents) < 3:
            return {"clusters": [], "cluster_labels": []}
        
        # Příprava dat pro clustering
        texts = [f"{p.title} {p.abstract}" for p in patents]
        vectorizer = TfidfVectorizer(max_features=100, stop_words='english')
        vectors = vectorizer.fit_transform(texts)
        
        # K-means clustering
        n_clusters = min(5, len(patents))
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        cluster_labels = kmeans.fit_predict(vectors.toarray())
        
        # Interpretace clusterů
        clusters = []
        for i in range(n_clusters):
            cluster_patents = [patents[j] for j, label in enumerate(cluster_labels) if label == i]
            
            # Nejčastější slova v clusteru
            cluster_texts = [f"{p.title} {p.abstract}" for p in cluster_patents]
            cluster_vector = vectorizer.transform(cluster_texts)
            feature_names = vectorizer.get_feature_names_out()
            mean_scores = np.mean(cluster_vector.toarray(), axis=0)
            top_indices = np.argsort(mean_scores)[-5:][::-1]
            top_terms = [feature_names[idx] for idx in top_indices]
            
            clusters.append({
                "cluster_id": i,
                "patent_count": len(cluster_patents),
                "top_terms": top_terms,
                "representative_patents": [p.title for p in cluster_patents[:3]]
            })
        
        return {"clusters": clusters, "cluster_labels": cluster_labels.tolist()}
    
    def _analyze_trends(self, patents: List[Patent]) -> Dict[str, Any]:
        """Analyzuje trendy v patentování"""
        # Analýza podle roků
        yearly_counts = {}
        for patent in patents:
            year = patent.filing_date.year
            yearly_counts[year] = yearly_counts.get(year, 0) + 1
        
        # Analýza podle přihlašovatelů
        assignee_counts = {}
        for patent in patents:
            assignee_counts[patent.assignee] = assignee_counts.get(patent.assignee, 0) + 1
        
        trends = {
            "yearly_filing_trend": yearly_counts,
            "top_assignees": dict(sorted(assignee_counts.items(), 
                                       key=lambda x: x[1], reverse=True)[:5]),
            "growth_rate": self._calculate_growth_rate(yearly_counts),
            "emerging_players": self._identify_emerging_players(patents)
        }
        
        return trends
    
    def _calculate_growth_rate(self, yearly_counts: Dict[int, int]) -> float:
        """Vypočítává růstovou rychlost patentování"""
        if len(yearly_counts) < 2:
            return 0.0
        
        years = sorted(yearly_counts.keys())
        if len(years) < 2:
            return 0.0
        
        start_count = yearly_counts[years[0]]
        end_count = yearly_counts[years[-1]]
        years_diff = years[-1] - years[0]
        
        if start_count == 0 or years_diff == 0:
            return 0.0
        
        growth_rate = ((end_count / start_count) ** (1 / years_diff) - 1) * 100
        return round(growth_rate, 2)
    
    def _identify_emerging_players(self, patents: List[Patent]) -> List[str]:
        """Identifikuje nové hráče na trhu"""
        recent_patents = [p for p in patents if p.filing_date.year >= 2020]
        
        assignee_counts = {}
        for patent in recent_patents:
            assignee_counts[patent.assignee] = assignee_counts.get(patent.assignee, 0) + 1
        
        # Hráči s méně než 5 patenty ale aktivní v posledních letech
        emerging = [assignee for assignee, count in assignee_counts.items() 
                   if 1 <= count <= 4]
        
        return emerging[:5]
    
    def _identify_leaders(self, patents: List[Patent]) -> List[Dict[str, Any]]:
        """Identifikuje lídry na trhu"""
        assignee_counts = {}
        for patent in patents:
            assignee_counts[patent.assignee] = assignee_counts.get(patent.assignee, 0) + 1
        
        leaders = []
        for assignee, count in sorted(assignee_counts.items(), 
                                    key=lambda x: x[1], reverse=True)[:5]:
            leaders.append({
                "company": assignee,
                "patent_count": count,
                "market_share": round(count / len(patents) * 100, 1)
            })
        
        return leaders
    
    def _identify_gaps(self, patents: List[Patent], technology_area: str) -> List[str]:
        """Identifikuje mezery v patentové krajině"""
        # Analýza pokrytí podle klasifikačních kódů
        all_codes = set()
        for patent in patents:
            all_codes.update(patent.classification_codes)
        
        # Předpokládané důležité oblasti (simulace)
        expected_areas = [
            "AI/Machine Learning applications",
            "Security implementations", 
            "Mobile device integration",
            "Cloud computing aspects",
            "User interface innovations"
        ]
        
        # Identifikace mezer (zjednodušeno)
        gaps = []
        if len(all_codes) < 10:
            gaps.extend(expected_areas[:3])
        
        return gaps
    
    def _calculate_competitive_density(self, patents: List[Patent]) -> str:
        """Vypočítává hustotu konkurence"""
        patent_count = len(patents)
        
        if patent_count > 50:
            return "Vysoká"
        elif patent_count > 20:
            return "Střední"
        else:
            return "Nízká"

class InnovationOpportunityAgent:
    """Agent pro identifikaci inovačních příležitostí"""
    
    def __init__(self):
        self.name = "InnovationOpportunityAgent"
        
    async def identify_opportunities(self, landscape_map: Dict[str, Any], 
                                   market_data: Dict[str, Any] = None) -> List[InnovationOpportunity]:
        """Identifikuje inovační příležitosti"""
        logger.info(f"{self.name}: Identifikuji inovační příležitosti")
        
        opportunities = []
        
        # Analýza mezer v patentové krajině
        gaps = landscape_map.get("identified_gaps", [])
        
        for gap in gaps:
            opportunity = InnovationOpportunity(
                technology_area=gap,
                gap_description=f"Nedostatečné pokrytí v oblasti: {gap}",
                market_potential=self._assess_market_potential(gap),
                technical_feasibility=self._assess_technical_feasibility(gap),
                patent_freedom=self._assess_patent_freedom(gap, landscape_map),
                recommended_approach=self._recommend_approach(gap)
            )
            opportunities.append(opportunity)
        
        # Analýza na základě trendů
        trends = landscape_map.get("trends", {})
        emerging_areas = self._identify_emerging_areas(trends)
        
        for area in emerging_areas:
            opportunity = InnovationOpportunity(
                technology_area=area,
                gap_description=f"Rychle rostoucí oblast s potenciálem",
                market_potential=0.8,
                technical_feasibility=0.7,
                patent_freedom=0.6,
                recommended_approach="Rychlý vstup na trh s inovativním řešením"
            )
            opportunities.append(opportunity)
        
        # Seřazení podle potenciálu
        opportunities.sort(key=lambda x: x.market_potential * x.technical_feasibility * x.patent_freedom, 
                         reverse=True)
        
        return opportunities[:5]
    
    def _assess_market_potential(self, technology_area: str) -> float:
        """Hodnotí tržní potenciál"""
        high_potential_areas = ["AI", "security", "mobile", "cloud"]
        
        score = 0.5  # základní skóre
        
        for area in high_potential_areas:
            if area.lower() in technology_area.lower():
                score += 0.2
        
        return min(1.0, score)
    
    def _assess_technical_feasibility(self, technology_area: str) -> float:
        """Hodnotí technickou proveditelnost"""
        # Simulace hodnocení na základě současného stavu technologie
        feasible_areas = ["software", "AI", "interface", "integration"]
        
        score = 0.6  # základní skóre
        
        for area in feasible_areas:
            if area.lower() in technology_area.lower():
                score += 0.1
        
        return min(1.0, score)
    
    def _assess_patent_freedom(self, technology_area: str, landscape_map: Dict[str, Any]) -> float:
        """Hodnotí patentovou svobodu"""
        competitive_density = landscape_map.get("competitive_density", "Střední")
        
        density_scores = {
            "Nízká": 0.9,
            "Střední": 0.6,
            "Vysoká": 0.3
        }
        
        return density_scores.get(competitive_density, 0.5)
    
    def _recommend_approach(self, technology_area: str) -> str:
        """Doporučuje přístup k inovaci"""
        approaches = {
            "AI": "Zaměřit se na specifické aplikační domény",
            "security": "Vyvinout nové kryptografické metody",
            "mobile": "Optimalizovat pro nové mobilní platformy",
            "cloud": "Implementovat edge computing řešení",
            "interface": "Vytvořit intuitivní uživatelské rozhraní"
        }
        
        for key, approach in approaches.items():
            if key.lower() in technology_area.lower():
                return approach
        
        return "Provést detailní analýzu trhu a technických požadavků"
    
    def _identify_emerging_areas(self, trends: Dict[str, Any]) -> List[str]:
        """Identifikuje vznikající oblasti"""
        growth_rate = trends.get("growth_rate", 0)
        
        emerging_areas = []
        if growth_rate > 10:
            emerging_areas.extend([
                "Next-generation interfaces",
                "Sustainable technology solutions",
                "Privacy-preserving algorithms"
            ])
        
        return emerging_areas

class IPStrategyAgent:
    """Agent pro vývoj IP strategie"""
    
    def __init__(self):
        self.name = "IPStrategyAgent"
        
    async def develop_strategy(self, invention_analysis: Dict[str, Any],
                             landscape_map: Dict[str, Any],
                             opportunities: List[InnovationOpportunity]) -> Dict[str, Any]:
        """Vyvíjí IP strategii"""
        logger.info(f"{self.name}: Vyvíjím IP strategii")
        
        strategy = {
            "patent_filing_recommendation": self._recommend_patent_filing(invention_analysis),
            "geographic_strategy": self._recommend_geographic_strategy(landscape_map),
            "timing_strategy": self._recommend_timing_strategy(opportunities),
            "defensive_strategy": self._develop_defensive_strategy(landscape_map),
            "offensive_strategy": self._develop_offensive_strategy(opportunities),
            "portfolio_development": self._recommend_portfolio_development(opportunities),
            "licensing_opportunities": self._identify_licensing_opportunities(landscape_map),
            "risk_assessment": self._assess_ip_risks(landscape_map, invention_analysis)
        }
        
        return strategy
    
    def _recommend_patent_filing(self, invention_analysis: Dict[str, Any]) -> Dict[str, str]:
        """Doporučuje patentové přihlašování"""
        patentability_score = invention_analysis.get("patentability_score", 0)
        
        if patentability_score >= 0.7:
            return {
                "recommendation": "Immediate filing",
                "priority": "High",
                "reasoning": "Vysoká patentovatelnost justifikuje okamžité podání"
            }
        elif patentability_score >= 0.5:
            return {
                "recommendation": "File after improvements",
                "priority": "Medium", 
                "reasoning": "Vyžaduje úpravy pro zvýšení patentovatelnosti"
            }
        else:
            return {
                "recommendation": "Significant modifications needed",
                "priority": "Low",
                "reasoning": "Současná forma má nízkou patentovatelnost"
            }
    
    def _recommend_geographic_strategy(self, landscape_map: Dict[str, Any]) -> Dict[str, Any]:
        """Doporučuje geografickou strategii"""
        leaders = landscape_map.get("market_leaders", [])
        
        # Analýza dominantních trhů
        priority_markets = ["US", "EP", "CN", "JP"]
        
        if len(leaders) > 3:
            priority_markets.extend(["KR", "IN"])
        
        return {
            "priority_markets": priority_markets,
            "filing_sequence": "US first, then PCT for international coverage",
            "reasoning": "Pokrytí hlavních technologických trhů"
        }
    
    def _recommend_timing_strategy(self, opportunities: List[InnovationOpportunity]) -> Dict[str, Any]:
        """Doporučuje časovou strategii"""
        high_potential_count = sum(1 for opp in opportunities if opp.market_potential > 0.7)
        
        if high_potential_count > 2:
            return {
                "urgency": "High",
                "timeline": "File within 3 months",
                "reasoning": "Vysoký počet příležitostí vyžaduje rychlé jednání"
            }
        else:
            return {
                "urgency": "Medium",
                "timeline": "File within 6 months",
                "reasoning": "Standardní časový rámec pro přípravu kvalitní přihlášky"
            }
    
    def _develop_defensive_strategy(self, landscape_map: Dict[str, Any]) -> Dict[str, Any]:
        """Vyvíjí obrannou strategii"""
        competitive_density = landscape_map.get("competitive_density", "Střední")
        
        if competitive_density == "Vysoká":
            return {
                "approach": "Strong defensive portfolio",
                "tactics": [
                    "File continuation applications",
                    "Develop design-around solutions", 
                    "Monitor competitor filings"
                ],
                "budget_allocation": "40% defensive, 60% offensive"
            }
        else:
            return {
                "approach": "Moderate defensive measures",
                "tactics": [
                    "Basic FTO analysis",
                    "Selective continuation filings"
                ],
                "budget_allocation": "20% defensive, 80% offensive"
            }
    
    def _develop_offensive_strategy(self, opportunities: List[InnovationOpportunity]) -> Dict[str, Any]:
        """Vyvíjí útočnou strategii"""
        top_opportunities = opportunities[:3]
        
        return {
            "target_areas": [opp.technology_area for opp in top_opportunities],
            "approach": "Build blocking patents in key technology areas",
            "tactics": [
                "File broad foundational patents",
                "Develop improvement patents",
                "Consider strategic acquisitions"
            ]
        }
    
    def _recommend_portfolio_development(self, opportunities: List[InnovationOpportunity]) -> Dict[str, Any]:
        """Doporučuje vývoj portfolia"""
        return {
            "portfolio_size": f"Target 15-25 patents over 3 years",
            "focus_areas": [opp.technology_area for opp in opportunities[:5]],
            "development_phases": {
                "Phase 1 (0-12 months)": "Core technology patents",
                "Phase 2 (12-24 months)": "Application-specific patents",
                "Phase 3 (24-36 months)": "Improvement and continuation patents"
            }
        }
    
    def _identify_licensing_opportunities(self, landscape_map: Dict[str, Any]) -> List[Dict[str, str]]:
        """Identifikuje licenční příležitosti"""
        leaders = landscape_map.get("market_leaders", [])
        
        opportunities = []
        for leader in leaders[:3]:
            opportunities.append({
                "target": leader.get("company", "Unknown"),
                "opportunity_type": "Cross-licensing",
                "potential": "Medium-High"
            })
        
        return opportunities
    
    def _assess_ip_risks(self, landscape_map: Dict[str, Any], 
                        invention_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Hodnotí IP rizika"""
        competitive_density = landscape_map.get("competitive_density", "Střední")
        patentability_score = invention_analysis.get("patentability_score", 0)
        
        risk_level = "Low"
        if competitive_density == "Vysoká" and patentability_score < 0.6:
            risk_level = "High"
        elif competitive_density == "Vysoká" or patentability_score < 0.6:
            risk_level = "Medium"
        
        return {
            "overall_risk": risk_level,
            "infringement_risk": competitive_density,
            "invalidity_risk": "Low" if patentability_score > 0.7 else "Medium",
            "mitigation_strategies": [
                "Conduct thorough FTO analysis",
                "Develop strong patent claims",
                "Monitor competitor activities"
            ]
        }

class PatentResearchOrchestrator:
    """Hlavní orchestrator pro koordinaci všech agentů"""
    
    def __init__(self):
        self.patent_db = PatentDatabase()
        self.prior_art_agent = PriorArtAgent(self.patent_db)
        self.invention_agent = InventionAnalysisAgent()
        self.landscape_agent = PatentLandscapeAgent(self.patent_db)
        self.opportunity_agent = InnovationOpportunityAgent()
        self.strategy_agent = IPStrategyAgent()
        
    async def comprehensive_analysis(self, invention_description: str, 
                                   technology_area: str) -> Dict[str, Any]:
        """Provádí komplexní analýzu vynálezu a IP strategie"""
        logger.info("Začínám komplexní patentovou analýzu")
        
        try:
            # Krok 1: Prior Art Discovery
            prior_art_result = await self.prior_art_agent.discover_prior_art(invention_description)
            
            # Krok 2: Invention Analysis
            invention_analysis = await self.invention_agent.analyze_invention(
                invention_description, prior_art_result
            )
            
            # Krok 3: Patent Landscape Mapping
            landscape_map = await self.landscape_agent.map_landscape(technology_area)
            
            # Krok 4: Innovation Opportunity Identification
            opportunities = await self.opportunity_agent.identify_opportunities(landscape_map)
            
            # Krok 5: IP Strategy Development
            ip_strategy = await self.strategy_agent.develop_strategy(
                invention_analysis, landscape_map, opportunities
            )
            
            # Kompilace výsledků
            comprehensive_result = {
                "analysis_timestamp": datetime.now().isoformat(),
                "invention_description": invention_description,
                "technology_area": technology_area,
                "prior_art_analysis": {
                    "relevant_patents_count": len(prior_art_result.relevant_patents),
                    "analysis_summary": prior_art_result.analysis_summary,
                    "top_similar_patents": [
                        {"title": p.title, "similarity": score} 
                        for p, score in zip(prior_art_result.relevant_patents[:3], 
                                          prior_art_result.similarity_scores[:3])
                    ]
                },
                "invention_analysis": invention_analysis,
                "patent_landscape": landscape_map,
                "innovation_opportunities": [
                    {
                        "technology_area": opp.technology_area,
                        "market_potential": opp.market_potential,
                        "technical_feasibility": opp.technical_feasibility,
                        "patent_freedom": opp.patent_freedom,
                        "recommended_approach": opp.recommended_approach
                    }
                    for opp in opportunities
                ],
                "ip_strategy": ip_strategy,
                "executive_summary": self._generate_executive_summary(
                    invention_analysis, landscape_map, opportunities, ip_strategy
                )
            }
            
            logger.info("Komplexní analýza dokončena úspěšně")
            return comprehensive_result
            
        except Exception as e:
            logger.error(f"Chyba při provádění analýzy: {str(e)}")
            return {"error": f"Analýza selhala: {str(e)}"}
    
    def _generate_executive_summary(self, invention_analysis: Dict[str, Any],
                                  landscape_map: Dict[str, Any],
                                  opportunities: List[InnovationOpportunity],
                                  ip_strategy: Dict[str, Any]) -> str:
        """Generuje exekutivní shrnutí"""
        patentability_score = invention_analysis.get("patentability_score", 0)
        competitive_density = landscape_map.get("competitive_density", "Neznámá")
        top_opportunity = opportunities[0] if opportunities else None
        
        summary = f"""
        EXEKUTIVNÍ SHRNUTÍ PATENTOVÉ ANALÝZY
        
        Patentovatelnost: {patentability_score:.2f}/1.00 ({invention_analysis.get('recommendation', 'N/A')})
        
        Tržní prostředí: {competitive_density} konkurenční hustota
        
        Hlavní příležitost: {top_opportunity.technology_area if top_opportunity else 'Neidentifikována'}
        
        Doporučená strategie: {ip_strategy.get('patent_filing_recommendation', {}).get('recommendation', 'N/A')}
        
        Klíčová doporučení:
        1. {ip_strategy.get('patent_filing_recommendation', {}).get('reasoning', 'N/A')}
        2. Zaměřit se na geografické trhy: {', '.join(ip_strategy.get('geographic_strategy', {}).get('priority_markets', [])[:3])}
        3. Timing: {ip_strategy.get('timing_strategy', {}).get('timeline', 'N/A')}
        """
        
        return summary.strip()

# Utility funkce pro vizualizaci
class PatentVisualization:
    """Třída pro vizualizaci patentových dat"""
    
    @staticmethod
    def plot_landscape_overview(landscape_map: Dict[str, Any]):
        """Vytváří přehledovou vizualizaci patentové krajiny"""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
        
        # Graf 1: Trendy podle let
        trends = landscape_map.get("trends", {})
        yearly_data = trends.get("yearly_filing_trend", {})
        
        if yearly_data:
            years = list(yearly_data.keys())
            counts = list(yearly_data.values())
            ax1.plot(years, counts, marker='o', linewidth=2, markersize=8)
            ax1.set_title("Trend patentování podle let")
            ax1.set_xlabel("Rok")
            ax1.set_ylabel("Počet patentů")
            ax1.grid(True, alpha=0.3)
        
        # Graf 2: Top přihlašovatelé
        top_assignees = trends.get("top_assignees", {})
        if top_assignees:
            companies = list(top_assignees.keys())[:5]
            patent_counts = list(top_assignees.values())[:5]
            
            ax2.barh(companies, patent_counts, color='skyblue', edgecolor='navy')
            ax2.set_title("Top 5 přihlašovatelů")
            ax2.set_xlabel("Počet patentů")
        
        # Graf 3: Clustery
        clusters = landscape_map.get("clusters", {}).get("clusters", [])
        if clusters:
            cluster_sizes = [c["patent_count"] for c in clusters]
            cluster_labels = [f"Cluster {c['cluster_id']}" for c in clusters]
            
            ax3.pie(cluster_sizes, labels=cluster_labels, autopct='%1.1f%%', startangle=90)
            ax3.set_title("Distribuce patentových clusterů")
        
        # Graf 4: Konkurenční hustota
        competitive_density = landscape_map.get("competitive_density", "Neznámá")
        total_patents = landscape_map.get("total_patents", 0)
        
        density_colors = {"Nízká": "green", "Střední": "orange", "Vysoká": "red"}
        color = density_colors.get(competitive_density, "gray")
        
        ax4.bar(["Konkurenční hustota"], [total_patents], color=color, alpha=0.7)
        ax4.set_title(f"Konkurenční hustota: {competitive_density}")
        ax4.set_ylabel("Celkový počet patentů")
        
        plt.tight_layout()
        plt.savefig("patent_landscape_overview.png", dpi=300, bbox_inches='tight')
        plt.show()
    
    @staticmethod
    def plot_opportunity_matrix(opportunities: List[InnovationOpportunity]):
        """Vytváří matrix příležitostí"""
        if not opportunities:
            return
        
        fig, ax = plt.subplots(figsize=(12, 8))
        
        # Příprava dat
        market_potential = [opp.market_potential for opp in opportunities]
        technical_feasibility = [opp.technical_feasibility for opp in opportunities]
        patent_freedom = [opp.patent_freedom for opp in opportunities]
        labels = [opp.technology_area for opp in opportunities]
        
        # Scatter plot s velikostí bubliny podle patent freedom
        scatter = ax.scatter(market_potential, technical_feasibility, 
                           s=[pf * 500 for pf in patent_freedom],
                           alpha=0.6, c=range(len(opportunities)), 
                           cmap='viridis', edgecolors='black')
        
        # Přidání labelů
        for i, label in enumerate(labels):
            ax.annotate(label, (market_potential[i], technical_feasibility[i]),
                       xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        ax.set_xlabel("Tržní potenciál")
        ax.set_ylabel("Technická proveditelnost")
        ax.set_title("Matrix inovačních příležitostí\n(velikost bubliny = patentová svoboda)")
        ax.grid(True, alpha=0.3)
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        
        # Přidání quadrantů
        ax.axhline(y=0.5, color='red', linestyle='--', alpha=0.5)
        ax.axvline(x=0.5, color='red', linestyle='--', alpha=0.5)
        
        # Legenda pro quadranty
        ax.text(0.75, 0.75, "Vysoký potenciál", fontsize=10, ha='center', 
               bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgreen", alpha=0.7))
        ax.text(0.25, 0.75, "Technicky náročné", fontsize=10, ha='center',
               bbox=dict(boxstyle="round,pad=0.3", facecolor="lightyellow", alpha=0.7))
        ax.text(0.75, 0.25, "Rychlé zisky", fontsize=10, ha='center',
               bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.7))
        ax.text(0.25, 0.25, "Nízký potenciál", fontsize=10, ha='center',
               bbox=dict(boxstyle="round,pad=0.3", facecolor="lightcoral", alpha=0.7))
        
        plt.tight_layout()
        plt.savefig("innovation_opportunity_matrix.png", dpi=300, bbox_inches='tight')
        plt.show()

# Hlavní demonstrační funkce
async def main():
    """Hlavní demonstrační funkce"""
    print("🚀 Spouštím Autonomní Hub pro Patentový Výzkum a Inovace")
    print("=" * 60)
    
    # Inicializace orchestratoru
    orchestrator = PatentResearchOrchestrator()
    
    # Ukázkový vynález
    invention_description = """
    An innovative quantum-enhanced machine learning system that combines quantum computing 
    principles with deep neural networks to optimize complex logistical problems in 
    real-time supply chain management. The system uses quantum superposition to explore 
    multiple solution paths simultaneously while employing classical ML for pattern 
    recognition and predictive analytics.
    """
    
    technology_area = "quantum machine learning logistics optimization"
    
    try:
        # Provedení komplexní analýzy
        print("📊 Provádím komplexní patentovou analýzu...")
        results = await orchestrator.comprehensive_analysis(
            invention_description, technology_area
        )
        
        if "error" in results:
            print(f"❌ Chyba: {results['error']}")
            return
        
        # Výpis výsledků
        print("\n" + "="*60)
        print("📋 VÝSLEDKY ANALÝZY")
        print("="*60)
        
        print(f"\n🔍 Prior Art Analýza:")
        prior_art = results["prior_art_analysis"]
        print(f"   • Nalezeno relevantních patentů: {prior_art['relevant_patents_count']}")
        print(f"   • Shrnutí: {prior_art['analysis_summary']}")
        
        print(f"\n⚖️ Analýza Vynálezu:")
        invention = results["invention_analysis"]
        print(f"   • Skóre patentovatelnosti: {invention['patentability_score']:.2f}/1.00")
        print(f"   • Doporučení: {invention['recommendation']}")
        print(f"   • Klíčové rysy: {', '.join(invention['key_features'])}")
        
        print(f"\n🗺️ Patentová Krajina:")
        landscape = results["patent_landscape"]
        print(f"   • Celkový počet patentů: {landscape['total_patents']}")
        print(f"   • Konkurenční hustota: {landscape['competitive_density']}")
        print(f"   • Růstová rychlost: {landscape['trends']['growth_rate']}% ročně")
        
        print(f"\n💡 Inovační Příležitosti:")
        opportunities = results["innovation_opportunities"]
        for i, opp in enumerate(opportunities[:3], 1):
            print(f"   {i}. {opp['technology_area']}")
            print(f"      • Tržní potenciál: {opp['market_potential']:.2f}")
            print(f"      • Technická proveditelnost: {opp['technical_feasibility']:.2f}")
            print(f"      • Doporučení: {opp['recommended_approach']}")
        
        print(f"\n📈 IP Strategie:")
        strategy = results["ip_strategy"]
        filing_rec = strategy["patent_filing_recommendation"]
        print(f"   • Doporučení k přihlášce: {filing_rec['recommendation']}")
        print(f"   • Priorita: {filing_rec['priority']}")
        print(f"   • Časový plán: {strategy['timing_strategy']['timeline']}")
        
        print(f"\n📊 Exekutivní Shrnutí:")
        print(results["executive_summary"])
        
        # Generování vizualizací
        print(f"\n📈 Generuji vizualizace...")
        
        # Příprava dat pro vizualizaci
        landscape_viz_data = results["patent_landscape"]
        opportunities_viz_data = [
            InnovationOpportunity(
                technology_area=opp["technology_area"],
                gap_description="",
                market_potential=opp["market_potential"],
                technical_feasibility=opp["technical_feasibility"], 
                patent_freedom=opp["patent_freedom"],
                recommended_approach=opp["recommended_approach"]
            )
            for opp in opportunities
        ]
        
        # Vytvoření vizualizací
        try:
            PatentVisualization.plot_landscape_overview(landscape_viz_data)
            PatentVisualization.plot_opportunity_matrix(opportunities_viz_data)
            print("✅ Vizualizace uloženy jako patent_landscape_overview.png a innovation_opportunity_matrix.png")
        except Exception as viz_error:
            print(f"⚠️ Chyba při generování vizualizací: {viz_error}")
        
        # Uložení výsledků do JSON
        output_file = f"patent_analysis_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False, default=str)
        print(f"💾 Výsledky uloženy do souboru: {output_file}")
        
        print(f"\n🎉 Analýza dokončena úspěšně!")
        
    except Exception as e:
        print(f"❌ Neočekávaná chyba: {str(e)}")
        logger.error(f"Chyba v main(): {str(e)}")

if __name__ == "__main__":
    # Spuštění hlavní funkce
    asyncio.run(main())
````

## 5. Souhrn Projektu

### Hodnota Projektu

Autonomní Hub pro Patentový Výzkum a Inovace představuje revoluci v oblasti správy duševního vlastnictví. Systém automatizuje časově náročné procesy analýzy patentů, umožňuje proaktivní identifikaci inovačních příležitostí a optimalizuje IP strategie.

### Klíčové Výhody

1. **Automatizace** - Eliminuje manuální procesy patentového výzkumu
2. **Komplexnost** - Integruje všechny aspekty IP managementu
3. **Prediktivní analýza** - Identifikuje budoucí trendy a příležitosti
4. **Rozhodovací podpora** - Poskytuje datově podložená doporučení

### Technologické Inovace

- **Multi-agentní orchestrace** pro koordinaci komplexních úloh
- **Sémantická analýza** pro porozumění patentovému obsahu
- **Strojové učení** pro predikci patentovatelnosti
- **Vizualizační nástroje** pro interpretaci výsledků

### Budoucí Rozvoj

Systém lze rozšířit o real-time monitoring konkurence, integraci s patentovými úřady, pokročilé AI modely pro právní analýzu a automatizované generování patentových přihlášek.