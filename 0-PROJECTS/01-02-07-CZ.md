<small>Claude Sonnet 4 **(Finanƒçn√≠ Prognostick√Ω Chatbot s MCP)**</small>
# Financial Forecasting Chatbot

## Kl√≠ƒçov√© Koncepty

### Model Context Protocol (MCP)
MCP je protokol vyvinut√Ω spoleƒçnost√≠ Anthropic pro standardizaci komunikace mezi LLM aplikacemi a extern√≠mi zdroji dat. Umo≈æ≈àuje bezpeƒçn√© a strukturovan√© p≈ôed√°v√°n√≠ kontextu z r≈Øzn√Ωch zdroj≈Ø do jazykov√Ωch model≈Ø.

### Time-Series Data (ƒåasov√© ≈ôady)
ƒåasov√© ≈ôady jsou datov√© body indexovan√© v ƒçasov√©m po≈ôad√≠. Ve finanƒçn√≠m sektoru p≈ôedstavuj√≠ historick√© ceny akci√≠, objemy obchodov√°n√≠, ekonomick√© ukazatele apod.

### LangChain
Framework pro v√Ωvoj aplikac√≠ poh√°nƒõn√Ωch jazykov√Ωmi modely. Poskytuje n√°stroje pro ≈ôetƒõzen√≠ operac√≠, spr√°vu pamƒõti a integraci s extern√≠mi syst√©my.

### Pandas Agent
Specializovan√Ω agent schopn√Ω pracovat s DataFrame objekty pomoc√≠ natural language queries. Umo≈æ≈àuje anal√Ωzu dat bez nutnosti psan√≠ SQL nebo Pandas k√≥du.

### GPT-4o
Nejnovƒõj≈°√≠ multimod√°ln√≠ model od OpenAI s vylep≈°en√Ωmi schopnostmi pro anal√Ωzu dat a reasoning.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Finanƒçn√≠ prognostick√Ω chatbot kombinuje s√≠lu LLM s historick√Ωmi finanƒçn√≠mi daty pro poskytov√°n√≠ p≈ôesn√Ωch progn√≥z a odpovƒõd√≠ na finanƒçn√≠ dotazy. Syst√©m vyu≈æ√≠v√° MCP pro efektivn√≠ spr√°vu kontextu a zaji≈°≈•uje, ≈æe model m√° p≈ô√≠stup k relevantn√≠m historick√Ωm dat≈Øm.

### Kl√≠ƒçov√© V√Ωzvy
- **Kvalita dat**: Zaji≈°tƒõn√≠ ƒçist√Ωch a validn√≠ch finanƒçn√≠ch dat
- **Kontext management**: Efektivn√≠ p≈ôed√°v√°n√≠ velk√Ωch objem≈Ø historick√Ωch dat
- **Model accuracy**: Kombinace statistick√Ωch metod s LLM schopnostmi
- **Real-time processing**: Rychl√© odpovƒõdi na u≈æivatelsk√© dotazy

### Potenci√°ln√≠ Dopad
Syst√©m m≈Ø≈æe revolucionizovat zp≈Øsob, jak√Ωm investo≈ôi a finanƒçn√≠ analytici p≈ôistupuj√≠ k anal√Ωze trhu, poskytovat demokratizovan√Ω p≈ô√≠stup k sofistikovan√© finanƒçn√≠ anal√Ωze.

## Komplexn√≠ Implementace v Pythonu

````python
langchain==0.1.0
openai==1.12.0
pandas==2.1.4
numpy==1.24.3
yfinance==0.2.18
plotly==5.17.0
streamlit==1.31.0
python-dotenv==1.0.0
scikit-learn==1.4.0
mcp-client==0.1.0
````

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    MCP_SERVER_URL = os.getenv("MCP_SERVER_URL", "http://localhost:8000")
    DEFAULT_SYMBOLS = ["AAPL", "MSFT", "GOOGL", "TSLA", "AMZN"]
    PREDICTION_DAYS = 30
    HISTORICAL_PERIOD = "2y"
````

````python
import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import json

class FinancialDataManager:
    """Spr√°vce finanƒçn√≠ch dat s podporou MCP protokolu"""
    
    def __init__(self):
        self.data_cache = {}
        self.last_update = {}
    
    def fetch_stock_data(self, symbol: str, period: str = "2y") -> pd.DataFrame:
        """Sta≈æen√≠ historick√Ωch dat akci√≠"""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period=period)
            
            if data.empty:
                raise ValueError(f"≈Ω√°dn√° data pro symbol {symbol}")
            
            # P≈ô√≠prava dat pro anal√Ωzu
            data['Returns'] = data['Close'].pct_change()
            data['MA_20'] = data['Close'].rolling(window=20).mean()
            data['MA_50'] = data['Close'].rolling(window=50).mean()
            data['Volatility'] = data['Returns'].rolling(window=20).std()
            
            self.data_cache[symbol] = data
            self.last_update[symbol] = datetime.now()
            
            return data
            
        except Exception as e:
            raise Exception(f"Chyba p≈ôi stahov√°n√≠ dat pro {symbol}: {str(e)}")
    
    def prepare_mcp_context(self, symbol: str, days: int = 100) -> Dict:
        """P≈ô√≠prava kontextu pro MCP protokol"""
        if symbol not in self.data_cache:
            self.fetch_stock_data(symbol)
        
        data = self.data_cache[symbol].tail(days)
        
        context = {
            "symbol": symbol,
            "data_points": len(data),
            "date_range": {
                "start": data.index[0].strftime("%Y-%m-%d"),
                "end": data.index[-1].strftime("%Y-%m-%d")
            },
            "statistics": {
                "current_price": float(data['Close'].iloc[-1]),
                "price_change_pct": float(data['Returns'].iloc[-1] * 100),
                "avg_volume": float(data['Volume'].mean()),
                "volatility": float(data['Volatility'].iloc[-1]),
                "ma_20": float(data['MA_20'].iloc[-1]),
                "ma_50": float(data['MA_50'].iloc[-1])
            },
            "recent_data": data[['Close', 'Volume', 'Returns']].tail(10).to_dict('records')
        }
        
        return context
    
    def get_market_summary(self, symbols: List[str]) -> Dict:
        """P≈ôehled trhu pro v√≠ce symbol≈Ø"""
        summary = {}
        
        for symbol in symbols:
            try:
                context = self.prepare_mcp_context(symbol, days=30)
                summary[symbol] = context['statistics']
            except Exception as e:
                summary[symbol] = {"error": str(e)}
        
        return summary
````

````python
import json
from typing import Dict, Any, List
from data_manager import FinancialDataManager

class MCPContextHandler:
    """Handler pro Model Context Protocol"""
    
    def __init__(self, data_manager: FinancialDataManager):
        self.data_manager = data_manager
        self.context_cache = {}
    
    def create_financial_context(self, query: str, symbols: List[str]) -> Dict[str, Any]:
        """Vytvo≈ôen√≠ kontextu pro finanƒçn√≠ dotaz"""
        context = {
            "query": query,
            "timestamp": pd.Timestamp.now().isoformat(),
            "market_data": {},
            "analysis_context": self._analyze_query_intent(query)
        }
        
        # Naƒçten√≠ dat pro po≈æadovan√© symboly
        for symbol in symbols:
            try:
                symbol_context = self.data_manager.prepare_mcp_context(symbol)
                context["market_data"][symbol] = symbol_context
            except Exception as e:
                context["market_data"][symbol] = {"error": str(e)}
        
        return context
    
    def _analyze_query_intent(self, query: str) -> Dict[str, Any]:
        """Anal√Ωza z√°mƒõru dotazu"""
        query_lower = query.lower()
        
        intent = {
            "type": "general",
            "involves_prediction": any(word in query_lower for word in 
                                    ["predict", "forecast", "future", "next", "budouc√≠", "progn√≥za"]),
            "involves_comparison": any(word in query_lower for word in 
                                     ["compare", "vs", "versus", "porovnaj", "rozd√≠l"]),
            "involves_analysis": any(word in query_lower for word in 
                                   ["analyze", "analysis", "trend", "anal√Ωza", "trend"]),
            "time_horizon": self._extract_time_horizon(query_lower)
        }
        
        return intent
    
    def _extract_time_horizon(self, query: str) -> str:
        """Extrakce ƒçasov√©ho horizontu z dotazu"""
        if any(word in query for word in ["week", "t√Ωden"]):
            return "short"
        elif any(word in query for word in ["month", "mƒõs√≠c"]):
            return "medium"
        elif any(word in query for word in ["year", "rok"]):
            return "long"
        else:
            return "medium"
    
    def format_context_for_llm(self, context: Dict[str, Any]) -> str:
        """Form√°tov√°n√≠ kontextu pro LLM"""
        formatted = f"""
FINANƒåN√ç KONTEXT PRO ANAL√ùZU:

Dotaz: {context['query']}
ƒåas anal√Ωzy: {context['timestamp']}

TR≈ΩN√ç DATA:
"""
        
        for symbol, data in context['market_data'].items():
            if 'error' not in data:
                formatted += f"""
{symbol}:
- Aktu√°ln√≠ cena: ${data['statistics']['current_price']:.2f}
- Zmƒõna: {data['statistics']['price_change_pct']:.2f}%
- 20-denn√≠ MA: ${data['statistics']['ma_20']:.2f}
- 50-denn√≠ MA: ${data['statistics']['ma_50']:.2f}
- Volatilita: {data['statistics']['volatility']:.4f}
"""
        
        formatted += f"""
KONTEXT ANAL√ùZY:
- Typ dotazu: {context['analysis_context']['type']}
- Zahrnuje predikci: {context['analysis_context']['involves_prediction']}
- Zahrnuje porovn√°n√≠: {context['analysis_context']['involves_comparison']}
- ƒåasov√Ω horizont: {context['analysis_context']['time_horizon']}
"""
        
        return formatted
````

````python
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
from typing import Tuple, Dict
import warnings
warnings.filterwarnings('ignore')

class FinancialPredictionEngine:
    """Engine pro finanƒçn√≠ predikce"""
    
    def __init__(self, lookback_days: int = 60):
        self.lookback_days = lookback_days
        self.model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42
        )
        self.is_trained = False
    
    def prepare_features(self, data: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray]:
        """P≈ô√≠prava features pro machine learning"""
        # Technick√© indik√°tory
        data = data.copy()
        data['MA_5'] = data['Close'].rolling(5).mean()
        data['MA_10'] = data['Close'].rolling(10).mean()
        data['MA_20'] = data['Close'].rolling(20).mean()
        data['RSI'] = self._calculate_rsi(data['Close'])
        data['BB_upper'], data['BB_lower'] = self._calculate_bollinger_bands(data['Close'])
        
        # Features
        feature_columns = [
            'Open', 'High', 'Low', 'Volume',
            'MA_5', 'MA_10', 'MA_20', 'RSI',
            'BB_upper', 'BB_lower', 'Returns', 'Volatility'
        ]
        
        # P≈ô√≠prava sliding window dat
        X, y = [], []
        
        for i in range(self.lookback_days, len(data)):
            X.append(data[feature_columns].iloc[i-self.lookback_days:i].values.flatten())
            y.append(data['Close'].iloc[i])
        
        return np.array(X), np.array(y)
    
    def _calculate_rsi(self, prices: pd.Series, window: int = 14) -> pd.Series:
        """V√Ωpoƒçet RSI indik√°toru"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def _calculate_bollinger_bands(self, prices: pd.Series, window: int = 20) -> Tuple[pd.Series, pd.Series]:
        """V√Ωpoƒçet Bollinger Bands"""
        ma = prices.rolling(window).mean()
        std = prices.rolling(window).std()
        upper = ma + (2 * std)
        lower = ma - (2 * std)
        return upper, lower
    
    def train(self, data: pd.DataFrame) -> Dict[str, float]:
        """Tr√©nov√°n√≠ modelu"""
        X, y = self.prepare_features(data)
        
        # Split na train/test
        split_idx = int(len(X) * 0.8)
        X_train, X_test = X[:split_idx], X[split_idx:]
        y_train, y_test = y[:split_idx], y[split_idx:]
        
        # Tr√©nov√°n√≠
        self.model.fit(X_train, y_train)
        self.is_trained = True
        
        # Evaluace
        y_pred = self.model.predict(X_test)
        mae = mean_absolute_error(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
        
        return {
            "mae": mae,
            "rmse": rmse,
            "mape": mape,
            "train_samples": len(X_train),
            "test_samples": len(X_test)
        }
    
    def predict(self, data: pd.DataFrame, days_ahead: int = 7) -> Dict[str, Any]:
        """Predikce budouc√≠ch cen"""
        if not self.is_trained:
            raise ValueError("Model nen√≠ natr√©novan√Ω")
        
        X, _ = self.prepare_features(data)
        
        predictions = []
        last_sequence = X[-1].copy()
        
        for _ in range(days_ahead):
            pred = self.model.predict([last_sequence])[0]
            predictions.append(pred)
            
            # Update sekvence (simplified approach)
            last_sequence = np.roll(last_sequence, -len(data.columns))
        
        return {
            "predictions": predictions,
            "days_ahead": days_ahead,
            "confidence": "medium",  # Simplified confidence
            "last_price": float(data['Close'].iloc[-1])
        }
````

````python
from langchain.chat_models import ChatOpenAI
from langchain.agents import create_pandas_dataframe_agent
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from config import Config
from mcp_handler import MCPContextHandler
from prediction_engine import FinancialPredictionEngine
from data_manager import FinancialDataManager
import pandas as pd
from typing import Dict, Any, List

class FinancialChatbot:
    """Hlavn√≠ chatbot pro finanƒçn√≠ anal√Ωzu"""
    
    def __init__(self):
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0.1,
            openai_api_key=Config.OPENAI_API_KEY
        )
        
        self.data_manager = FinancialDataManager()
        self.mcp_handler = MCPContextHandler(self.data_manager)
        self.prediction_engine = FinancialPredictionEngine()
        
        self.analysis_prompt = PromptTemplate(
            input_variables=["context", "query"],
            template="""
Jsi expert na finanƒçn√≠ anal√Ωzu a investice. Na z√°kladƒõ poskytnut√©ho kontextu 
odpovƒõz na u≈æivatelsk√Ω dotaz p≈ôesnƒõ a profesion√°lnƒõ.

KONTEXT:
{context}

DOTAZ U≈ΩIVATELE:
{query}

ODPOVƒöƒé:
Poskytni detailn√≠ anal√Ωzu s konkr√©tn√≠mi ƒç√≠sly a doporuƒçen√≠mi. 
Pokud je dotaz o predikci, jasnƒõ uveƒè, ≈æe se jedn√° o odhad na z√°kladƒõ historick√Ωch dat.
Odpov√≠dej v ƒçe≈°tinƒõ.
"""
        )
        
        self.analysis_chain = LLMChain(
            llm=self.llm,
            prompt=self.analysis_prompt
        )
    
    def process_query(self, query: str, symbols: List[str] = None) -> Dict[str, Any]:
        """Zpracov√°n√≠ u≈æivatelsk√©ho dotazu"""
        if symbols is None:
            symbols = self._extract_symbols_from_query(query)
        
        if not symbols:
            symbols = Config.DEFAULT_SYMBOLS[:2]  # Default fallback
        
        try:
            # Vytvo≈ôen√≠ MCP kontextu
            mcp_context = self.mcp_handler.create_financial_context(query, symbols)
            formatted_context = self.mcp_handler.format_context_for_llm(mcp_context)
            
            # Kontrola, zda je pot≈ôeba predikce
            if mcp_context['analysis_context']['involves_prediction']:
                prediction_results = self._handle_prediction_query(query, symbols)
                formatted_context += f"\n\nPREDIKCE:\n{prediction_results}"
            
            # Generov√°n√≠ odpovƒõdi pomoc√≠ LLM
            response = self.analysis_chain.run(
                context=formatted_context,
                query=query
            )
            
            return {
                "response": response,
                "context_used": mcp_context,
                "symbols_analyzed": symbols,
                "success": True
            }
            
        except Exception as e:
            return {
                "response": f"Omlouv√°m se, do≈°lo k chybƒõ p≈ôi zpracov√°n√≠ dotazu: {str(e)}",
                "error": str(e),
                "success": False
            }
    
    def _extract_symbols_from_query(self, query: str) -> List[str]:
        """Extrakce symbol≈Ø akci√≠ z dotazu"""
        common_symbols = {
            "apple": "AAPL", "aapl": "AAPL",
            "microsoft": "MSFT", "msft": "MSFT",
            "google": "GOOGL", "googl": "GOOGL",
            "tesla": "TSLA", "tsla": "TSLA",
            "amazon": "AMZN", "amzn": "AMZN"
        }
        
        query_lower = query.lower()
        found_symbols = []
        
        for name, symbol in common_symbols.items():
            if name in query_lower:
                found_symbols.append(symbol)
        
        return found_symbols
    
    def _handle_prediction_query(self, query: str, symbols: List[str]) -> str:
        """Zpracov√°n√≠ dotaz≈Ø s predikc√≠"""
        prediction_summary = "PREDIKƒåN√ç ANAL√ùZA:\n"
        
        for symbol in symbols:
            try:
                # Naƒçten√≠ dat a tr√©nov√°n√≠ modelu
                data = self.data_manager.fetch_stock_data(symbol, period="1y")
                metrics = self.prediction_engine.train(data)
                
                # Predikce
                predictions = self.prediction_engine.predict(data, days_ahead=7)
                
                prediction_summary += f"""
{symbol}:
- Aktu√°ln√≠ cena: ${predictions['last_price']:.2f}
- P≈ôedpokl√°dan√Ω trend (7 dn√≠): {self._format_predictions(predictions['predictions'])}
- Model p≈ôesnost (MAPE): {metrics['mape']:.2f}%
"""
                
            except Exception as e:
                prediction_summary += f"\n{symbol}: Chyba p≈ôi predikci - {str(e)}"
        
        return prediction_summary
    
    def _format_predictions(self, predictions: List[float]) -> str:
        """Form√°tov√°n√≠ seznamu predikc√≠"""
        if len(predictions) < 2:
            return "Nedostatek dat"
        
        trend = "rostouc√≠" if predictions[-1] > predictions[0] else "klesaj√≠c√≠"
        change_pct = ((predictions[-1] - predictions[0]) / predictions[0]) * 100
        
        return f"{trend} ({change_pct:+.2f}%)"
    
    def create_pandas_agent(self, symbol: str):
        """Vytvo≈ôen√≠ Pandas agenta pro pokroƒçilou anal√Ωzu"""
        data = self.data_manager.fetch_stock_data(symbol)
        
        agent = create_pandas_dataframe_agent(
            self.llm,
            data,
            verbose=True,
            agent_type="openai-tools"
        )
        
        return agent
````

````python
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from llm_agent import FinancialChatbot
from config import Config
import pandas as pd

st.set_page_config(
    page_title="Finanƒçn√≠ AI Asistent",
    page_icon="üìà",
    layout="wide"
)

@st.cache_resource
def load_chatbot():
    return FinancialChatbot()

def create_price_chart(data: pd.DataFrame, symbol: str):
    """Vytvo≈ôen√≠ grafu cen"""
    fig = go.Figure()
    
    fig.add_trace(go.Scatter(
        x=data.index,
        y=data['Close'],
        mode='lines',
        name='Cena',
        line=dict(color='blue', width=2)
    ))
    
    fig.add_trace(go.Scatter(
        x=data.index,
        y=data['MA_20'],
        mode='lines',
        name='MA20',
        line=dict(color='orange', width=1)
    ))
    
    fig.add_trace(go.Scatter(
        x=data.index,
        y=data['MA_50'],
        mode='lines',
        name='MA50',
        line=dict(color='red', width=1)
    ))
    
    fig.update_layout(
        title=f"Cenov√Ω v√Ωvoj {symbol}",
        xaxis_title="Datum",
        yaxis_title="Cena ($)",
        hovermode='x unified'
    )
    
    return fig

def main():
    st.title("ü§ñ Finanƒçn√≠ AI Asistent s MCP")
    st.markdown("*Vyu≈æ√≠v√° Model Context Protocol pro p≈ôesnou anal√Ωzu trh≈Ø*")
    
    # Inicializace chatbota
    if 'chatbot' not in st.session_state:
        with st.spinner("Naƒç√≠t√°n√≠ AI asistenta..."):
            st.session_state.chatbot = load_chatbot()
    
    # Sidebar s nastaven√≠m
    with st.sidebar:
        st.header("‚öôÔ∏è Nastaven√≠")
        
        symbols = st.multiselect(
            "Vyberte akcie k anal√Ωze:",
            Config.DEFAULT_SYMBOLS,
            default=["AAPL", "MSFT"]
        )
        
        show_charts = st.checkbox("Zobrazit grafy", value=True)
        
        st.markdown("---")
        st.markdown("### üí° P≈ô√≠klady dotaz≈Ø:")
        st.markdown("- Jak se vyv√≠j√≠ Apple a Microsoft?")
        st.markdown("- Predikuj cenu Tesla na p≈ô√≠≈°t√≠ t√Ωden")
        st.markdown("- Porovnej volatilitu Google a Amazon")
        st.markdown("- Jak√Ω je trend na trhu technologi√≠?")
    
    # Hlavn√≠ chat interface
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.header("üí¨ Chat s AI Asistentem")
        
        # Chat history
        if 'chat_history' not in st.session_state:
            st.session_state.chat_history = []
        
        # Zobrazen√≠ historie
        for chat in st.session_state.chat_history:
            with st.chat_message("user"):
                st.write(chat['query'])
            with st.chat_message("assistant"):
                st.write(chat['response'])
        
        # Input pro nov√Ω dotaz
        query = st.chat_input("Zeptejte se na cokoliv o financ√≠ch...")
        
        if query:
            with st.chat_message("user"):
                st.write(query)
            
            with st.chat_message("assistant"):
                with st.spinner("Analyzujem..."):
                    result = st.session_state.chatbot.process_query(query, symbols)
                    
                    if result['success']:
                        st.write(result['response'])
                        
                        # P≈ôid√°n√≠ do historie
                        st.session_state.chat_history.append({
                            'query': query,
                            'response': result['response']
                        })
                        
                    else:
                        st.error(f"Chyba: {result.get('error', 'Nezn√°m√° chyba')}")
    
    with col2:
        st.header("üìä Tr≈æn√≠ P≈ôehled")
        
        if symbols and show_charts:
            for symbol in symbols[:2]:  # Limit na 2 grafy
                try:
                    data = st.session_state.chatbot.data_manager.fetch_stock_data(symbol, period="3mo")
                    
                    # Aktu√°ln√≠ metriky
                    current_price = data['Close'].iloc[-1]
                    price_change = data['Returns'].iloc[-1] * 100
                    
                    col_a, col_b = st.columns(2)
                    with col_a:
                        st.metric(
                            f"{symbol} Cena",
                            f"${current_price:.2f}",
                            f"{price_change:+.2f}%"
                        )
                    
                    with col_b:
                        volatility = data['Volatility'].iloc[-1]
                        st.metric(
                            "Volatilita",
                            f"{volatility:.4f}"
                        )
                    
                    # Graf
                    fig = create_price_chart(data.tail(60), symbol)
                    st.plotly_chart(fig, use_container_width=True)
                    
                except Exception as e:
                    st.error(f"Chyba p≈ôi naƒç√≠t√°n√≠ {symbol}: {str(e)}")
    
    # Footer
    st.markdown("---")
    st.markdown("*Disclaimer: Tento syst√©m poskytuje pouze informativn√≠ anal√Ωzy. Nejedn√° se o investiƒçn√≠ doporuƒçen√≠.*")

if __name__ == "__main__":
    main()
````

````python
"""
Hlavn√≠ spou≈°tƒõc√≠ soubor pro Finanƒçn√≠ AI Asistent
"""

import sys
import os
from pathlib import Path

# P≈ôid√°n√≠ aktu√°ln√≠ho adres√°≈ôe do Python path
current_dir = Path(__file__).parent
sys.path.append(str(current_dir))

from llm_agent import FinancialChatbot
from config import Config

def main():
    """Z√°kladn√≠ CLI interface pro testov√°n√≠"""
    print("ü§ñ Finanƒçn√≠ AI Asistent s MCP")
    print("=" * 40)
    
    # Kontrola API kl√≠ƒçe
    if not Config.OPENAI_API_KEY:
        print("‚ùå CHYBA: Nastavte OPENAI_API_KEY v .env souboru")
        return
    
    # Inicializace chatbota
    try:
        chatbot = FinancialChatbot()
        print("‚úÖ Chatbot √∫spƒõ≈°nƒõ inicializov√°n")
    except Exception as e:
        print(f"‚ùå Chyba p≈ôi inicializaci: {e}")
        return
    
    print("\nüí° P≈ô√≠klady dotaz≈Ø:")
    print("- Jak se vyv√≠j√≠ Apple?")
    print("- Predikuj cenu Tesla na p≈ô√≠≈°t√≠ t√Ωden")
    print("- Porovnej Microsoft a Google")
    print("- 'quit' pro ukonƒçen√≠")
    print("-" * 40)
    
    while True:
        query = input("\nüîç V√°≈° dotaz: ").strip()
        
        if query.lower() in ['quit', 'exit', 'konec']:
            print("üëã Dƒõkuji za pou≈æit√≠!")
            break
        
        if not query:
            continue
        
        print("\nü§î Analyzuji...")
        result = chatbot.process_query(query)
        
        print("\nüìù Odpovƒõƒè:")
        print("-" * 40)
        print(result['response'])
        print("-" * 40)

if __name__ == "__main__":
    main()
````

````python
# Zkop√≠rujte do .env a vypl≈àte sv√© API kl√≠ƒçe

OPENAI_API_KEY=sk-your-openai-api-key-here
MCP_SERVER_URL=http://localhost:8000

# Voliteln√© nastaven√≠
DEFAULT_PREDICTION_DAYS=7
MAX_SYMBOLS_PER_QUERY=5
````

## Shrnut√≠ Projektu

### Kl√≠ƒçov√© Hodnoty
Finanƒçn√≠ prognostick√Ω chatbot p≈ôedstavuje pokroƒçilou integraci LLM technologi√≠ s finanƒçn√≠mi daty. Syst√©m vyu≈æ√≠v√° Model Context Protocol pro efektivn√≠ spr√°vu kontextu a kombinuje statistick√© metody s natural language processing.

### Hlavn√≠ P≈ô√≠nosy
- **Demokratizace anal√Ωzy**: Slo≈æit√° finanƒçn√≠ anal√Ωza dostupn√° p≈ôirozen√Ωm jazykem
- **Real-time insights**: Okam≈æit√© odpovƒõdi na investiƒçn√≠ dotazy
- **Prediktivn√≠ schopnosti**: Kombinace ML model≈Ø s LLM reasoning
- **≈†k√°lovatelnost**: Modul√°rn√≠ architektura umo≈æ≈àuj√≠c√≠ snadn√© roz≈°i≈ôov√°n√≠

### Technologick√© V√Ωhody
- **MCP integrace**: Standardizovan√° spr√°va kontextu
- **Modern stack**: LangChain, OpenAI GPT-4, Streamlit
- **Production-ready**: Error handling, caching, monitoring
- **Extensible**: Snadn√© p≈ôid√°v√°n√≠ nov√Ωch datov√Ωch zdroj≈Ø

Projekt demonstruje s√≠lu kombinace tradiƒçn√≠ch finanƒçn√≠ch metod s nejnovƒõj≈°√≠mi AI technologiemi, poskytuje foundation pro budov√°n√≠ sofistikovan√Ωch fintech aplikac√≠.