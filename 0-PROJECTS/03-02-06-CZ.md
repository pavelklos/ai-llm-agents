<small>Claude Sonnet 4 **(Multilingv√°ln√≠ cestovn√≠ asistent s RAG)**</small>
# Multilingual Travel Assistant

## Kl√≠ƒçov√© koncepty projektu

### Retrieval-Augmented Generation (RAG)
RAG je technika, kter√° kombinuje p≈ôedtr√©novan√© jazykov√© modely s extern√≠mi znalostn√≠mi b√°zemi. M√≠sto spol√©h√°n√≠ pouze na znalosti nauƒçen√© bƒõhem tr√©ninku, RAG nejd≈ô√≠ve vyhled√° relevantn√≠ informace z datab√°ze a pot√© generuje odpovƒõƒè na z√°kladƒõ tƒõchto dat.

### GPT-4 Turbo
Pokroƒçil√Ω jazykov√Ω model OpenAI s vylep≈°enou rychlost√≠ a n√°kladovou efektivitou. Poskytuje vysokou kvalitu textov√© generace a podporuje multilingv√°ln√≠ komunikaci.

### Pinecone
Cloudov√° vektorov√° datab√°ze optimalizovan√° pro podobnostn√≠ vyhled√°v√°n√≠. Umo≈æ≈àuje rychl√© ukl√°d√°n√≠ a dotazov√°n√≠ na vektory reprezentuj√≠c√≠ textov√© dokumenty.

### Translation APIs
Slu≈æby pro automatick√Ω p≈ôeklad textu mezi r≈Øzn√Ωmi jazyky. Umo≈æ≈àuj√≠ real-time p≈ôeklad dotaz≈Ø a odpovƒõd√≠.

### Location-based RAG
Roz≈°√≠≈ôen√≠ RAG o prostorov√© informace, kter√© umo≈æ≈àuje filtrov√°n√≠ a vyhled√°v√°n√≠ obsahu na z√°kladƒõ geografick√© polohy u≈æivatele.

## Komplexn√≠ vysvƒõtlen√≠ projektu

### C√≠le projektu
Multilingv√°ln√≠ cestovn√≠ asistent m√° za c√≠l poskytovat turist≈Øm personalizovan√© informace o m√≠stn√≠ch atrakc√≠ch, restaurac√≠ch, ubytov√°n√≠ a kulturn√≠ch ud√°lostech v jejich preferovan√©m jazyce. Syst√©m kombinuje lok√°ln√≠ znalosti s pokroƒçil√Ωmi AI technologiemi.

### Hlavn√≠ v√Ωzvy
- **Multilingv√°ln√≠ podpora**: Zaji≈°tƒõn√≠ p≈ôesn√Ωch p≈ôeklad≈Ø a kulturnƒõ relevantn√≠ch odpovƒõd√≠
- **Aktu√°lnost dat**: Udr≈æov√°n√≠ aktu√°ln√≠ch informac√≠ o m√≠stn√≠ch atrakc√≠ch a slu≈æb√°ch
- **Geografick√© filtrov√°n√≠**: Efektivn√≠ vyhled√°v√°n√≠ podle polohy u≈æivatele
- **≈†k√°lovatelnost**: Podpora v√≠ce destinac√≠ a jazyk≈Ø souƒçasnƒõ

### Potenci√°ln√≠ dopad
Projekt m≈Ø≈æe v√Ωznamnƒõ zlep≈°it z√°≈æitek turist≈Ø, sn√≠≈æit jazykov√© bari√©ry a podpo≈ôit m√≠stn√≠ cestovn√≠ ruch poskytov√°n√≠m personalizovan√Ωch doporuƒçen√≠.

## Komplexn√≠ p≈ô√≠klad implementace v Pythonu

### Instalace z√°vislost√≠

````bash
pip install langchain openai pinecone-client googletrans==3.1.0a0 pandas numpy python-dotenv streamlit geopy
````

### Hlavn√≠ implementace

````python
import os
import pandas as pd
import numpy as np
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime
import json

# LangChain imports
from langchain.embeddings import OpenAIEmbeddings
from langchain.llms import OpenAI
from langchain.vectorstores import Pinecone
from langchain.chains import RetrievalQA
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document

# Additional imports
import pinecone
from googletrans import Translator
from geopy.distance import geodesic
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

@dataclass
class TravelLocation:
    name: str
    description: str
    category: str
    latitude: float
    longitude: float
    city: str
    country: str
    language: str
    rating: float
    price_range: str
    opening_hours: str
    contact_info: Dict[str, str]

class MultilingualTravelAssistant:
    def __init__(self):
        self.openai_api_key = os.getenv("OPENAI_API_KEY")
        self.pinecone_api_key = os.getenv("PINECONE_API_KEY")
        self.pinecone_env = os.getenv("PINECONE_ENVIRONMENT")
        
        # Initialize components
        self.translator = Translator()
        self.embeddings = OpenAIEmbeddings(openai_api_key=self.openai_api_key)
        self.llm = OpenAI(temperature=0.7, openai_api_key=self.openai_api_key)
        
        # Initialize Pinecone
        pinecone.init(
            api_key=self.pinecone_api_key,
            environment=self.pinecone_env
        )
        
        self.index_name = "travel-locations"
        self.vectorstore = None
        self.qa_chain = None
        
        # Supported languages
        self.supported_languages = {
            'cs': 'ƒçe≈°tina',
            'en': 'English',
            'de': 'Deutsch',
            'fr': 'Fran√ßais',
            'es': 'Espa√±ol',
            'it': 'Italiano'
        }
        
    def create_sample_data(self) -> List[TravelLocation]:
        """Vytvo≈ô√≠ uk√°zkov√° data cestovn√≠ch destinac√≠"""
        sample_locations = [
            TravelLocation(
                name="Pra≈æsk√Ω hrad",
                description="Nejvƒõt≈°√≠ starovƒõk√Ω hradn√≠ komplex na svƒõtƒõ s bohatou histori√≠ sahaj√≠c√≠ do 9. stolet√≠. Zahrnuje Katedr√°lu sv. V√≠ta, Star√Ω kr√°lovsk√Ω pal√°c a dal≈°√≠ historick√© budovy.",
                category="Historick√° pam√°tka",
                latitude=50.0905,
                longitude=14.4006,
                city="Praha",
                country="ƒåesk√° republika",
                language="cs",
                rating=4.8,
                price_range="‚Ç¨‚Ç¨",
                opening_hours="9:00-17:00",
                contact_info={"website": "www.hrad.cz", "phone": "+420 224 373 368"}
            ),
            TravelLocation(
                name="Karl≈Øv most",
                description="Ikonick√Ω kamenn√Ω most z 14. stolet√≠ spojuj√≠c√≠ Star√© Mƒõsto s Malou Stranou. Zdoben√Ω 30 sochami svat√Ωch a ƒçasto pova≈æovan√Ω za symbol Prahy.",
                category="Architektura",
                latitude=50.0865,
                longitude=14.4114,
                city="Praha",
                country="ƒåesk√° republika",
                language="cs",
                rating=4.7,
                price_range="Zdarma",
                opening_hours="24/7",
                contact_info={"website": "www.prague.eu"}
            ),
            TravelLocation(
                name="Louvre Museum",
                description="The world's largest art museum housing over 35,000 works including the Mona Lisa and Venus de Milo. A historic palace turned into the ultimate cultural destination.",
                category="Museum",
                latitude=48.8606,
                longitude=2.3376,
                city="Paris",
                country="France",
                language="en",
                rating=4.6,
                price_range="‚Ç¨‚Ç¨‚Ç¨",
                opening_hours="9:00-18:00",
                contact_info={"website": "www.louvre.fr", "phone": "+33 1 40 20 50 50"}
            ),
            TravelLocation(
                name="Eiffel Tower",
                description="Iconic iron lattice tower built in 1889, offering breathtaking views of Paris from its observation decks. Symbol of France and architectural marvel.",
                category="Landmark",
                latitude=48.8584,
                longitude=2.2945,
                city="Paris",
                country="France",
                language="en",
                rating=4.5,
                price_range="‚Ç¨‚Ç¨",
                opening_hours="9:30-23:45",
                contact_info={"website": "www.toureiffel.paris"}
            )
        ]
        return sample_locations
    
    def setup_vectorstore(self, locations: List[TravelLocation]):
        """Nastaven√≠ vektorov√© datab√°ze Pinecone"""
        try:
            # Vytvo≈ôen√≠ nebo p≈ôipojen√≠ k indexu
            if self.index_name not in pinecone.list_indexes():
                pinecone.create_index(
                    name=self.index_name,
                    dimension=1536,  # OpenAI embedding dimension
                    metric="cosine"
                )
            
            # P≈ô√≠prava dokument≈Ø pro indexov√°n√≠
            documents = []
            for location in locations:
                content = f"""
                N√°zev: {location.name}
                Popis: {location.description}
                Kategorie: {location.category}
                Mƒõsto: {location.city}
                Zemƒõ: {location.country}
                Hodnocen√≠: {location.rating}/5
                Cenov√° kategorie: {location.price_range}
                Otev√≠rac√≠ doba: {location.opening_hours}
                Sou≈ôadnice: {location.latitude}, {location.longitude}
                """
                
                metadata = {
                    "name": location.name,
                    "category": location.category,
                    "city": location.city,
                    "country": location.country,
                    "latitude": location.latitude,
                    "longitude": location.longitude,
                    "rating": location.rating,
                    "language": location.language
                }
                
                doc = Document(page_content=content, metadata=metadata)
                documents.append(doc)
            
            # Rozdƒõlen√≠ dokument≈Ø na men≈°√≠ ƒç√°sti
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=1000,
                chunk_overlap=200
            )
            splits = text_splitter.split_documents(documents)
            
            # Vytvo≈ôen√≠ vektorov√© datab√°ze
            self.vectorstore = Pinecone.from_documents(
                splits,
                self.embeddings,
                index_name=self.index_name
            )
            
            # Vytvo≈ôen√≠ QA ≈ôetƒõzce
            self.qa_chain = RetrievalQA.from_chain_type(
                llm=self.llm,
                chain_type="stuff",
                retriever=self.vectorstore.as_retriever(search_kwargs={"k": 3}),
                return_source_documents=True
            )
            
            print(f"Vektorov√° datab√°ze √∫spƒõ≈°nƒõ nastavena s {len(splits)} dokumenty")
            
        except Exception as e:
            print(f"Chyba p≈ôi nastavov√°n√≠ vektorov√© datab√°ze: {str(e)}")
            raise
    
    def detect_language(self, text: str) -> str:
        """Detekce jazyka vstupn√≠ho textu"""
        try:
            detected = self.translator.detect(text)
            return detected.lang if detected.lang in self.supported_languages else 'en'
        except:
            return 'en'
    
    def translate_text(self, text: str, target_language: str) -> str:
        """P≈ôeklad textu do c√≠lov√©ho jazyka"""
        try:
            if target_language == 'en':
                return text
            translated = self.translator.translate(text, dest=target_language)
            return translated.text
        except Exception as e:
            print(f"Chyba p≈ôi p≈ôekladu: {str(e)}")
            return text
    
    def filter_by_location(self, user_lat: float, user_lon: float, max_distance_km: float = 50) -> List[str]:
        """Filtrov√°n√≠ destinac√≠ podle vzd√°lenosti od u≈æivatele"""
        try:
            # Pro demonstraci - v re√°ln√© aplikaci by se pou≈æ√≠val Pinecone metadata filtr
            sample_locations = self.create_sample_data()
            nearby_locations = []
            
            for location in sample_locations:
                distance = geodesic(
                    (user_lat, user_lon),
                    (location.latitude, location.longitude)
                ).kilometers
                
                if distance <= max_distance_km:
                    nearby_locations.append(location.name)
            
            return nearby_locations
        except Exception as e:
            print(f"Chyba p≈ôi filtrov√°n√≠ podle polohy: {str(e)}")
            return []
    
    def process_query(self, query: str, user_lat: Optional[float] = None, 
                     user_lon: Optional[float] = None, target_language: str = 'cs') -> Dict[str, str]:
        """Zpracov√°n√≠ u≈æivatelsk√©ho dotazu"""
        try:
            # Detekce jazyka dotazu
            detected_lang = self.detect_language(query)
            
            # P≈ôeklad dotazu do angliƒçtiny pro zpracov√°n√≠
            english_query = self.translate_text(query, 'en') if detected_lang != 'en' else query
            
            # P≈ôid√°n√≠ kontextu polohy
            if user_lat and user_lon:
                nearby_locations = self.filter_by_location(user_lat, user_lon)
                if nearby_locations:
                    location_context = f"Nearby locations: {', '.join(nearby_locations)}. "
                    english_query = location_context + english_query
            
            # Vylep≈°en√≠ dotazu pro cestovn√≠ kontext
            enhanced_query = f"""
            As a multilingual travel assistant, please provide helpful information about: {english_query}
            Include practical details like opening hours, prices, and recommendations when relevant.
            Be specific and informative for tourists.
            """
            
            # Z√≠sk√°n√≠ odpovƒõdi z RAG syst√©mu
            result = self.qa_chain({"query": enhanced_query})
            answer = result["result"]
            source_docs = result["source_documents"]
            
            # P≈ôeklad odpovƒõdi do po≈æadovan√©ho jazyka
            final_answer = self.translate_text(answer, target_language)
            
            # P≈ô√≠prava metadat o zdroj√≠ch
            sources = []
            for doc in source_docs:
                if "name" in doc.metadata:
                    sources.append(doc.metadata["name"])
            
            return {
                "answer": final_answer,
                "sources": list(set(sources)),
                "original_query": query,
                "detected_language": detected_lang,
                "target_language": target_language
            }
            
        except Exception as e:
            error_msg = f"Omlouv√°m se, do≈°lo k chybƒõ p≈ôi zpracov√°n√≠ dotazu: {str(e)}"
            return {
                "answer": error_msg,
                "sources": [],
                "original_query": query,
                "detected_language": detected_lang,
                "target_language": target_language
            }

class TravelAssistantInterface:
    """Jednoduch√© rozhran√≠ pro testov√°n√≠ asistenta"""
    
    def __init__(self):
        self.assistant = MultilingualTravelAssistant()
        self.setup_assistant()
    
    def setup_assistant(self):
        """Inicializace asistenta s uk√°zkov√Ωmi daty"""
        print("Inicializace cestovn√≠ho asistenta...")
        sample_data = self.assistant.create_sample_data()
        self.assistant.setup_vectorstore(sample_data)
        print("Asistent je p≈ôipraven k pou≈æit√≠!")
    
    def run_example_queries(self):
        """Spu≈°tƒõn√≠ uk√°zkov√Ωch dotaz≈Ø"""
        example_queries = [
            {
                "query": "Jak√© jsou nejlep≈°√≠ pam√°tky v Praze?",
                "language": "cs",
                "lat": 50.0755,
                "lon": 14.4378
            },
            {
                "query": "What are the best museums in Paris?",
                "language": "en", 
                "lat": 48.8566,
                "lon": 2.3522
            },
            {
                "query": "Kolik stoj√≠ vstupn√© do Louvru?",
                "language": "cs",
                "lat": None,
                "lon": None
            }
        ]
        
        for i, example in enumerate(example_queries, 1):
            print(f"\n{'='*50}")
            print(f"DOTAZ {i}: {example['query']}")
            print(f"{'='*50}")
            
            result = self.assistant.process_query(
                query=example["query"],
                user_lat=example["lat"],
                user_lon=example["lon"],
                target_language=example["language"]
            )
            
            print(f"Odpovƒõƒè: {result['answer']}")
            if result['sources']:
                print(f"Zdroje: {', '.join(result['sources'])}")
            print(f"Detekovan√Ω jazyk: {result['detected_language']}")

def main():
    """Hlavn√≠ funkce pro spu≈°tƒõn√≠ aplikace"""
    try:
        # Kontrola environment variables
        required_vars = ["OPENAI_API_KEY", "PINECONE_API_KEY", "PINECONE_ENVIRONMENT"]
        missing_vars = [var for var in required_vars if not os.getenv(var)]
        
        if missing_vars:
            print(f"Chyb√≠ environment variables: {', '.join(missing_vars)}")
            print("Pros√≠m nastavte je v .env souboru nebo syst√©mov√Ωch promƒõnn√Ωch.")
            return
        
        # Spu≈°tƒõn√≠ uk√°zkov√© aplikace
        interface = TravelAssistantInterface()
        interface.run_example_queries()
        
        # Interaktivn√≠ re≈æim
        print(f"\n{'='*50}")
        print("INTERAKTIVN√ç RE≈ΩIM")
        print("Zadejte 'quit' pro ukonƒçen√≠")
        print(f"{'='*50}")
        
        while True:
            query = input("\nV√°≈° dotaz: ").strip()
            if query.lower() == 'quit':
                break
                
            if not query:
                continue
            
            result = interface.assistant.process_query(query)
            print(f"\nOdpovƒõƒè: {result['answer']}")
            if result['sources']:
                print(f"Zdroje: {', '.join(result['sources'])}")
        
    except KeyboardInterrupt:
        print("\nUkonƒçov√°n√≠ aplikace...")
    except Exception as e:
        print(f"Neoƒçek√°van√° chyba: {str(e)}")

if __name__ == "__main__":
    main()
````

### Konfiguraƒçn√≠ soubory

````python
langchain==0.0.350
openai==1.3.7
pinecone-client==2.2.4
googletrans==3.1.0a0
pandas==2.1.4
numpy==1.24.3
python-dotenv==1.0.0
streamlit==1.28.2
geopy==2.4.0
````

````bash
OPENAI_API_KEY=your_openai_api_key_here
PINECONE_API_KEY=your_pinecone_api_key_here
PINECONE_ENVIRONMENT=your_pinecone_environment_here
````

### Streamlit webov√© rozhran√≠

````python
import streamlit as st
import os
from multilingual_travel_assistant import MultilingualTravelAssistant

def main():
    st.set_page_config(
        page_title="Multilingv√°ln√≠ cestovn√≠ asistent",
        page_icon="üåç",
        layout="wide"
    )
    
    st.title("üåç Multilingv√°ln√≠ cestovn√≠ asistent")
    st.write("Polo≈æte dotaz o cestov√°n√≠ v libovoln√©m jazyce!")
    
    # Inicializace asistenta
    if 'assistant' not in st.session_state:
        with st.spinner('Inicializace asistenta...'):
            st.session_state.assistant = MultilingualTravelAssistant()
            sample_data = st.session_state.assistant.create_sample_data()
            st.session_state.assistant.setup_vectorstore(sample_data)
    
    # Vstupn√≠ formul√°≈ô
    col1, col2 = st.columns([3, 1])
    
    with col1:
        query = st.text_input("V√°≈° dotaz:", placeholder="Nap≈ô√≠klad: Jak√© jsou nejlep≈°√≠ restaurace v Praze?")
    
    with col2:
        target_lang = st.selectbox("Jazyk odpovƒõdi:", ["cs", "en", "de", "fr", "es", "it"])
    
    # Voliteln√© informace o poloze
    with st.expander("P≈ôidat informace o poloze"):
        col1, col2 = st.columns(2)
        with col1:
            lat = st.number_input("Zemƒõpisn√° ≈°√≠≈ôka:", value=None, format="%.6f")
        with col2:
            lon = st.number_input("Zemƒõpisn√° d√©lka:", value=None, format="%.6f")
    
    # Zpracov√°n√≠ dotazu
    if st.button("Zeptat se", type="primary"):
        if query:
            with st.spinner('Zpracov√°v√°m dotaz...'):
                result = st.session_state.assistant.process_query(
                    query=query,
                    user_lat=lat,
                    user_lon=lon,
                    target_language=target_lang
                )
                
                # Zobrazen√≠ v√Ωsledk≈Ø
                st.write("### Odpovƒõƒè:")
                st.write(result['answer'])
                
                if result['sources']:
                    st.write("### Zdroje:")
                    for source in result['sources']:
                        st.write(f"- {source}")
                
                # Metadata
                with st.expander("Technick√© informace"):
                    st.write(f"**Detekovan√Ω jazyk:** {result['detected_language']}")
                    st.write(f"**C√≠lov√Ω jazyk:** {result['target_language']}")
        else:
            st.warning("Pros√≠m zadejte dotaz.")

if __name__ == "__main__":
    main()
````

## Shrnut√≠ projektu

Multilingv√°ln√≠ cestovn√≠ asistent p≈ôedstavuje pokroƒçil√© ≈ôe≈°en√≠ kombinuj√≠c√≠ RAG technologii s modern√≠mi AI n√°stroji pro poskytov√°n√≠ personalizovan√Ωch cestovn√≠ch informac√≠. Projekt √∫spƒõ≈°nƒõ ≈ôe≈°√≠ kl√≠ƒçov√© v√Ωzvy multilingv√°ln√≠ komunikace, geografick√©ho filtrov√°n√≠ a aktu√°lnosti dat.

### Kl√≠ƒçov√© v√Ωhody:
- **Multilingv√°ln√≠ podpora** s automatickou detekc√≠ a p≈ôekladem
- **Geografick√© filtrov√°n√≠** pro relevantn√≠ m√≠stn√≠ informace  
- **≈†k√°lovateln√° architektura** s Pinecone vektorovou datab√°z√≠
- **Real-time odpovƒõdi** kombinuj√≠c√≠ p≈ôesn√© informace s konverzaƒçn√≠mi schopnostmi

### Technologick√° hodnota:
Projekt demonstruje efektivn√≠ kombinaci LangChain, OpenAI GPT-4, Pinecone a p≈ôekladov√Ωch slu≈æeb pro vytvo≈ôen√≠ praktick√© AI aplikace s re√°ln√Ωm dopadem na cestovn√≠ ruch.