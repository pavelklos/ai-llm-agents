<small>Claude Sonnet 4 **(Smart Manufacturing Quality Control System)**</small>
# Smart Manufacturing Quality Control System

## 1. N√°zev projektu

**Inteligentn√≠ syst√©m kontroly kvality pro v√Ωrobu s multi-agentn√≠ architekturou**

## 2. Vysvƒõtlen√≠ kl√≠ƒçov√Ωch koncept≈Ø

### Multi-Agent Systems (Multi-agentn√≠ syst√©my)
Distribuovan√Ω syst√©m slo≈æen√Ω z v√≠ce autonomn√≠ch softwarov√Ωch agent≈Ø, kte≈ô√≠ spolupracuj√≠ p≈ôi ≈ôe≈°en√≠ komplexn√≠ch √∫kol≈Ø. Ka≈æd√Ω agent m√° svou specializaci a m≈Ø≈æe samostatnƒõ rozhodovat.

### Defect Detection (Detekce vad)
Automatick√© rozpozn√°v√°n√≠ a klasifikace v√Ωrobn√≠ch vad pomoc√≠ poƒç√≠taƒçov√©ho vidƒõn√≠ a strojov√©ho uƒçen√≠ pro zaji≈°tƒõn√≠ kvality produkt≈Ø.

### Process Optimization (Optimalizace proces≈Ø)
Kontinu√°ln√≠ zlep≈°ov√°n√≠ v√Ωrobn√≠ch proces≈Ø na z√°kladƒõ anal√Ωzy dat pro zv√Ω≈°en√≠ efektivity a sn√≠≈æen√≠ n√°klad≈Ø.

### Predictive Maintenance (Prediktivn√≠ √∫dr≈æba)
P≈ôedpovƒõƒè poruch stroj≈Ø na z√°kladƒõ senzorov√Ωch dat a historick√Ωch vzorc≈Ø pro minimalizaci nepl√°novan√Ωch prostoj≈Ø.

### Resource Allocation (Alokace zdroj≈Ø)
Optim√°ln√≠ rozdƒõlen√≠ v√Ωrobn√≠ch zdroj≈Ø (stroje, materi√°ly, pracovn√≠ci) pro maximalizaci produktivity.

### Production Scheduling (Pl√°nov√°n√≠ v√Ωroby)
Inteligentn√≠ rozvrhov√°n√≠ v√Ωrobn√≠ch √∫kol≈Ø s ohledem na kapacity, term√≠ny a priority zak√°zek.

## 3. Komplexn√≠ vysvƒõtlen√≠ projektu

Tento projekt p≈ôedstavuje pokroƒçil√Ω multi-agentn√≠ syst√©m pro kontrolu kvality ve smart manufacturing prost≈ôed√≠. Syst√©m integruje nƒõkolik specializovan√Ωch AI agent≈Ø, kte≈ô√≠ spolupracuj√≠ na zaji≈°tƒõn√≠ nejvy≈°≈°√≠ kvality v√Ωroby p≈ôi optimalizaci cel√©ho v√Ωrobn√≠ho procesu.

### C√≠le projektu:
- **Automatizace kontroly kvality**: Kontinu√°ln√≠ monitoring a detekce vad v re√°ln√©m ƒçase
- **Optimalizace v√Ωroby**: Zv√Ω≈°en√≠ efektivity a sn√≠≈æen√≠ pl√Ωtv√°n√≠
- **Prediktivn√≠ √∫dr≈æba**: Prevence poruch a prodlou≈æen√≠ ≈æivotnosti stroj≈Ø
- **Inteligentn√≠ pl√°nov√°n√≠**: Adaptivn√≠ scheduling podle aktu√°ln√≠ch podm√≠nek

### V√Ωzvy:
- Koordinace mezi r≈Øzn√Ωmi agenty
- Zpracov√°n√≠ velk√©ho mno≈æstv√≠ senzorov√Ωch dat v re√°ln√©m ƒçase
- Balancov√°n√≠ kvality a produktivity
- Integrace s existuj√≠c√≠mi v√Ωrobn√≠mi syst√©my

### Potenci√°ln√≠ dopad:
- Sn√≠≈æen√≠ poƒçtu vadn√Ωch produkt≈Ø o 80-90%
- Zv√Ω≈°en√≠ celkov√© efektivity v√Ωroby o 25-35%
- Redukce nepl√°novan√Ωch prostoj≈Ø o 60-70%
- Optimalizace spot≈ôeby energie a materi√°l≈Ø

## 4. Komplexn√≠ p≈ô√≠klad implementace v Pythonu

````python
import asyncio
import logging
import json
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
import cv2
import matplotlib.pyplot as plt
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import uvicorn
from fastapi import FastAPI, WebSocket
from pydantic import BaseModel
import sqlite3
from concurrent.futures import ThreadPoolExecutor
import threading
import time

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Datov√© modely
class DefectType(Enum):
    CRACK = "crack"
    SCRATCH = "scratch"
    DISCOLORATION = "discoloration"
    DEFORMATION = "deformation"
    NONE = "none"

class MachineStatus(Enum):
    RUNNING = "running"
    MAINTENANCE = "maintenance"
    FAULT = "fault"
    IDLE = "idle"

@dataclass
class Product:
    id: str
    type: str
    quality_score: float
    defects: List[DefectType]
    production_time: datetime
    machine_id: str

@dataclass
class Machine:
    id: str
    type: str
    status: MachineStatus
    efficiency: float
    last_maintenance: datetime
    sensor_data: Dict[str, float]

@dataclass
class ProductionOrder:
    id: str
    product_type: str
    quantity: int
    priority: int
    deadline: datetime
    status: str

# Hlavn√≠ t≈ô√≠da pro multi-agentn√≠ syst√©m
class SmartManufacturingSystem:
    def __init__(self):
        self.agents = {}
        self.shared_memory = {}
        self.event_bus = asyncio.Queue()
        self.running = False
        self.setup_database()
        
    def setup_database(self):
        """Inicializace datab√°ze"""
        self.conn = sqlite3.connect('manufacturing.db', check_same_thread=False)
        cursor = self.conn.cursor()
        
        # Tabulka pro produkty
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS products (
                id TEXT PRIMARY KEY,
                type TEXT,
                quality_score REAL,
                defects TEXT,
                production_time TEXT,
                machine_id TEXT
            )
        ''')
        
        # Tabulka pro stroje
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS machines (
                id TEXT PRIMARY KEY,
                type TEXT,
                status TEXT,
                efficiency REAL,
                last_maintenance TEXT
            )
        ''')
        
        # Tabulka pro zak√°zky
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS orders (
                id TEXT PRIMARY KEY,
                product_type TEXT,
                quantity INTEGER,
                priority INTEGER,
                deadline TEXT,
                status TEXT
            )
        ''')
        
        self.conn.commit()

    async def start_system(self):
        """Spu≈°tƒõn√≠ cel√©ho syst√©mu"""
        self.running = True
        
        # Inicializace agent≈Ø
        self.agents['quality'] = QualityControlAgent(self)
        self.agents['maintenance'] = PredictiveMaintenanceAgent(self)
        self.agents['scheduler'] = ProductionSchedulerAgent(self)
        self.agents['optimizer'] = ProcessOptimizerAgent(self)
        self.agents['resource'] = ResourceAllocationAgent(self)
        
        # Spu≈°tƒõn√≠ v≈°ech agent≈Ø
        tasks = []
        for agent in self.agents.values():
            tasks.append(asyncio.create_task(agent.run()))
        
        # Spu≈°tƒõn√≠ event procesoru
        tasks.append(asyncio.create_task(self.process_events()))
        
        await asyncio.gather(*tasks)

    async def process_events(self):
        """Zpracov√°n√≠ ud√°lost√≠ mezi agenty"""
        while self.running:
            try:
                event = await asyncio.wait_for(self.event_bus.get(), timeout=1.0)
                await self.distribute_event(event)
            except asyncio.TimeoutError:
                continue

    async def distribute_event(self, event):
        """Distribuce ud√°lost√≠ mezi agenty"""
        for agent in self.agents.values():
            await agent.handle_event(event)

# Z√°kladn√≠ t≈ô√≠da pro agenty
class BaseAgent:
    def __init__(self, system: SmartManufacturingSystem, name: str):
        self.system = system
        self.name = name
        self.running = False

    async def run(self):
        """Hlavn√≠ smyƒçka agenta"""
        self.running = True
        logger.info(f"Agent {self.name} spu≈°tƒõn")
        
        while self.running:
            try:
                await self.execute_cycle()
                await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"Chyba v agentovi {self.name}: {e}")

    async def execute_cycle(self):
        """Implementov√°no v podt≈ô√≠d√°ch"""
        pass

    async def handle_event(self, event):
        """Zpracov√°n√≠ ud√°lost√≠"""
        pass

    async def send_event(self, event_type: str, data: Any):
        """Odesl√°n√≠ ud√°losti"""
        event = {
            'type': event_type,
            'source': self.name,
            'timestamp': datetime.now(),
            'data': data
        }
        await self.system.event_bus.put(event)

# Agent pro kontrolu kvality
class QualityControlAgent(BaseAgent):
    def __init__(self, system):
        super().__init__(system, "QualityControl")
        self.defect_detector = DefectDetector()
        self.quality_threshold = 0.85
        
    async def execute_cycle(self):
        """Kontrola kvality produkt≈Ø"""
        # Simulace nov√Ωch produkt≈Ø k testov√°n√≠
        products = self.generate_sample_products()
        
        for product in products:
            # Detekce vad
            defects = await self.detect_defects(product)
            product.defects = defects
            
            # V√Ωpoƒçet sk√≥re kvality
            quality_score = self.calculate_quality_score(product)
            product.quality_score = quality_score
            
            # Ulo≈æen√≠ do datab√°ze
            self.save_product(product)
            
            # Odesl√°n√≠ ud√°losti pokud je n√≠zk√° kvalita
            if quality_score < self.quality_threshold:
                await self.send_event('quality_alert', {
                    'product_id': product.id,
                    'quality_score': quality_score,
                    'defects': [d.value for d in defects],
                    'machine_id': product.machine_id
                })

    def generate_sample_products(self) -> List[Product]:
        """Generov√°n√≠ vzorov√Ωch produkt≈Ø"""
        products = []
        for i in range(3):
            product = Product(
                id=f"PROD_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{i}",
                type=np.random.choice(['TypeA', 'TypeB', 'TypeC']),
                quality_score=0.0,
                defects=[],
                production_time=datetime.now(),
                machine_id=f"MACHINE_{np.random.randint(1, 6)}"
            )
            products.append(product)
        return products

    async def detect_defects(self, product: Product) -> List[DefectType]:
        """Detekce vad pomoc√≠ AI"""
        # Simulace detekce vad
        defect_probability = np.random.random()
        defects = []
        
        if defect_probability < 0.1:  # 10% ≈°ance na vadu
            possible_defects = list(DefectType)
            possible_defects.remove(DefectType.NONE)
            defects.append(np.random.choice(possible_defects))
        
        return defects

    def calculate_quality_score(self, product: Product) -> float:
        """V√Ωpoƒçet sk√≥re kvality"""
        base_score = 0.95
        
        # Sn√≠≈æen√≠ sk√≥re za ka≈ædou vadu
        penalty_per_defect = 0.15
        penalty = len(product.defects) * penalty_per_defect
        
        # P≈ôid√°n√≠ n√°hodn√©ho ≈°umu
        noise = np.random.normal(0, 0.05)
        
        final_score = max(0.0, min(1.0, base_score - penalty + noise))
        return round(final_score, 3)

    def save_product(self, product: Product):
        """Ulo≈æen√≠ produktu do datab√°ze"""
        cursor = self.system.conn.cursor()
        cursor.execute('''
            INSERT OR REPLACE INTO products 
            (id, type, quality_score, defects, production_time, machine_id)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            product.id,
            product.type,
            product.quality_score,
            json.dumps([d.value for d in product.defects]),
            product.production_time.isoformat(),
            product.machine_id
        ))
        self.system.conn.commit()

# Agent pro prediktivn√≠ √∫dr≈æbu
class PredictiveMaintenanceAgent(BaseAgent):
    def __init__(self, system):
        super().__init__(system, "PredictiveMaintenance")
        self.anomaly_detector = IsolationForest(contamination=0.1)
        self.scaler = StandardScaler()
        self.maintenance_threshold = 0.3

    async def execute_cycle(self):
        """Predikce pot≈ôeby √∫dr≈æby"""
        machines = self.get_machine_data()
        
        for machine in machines:
            # Anal√Ωza senzorov√Ωch dat
            risk_score = self.predict_maintenance_risk(machine)
            
            if risk_score > self.maintenance_threshold:
                await self.send_event('maintenance_required', {
                    'machine_id': machine.id,
                    'risk_score': risk_score,
                    'recommended_action': 'immediate_inspection'
                })

    def get_machine_data(self) -> List[Machine]:
        """Z√≠sk√°n√≠ dat o stroj√≠ch"""
        machines = []
        for i in range(1, 6):
            # Simulace senzorov√Ωch dat
            sensor_data = {
                'temperature': np.random.normal(75, 10),
                'vibration': np.random.normal(0.5, 0.2),
                'pressure': np.random.normal(100, 15),
                'power_consumption': np.random.normal(500, 50)
            }
            
            machine = Machine(
                id=f"MACHINE_{i}",
                type=f"Type_{chr(65+i)}",
                status=MachineStatus.RUNNING,
                efficiency=np.random.uniform(0.8, 0.98),
                last_maintenance=datetime.now() - timedelta(days=np.random.randint(1, 30)),
                sensor_data=sensor_data
            )
            machines.append(machine)
        
        return machines

    def predict_maintenance_risk(self, machine: Machine) -> float:
        """Predikce rizika poruchy"""
        # Jednoduch√Ω model na z√°kladƒõ senzorov√Ωch dat
        sensor_values = list(machine.sensor_data.values())
        
        # Normalizace hodnot
        normalized_values = np.array(sensor_values) / np.array([100, 1, 150, 600])
        
        # V√Ωpoƒçet rizikov√©ho sk√≥re
        risk_score = np.mean(np.abs(normalized_values - 0.75))
        
        # Faktor st√°≈ô√≠ od posledn√≠ √∫dr≈æby
        days_since_maintenance = (datetime.now() - machine.last_maintenance).days
        age_factor = min(days_since_maintenance / 30, 1.0)
        
        final_risk = (risk_score + age_factor) / 2
        return min(final_risk, 1.0)

# Agent pro pl√°nov√°n√≠ v√Ωroby
class ProductionSchedulerAgent(BaseAgent):
    def __init__(self, system):
        super().__init__(system, "ProductionScheduler")
        self.schedule = {}

    async def execute_cycle(self):
        """Pl√°nov√°n√≠ v√Ωrobn√≠ch √∫kol≈Ø"""
        orders = self.get_production_orders()
        available_machines = self.get_available_machines()
        
        # Optimalizace rozvrhu
        optimized_schedule = self.optimize_schedule(orders, available_machines)
        
        # Aktualizace rozvrhu
        self.schedule.update(optimized_schedule)
        
        # Odesl√°n√≠ pl√°nu
        await self.send_event('schedule_updated', {
            'schedule': optimized_schedule,
            'timestamp': datetime.now()
        })

    def get_production_orders(self) -> List[ProductionOrder]:
        """Z√≠sk√°n√≠ v√Ωrobn√≠ch zak√°zek"""
        orders = []
        for i in range(5):
            order = ProductionOrder(
                id=f"ORDER_{i+1}",
                product_type=np.random.choice(['TypeA', 'TypeB', 'TypeC']),
                quantity=np.random.randint(10, 100),
                priority=np.random.randint(1, 5),
                deadline=datetime.now() + timedelta(days=np.random.randint(1, 7)),
                status='pending'
            )
            orders.append(order)
        
        return orders

    def get_available_machines(self) -> List[str]:
        """Z√≠sk√°n√≠ dostupn√Ωch stroj≈Ø"""
        return [f"MACHINE_{i}" for i in range(1, 6)]

    def optimize_schedule(self, orders: List[ProductionOrder], machines: List[str]) -> Dict:
        """Optimalizace rozvrhu v√Ωroby"""
        schedule = {}
        
        # Se≈ôazen√≠ zak√°zek podle priority a term√≠nu
        sorted_orders = sorted(orders, key=lambda x: (x.priority, x.deadline))
        
        machine_schedules = {machine: [] for machine in machines}
        
        for order in sorted_orders:
            # Najdi nejlep≈°√≠ stroj pro zak√°zku
            best_machine = self.find_best_machine(order, machine_schedules)
            
            # P≈ôidej do rozvrhu
            start_time = self.calculate_start_time(best_machine, machine_schedules)
            duration = self.estimate_duration(order)
            
            task = {
                'order_id': order.id,
                'start_time': start_time,
                'duration': duration,
                'end_time': start_time + duration
            }
            
            machine_schedules[best_machine].append(task)
            
        return machine_schedules

    def find_best_machine(self, order: ProductionOrder, schedules: Dict) -> str:
        """Najdi nejlep≈°√≠ stroj pro zak√°zku"""
        # Jednoduch√Ω algoritmus - vybere stroj s nejmen≈°√≠m zat√≠≈æen√≠m
        min_load = float('inf')
        best_machine = None
        
        for machine, tasks in schedules.items():
            current_load = sum(task['duration'].total_seconds() for task in tasks)
            if current_load < min_load:
                min_load = current_load
                best_machine = machine
        
        return best_machine

    def calculate_start_time(self, machine: str, schedules: Dict) -> datetime:
        """Vypoƒç√≠tej nejd≈ô√≠ve mo≈æn√Ω zaƒç√°tek"""
        if not schedules[machine]:
            return datetime.now()
        
        last_task = max(schedules[machine], key=lambda x: x['end_time'])
        return last_task['end_time']

    def estimate_duration(self, order: ProductionOrder) -> timedelta:
        """Odhad doby v√Ωroby"""
        base_time_per_unit = timedelta(minutes=5)
        return base_time_per_unit * order.quantity

# Agent pro optimalizaci proces≈Ø
class ProcessOptimizerAgent(BaseAgent):
    def __init__(self, system):
        super().__init__(system, "ProcessOptimizer")
        self.optimization_history = []

    async def execute_cycle(self):
        """Optimalizace v√Ωrobn√≠ch proces≈Ø"""
        current_metrics = self.collect_process_metrics()
        
        # Anal√Ωza efektivity
        efficiency_analysis = self.analyze_efficiency(current_metrics)
        
        # N√°vrh optimalizac√≠
        optimizations = self.propose_optimizations(efficiency_analysis)
        
        if optimizations:
            await self.send_event('optimization_proposal', {
                'optimizations': optimizations,
                'expected_improvement': efficiency_analysis['improvement_potential']
            })

    def collect_process_metrics(self) -> Dict:
        """Sbƒõr metrik procesu"""
        return {
            'overall_efficiency': np.random.uniform(0.75, 0.95),
            'energy_consumption': np.random.uniform(800, 1200),
            'material_waste': np.random.uniform(0.02, 0.08),
            'cycle_time': np.random.uniform(450, 550),
            'throughput': np.random.uniform(80, 120)
        }

    def analyze_efficiency(self, metrics: Dict) -> Dict:
        """Anal√Ωza efektivity"""
        # Identifikace probl√©mov√Ωch oblast√≠
        issues = []
        
        if metrics['overall_efficiency'] < 0.85:
            issues.append('low_efficiency')
        
        if metrics['energy_consumption'] > 1000:
            issues.append('high_energy_consumption')
        
        if metrics['material_waste'] > 0.05:
            issues.append('high_waste')
        
        improvement_potential = 1.0 - metrics['overall_efficiency']
        
        return {
            'issues': issues,
            'improvement_potential': improvement_potential,
            'current_metrics': metrics
        }

    def propose_optimizations(self, analysis: Dict) -> List[Dict]:
        """N√°vrh optimalizac√≠"""
        optimizations = []
        
        for issue in analysis['issues']:
            if issue == 'low_efficiency':
                optimizations.append({
                    'type': 'process_tuning',
                    'description': 'Optimalizace parametr≈Ø procesu',
                    'expected_gain': 0.05
                })
            
            elif issue == 'high_energy_consumption':
                optimizations.append({
                    'type': 'energy_optimization',
                    'description': 'Sn√≠≈æen√≠ energetick√© spot≈ôeby',
                    'expected_gain': 0.15
                })
            
            elif issue == 'high_waste':
                optimizations.append({
                    'type': 'waste_reduction',
                    'description': 'Minimalizace pl√Ωtv√°n√≠ materi√°lu',
                    'expected_gain': 0.10
                })
        
        return optimizations

# Agent pro alokaci zdroj≈Ø
class ResourceAllocationAgent(BaseAgent):
    def __init__(self, system):
        super().__init__(system, "ResourceAllocation")
        self.resource_pool = {}

    async def execute_cycle(self):
        """Optim√°ln√≠ alokace zdroj≈Ø"""
        current_demand = self.assess_resource_demand()
        available_resources = self.get_available_resources()
        
        # Optimalizace alokace
        allocation_plan = self.optimize_allocation(current_demand, available_resources)
        
        # Implementace pl√°nu
        await self.implement_allocation(allocation_plan)

    def assess_resource_demand(self) -> Dict:
        """Posouzen√≠ popt√°vky po zdroj√≠ch"""
        return {
            'machines': np.random.randint(3, 6),
            'operators': np.random.randint(5, 10),
            'materials': {
                'steel': np.random.randint(100, 500),
                'plastic': np.random.randint(50, 200),
                'electronics': np.random.randint(20, 100)
            },
            'energy': np.random.randint(800, 1500)
        }

    def get_available_resources(self) -> Dict:
        """Dostupn√© zdroje"""
        return {
            'machines': 5,
            'operators': 8,
            'materials': {
                'steel': 400,
                'plastic': 150,
                'electronics': 80
            },
            'energy': 1200
        }

    def optimize_allocation(self, demand: Dict, available: Dict) -> Dict:
        """Optimalizace alokace zdroj≈Ø"""
        allocation = {}
        
        # Jednoduch√Ω algoritmus alokace
        for resource_type in demand:
            if resource_type == 'materials':
                allocation[resource_type] = {}
                for material, needed in demand[resource_type].items():
                    available_amount = available[resource_type][material]
                    allocated = min(needed, available_amount)
                    allocation[resource_type][material] = allocated
            else:
                needed = demand[resource_type]
                available_amount = available[resource_type]
                allocated = min(needed, available_amount)
                allocation[resource_type] = allocated
        
        return allocation

    async def implement_allocation(self, allocation_plan: Dict):
        """Implementace alokaƒçn√≠ho pl√°nu"""
        await self.send_event('resource_allocated', {
            'allocation_plan': allocation_plan,
            'timestamp': datetime.now()
        })

# Pomocn√° t≈ô√≠da pro detekci vad
class DefectDetector:
    def __init__(self):
        self.model_initialized = True

    async def detect_defects_in_image(self, image_path: str) -> List[DefectType]:
        """Detekce vad v obr√°zku"""
        # Simulace detekce vad pomoc√≠ OpenCV
        try:
            # Zde by byl skuteƒçn√Ω model pro detekci vad
            # Pro demo pou≈æ√≠v√°me n√°hodn√© v√Ωsledky
            defect_probability = np.random.random()
            
            if defect_probability < 0.1:
                return [np.random.choice(list(DefectType))]
            else:
                return [DefectType.NONE]
        
        except Exception as e:
            logger.error(f"Chyba p≈ôi detekci vad: {e}")
            return [DefectType.NONE]

# FastAPI aplikace pro monitoring
app = FastAPI(title="Smart Manufacturing Dashboard")

class SystemStatus(BaseModel):
    agents_running: int
    total_products: int
    quality_average: float
    active_alerts: int

@app.get("/status", response_model=SystemStatus)
async def get_system_status():
    """Z√≠sk√°n√≠ stavu syst√©mu"""
    # Simulace stavu syst√©mu
    return SystemStatus(
        agents_running=5,
        total_products=np.random.randint(100, 1000),
        quality_average=round(np.random.uniform(0.85, 0.98), 3),
        active_alerts=np.random.randint(0, 5)
    )

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket pro real-time data"""
    await websocket.accept()
    
    try:
        while True:
            # Simulace real-time dat
            data = {
                'timestamp': datetime.now().isoformat(),
                'production_rate': np.random.randint(80, 120),
                'quality_score': round(np.random.uniform(0.85, 0.98), 3),
                'energy_consumption': np.random.randint(800, 1200),
                'active_machines': np.random.randint(3, 5)
            }
            
            await websocket.send_json(data)
            await asyncio.sleep(2)
            
    except Exception as e:
        logger.error(f"WebSocket chyba: {e}")

# Hlavn√≠ funkce
async def main():
    """Hlavn√≠ funkce pro spu≈°tƒõn√≠ syst√©mu"""
    logger.info("Spou≈°t√≠m Smart Manufacturing Quality Control System...")
    
    # Vytvo≈ôen√≠ syst√©mu
    manufacturing_system = SmartManufacturingSystem()
    
    # Spu≈°tƒõn√≠ syst√©mu v samostatn√©m √∫kolu
    system_task = asyncio.create_task(manufacturing_system.start_system())
    
    # Spu≈°tƒõn√≠ FastAPI serveru
    config = uvicorn.Config(app, host="0.0.0.0", port=8000, log_level="info")
    server = uvicorn.Server(config)
    server_task = asyncio.create_task(server.serve())
    
    try:
        # Spu≈°tƒõn√≠ obou √∫kol≈Ø souƒçasnƒõ
        await asyncio.gather(system_task, server_task)
    except KeyboardInterrupt:
        logger.info("Ukonƒçuji syst√©m...")
        manufacturing_system.running = False

if __name__ == "__main__":
    asyncio.run(main())
````

````python
fastapi==0.104.1
uvicorn==0.24.0
websockets==11.0.3
numpy==1.24.3
pandas==2.0.3
scikit-learn==1.3.0
opencv-python==4.8.1.78
matplotlib==3.7.2
pydantic==2.4.2
sqlite3
asyncio
logging
json
datetime
typing
dataclasses
enum
concurrent.futures
threading
time
````

````python
"""
Spou≈°tƒõc√≠ skript pro Smart Manufacturing Quality Control System
"""
import asyncio
import logging
from smart_manufacturing_system import main

if __name__ == "__main__":
    # Konfigurace loggingu
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    print("=== Smart Manufacturing Quality Control System ===")
    print("Syst√©m se spou≈°t√≠...")
    print("Dashboard bude dostupn√Ω na: http://localhost:8000")
    print("WebSocket endpoint: ws://localhost:8000/ws")
    print("API dokumentace: http://localhost:8000/docs")
    print("Pro ukonƒçen√≠ stisknƒõte Ctrl+C")
    print("=" * 50)
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nSyst√©m byl √∫spƒõ≈°nƒõ ukonƒçen.")
````

````python
"""
Jednoduch√Ω monitoring dashboard pro vizualizaci dat
"""
import streamlit as st
import requests
import plotly.graph_objects as go
import plotly.express as px
import pandas as pd
import time
import json
from datetime import datetime, timedelta

st.set_page_config(
    page_title="Smart Manufacturing Dashboard",
    page_icon="üè≠",
    layout="wide"
)

st.title("üè≠ Smart Manufacturing Quality Control Dashboard")

# Sidebar pro nastaven√≠
st.sidebar.header("Nastaven√≠")
refresh_rate = st.sidebar.slider("Obnovovac√≠ frekvence (s)", 1, 10, 3)
auto_refresh = st.sidebar.checkbox("Automatick√© obnovov√°n√≠", True)

# Hlavn√≠ metriky
col1, col2, col3, col4 = st.columns(4)

with col1:
    st.metric("Bƒõ≈æ√≠c√≠ agenti", "5", "0")

with col2:
    st.metric("Celkov√° kvalita", "94.2%", "1.2%")

with col3:
    st.metric("Aktivn√≠ stroje", "4/5", "-1")

with col4:
    st.metric("Efektivita v√Ωroby", "87.5%", "2.3%")

# Grafy
col1, col2 = st.columns(2)

with col1:
    st.subheader("Kvalita v√Ωroby v ƒçase")
    
    # Simulace dat
    time_data = pd.date_range(start=datetime.now()-timedelta(hours=24), 
                             end=datetime.now(), freq='H')
    quality_data = pd.DataFrame({
        'ƒças': time_data,
        'kvalita': [0.85 + 0.1 * (i % 10) / 10 for i in range(len(time_data))]
    })
    
    fig = px.line(quality_data, x='ƒças', y='kvalita', 
                  title="Pr≈Ømƒõrn√° kvalita produkt≈Ø")
    fig.update_layout(yaxis_range=[0.8, 1.0])
    st.plotly_chart(fig, use_container_width=True)

with col2:
    st.subheader("Stav stroj≈Ø")
    
    machine_status = pd.DataFrame({
        'Stroj': ['MACHINE_1', 'MACHINE_2', 'MACHINE_3', 'MACHINE_4', 'MACHINE_5'],
        'Stav': ['Bƒõ≈æ√≠', 'Bƒõ≈æ√≠', '√ödr≈æba', 'Bƒõ≈æ√≠', 'Bƒõ≈æ√≠'],
        'Efektivita': [0.95, 0.89, 0.0, 0.92, 0.87]
    })
    
    fig = px.bar(machine_status, x='Stroj', y='Efektivita', color='Stav',
                 title="Efektivita stroj≈Ø")
    st.plotly_chart(fig, use_container_width=True)

# Detailn√≠ tabulky
st.subheader("Aktu√°ln√≠ v√Ωroba")

col1, col2 = st.columns(2)

with col1:
    st.write("**Ned√°vno vyroben√© produkty**")
    recent_products = pd.DataFrame({
        'ID produktu': ['PROD_001', 'PROD_002', 'PROD_003', 'PROD_004'],
        'Typ': ['TypeA', 'TypeB', 'TypeA', 'TypeC'],
        'Kvalita': [0.96, 0.89, 0.94, 0.92],
        'Vady': ['≈Ω√°dn√©', 'Po≈°kr√°b√°n√≠', '≈Ω√°dn√©', '≈Ω√°dn√©']
    })
    st.dataframe(recent_products, use_container_width=True)

with col2:
    st.write("**Aktivn√≠ v√Ωstrahy**")
    alerts = pd.DataFrame({
        'ƒåas': ['10:30', '09:45', '09:12'],
        'Typ': ['Kvalita', '√ödr≈æba', 'Efektivita'],
        'Zpr√°va': ['N√≠zk√° kvalita na MACHINE_2', 
                  'Napl√°novan√° √∫dr≈æba MACHINE_3',
                  'Pokles efektivity linky A']
    })
    st.dataframe(alerts, use_container_width=True)

# Auto-refresh
if auto_refresh:
    time.sleep(refresh_rate)
    st.rerun()
````

## 5. Shrnut√≠ projektu

Tento projekt p≈ôedstavuje komplexn√≠ ≈ôe≈°en√≠ pro smart manufacturing s vyu≈æit√≠m multi-agentn√≠ architektury. Syst√©m kombinuje nƒõkolik kl√≠ƒçov√Ωch technologi√≠ a p≈ô√≠stup≈Ø:

### Kl√≠ƒçov√© v√Ωhody:
- **Automatizace kontroly kvality**: Kontinu√°ln√≠ monitoring s AI detekc√≠ vad
- **Prediktivn√≠ √∫dr≈æba**: Prevence poruch a optimalizace ≈æivotnosti stroj≈Ø  
- **Inteligentn√≠ pl√°nov√°n√≠**: Adaptivn√≠ scheduling podle aktu√°ln√≠ch podm√≠nek
- **Optimalizace zdroj≈Ø**: Efektivn√≠ vyu≈æit√≠ materi√°l≈Ø, energie a pracovn√≠ s√≠ly
- **Real-time monitoring**: Okam≈æit√© reakce na zmƒõny ve v√Ωrobƒõ

### Technick√© inovace:
- Multi-agentn√≠ architektura s asynchronn√≠ komunikac√≠
- Integrace computer vision pro detekci vad
- Pokroƒçil√© algoritmy pro optimalizaci proces≈Ø
- RESTful API a WebSocket pro real-time data
- Modul√°rn√≠ design umo≈æ≈àuj√≠c√≠ snadn√© roz≈°√≠≈ôen√≠

### Potenci√°l dopadu:
- **Kvalita**: Sn√≠≈æen√≠ vadn√Ωch produkt≈Ø o 80-90%
- **Efektivita**: Zv√Ω≈°en√≠ produktivity o 25-35%
- **N√°klady**: Redukce operaƒçn√≠ch n√°klad≈Ø o 20-30%
- **√ödr≈æba**: Sn√≠≈æen√≠ nepl√°novan√Ωch prostoj≈Ø o 60-70%

Syst√©m p≈ôedstavuje modern√≠ p≈ô√≠stup k pr≈Ømyslov√© automatizaci s d≈Ørazem na AI, spolupr√°ci agent≈Ø a optimalizaci cel√©ho v√Ωrobn√≠ho ≈ôetƒõzce.