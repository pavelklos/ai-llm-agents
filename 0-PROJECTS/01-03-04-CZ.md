<small>Claude Sonnet 4 **(MCP-Based Multi-Agent Simulation Environment)**</small>
# MCP-Based Multi-Agent Simulation Environment

## Key Concepts Explanation

### Model Context Protocol (MCP)
**Model Context Protocol** je standardizovaný komunikační protokol navržený pro efektivní výměnu kontextových informací mezi různými AI modely a systémy. MCP umožňuje sdílení znalostí, stavů a výsledků mezi agenty v reálném čase.

### Autonomous Agents (Autonomní Agenti)
**Autonomní agenti** jsou nezávislé AI entity schopné samostatného rozhodování, učení a interakce s prostředím i ostatními agenty. Každý agent má vlastní cíle, strategie a schopnosti adaptace.

### Game Theory (Teorie Her)
**Teorie her** je matematický rámec pro analýzu strategických interakcí mezi racionálními rozhodovacími entitami. V kontextu AI agentů pomáhá modelovat konflikty, spolupráci a optimální strategie.

### Emergent Behavior (Emergentní Chování)
**Emergentní chování** vzniká jako výsledek složitých interakcí mezi jednoduchými agenty, kdy celkové chování systému je více než suma jeho částí. Tyto vzorce nejsou explicitně naprogramované, ale vznikají spontánně.

### LLM Orchestration (Orchestrace LLM)
**Orchestrace LLM** je proces koordinace a řízení více velkých jazykových modelů současně, včetně distribuce úkolů, synchronizace a agregace výsledků pro dosažení komplexních cílů.

## Comprehensive Project Explanation

### Cíle Projektu
Tento projekt vytváří pokročilé simulační prostředí využívající Model Context Protocol pro koordinaci více autonomních AI agentů. Hlavními cíli jsou:

1. **Implementace MCP protokolu** pro efektivní komunikaci mezi agenty
2. **Vytvoření simulačního prostředí** s různými scénáři a výzvami
3. **Aplikace teorie her** pro modelování strategických interakcí
4. **Pozorování emergentního chování** vznikajícího ze složitých interakcí
5. **Orchestrace LLM** pro koordinaci heterogenních AI systémů

### Technické Výzvy
- **Synchronizace agentů** v distribuovaném prostředí
- **Správa stavu** a kontextových informací
- **Optimalizace komunikačního protokolu** pro nízkou latenci
- **Škálovatelnost** pro velký počet současně běžících agentů
- **Monitoring a analýza** emergentních vzorců chování

### Potenciální Dopad
Projekt může revolucionalizovat oblasti jako:
- **Distribuované AI systémy** v podnikových aplikacích
- **Simulace komplexních systémů** ve vědě a výzkumu
- **Optimalizace procesů** v logistice a řízení zdrojů
- **Kolaborativní AI** pro řešení multidisciplinárních problémů

## Comprehensive Project Example with Python Implementation

### Instalace a Závislosti

````python
fastapi==0.104.1
uvicorn==0.24.0
websockets==12.0
pydantic==2.5.0
asyncio-mqtt==0.16.1
openai==1.3.0
anthropic==0.7.0
numpy==1.24.3
pandas==2.1.3
networkx==3.2.1
matplotlib==3.8.2
aioredis==2.0.1
python-dotenv==1.0.0
````

### Základní MCP Protokol

````python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum
import json
import asyncio
import time
import uuid

class MessageType(Enum):
    CONTEXT_SHARE = "context_share"
    STATE_UPDATE = "state_update"
    STRATEGY_REQUEST = "strategy_request"
    STRATEGY_RESPONSE = "strategy_response"
    NEGOTIATION = "negotiation"
    COORDINATION = "coordination"

@dataclass
class MCPMessage:
    id: str
    sender_id: str
    receiver_id: Optional[str]
    message_type: MessageType
    payload: Dict[str, Any]
    timestamp: float
    priority: int = 1

    def to_json(self) -> str:
        data = asdict(self)
        data['message_type'] = self.message_type.value
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str: str) -> 'MCPMessage':
        data = json.loads(json_str)
        data['message_type'] = MessageType(data['message_type'])
        return cls(**data)

class MCPProtocol:
    def __init__(self, agent_id: str):
        self.agent_id = agent_id
        self.context_store: Dict[str, Any] = {}
        self.message_handlers: Dict[MessageType, callable] = {}
        self.outbound_queue: asyncio.Queue = asyncio.Queue()
        self.inbound_queue: asyncio.Queue = asyncio.Queue()
        
    def register_handler(self, message_type: MessageType, handler: callable):
        """Registrace handleru pro specifický typ zprávy"""
        self.message_handlers[message_type] = handler
    
    async def send_message(self, message: MCPMessage):
        """Odeslání zprávy přes protokol"""
        await self.outbound_queue.put(message)
    
    async def process_inbound_messages(self):
        """Zpracování příchozích zpráv"""
        while True:
            try:
                message = await asyncio.wait_for(
                    self.inbound_queue.get(), timeout=0.1
                )
                await self._handle_message(message)
            except asyncio.TimeoutError:
                continue
    
    async def _handle_message(self, message: MCPMessage):
        """Zpracování jednotlivé zprávy"""
        handler = self.message_handlers.get(message.message_type)
        if handler:
            await handler(message)
        else:
            print(f"No handler for message type: {message.message_type}")
    
    def update_context(self, key: str, value: Any):
        """Aktualizace kontextového úložiště"""
        self.context_store[key] = {
            'value': value,
            'timestamp': time.time(),
            'agent_id': self.agent_id
        }
    
    def get_context(self, key: str) -> Optional[Any]:
        """Získání hodnoty z kontextového úložiště"""
        context_item = self.context_store.get(key)
        return context_item['value'] if context_item else None
````

### Simulační Prostředí

````python
import asyncio
import random
import numpy as np
from typing import Dict, List, Tuple
from dataclasses import dataclass
from enum import Enum

class ResourceType(Enum):
    ENERGY = "energy"
    MATERIALS = "materials"
    INFORMATION = "information"
    TERRITORY = "territory"

@dataclass
class Resource:
    type: ResourceType
    amount: float
    location: Tuple[float, float]
    regeneration_rate: float = 0.1

class SimulationEnvironment:
    def __init__(self, width: int = 100, height: int = 100):
        self.width = width
        self.height = height
        self.resources: Dict[str, Resource] = {}
        self.agents: Dict[str, 'SimulationAgent'] = {}
        self.time_step = 0
        self.running = False
        
        # Inicializace zdrojů
        self._initialize_resources()
    
    def _initialize_resources(self):
        """Inicializace zdrojů v prostředí"""
        for i in range(20):  # 20 zdrojů různých typů
            resource_id = f"resource_{i}"
            resource_type = random.choice(list(ResourceType))
            location = (
                random.uniform(0, self.width),
                random.uniform(0, self.height)
            )
            
            self.resources[resource_id] = Resource(
                type=resource_type,
                amount=random.uniform(50, 200),
                location=location,
                regeneration_rate=random.uniform(0.05, 0.15)
            )
    
    def add_agent(self, agent: 'SimulationAgent'):
        """Přidání agenta do simulace"""
        self.agents[agent.agent_id] = agent
        agent.environment = self
    
    def get_nearby_resources(self, position: Tuple[float, float], 
                           radius: float) -> List[Tuple[str, Resource]]:
        """Nalezení zdrojů v okolí pozice"""
        nearby = []
        for resource_id, resource in self.resources.items():
            distance = np.sqrt(
                (position[0] - resource.location[0])**2 + 
                (position[1] - resource.location[1])**2
            )
            if distance <= radius:
                nearby.append((resource_id, resource))
        return nearby
    
    def get_nearby_agents(self, position: Tuple[float, float], 
                         radius: float, exclude_id: str = None) -> List['SimulationAgent']:
        """Nalezení agentů v okolí pozice"""
        nearby = []
        for agent in self.agents.values():
            if agent.agent_id == exclude_id:
                continue
            
            distance = np.sqrt(
                (position[0] - agent.position[0])**2 + 
                (position[1] - agent.position[1])**2
            )
            if distance <= radius:
                nearby.append(agent)
        return nearby
    
    async def step(self):
        """Jeden krok simulace"""
        self.time_step += 1
        
        # Regenerace zdrojů
        for resource in self.resources.values():
            resource.amount += resource.regeneration_rate
            resource.amount = min(resource.amount, 200)  # Maximum
        
        # Aktualizace všech agentů
        update_tasks = [agent.update() for agent in self.agents.values()]
        await asyncio.gather(*update_tasks)
    
    async def run(self, max_steps: int = 1000):
        """Spuštění simulace"""
        self.running = True
        
        while self.running and self.time_step < max_steps:
            await self.step()
            await asyncio.sleep(0.01)  # Krátká pauza
            
            if self.time_step % 100 == 0:
                print(f"Simulation step: {self.time_step}")
    
    def stop(self):
        """Zastavení simulace"""
        self.running = False
````

### Autonomní Agent s Game Theory

````python
import asyncio
import random
import numpy as np
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import openai

class AgentStrategy(Enum):
    COOPERATIVE = "cooperative"
    COMPETITIVE = "competitive"
    OPPORTUNISTIC = "opportunistic"
    DEFENSIVE = "defensive"

class AgentPersonality(Enum):
    AGGRESSIVE = "aggressive"
    CAUTIOUS = "cautious"
    SOCIAL = "social"
    INDEPENDENT = "independent"

@dataclass
class GameTheoryPayoff:
    """Výplatní matice pro teorii her"""
    cooperate_cooperate: float = 3.0
    cooperate_defect: float = 0.0
    defect_cooperate: float = 5.0
    defect_defect: float = 1.0

class SimulationAgent:
    def __init__(self, agent_id: str, personality: AgentPersonality, 
                 llm_model: str = "gpt-3.5-turbo"):
        self.agent_id = agent_id
        self.personality = personality
        self.llm_model = llm_model
        
        # MCP Protocol
        self.mcp = MCPProtocol(agent_id)
        self._register_mcp_handlers()
        
        # Pozice a stav
        self.position = (random.uniform(0, 100), random.uniform(0, 100))
        self.energy = 100.0
        self.resources = {rt: 0.0 for rt in ResourceType}
        
        # Strategy and behavior
        self.current_strategy = AgentStrategy.COOPERATIVE
        self.reputation = {}  # Reputace ostatních agentů
        self.memory = []  # Paměť interakcí
        self.environment = None
        
        # Game theory
        self.payoff_matrix = GameTheoryPayoff()
        self.cooperation_history = {}
        
        # LLM integration
        self.openai_client = openai.AsyncOpenAI()
    
    def _register_mcp_handlers(self):
        """Registrace MCP handlerů"""
        self.mcp.register_handler(
            MessageType.STRATEGY_REQUEST, 
            self._handle_strategy_request
        )
        self.mcp.register_handler(
            MessageType.NEGOTIATION, 
            self._handle_negotiation
        )
        self.mcp.register_handler(
            MessageType.CONTEXT_SHARE, 
            self._handle_context_share
        )
    
    async def _handle_strategy_request(self, message: MCPMessage):
        """Zpracování požadavku na strategii"""
        requester_id = message.sender_id
        situation = message.payload.get('situation', '')
        
        # LLM-based strategy decision
        strategy_decision = await self._llm_strategy_decision(
            situation, requester_id
        )
        
        response = MCPMessage(
            id=str(uuid.uuid4()),
            sender_id=self.agent_id,
            receiver_id=requester_id,
            message_type=MessageType.STRATEGY_RESPONSE,
            payload={'strategy': strategy_decision, 'confidence': 0.8},
            timestamp=time.time()
        )
        
        await self.mcp.send_message(response)
    
    async def _handle_negotiation(self, message: MCPMessage):
        """Zpracování vyjednávání"""
        proposal = message.payload.get('proposal', {})
        sender_id = message.sender_id
        
        # Rozhodnutí o přijetí/odmítnutí návrhu
        decision = await self._evaluate_proposal(proposal, sender_id)
        
        # Aktualizace reputace
        self._update_reputation(sender_id, decision)
    
    async def _handle_context_share(self, message: MCPMessage):
        """Zpracování sdílení kontextu"""
        shared_context = message.payload.get('context', {})
        sender_id = message.sender_id
        
        # Integracja sdíleného kontextu
        for key, value in shared_context.items():
            self.mcp.update_context(f"shared_{sender_id}_{key}", value)
    
    async def _llm_strategy_decision(self, situation: str, 
                                   other_agent_id: str) -> str:
        """LLM-based rozhodování o strategii"""
        reputation = self.reputation.get(other_agent_id, 0.5)
        
        prompt = f"""
        Jsi autonomní agent s osobností {self.personality.value}.
        Situace: {situation}
        Reputace druhého agenta: {reputation}
        Tvoje současné zdroje: {self.resources}
        
        Rozhodni o strategii (cooperative/competitive/opportunistic/defensive)
        a vrať pouze název strategie.
        """
        
        try:
            response = await self.openai_client.chat.completions.create(
                model=self.llm_model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=50,
                temperature=0.7
            )
            
            strategy_text = response.choices[0].message.content.strip().lower()
            
            # Mapování na dostupné strategie
            if "cooperative" in strategy_text:
                return AgentStrategy.COOPERATIVE.value
            elif "competitive" in strategy_text:
                return AgentStrategy.COMPETITIVE.value
            elif "opportunistic" in strategy_text:
                return AgentStrategy.OPPORTUNISTIC.value
            else:
                return AgentStrategy.DEFENSIVE.value
                
        except Exception as e:
            print(f"LLM error: {e}")
            return self.current_strategy.value
    
    async def _evaluate_proposal(self, proposal: Dict, sender_id: str) -> bool:
        """Evaluace návrhu od jiného agenta"""
        # Jednoduchá heuristika založená na game theory
        reputation = self.reputation.get(sender_id, 0.5)
        resource_gain = proposal.get('resource_exchange', {})
        
        # Výpočet očekávané hodnoty
        expected_value = sum(resource_gain.values()) * reputation
        
        return expected_value > 0
    
    def _update_reputation(self, agent_id: str, positive_interaction: bool):
        """Aktualizace reputace agenta"""
        if agent_id not in self.reputation:
            self.reputation[agent_id] = 0.5
        
        # Simple learning rate
        learning_rate = 0.1
        if positive_interaction:
            self.reputation[agent_id] += learning_rate * (1 - self.reputation[agent_id])
        else:
            self.reputation[agent_id] -= learning_rate * self.reputation[agent_id]
    
    async def update(self):
        """Hlavní update loop agenta"""
        # Spotřeba energie
        self.energy -= 1.0
        
        if self.energy <= 0:
            return  # Agent je neaktivní
        
        # Hledání zdrojů
        await self._search_resources()
        
        # Interakce s ostatními agenty
        await self._interact_with_nearby_agents()
        
        # Aktualizace strategie na základě prostředí
        await self._adapt_strategy()
        
        # Zpracování MCP zpráv
        await self.mcp.process_inbound_messages()
    
    async def _search_resources(self):
        """Hledání a sběr zdrojů"""
        if not self.environment:
            return
        
        nearby_resources = self.environment.get_nearby_resources(
            self.position, radius=10.0
        )
        
        for resource_id, resource in nearby_resources:
            if resource.amount > 0:
                # Sběr zdroje
                collected = min(resource.amount, 5.0)
                resource.amount -= collected
                self.resources[resource.type] += collected
                
                # Obnova energie
                if resource.type == ResourceType.ENERGY:
                    self.energy = min(self.energy + collected, 100.0)
    
    async def _interact_with_nearby_agents(self):
        """Interakce s blízkými agenty"""
        if not self.environment:
            return
        
        nearby_agents = self.environment.get_nearby_agents(
            self.position, radius=15.0, exclude_id=self.agent_id
        )
        
        for other_agent in nearby_agents:
            # Rozhodnutí o typu interakce
            interaction_type = await self._decide_interaction_type(other_agent)
            
            if interaction_type == "negotiate":
                await self._negotiate_with_agent(other_agent)
            elif interaction_type == "share_context":
                await self._share_context_with_agent(other_agent)
    
    async def _decide_interaction_type(self, other_agent: 'SimulationAgent') -> str:
        """Rozhodnutí o typu interakce s jiným agentem"""
        reputation = self.reputation.get(other_agent.agent_id, 0.5)
        
        if reputation > 0.7 and self.personality == AgentPersonality.SOCIAL:
            return "share_context"
        elif reputation > 0.4:
            return "negotiate"
        else:
            return "avoid"
    
    async def _negotiate_with_agent(self, other_agent: 'SimulationAgent'):
        """Vyjednávání s jiným agentem"""
        # Vytvoření návrhu na výměnu zdrojů
        proposal = {
            'resource_exchange': {
                ResourceType.ENERGY.value: -10,  # Nabízím energii
                ResourceType.MATERIALS.value: 5   # Požaduji materiály
            },
            'duration': 10  # Platnost návrhu
        }
        
        message = MCPMessage(
            id=str(uuid.uuid4()),
            sender_id=self.agent_id,
            receiver_id=other_agent.agent_id,
            message_type=MessageType.NEGOTIATION,
            payload={'proposal': proposal},
            timestamp=time.time()
        )
        
        await other_agent.mcp.inbound_queue.put(message)
    
    async def _share_context_with_agent(self, other_agent: 'SimulationAgent'):
        """Sdílení kontextu s jiným agentem"""
        shared_context = {
            'position': self.position,
            'energy_level': self.energy,
            'known_resources': len(self.environment.get_nearby_resources(
                self.position, 20.0
            )) if self.environment else 0
        }
        
        message = MCPMessage(
            id=str(uuid.uuid4()),
            sender_id=self.agent_id,
            receiver_id=other_agent.agent_id,
            message_type=MessageType.CONTEXT_SHARE,
            payload={'context': shared_context},
            timestamp=time.time()
        )
        
        await other_agent.mcp.inbound_queue.put(message)
    
    async def _adapt_strategy(self):
        """Adaptace strategie na základě prostředí"""
        # Analýza současného stavu
        energy_ratio = self.energy / 100.0
        resource_abundance = sum(self.resources.values())
        
        # Změna strategie na základě podmínek
        if energy_ratio < 0.3:
            self.current_strategy = AgentStrategy.DEFENSIVE
        elif resource_abundance > 50:
            self.current_strategy = AgentStrategy.COOPERATIVE
        else:
            self.current_strategy = AgentStrategy.OPPORTUNISTIC
        
        # Aktualizace pozice (jednoduchý random walk)
        self.position = (
            max(0, min(100, self.position[0] + random.uniform(-2, 2))),
            max(0, min(100, self.position[1] + random.uniform(-2, 2)))
        )
````

### Orchestration Engine

````python
import asyncio
import json
from typing import Dict, List, Optional
from dataclasses import asdict
import time
import uuid

class LLMOrchestrationEngine:
    def __init__(self):
        self.agents: Dict[str, SimulationAgent] = {}
        self.message_router: Dict[str, asyncio.Queue] = {}
        self.global_context: Dict[str, Any] = {}
        self.coordination_tasks: List[asyncio.Task] = []
        self.performance_metrics: Dict[str, Any] = {}
        
    def register_agent(self, agent: SimulationAgent):
        """Registrace agenta do orchestrátora"""
        self.agents[agent.agent_id] = agent
        self.message_router[agent.agent_id] = asyncio.Queue()
        
        # Spuštění message routing pro agenta
        task = asyncio.create_task(self._route_messages(agent.agent_id))
        self.coordination_tasks.append(task)
    
    async def _route_messages(self, agent_id: str):
        """Routing zpráv pro konkrétního agenta"""
        agent = self.agents[agent_id]
        queue = self.message_router[agent_id]
        
        while True:
            try:
                # Zpracování odchozích zpráv od agenta
                message = await asyncio.wait_for(
                    agent.mcp.outbound_queue.get(), timeout=0.1
                )
                await self._deliver_message(message)
                
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                print(f"Message routing error for {agent_id}: {e}")
    
    async def _deliver_message(self, message: MCPMessage):
        """Doručení zprávy cílovému agentovi"""
        if message.receiver_id:
            # Unicast - zpráva pro konkrétního agenta
            target_agent = self.agents.get(message.receiver_id)
            if target_agent:
                await target_agent.mcp.inbound_queue.put(message)
        else:
            # Broadcast - zpráva pro všechny agenty
            for agent_id, agent in self.agents.items():
                if agent_id != message.sender_id:
                    await agent.mcp.inbound_queue.put(message)
        
        # Aktualizace globálního kontextu
        self._update_global_context(message)
    
    def _update_global_context(self, message: MCPMessage):
        """Aktualizace globálního kontextu na základě zprávy"""
        context_key = f"{message.sender_id}_{message.message_type.value}"
        self.global_context[context_key] = {
            'payload': message.payload,
            'timestamp': message.timestamp,
            'priority': message.priority
        }
    
    async def coordinate_collective_behavior(self):
        """Koordinace kolektivního chování agentů"""
        while True:
            await asyncio.sleep(5.0)  # Koordinace každých 5 sekund
            
            # Analýza globálního stavu
            await self._analyze_global_state()
            
            # Detekce emergentních vzorců
            await self._detect_emergent_patterns()
            
            # Optimalizace strategie
            await self._optimize_global_strategy()
    
    async def _analyze_global_state(self):
        """Analýza globálního stavu systému"""
        total_agents = len(self.agents)
        active_agents = sum(1 for a in self.agents.values() if a.energy > 0)
        
        # Distribuce strategií
        strategy_distribution = {}
        for agent in self.agents.values():
            strategy = agent.current_strategy.value
            strategy_distribution[strategy] = strategy_distribution.get(strategy, 0) + 1
        
        # Celkové zdroje
        total_resources = {}
        for agent in self.agents.values():
            for resource_type, amount in agent.resources.items():
                total_resources[resource_type.value] = \
                    total_resources.get(resource_type.value, 0) + amount
        
        self.performance_metrics.update({
            'total_agents': total_agents,
            'active_agents': active_agents,
            'strategy_distribution': strategy_distribution,
            'total_resources': total_resources,
            'timestamp': time.time()
        })
    
    async def _detect_emergent_patterns(self):
        """Detekce emergentních vzorců chování"""
        # Klusterová analýza pozic agentů
        positions = [agent.position for agent in self.agents.values()]
        
        if len(positions) >= 3:
            # Výpočet clustery (zjednodušená implementace)
            clusters = self._simple_clustering(positions)
            
            # Detekce specializace rolí
            role_specialization = self._detect_role_specialization()
            
            # Komunikační sítě
            communication_networks = self._analyze_communication_patterns()
            
            emergent_patterns = {
                'spatial_clusters': len(clusters),
                'role_specialization': role_specialization,
                'communication_density': len(communication_networks),
                'timestamp': time.time()
            }
            
            self.global_context['emergent_patterns'] = emergent_patterns
    
    def _simple_clustering(self, positions: List[Tuple[float, float]], 
                          threshold: float = 15.0) -> List[List[int]]:
        """Jednoduchá klusterová analýza pozic"""
        clusters = []
        visited = set()
        
        for i, pos1 in enumerate(positions):
            if i in visited:
                continue
                
            cluster = [i]
            visited.add(i)
            
            for j, pos2 in enumerate(positions[i+1:], i+1):
                if j in visited:
                    continue
                
                distance = np.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)
                if distance <= threshold:
                    cluster.append(j)
                    visited.add(j)
            
            if len(cluster) > 1:
                clusters.append(cluster)
        
        return clusters
    
    def _detect_role_specialization(self) -> Dict[str, int]:
        """Detekce specializace rolí mezi agenty"""
        specialization = {}
        
        for agent in self.agents.values():
            # Identifikace hlavního typu zdroje
            max_resource = max(agent.resources.items(), 
                             key=lambda x: x[1], default=(None, 0))
            
            if max_resource[1] > 20:  # Práh pro specializaci
                role = f"{max_resource[0].value}_specialist"
                specialization[role] = specialization.get(role, 0) + 1
        
        return specialization
    
    def _analyze_communication_patterns(self) -> Dict[str, int]:
        """Analýza komunikačních vzorců"""
        patterns = {}
        
        # Analýza na základě reputačních sítí agentů
        for agent in self.agents.values():
            connections = len([r for r in agent.reputation.values() if r > 0.6])
            if connections > 0:
                pattern = f"highly_connected" if connections > 3 else "moderately_connected"
                patterns[pattern] = patterns.get(pattern, 0) + 1
        
        return patterns
    
    async def _optimize_global_strategy(self):
        """Optimalizace globální strategie"""
        # Identifikace bottlenecků
        low_energy_agents = [a for a in self.agents.values() if a.energy < 30]
        
        if len(low_energy_agents) > len(self.agents) * 0.3:
            # Více než 30% agentů má nízkou energii
            await self._trigger_resource_redistribution()
    
    async def _trigger_resource_redistribution(self):
        """Spuštění redistribuce zdrojů"""
        # Identifikace agentů s přebytkem energie
        surplus_agents = [a for a in self.agents.values() 
                         if a.resources[ResourceType.ENERGY] > 50]
        
        # Odeslání koordinačních zpráv
        for agent in surplus_agents:
            coordination_message = MCPMessage(
                id=str(uuid.uuid4()),
                sender_id="orchestrator",
                receiver_id=agent.agent_id,
                message_type=MessageType.COORDINATION,
                payload={
                    'action': 'resource_sharing',
                    'priority': 'high',
                    'targets': [a.agent_id for a in self.agents.values() 
                              if a.energy < 30]
                },
                timestamp=time.time(),
                priority=3
            )
            
            await agent.mcp.inbound_queue.put(coordination_message)
    
    def get_performance_report(self) -> Dict[str, Any]:
        """Získání zprávy o výkonu systému"""
        return {
            'metrics': self.performance_metrics,
            'global_context': self.global_context,
            'agent_count': len(self.agents),
            'active_tasks': len(self.coordination_tasks)
        }
````

### Hlavní Aplikace

````python
import asyncio
import os
from dotenv import load_dotenv
import matplotlib.pyplot as plt
import pandas as pd

# Načtení environment variables
load_dotenv()

async def main():
    """Hlavní funkce pro spuštění simulace"""
    
    # Vytvoření simulačního prostředí
    environment = SimulationEnvironment(width=100, height=100)
    
    # Vytvoření orchestrátora
    orchestrator = LLMOrchestrationEngine()
    
    # Vytvoření agentů s různými osobnostmi
    agents = []
    personalities = [
        AgentPersonality.AGGRESSIVE,
        AgentPersonality.CAUTIOUS,
        AgentPersonality.SOCIAL,
        AgentPersonality.INDEPENDENT
    ]
    
    for i in range(12):  # 12 agentů
        personality = personalities[i % len(personalities)]
        agent = SimulationAgent(
            agent_id=f"agent_{i}",
            personality=personality,
            llm_model="gpt-3.5-turbo"
        )
        
        agents.append(agent)
        environment.add_agent(agent)
        orchestrator.register_agent(agent)
    
    print(f"Vytvořeno {len(agents)} agentů s různými osobnostmi")
    
    # Spuštění koordinace
    coordination_task = asyncio.create_task(
        orchestrator.coordinate_collective_behavior()
    )
    
    # Spuštění simulace
    simulation_task = asyncio.create_task(
        environment.run(max_steps=500)
    )
    
    # Monitoring task
    monitoring_task = asyncio.create_task(
        monitor_simulation(orchestrator, environment)
    )
    
    try:
        # Čekání na dokončení simulace
        await asyncio.gather(
            simulation_task,
            coordination_task,
            monitoring_task,
            return_exceptions=True
        )
    except KeyboardInterrupt:
        print("Simulace přerušena uživatelem")
        environment.stop()
    
    # Generování závěrečné zprávy
    final_report = orchestrator.get_performance_report()
    print("\n=== ZÁVĚREČNÁ ZPRÁVA ===")
    print(f"Celkový počet agentů: {final_report['agent_count']}")
    print(f"Aktivní úkoly: {final_report['active_tasks']}")
    
    if 'emergent_patterns' in final_report['global_context']:
        patterns = final_report['global_context']['emergent_patterns']
        print(f"Detekované prostorové klastry: {patterns.get('spatial_clusters', 0)}")
        print(f"Specializace rolí: {patterns.get('role_specialization', {})}")

async def monitor_simulation(orchestrator: LLMOrchestrationEngine, 
                           environment: SimulationEnvironment):
    """Monitoring a analýza běžící simulace"""
    metrics_history = []
    
    while environment.running:
        await asyncio.sleep(10)  # Monitoring každých 10 sekund
        
        # Získání aktuálních metrik
        report = orchestrator.get_performance_report()
        metrics = report.get('metrics', {})
        
        if metrics:
            metrics['simulation_step'] = environment.time_step
            metrics_history.append(metrics.copy())
            
            print(f"Krok {environment.time_step}: "
                  f"Aktivní agenti: {metrics.get('active_agents', 0)}/{metrics.get('total_agents', 0)}")
    
    # Uložení výsledků
    if metrics_history:
        df = pd.DataFrame(metrics_history)
        df.to_csv('simulation_results.csv', index=False)
        print("Výsledky simulace uloženy do 'simulation_results.csv'")

if __name__ == "__main__":
    # Kontrola API klíčů
    if not os.getenv("OPENAI_API_KEY"):
        print("UPOZORNĚNÍ: OPENAI_API_KEY není nastaven")
        print("Simulace poběží bez LLM funkcionalit")
    
    # Spuštění simulace
    asyncio.run(main())
````

### Analýza a Vizualizace

````python
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from typing import List, Dict, Any
import seaborn as sns

class SimulationAnalyzer:
    def __init__(self, results_file: str = 'simulation_results.csv'):
        self.results_file = results_file
        self.data = None
        self._load_data()
    
    def _load_data(self):
        """Načtení dat ze simulace"""
        try:
            self.data = pd.read_csv(self.results_file)
            print(f"Načteno {len(self.data)} záznamů ze simulace")
        except FileNotFoundError:
            print(f"Soubor {self.results_file} nebyl nalezen")
    
    def plot_agent_activity(self):
        """Graf aktivity agentů v čase"""
        if self.data is None:
            return
        
        plt.figure(figsize=(12, 6))
        plt.plot(self.data['simulation_step'], self.data['active_agents'], 
                label='Aktivní agenti', linewidth=2)
        plt.plot(self.data['simulation_step'], self.data['total_agents'], 
                label='Celkem agentů', linestyle='--', alpha=0.7)
        
        plt.xlabel('Krok simulace')
        plt.ylabel('Počet agentů')
        plt.title('Aktivita agentů během simulace')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig('agent_activity.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def plot_strategy_evolution(self):
        """Graf evoluce strategií"""
        if self.data is None:
            return
        
        # Extrakce dat o strategiích (zjednodušeno)
        fig, ax = plt.subplots(figsize=(12, 8))
        
        # Simulace dat o strategiích pro demonstraci
        strategies = ['cooperative', 'competitive', 'opportunistic', 'defensive']
        colors = ['green', 'red', 'orange', 'blue']
        
        for i, strategy in enumerate(strategies):
            # Simulovaná data
            values = np.random.randint(0, 4, len(self.data)) + i
            plt.plot(self.data['simulation_step'], values, 
                    label=strategy.capitalize(), color=colors[i], linewidth=2)
        
        plt.xlabel('Krok simulace')
        plt.ylabel('Počet agentů')
        plt.title('Evoluce strategií během simulace')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig('strategy_evolution.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def plot_resource_distribution(self):
        """Graf distribuce zdrojů"""
        if self.data is None:
            return
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        
        # Simulace dat pro různé typy zdrojů
        steps = self.data['simulation_step']
        
        # Energy resources
        energy_data = np.cumsum(np.random.randn(len(steps)) * 10) + 1000
        ax1.plot(steps, energy_data, color='yellow', linewidth=2)
        ax1.set_title('Celková energie v systému')
        ax1.set_ylabel('Jednotky energie')
        ax1.grid(True, alpha=0.3)
        
        # Materials
        materials_data = np.cumsum(np.random.randn(len(steps)) * 5) + 500
        ax2.plot(steps, materials_data, color='brown', linewidth=2)
        ax2.set_title('Celkové materiály v systému')
        ax2.set_ylabel('Jednotky materiálů')
        ax2.grid(True, alpha=0.3)
        
        # Information
        info_data = np.cumsum(np.random.randn(len(steps)) * 3) + 200
        ax3.plot(steps, info_data, color='blue', linewidth=2)
        ax3.set_title('Celkové informace v systému')
        ax3.set_xlabel('Krok simulace')
        ax3.set_ylabel('Jednotky informací')
        ax3.grid(True, alpha=0.3)
        
        # Territory
        territory_data = np.cumsum(np.random.randn(len(steps)) * 2) + 100
        ax4.plot(steps, territory_data, color='green', linewidth=2)
        ax4.set_title('Celkové území v systému')
        ax4.set_xlabel('Krok simulace')
        ax4.set_ylabel('Jednotky území')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('resource_distribution.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def generate_comprehensive_report(self):
        """Generování komplexní zprávy"""
        if self.data is None:
            return
        
        report = {
            'simulation_duration': len(self.data),
            'final_active_agents': self.data['active_agents'].iloc[-1],
            'total_agents': self.data['total_agents'].iloc[-1],
            'survival_rate': self.data['active_agents'].iloc[-1] / self.data['total_agents'].iloc[-1],
            'average_activity': self.data['active_agents'].mean(),
        }
        
        print("\n=== KOMPLEXNÍ ANALÝZA SIMULACE ===")
        print(f"Doba simulace: {report['simulation_duration']} kroků")
        print(f"Finální počet aktivních agentů: {report['final_active_agents']}")
        print(f"Míra přežití: {report['survival_rate']:.2%}")
        print(f"Průměrná aktivita: {report['average_activity']:.1f} agentů")
        
        return report

# Příklad použití
if __name__ == "__main__":
    analyzer = SimulationAnalyzer()
    
    if analyzer.data is not None:
        analyzer.plot_agent_activity()
        analyzer.plot_strategy_evolution()
        analyzer.plot_resource_distribution()
        analyzer.generate_comprehensive_report()
````

## Project Summary

### Klíčové Výhody Projektu

**MCP-Based Multi-Agent Simulation Environment** představuje průlomovou implementaci koordinovaných AI systémů s následujícími klíčovými přínosy:

#### 1. **Pokročilá Architektura**
- **Model Context Protocol** umožňuje efektivní sdílení kontextu mezi heterogenními AI agenty
- **Distribuovaná orchestrace** zajišťuje škálovatelnost pro velké množství současně běžících agentů
- **Modulární design** umožňuje snadné rozšiřování a customizaci

#### 2. **Emergentní Inteligence**
- **Samoorganizující se chování** vznikající z jednoduchých pravidel interakce
- **Adaptivní strategie** založené na teorii her a strojovém učení
- **Kolektivní rozhodování** překonávající schopnosti jednotlivých agentů

#### 3. **Praktické Aplikace**
- **Optimalizace supply chain** ve složitých logistických sítích
- **Simulace finančních trhů** s různými typy investorů
- **Modelování sociálních sítí** a šíření informací
- **Koordinace robotických systémů** v průmyslových aplikacích

#### 4. **Technologické Inovace**
- **LLM-powered rozhodování** pro složité strategické situace
- **Real-time monitoring** emergentních vzorců chování
- **Automatická optimalizace** systémové výkonnosti
- **Škálovatelná komunikační infrastruktura**

### Klíčové Poznatky

Projekt demonstruje, jak lze kombinovat nejmodernější AI technologie pro vytvoření inteligentních, adaptivních systémů schopných řešit komplexní reálné problémy. Implementace MCP protokolu poskytuje solidní základ pro budoucí rozšíření do oblastí jako autonomní vozidla, smart cities nebo distribuované AI asistenty.

**Budoucí směry vývoje** zahrnují integraci s blockchain technologiemi pro decentralizované řízení, implementaci kvantových algoritmů pro optimalizaci a rozšíření na edge computing platformy pro real-time aplikace.