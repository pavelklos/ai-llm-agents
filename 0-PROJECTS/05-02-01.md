<small>Claude Sonnet 4 **(Personal Productivity Agent)**</small>
# Personal Productivity Agent

## Key Concepts Explanation

### Calendar Integration
Seamless connectivity with calendar platforms (Google Calendar, Outlook, iCal) enabling the agent to access, create, modify, and manage appointments, meetings, and events while understanding temporal relationships and scheduling conflicts to optimize time management workflows.

### Task Management
Intelligent task organization system that creates, prioritizes, tracks, and completes tasks while understanding dependencies, deadlines, and context, integrating with productivity platforms like Todoist, Notion, or Trello for comprehensive workflow management.

### Retrieval-Augmented Generation (RAG)
Advanced knowledge retrieval system that combines personal documents, notes, emails, and context-specific information with large language models to provide personalized, accurate responses based on the user's historical data and preferences.

### Contextual Intelligence
AI capability to understand user patterns, preferences, work habits, and priorities to provide proactive suggestions, intelligent scheduling, and personalized productivity recommendations based on historical behavior analysis.

### Multi-Modal Integration
Comprehensive connectivity across various productivity platforms, communication tools, and data sources to create a unified personal assistant experience that operates seamlessly across different applications and services.

## Comprehensive Project Explanation

### Objectives
The Personal Productivity Agent aims to serve as an intelligent digital assistant that autonomously manages calendars, organizes tasks, provides contextual information through RAG, and proactively optimizes productivity workflows based on individual user patterns and preferences.

### Key Features
- **Smart Calendar Management**: Automated scheduling, conflict resolution, and meeting optimization
- **Intelligent Task Organization**: Priority-based task management with deadline tracking
- **Personal Knowledge Base**: RAG-powered information retrieval from personal documents
- **Proactive Recommendations**: AI-driven productivity suggestions and workflow optimization
- **Cross-Platform Integration**: Seamless connectivity with major productivity platforms
- **Natural Language Interface**: Conversational interaction for all productivity operations

### Challenges
- **Privacy and Security**: Protecting sensitive personal and professional information
- **Platform Synchronization**: Maintaining consistency across multiple integrated services
- **Context Understanding**: Accurately interpreting user intent and preferences
- **Real-time Updates**: Ensuring immediate synchronization across all connected platforms
- **Scalability**: Handling increasing amounts of personal data and complexity

### Potential Impact
This system can significantly enhance personal productivity, reduce administrative overhead, improve time management, enable better work-life balance, and create more efficient workflows for professionals and individuals.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
chromadb==0.4.18
sentence-transformers==2.2.2
google-auth==2.25.2
google-auth-oauthlib==1.2.0
google-auth-httplib2==0.2.0
google-api-python-client==2.110.0
requests==2.31.0
pandas==2.1.4
numpy==1.24.3
python-dateutil==2.8.2
pytz==2023.3
icalendar==5.0.11
notion-client==2.2.1
todoist-api-python==2.1.4
datetime
logging
json
uuid
re
typing
````

### Core Implementation

````python
import os
import json
import uuid
import logging
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum

import streamlit as st
import pandas as pd
import numpy as np
from dateutil import parser as date_parser
import pytz

# Google Calendar API
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

# Vector storage and embeddings
import chromadb
from sentence_transformers import SentenceTransformer

# LangChain components
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TaskPriority(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class TaskStatus(Enum):
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class EventType(Enum):
    MEETING = "meeting"
    APPOINTMENT = "appointment"
    REMINDER = "reminder"
    TASK = "task"
    PERSONAL = "personal"

@dataclass
class Task:
    task_id: str
    title: str
    description: str
    priority: TaskPriority
    status: TaskStatus
    due_date: Optional[datetime] = None
    created_date: datetime = field(default_factory=datetime.now)
    completed_date: Optional[datetime] = None
    tags: List[str] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)

@dataclass
class CalendarEvent:
    event_id: str
    title: str
    description: str
    start_time: datetime
    end_time: datetime
    event_type: EventType
    attendees: List[str] = field(default_factory=list)
    location: Optional[str] = None
    is_recurring: bool = False

@dataclass
class UserProfile:
    user_id: str
    name: str
    email: str
    timezone: str
    work_hours: Tuple[int, int]  # (start_hour, end_hour)
    preferences: Dict[str, Any] = field(default_factory=dict)
    productivity_patterns: Dict[str, Any] = field(default_factory=dict)

class CalendarManager:
    """Manages calendar operations and integrations."""
    
    def __init__(self, credentials_path: str = None):
        self.credentials_path = credentials_path
        self.service = None
        self.events_cache = {}
        self.timezone = pytz.timezone('UTC')
        
        if credentials_path:
            self._initialize_google_calendar()
    
    def _initialize_google_calendar(self):
        """Initialize Google Calendar API connection."""
        try:
            SCOPES = ['https://www.googleapis.com/auth/calendar']
            creds = None
            
            if os.path.exists('token.json'):
                creds = Credentials.from_authorized_user_file('token.json', SCOPES)
            
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    creds.refresh(Request())
                else:
                    if self.credentials_path and os.path.exists(self.credentials_path):
                        flow = InstalledAppFlow.from_client_secrets_file(
                            self.credentials_path, SCOPES)
                        creds = flow.run_local_server(port=0)
                
                with open('token.json', 'w') as token:
                    token.write(creds.to_json())
            
            self.service = build('calendar', 'v3', credentials=creds)
            logger.info("Google Calendar service initialized")
            
        except Exception as e:
            logger.error(f"Calendar initialization error: {e}")
            self.service = None
    
    def get_events(self, start_date: datetime, end_date: datetime) -> List[CalendarEvent]:
        """Retrieve events from calendar."""
        try:
            if not self.service:
                return self._generate_sample_events(start_date, end_date)
            
            # Call Google Calendar API
            events_result = self.service.events().list(
                calendarId='primary',
                timeMin=start_date.isoformat(),
                timeMax=end_date.isoformat(),
                singleEvents=True,
                orderBy='startTime'
            ).execute()
            
            events = events_result.get('items', [])
            calendar_events = []
            
            for event in events:
                start = event['start'].get('dateTime', event['start'].get('date'))
                end = event['end'].get('dateTime', event['end'].get('date'))
                
                calendar_event = CalendarEvent(
                    event_id=event['id'],
                    title=event.get('summary', 'No Title'),
                    description=event.get('description', ''),
                    start_time=date_parser.parse(start),
                    end_time=date_parser.parse(end),
                    event_type=EventType.MEETING,
                    attendees=[att.get('email', '') for att in event.get('attendees', [])],
                    location=event.get('location', '')
                )
                calendar_events.append(calendar_event)
            
            return calendar_events
            
        except Exception as e:
            logger.error(f"Error retrieving events: {e}")
            return self._generate_sample_events(start_date, end_date)
    
    def create_event(self, event: CalendarEvent) -> bool:
        """Create a new calendar event."""
        try:
            if not self.service:
                logger.info(f"Mock: Created event '{event.title}'")
                return True
            
            event_body = {
                'summary': event.title,
                'description': event.description,
                'start': {
                    'dateTime': event.start_time.isoformat(),
                    'timeZone': str(self.timezone),
                },
                'end': {
                    'dateTime': event.end_time.isoformat(),
                    'timeZone': str(self.timezone),
                },
                'attendees': [{'email': email} for email in event.attendees],
                'location': event.location,
            }
            
            created_event = self.service.events().insert(
                calendarId='primary',
                body=event_body
            ).execute()
            
            logger.info(f"Event created: {created_event.get('htmlLink')}")
            return True
            
        except Exception as e:
            logger.error(f"Error creating event: {e}")
            return False
    
    def find_free_slots(self, date: datetime, duration_minutes: int, 
                       work_hours: Tuple[int, int] = (9, 17)) -> List[Tuple[datetime, datetime]]:
        """Find available time slots."""
        try:
            start_date = date.replace(hour=work_hours[0], minute=0, second=0, microsecond=0)
            end_date = date.replace(hour=work_hours[1], minute=0, second=0, microsecond=0)
            
            # Get existing events
            events = self.get_events(start_date, end_date)
            
            # Sort events by start time
            events.sort(key=lambda x: x.start_time)
            
            free_slots = []
            current_time = start_date
            
            for event in events:
                # Check if there's a gap before this event
                if current_time < event.start_time:
                    slot_duration = (event.start_time - current_time).total_seconds() / 60
                    if slot_duration >= duration_minutes:
                        free_slots.append((current_time, event.start_time))
                
                current_time = max(current_time, event.end_time)
            
            # Check if there's time after the last event
            if current_time < end_date:
                slot_duration = (end_date - current_time).total_seconds() / 60
                if slot_duration >= duration_minutes:
                    free_slots.append((current_time, end_date))
            
            return free_slots
            
        except Exception as e:
            logger.error(f"Error finding free slots: {e}")
            return []
    
    def _generate_sample_events(self, start_date: datetime, end_date: datetime) -> List[CalendarEvent]:
        """Generate sample events for demonstration."""
        sample_events = []
        current_date = start_date.date()
        
        while current_date <= end_date.date():
            # Morning meeting
            if current_date.weekday() < 5:  # Weekdays only
                morning_start = datetime.combine(current_date, datetime.min.time().replace(hour=9))
                morning_end = morning_start + timedelta(hours=1)
                
                sample_events.append(CalendarEvent(
                    event_id=str(uuid.uuid4()),
                    title="Team Standup",
                    description="Daily team synchronization meeting",
                    start_time=morning_start,
                    end_time=morning_end,
                    event_type=EventType.MEETING,
                    attendees=["team@company.com"]
                ))
                
                # Afternoon meeting
                afternoon_start = datetime.combine(current_date, datetime.min.time().replace(hour=14))
                afternoon_end = afternoon_start + timedelta(hours=2)
                
                sample_events.append(CalendarEvent(
                    event_id=str(uuid.uuid4()),
                    title="Project Review",
                    description="Weekly project status review",
                    start_time=afternoon_start,
                    end_time=afternoon_end,
                    event_type=EventType.MEETING,
                    attendees=["manager@company.com"]
                ))
            
            current_date += timedelta(days=1)
        
        return sample_events

class TaskManager:
    """Manages tasks and todo items."""
    
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        self.task_history = []
    
    def create_task(self, title: str, description: str, priority: TaskPriority,
                   due_date: Optional[datetime] = None, tags: List[str] = None) -> str:
        """Create a new task."""
        task_id = str(uuid.uuid4())
        
        task = Task(
            task_id=task_id,
            title=title,
            description=description,
            priority=priority,
            status=TaskStatus.TODO,
            due_date=due_date,
            tags=tags or []
        )
        
        self.tasks[task_id] = task
        logger.info(f"Created task: {title}")
        return task_id
    
    def update_task_status(self, task_id: str, status: TaskStatus) -> bool:
        """Update task status."""
        if task_id in self.tasks:
            self.tasks[task_id].status = status
            if status == TaskStatus.COMPLETED:
                self.tasks[task_id].completed_date = datetime.now()
            logger.info(f"Updated task {task_id} status to {status.value}")
            return True
        return False
    
    def get_tasks_by_priority(self, priority: TaskPriority) -> List[Task]:
        """Get tasks filtered by priority."""
        return [task for task in self.tasks.values() if task.priority == priority]
    
    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:
        """Get tasks filtered by status."""
        return [task for task in self.tasks.values() if task.status == status]
    
    def get_overdue_tasks(self) -> List[Task]:
        """Get overdue tasks."""
        now = datetime.now()
        return [
            task for task in self.tasks.values()
            if task.due_date and task.due_date < now and task.status != TaskStatus.COMPLETED
        ]
    
    def get_upcoming_tasks(self, days: int = 7) -> List[Task]:
        """Get tasks due in the next specified days."""
        now = datetime.now()
        future = now + timedelta(days=days)
        
        return [
            task for task in self.tasks.values()
            if task.due_date and now <= task.due_date <= future and task.status != TaskStatus.COMPLETED
        ]
    
    def suggest_task_priority(self, title: str, description: str, due_date: Optional[datetime]) -> TaskPriority:
        """Suggest task priority based on content and deadline."""
        urgent_keywords = ['urgent', 'asap', 'critical', 'emergency', 'immediately']
        high_keywords = ['important', 'high', 'priority', 'deadline']
        
        text = f"{title} {description}".lower()
        
        # Check for urgent keywords
        if any(keyword in text for keyword in urgent_keywords):
            return TaskPriority.URGENT
        
        # Check deadline urgency
        if due_date:
            days_until_due = (due_date - datetime.now()).days
            if days_until_due <= 1:
                return TaskPriority.URGENT
            elif days_until_due <= 3:
                return TaskPriority.HIGH
        
        # Check for high priority keywords
        if any(keyword in text for keyword in high_keywords):
            return TaskPriority.HIGH
        
        return TaskPriority.MEDIUM

class PersonalKnowledgeBase:
    """RAG-based personal knowledge management system."""
    
    def __init__(self, embedding_model: str = "all-MiniLM-L6-v2"):
        self.embedding_model = SentenceTransformer(embedding_model)
        
        # Initialize ChromaDB
        self.chroma_client = chromadb.Client()
        try:
            self.collection = self.chroma_client.get_collection("personal_knowledge")
        except:
            self.collection = self.chroma_client.create_collection(
                name="personal_knowledge",
                metadata={"description": "Personal documents and notes"}
            )
        
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        
        # Initialize with sample knowledge
        self._initialize_sample_knowledge()
    
    def add_document(self, content: str, metadata: Dict[str, Any] = None) -> str:
        """Add document to knowledge base."""
        try:
            doc_id = str(uuid.uuid4())
            
            # Split document into chunks
            chunks = self.text_splitter.split_text(content)
            
            for i, chunk in enumerate(chunks):
                chunk_id = f"{doc_id}_{i}"
                embedding = self.embedding_model.encode(chunk).tolist()
                
                chunk_metadata = {
                    "doc_id": doc_id,
                    "chunk_index": i,
                    "timestamp": datetime.now().isoformat(),
                    **(metadata or {})
                }
                
                self.collection.add(
                    documents=[chunk],
                    embeddings=[embedding],
                    metadatas=[chunk_metadata],
                    ids=[chunk_id]
                )
            
            logger.info(f"Added document {doc_id} with {len(chunks)} chunks")
            return doc_id
            
        except Exception as e:
            logger.error(f"Error adding document: {e}")
            return ""
    
    def search_knowledge(self, query: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Search personal knowledge base."""
        try:
            query_embedding = self.embedding_model.encode(query).tolist()
            
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results
            )
            
            search_results = []
            if results['documents']:
                for i, document in enumerate(results['documents'][0]):
                    search_results.append({
                        'content': document,
                        'metadata': results['metadatas'][0][i],
                        'similarity': 1 - results['distances'][0][i] if 'distances' in results else 0.0
                    })
            
            return search_results
            
        except Exception as e:
            logger.error(f"Knowledge search error: {e}")
            return []
    
    def _initialize_sample_knowledge(self):
        """Initialize with sample personal knowledge."""
        sample_docs = [
            {
                "content": """
                Project Alpha Meeting Notes - 2024-01-15
                
                Discussed the new feature rollout for Q2. Key decisions:
                - Implementation timeline: 8 weeks
                - Team lead: Sarah Johnson
                - Budget approved: $50,000
                - Risk assessment needed by end of month
                
                Action items:
                - Complete technical specification
                - Setup development environment
                - Schedule stakeholder review meeting
                """,
                "metadata": {"type": "meeting_notes", "project": "Alpha", "date": "2024-01-15"}
            },
            {
                "content": """
                Personal Goals for 2024
                
                Career Objectives:
                - Complete cloud architecture certification
                - Lead at least 2 major projects
                - Mentor junior developers
                - Improve public speaking skills
                
                Personal Development:
                - Read 12 books this year
                - Learn a new programming language
                - Improve work-life balance
                - Start a side project
                """,
                "metadata": {"type": "personal_goals", "year": "2024"}
            },
            {
                "content": """
                Vendor Contact Information
                
                Tech Solutions Inc.
                Contact: Mike Chen
                Email: mike.chen@techsolutions.com
                Phone: (555) 123-4567
                Services: Cloud infrastructure, DevOps consulting
                
                Creative Designs Ltd.
                Contact: Emma Rodriguez
                Email: emma@creativedesigns.com
                Phone: (555) 987-6543
                Services: UI/UX design, branding
                """,
                "metadata": {"type": "contacts", "category": "vendors"}
            }
        ]
        
        for doc in sample_docs:
            self.add_document(doc["content"], doc["metadata"])

class ProductivityAgent:
    """Main productivity agent orchestrating all components."""
    
    def __init__(self, openai_api_key: str = None, calendar_credentials: str = None):
        self.calendar_manager = CalendarManager(calendar_credentials)
        self.task_manager = TaskManager()
        self.knowledge_base = PersonalKnowledgeBase()
        
        # Initialize LLM
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.7,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        else:
            self.llm = None
        
        self.user_profile = None
        self._initialize_prompts()
    
    def _initialize_prompts(self):
        """Initialize LLM prompts."""
        self.main_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are a personal productivity assistant. Help the user manage their tasks,
            calendar, and access their personal knowledge base.
            
            Current context:
            - Date: {current_date}
            - User timezone: {timezone}
            - Upcoming tasks: {upcoming_tasks}
            - Today's events: {todays_events}
            - Recent knowledge: {knowledge_context}
            
            Guidelines:
            1. Be proactive and helpful
            2. Suggest optimizations and improvements
            3. Use the user's personal knowledge when relevant
            4. Be concise but informative
            5. Prioritize urgent items
            
            User query: {query}
            """),
            ("human", "{query}")
        ])
        
        self.scheduling_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are a scheduling assistant. Help find the best time for meetings and events.
            
            Available time slots: {available_slots}
            Meeting requirements: {requirements}
            User preferences: {preferences}
            
            Suggest the optimal time slot and provide reasoning.
            """),
            ("human", "Find the best time for: {meeting_request}")
        ])
    
    def set_user_profile(self, profile: UserProfile):
        """Set user profile for personalization."""
        self.user_profile = profile
        self.calendar_manager.timezone = pytz.timezone(profile.timezone)
    
    def process_query(self, query: str) -> Dict[str, Any]:
        """Process user query and provide intelligent response."""
        try:
            query_lower = query.lower()
            
            # Classify query intent
            intent = self._classify_intent(query)
            
            if intent == "calendar":
                return self._handle_calendar_query(query)
            elif intent == "task":
                return self._handle_task_query(query)
            elif intent == "knowledge":
                return self._handle_knowledge_query(query)
            elif intent == "scheduling":
                return self._handle_scheduling_query(query)
            else:
                return self._handle_general_query(query)
            
        except Exception as e:
            logger.error(f"Query processing error: {e}")
            return {"error": f"Failed to process query: {str(e)}"}
    
    def _classify_intent(self, query: str) -> str:
        """Classify user query intent."""
        query_lower = query.lower()
        
        calendar_keywords = ['calendar', 'meeting', 'appointment', 'schedule', 'event']
        task_keywords = ['task', 'todo', 'remind', 'deadline', 'priority']
        knowledge_keywords = ['find', 'search', 'remember', 'note', 'document']
        scheduling_keywords = ['book', 'arrange', 'set up', 'find time']
        
        if any(keyword in query_lower for keyword in scheduling_keywords):
            return "scheduling"
        elif any(keyword in query_lower for keyword in calendar_keywords):
            return "calendar"
        elif any(keyword in query_lower for keyword in task_keywords):
            return "task"
        elif any(keyword in query_lower for keyword in knowledge_keywords):
            return "knowledge"
        else:
            return "general"
    
    def _handle_calendar_query(self, query: str) -> Dict[str, Any]:
        """Handle calendar-related queries."""
        today = datetime.now()
        tomorrow = today + timedelta(days=1)
        
        events_today = self.calendar_manager.get_events(
            today.replace(hour=0, minute=0, second=0),
            today.replace(hour=23, minute=59, second=59)
        )
        
        if "today" in query.lower():
            return {
                "response": f"You have {len(events_today)} events today.",
                "events": [{"title": e.title, "time": e.start_time.strftime("%H:%M")} for e in events_today],
                "type": "calendar_summary"
            }
        elif "free" in query.lower() or "available" in query.lower():
            free_slots = self.calendar_manager.find_free_slots(today, 60)
            return {
                "response": f"Found {len(free_slots)} available time slots today.",
                "free_slots": [
                    {"start": start.strftime("%H:%M"), "end": end.strftime("%H:%M")}
                    for start, end in free_slots
                ],
                "type": "availability"
            }
        else:
            return {"response": "I can help you with calendar queries. Try asking about today's events or free time.", "type": "calendar_help"}
    
    def _handle_task_query(self, query: str) -> Dict[str, Any]:
        """Handle task-related queries."""
        if "create" in query.lower() or "add" in query.lower():
            # Extract task details from query (simplified)
            title = self._extract_task_title(query)
            priority = self.task_manager.suggest_task_priority(title, "", None)
            
            task_id = self.task_manager.create_task(
                title=title,
                description="",
                priority=priority
            )
            
            return {
                "response": f"Created task: {title}",
                "task_id": task_id,
                "type": "task_created"
            }
        
        elif "priority" in query.lower() or "urgent" in query.lower():
            urgent_tasks = self.task_manager.get_tasks_by_priority(TaskPriority.URGENT)
            high_tasks = self.task_manager.get_tasks_by_priority(TaskPriority.HIGH)
            
            return {
                "response": f"You have {len(urgent_tasks)} urgent and {len(high_tasks)} high priority tasks.",
                "urgent_tasks": [{"title": t.title, "due": t.due_date.strftime("%Y-%m-%d") if t.due_date else "No due date"} for t in urgent_tasks],
                "high_tasks": [{"title": t.title, "due": t.due_date.strftime("%Y-%m-%d") if t.due_date else "No due date"} for t in high_tasks],
                "type": "priority_tasks"
            }
        
        elif "overdue" in query.lower():
            overdue_tasks = self.task_manager.get_overdue_tasks()
            return {
                "response": f"You have {len(overdue_tasks)} overdue tasks.",
                "overdue_tasks": [{"title": t.title, "due": t.due_date.strftime("%Y-%m-%d")} for t in overdue_tasks],
                "type": "overdue_tasks"
            }
        
        else:
            pending_tasks = self.task_manager.get_tasks_by_status(TaskStatus.TODO)
            return {
                "response": f"You have {len(pending_tasks)} pending tasks.",
                "tasks": [{"title": t.title, "priority": t.priority.value} for t in pending_tasks[:5]],
                "type": "task_summary"
            }
    
    def _handle_knowledge_query(self, query: str) -> Dict[str, Any]:
        """Handle knowledge base queries."""
        search_results = self.knowledge_base.search_knowledge(query, 3)
        
        if search_results:
            best_match = search_results[0]
            return {
                "response": f"Found relevant information: {best_match['content'][:200]}...",
                "full_content": best_match['content'],
                "metadata": best_match['metadata'],
                "similarity": best_match['similarity'],
                "type": "knowledge_found"
            }
        else:
            return {
                "response": "I couldn't find relevant information in your knowledge base.",
                "type": "knowledge_not_found"
            }
    
    def _handle_scheduling_query(self, query: str) -> Dict[str, Any]:
        """Handle scheduling requests."""
        today = datetime.now()
        free_slots = self.calendar_manager.find_free_slots(today, 60)
        
        if free_slots:
            best_slot = free_slots[0]  # Take first available slot
            return {
                "response": f"I found available time today from {best_slot[0].strftime('%H:%M')} to {best_slot[1].strftime('%H:%M')}",
                "suggested_time": {
                    "start": best_slot[0].isoformat(),
                    "end": best_slot[1].isoformat()
                },
                "type": "scheduling_suggestion"
            }
        else:
            return {
                "response": "No available time slots found today. Would you like me to check tomorrow?",
                "type": "no_availability"
            }
    
    def _handle_general_query(self, query: str) -> Dict[str, Any]:
        """Handle general queries using LLM."""
        if not self.llm:
            return {"response": "I can help with calendar, tasks, and knowledge queries. Try being more specific!", "type": "help"}
        
        try:
            # Gather context
            context = self._gather_context()
            
            response = self.llm.invoke(
                self.main_prompt.format(
                    current_date=datetime.now().strftime("%Y-%m-%d"),
                    timezone=self.user_profile.timezone if self.user_profile else "UTC",
                    upcoming_tasks=context.get("upcoming_tasks", "None"),
                    todays_events=context.get("todays_events", "None"),
                    knowledge_context=context.get("knowledge_context", "None"),
                    query=query
                )
            )
            
            return {
                "response": response.content,
                "type": "llm_response"
            }
            
        except Exception as e:
            logger.error(f"LLM query error: {e}")
            return {"response": "I'm having trouble processing that request. Please try again.", "type": "error"}
    
    def _gather_context(self) -> Dict[str, str]:
        """Gather context for LLM queries."""
        today = datetime.now()
        
        # Get upcoming tasks
        upcoming_tasks = self.task_manager.get_upcoming_tasks(7)
        tasks_text = "; ".join([f"{t.title} ({t.priority.value})" for t in upcoming_tasks[:5]])
        
        # Get today's events
        todays_events = self.calendar_manager.get_events(
            today.replace(hour=0, minute=0, second=0),
            today.replace(hour=23, minute=59, second=59)
        )
        events_text = "; ".join([f"{e.title} at {e.start_time.strftime('%H:%M')}" for e in todays_events])
        
        return {
            "upcoming_tasks": tasks_text or "No upcoming tasks",
            "todays_events": events_text or "No events today",
            "knowledge_context": "Personal knowledge base available"
        }
    
    def _extract_task_title(self, query: str) -> str:
        """Extract task title from query."""
        # Simple extraction (could be enhanced with NLP)
        patterns = [
            r'create task[:\s]+(.+)',
            r'add task[:\s]+(.+)',
            r'remind me to\s+(.+)',
            r'task[:\s]+(.+)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, query, re.IGNORECASE)
            if match:
                return match.group(1).strip()
        
        return "New task from query"
    
    def get_daily_summary(self) -> Dict[str, Any]:
        """Generate daily productivity summary."""
        today = datetime.now()
        
        # Calendar summary
        todays_events = self.calendar_manager.get_events(
            today.replace(hour=0, minute=0, second=0),
            today.replace(hour=23, minute=59, second=59)
        )
        
        # Task summary
        pending_tasks = self.task_manager.get_tasks_by_status(TaskStatus.TODO)
        overdue_tasks = self.task_manager.get_overdue_tasks()
        upcoming_tasks = self.task_manager.get_upcoming_tasks(3)
        
        # Generate summary
        summary = {
            "date": today.strftime("%Y-%m-%d"),
            "calendar": {
                "events_today": len(todays_events),
                "next_event": todays_events[0].title if todays_events else "No events",
                "events": [{"title": e.title, "time": e.start_time.strftime("%H:%M")} for e in todays_events]
            },
            "tasks": {
                "pending": len(pending_tasks),
                "overdue": len(overdue_tasks),
                "upcoming": len(upcoming_tasks),
                "urgent_tasks": [t.title for t in self.task_manager.get_tasks_by_priority(TaskPriority.URGENT)]
            },
            "recommendations": self._generate_recommendations()
        }
        
        return summary
    
    def _generate_recommendations(self) -> List[str]:
        """Generate productivity recommendations."""
        recommendations = []
        
        # Check for overdue tasks
        overdue_tasks = self.task_manager.get_overdue_tasks()
        if overdue_tasks:
            recommendations.append(f"You have {len(overdue_tasks)} overdue tasks. Consider prioritizing them.")
        
        # Check for upcoming deadlines
        upcoming_tasks = self.task_manager.get_upcoming_tasks(3)
        urgent_upcoming = [t for t in upcoming_tasks if t.priority in [TaskPriority.URGENT, TaskPriority.HIGH]]
        if urgent_upcoming:
            recommendations.append(f"You have {len(urgent_upcoming)} high-priority tasks due soon.")
        
        # Check calendar density
        today = datetime.now()
        todays_events = self.calendar_manager.get_events(
            today.replace(hour=0, minute=0, second=0),
            today.replace(hour=23, minute=59, second=59)
        )
        
        if len(todays_events) > 5:
            recommendations.append("Your schedule is quite busy today. Consider blocking time for focused work.")
        elif len(todays_events) == 0:
            recommendations.append("You have a free day! Great time to tackle pending tasks or strategic planning.")
        
        return recommendations

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Personal Productivity Agent",
        page_icon="ğŸ¤–",
        layout="wide"
    )
    
    st.title("ğŸ¤– Personal Productivity Agent")
    st.markdown("Your AI-powered assistant for calendar, tasks, and personal knowledge management")
    
    # Initialize session state
    if 'agent' not in st.session_state:
        st.session_state['agent'] = None
    if 'user_profile' not in st.session_state:
        st.session_state['user_profile'] = None
    
    # Sidebar configuration
    with st.sidebar:
        st.header("ğŸ”§ Configuration")
        
        # API keys and credentials
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        calendar_creds = st.text_input("Google Calendar Credentials Path (Optional)", 
                                     placeholder="/path/to/credentials.json")
        
        if st.button("Initialize Agent") or st.session_state['agent'] is None:
            with st.spinner("Setting up your productivity agent..."):
                st.session_state['agent'] = ProductivityAgent(
                    openai_api_key=openai_key if openai_key else None,
                    calendar_credentials=calendar_creds if calendar_creds else None
                )
                st.success("Agent initialized!")
        
        # User profile setup
        st.header("ğŸ‘¤ User Profile")
        
        if st.session_state['user_profile'] is None:
            name = st.text_input("Name", placeholder="Your Name")
            email = st.text_input("Email", placeholder="your.email@example.com")
            timezone = st.selectbox("Timezone", 
                                  ["UTC", "US/Eastern", "US/Central", "US/Mountain", "US/Pacific", 
                                   "Europe/London", "Europe/Paris", "Asia/Tokyo"])
            
            work_start = st.selectbox("Work Start Hour", list(range(24)), index=9)
            work_end = st.selectbox("Work End Hour", list(range(24)), index=17)
            
            if st.button("Save Profile") and name and email:
                profile = UserProfile(
                    user_id=str(uuid.uuid4()),
                    name=name,
                    email=email,
                    timezone=timezone,
                    work_hours=(work_start, work_end)
                )
                
                st.session_state['user_profile'] = profile
                st.session_state['agent'].set_user_profile(profile)
                st.success("Profile saved!")
                st.rerun()
        else:
            profile = st.session_state['user_profile']
            st.write(f"**Name:** {profile.name}")
            st.write(f"**Email:** {profile.email}")
            st.write(f"**Timezone:** {profile.timezone}")
            st.write(f"**Work Hours:** {profile.work_hours[0]:02d}:00 - {profile.work_hours[1]:02d}:00")
            
            if st.button("Reset Profile"):
                st.session_state['user_profile'] = None
                st.rerun()
    
    # Main interface
    if not st.session_state['agent']:
        st.info("ğŸ‘ˆ Please initialize the agent using the sidebar")
        return
    
    agent = st.session_state['agent']
    
    # Create tabs
    tab1, tab2, tab3, tab4 = st.tabs(["ğŸ’¬ Chat", "ğŸ“… Calendar", "âœ… Tasks", "ğŸ“š Knowledge"])
    
    with tab1:
        st.header("ğŸ’¬ Chat with Your Assistant")
        
        # Display daily summary
        if st.session_state['user_profile']:
            summary = agent.get_daily_summary()
            
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Today's Events", summary['calendar']['events_today'])
            with col2:
                st.metric("Pending Tasks", summary['tasks']['pending'])
            with col3:
                st.metric("Overdue Tasks", summary['tasks']['overdue'])
            with col4:
                st.metric("Upcoming Tasks", summary['tasks']['upcoming'])
            
            # Recommendations
            if summary['recommendations']:
                st.subheader("ğŸ’¡ Recommendations")
                for rec in summary['recommendations']:
                    st.info(rec)
        
        # Chat interface
        st.subheader("Ask me anything!")
        
        # Sample queries
        sample_queries = [
            "What do I have scheduled today?",
            "Show me my urgent tasks",
            "Find time for a 1-hour meeting",
            "What are my overdue tasks?",
            "Search for project alpha notes",
            "Create a task to review budget"
        ]
        
        selected_query = st.selectbox("Sample queries:", [""] + sample_queries)
        
        user_input = st.text_area("Your message:", 
                                value=selected_query,
                                placeholder="Ask about your calendar, tasks, or search your knowledge...")
        
        if st.button("Send") and user_input:
            with st.spinner("Processing your request..."):
                response = agent.process_query(user_input)
                
                if "error" in response:
                    st.error(response["error"])
                else:
                    st.success("Response:")
                    st.write(response["response"])
                    
                    # Display additional data based on response type
                    if response.get("type") == "calendar_summary" and response.get("events"):
                        st.subheader("Today's Events")
                        for event in response["events"]:
                            st.write(f"â€¢ {event['title']} at {event['time']}")
                    
                    elif response.get("type") == "priority_tasks":
                        if response.get("urgent_tasks"):
                            st.subheader("Urgent Tasks")
                            for task in response["urgent_tasks"]:
                                st.write(f"ğŸ”´ {task['title']} (Due: {task['due']})")
                        
                        if response.get("high_tasks"):
                            st.subheader("High Priority Tasks")
                            for task in response["high_tasks"]:
                                st.write(f"ğŸŸ¡ {task['title']} (Due: {task['due']})")
                    
                    elif response.get("type") == "knowledge_found":
                        with st.expander("Full Content"):
                            st.write(response["full_content"])
                            st.json(response["metadata"])
    
    with tab2:
        st.header("ğŸ“… Calendar Management")
        
        # Calendar view
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader("Today's Schedule")
            
            today = datetime.now()
            events = agent.calendar_manager.get_events(
                today.replace(hour=0, minute=0, second=0),
                today.replace(hour=23, minute=59, second=59)
            )
            
            if events:
                for event in events:
                    with st.container():
                        st.write(f"**{event.title}**")
                        st.write(f"ğŸ• {event.start_time.strftime('%H:%M')} - {event.end_time.strftime('%H:%M')}")
                        if event.description:
                            st.write(f"ğŸ“ {event.description}")
                        if event.attendees:
                            st.write(f"ğŸ‘¥ {', '.join(event.attendees)}")
                        st.divider()
            else:
                st.info("No events scheduled for today")
        
        with col2:
            st.subheader("Free Time Slots")
            
            free_slots = agent.calendar_manager.find_free_slots(today, 60)
            
            if free_slots:
                for start, end in free_slots:
                    duration_hours = (end - start).total_seconds() / 3600
                    st.write(f"ğŸŸ¢ {start.strftime('%H:%M')} - {end.strftime('%H:%M')} ({duration_hours:.1f}h)")
            else:
                st.info("No free time slots available")
            
            # Quick event creation
            st.subheader("Quick Event")
            event_title = st.text_input("Event title")
            event_time = st.time_input("Start time")
            event_duration = st.selectbox("Duration", [30, 60, 90, 120], index=1)
            
            if st.button("Create Event") and event_title:
                start_datetime = datetime.combine(today.date(), event_time)
                end_datetime = start_datetime + timedelta(minutes=event_duration)
                
                new_event = CalendarEvent(
                    event_id=str(uuid.uuid4()),
                    title=event_title,
                    description="",
                    start_time=start_datetime,
                    end_time=end_datetime,
                    event_type=EventType.APPOINTMENT
                )
                
                success = agent.calendar_manager.create_event(new_event)
                if success:
                    st.success("Event created!")
                    st.rerun()
                else:
                    st.error("Failed to create event")
    
    with tab3:
        st.header("âœ… Task Management")
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            # Task list
            tasks = list(agent.task_manager.tasks.values())
            
            if tasks:
                # Filter options
                status_filter = st.selectbox("Filter by status", 
                                           ["All"] + [status.value for status in TaskStatus])
                priority_filter = st.selectbox("Filter by priority", 
                                             ["All"] + [priority.value for priority in TaskPriority])
                
                filtered_tasks = tasks
                if status_filter != "All":
                    filtered_tasks = [t for t in filtered_tasks if t.status.value == status_filter]
                if priority_filter != "All":
                    filtered_tasks = [t for t in filtered_tasks if t.priority.value == priority_filter]
                
                # Display tasks
                for task in filtered_tasks:
                    with st.container():
                        col_a, col_b, col_c = st.columns([3, 1, 1])
                        
                        with col_a:
                            priority_emoji = {"urgent": "ğŸ”´", "high": "ğŸŸ¡", "medium": "ğŸŸ ", "low": "ğŸŸ¢"}
                            status_emoji = {"todo": "â­•", "in_progress": "ğŸ”„", "completed": "âœ…", "cancelled": "âŒ"}
                            
                            st.write(f"{priority_emoji.get(task.priority.value, 'âšª')} {status_emoji.get(task.status.value, 'â­•')} **{task.title}**")
                            if task.description:
                                st.write(f"ğŸ“ {task.description}")
                            if task.due_date:
                                st.write(f"ğŸ“… Due: {task.due_date.strftime('%Y-%m-%d %H:%M')}")
                        
                        with col_b:
                            st.write(f"Priority: {task.priority.value}")
                            st.write(f"Status: {task.status.value}")
                        
                        with col_c:
                            if task.status != TaskStatus.COMPLETED:
                                if st.button("Complete", key=f"complete_{task.task_id}"):
                                    agent.task_manager.update_task_status(task.task_id, TaskStatus.COMPLETED)
                                    st.rerun()
                        
                        st.divider()
            else:
                st.info("No tasks yet. Create your first task!")
        
        with col2:
            # Task creation
            st.subheader("Create New Task")
            
            task_title = st.text_input("Task title")
            task_desc = st.text_area("Description")
            task_priority = st.selectbox("Priority", [p.value for p in TaskPriority])
            task_due = st.datetime_input("Due date (optional)")
            task_tags = st.text_input("Tags (comma-separated)")
            
            if st.button("Create Task") and task_title:
                tags = [tag.strip() for tag in task_tags.split(',') if tag.strip()]
                
                task_id = agent.task_manager.create_task(
                    title=task_title,
                    description=task_desc,
                    priority=TaskPriority(task_priority),
                    due_date=task_due,
                    tags=tags
                )
                
                st.success("Task created!")
                st.rerun()
            
            # Task statistics
            st.subheader("Task Statistics")
            total_tasks = len(agent.task_manager.tasks)
            completed_tasks = len(agent.task_manager.get_tasks_by_status(TaskStatus.COMPLETED))
            pending_tasks = len(agent.task_manager.get_tasks_by_status(TaskStatus.TODO))
            overdue_tasks = len(agent.task_manager.get_overdue_tasks())
            
            st.metric("Total Tasks", total_tasks)
            st.metric("Completed", completed_tasks)
            st.metric("Pending", pending_tasks)
            st.metric("Overdue", overdue_tasks)
    
    with tab4:
        st.header("ğŸ“š Personal Knowledge Base")
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            # Knowledge search
            st.subheader("Search Knowledge")
            
            search_query = st.text_input("Search your personal knowledge base...")
            
            if search_query:
                results = agent.knowledge_base.search_knowledge(search_query, 5)
                
                if results:
                    st.write(f"Found {len(results)} relevant results:")
                    
                    for i, result in enumerate(results, 1):
                        with st.expander(f"Result {i} (Similarity: {result['similarity']:.2f})"):
                            st.write(result['content'])
                            st.json(result['metadata'])
                else:
                    st.info("No relevant information found")
        
        with col2:
            # Add knowledge
            st.subheader("Add Knowledge")
            
            doc_title = st.text_input("Document title")
            doc_content = st.text_area("Content", height=200)
            doc_type = st.selectbox("Type", ["notes", "meeting_notes", "contacts", "goals", "other"])
            
            if st.button("Add Document") and doc_content:
                metadata = {
                    "title": doc_title,
                    "type": doc_type,
                    "added_date": datetime.now().isoformat()
                }
                
                doc_id = agent.knowledge_base.add_document(doc_content, metadata)
                
                if doc_id:
                    st.success("Document added to knowledge base!")
                else:
                    st.error("Failed to add document")
            
            # File upload
            st.subheader("Upload Document")
            uploaded_file = st.file_uploader("Choose a text file", type=['txt', 'md'])
            
            if uploaded_file:
                content = uploaded_file.read().decode('utf-8')
                
                if st.button("Process Upload"):
                    metadata = {
                        "filename": uploaded_file.name,
                        "type": "uploaded_file",
                        "added_date": datetime.now().isoformat()
                    }
                    
                    doc_id = agent.knowledge_base.add_document(content, metadata)
                    
                    if doc_id:
                        st.success(f"File {uploaded_file.name} added to knowledge base!")
                    else:
                        st.error("Failed to process file")

if __name__ == "__main__":
    main()
````

## Project Summary

The Personal Productivity Agent represents a comprehensive AI-powered assistant that revolutionizes personal productivity through intelligent calendar management, task organization, and knowledge retrieval, creating a unified platform that learns from user patterns and proactively optimizes workflow efficiency.

### Key Value Propositions:
- **Intelligent Calendar Integration**: Seamless connectivity with Google Calendar and other platforms for automated scheduling, conflict resolution, and optimal time slot identification with smart meeting coordination
- **Advanced Task Management**: Priority-based task organization with deadline tracking, dependency management, and intelligent priority suggestion based on content analysis and user patterns
- **Personal Knowledge RAG System**: Retrieval-augmented generation powered by ChromaDB and sentence transformers for contextual information retrieval from personal documents, notes, and historical data
- **Proactive Productivity Optimization**: AI-driven recommendations, workflow analysis, and pattern recognition for continuous productivity improvement and personalized efficiency enhancement
- **Unified Multi-Platform Interface**: Streamlined interface integrating calendar, tasks, and knowledge management with natural language interaction and cross-platform synchronization

### Technical Highlights:
- LangChain integration with OpenAI GPT-4 for sophisticated natural language understanding and intelligent query processing with context-aware responses
- Google Calendar API integration with OAuth authentication for secure calendar access, event management, and real-time synchronization across platforms
- ChromaDB vector storage with sentence transformers for semantic search capabilities and personal knowledge base management with metadata-rich document organization
- Streamlit-based interactive interface with tabbed navigation, real-time updates, and comprehensive productivity analytics for enhanced user experience
- Modular architecture supporting extensible integrations, scalable knowledge management, and flexible task workflow customization for diverse productivity needs

This system transforms personal productivity by providing an intelligent, context-aware assistant that learns user preferences, automates routine tasks, and delivers proactive recommendations for optimized time management and enhanced professional efficiency.