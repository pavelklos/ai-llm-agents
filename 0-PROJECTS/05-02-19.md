<small>Claude Sonnet 4 **(Custom Legal Contract Generator Agent)**</small>
# Custom Legal Contract Generator Agent

## Key Concepts Explanation

### LLM-Powered Contract Generation
Advanced AI system that leverages Large Language Models to automatically generate legal contracts by understanding natural language requirements, legal terminology, and contextual relationships between contractual clauses while maintaining legal accuracy and enforceability standards.

### Template-Based Legal Framework
Structured approach using pre-defined legal templates as foundational frameworks that can be dynamically customized and populated with specific terms, conditions, and party-specific details while ensuring compliance with jurisdictional requirements and legal best practices.

### Intelligent Template Filling
Automated process that extracts relevant information from user inputs and intelligently maps them to appropriate contract sections, handling complex legal logic, conditional clauses, cross-references, and ensuring consistency across all contract provisions.

### Prompt Chaining for Legal Reasoning
Sequential AI reasoning methodology that breaks down complex contract generation into multiple interconnected prompts, enabling step-by-step legal analysis, clause validation, risk assessment, and iterative refinement of contract language.

### Legal Compliance and Validation
Automated verification system that checks generated contracts against legal standards, regulatory requirements, common law principles, and jurisdictional variations while flagging potential issues and suggesting improvements for legal soundness.

## Comprehensive Project Explanation

### Objectives
The Custom Legal Contract Generator Agent democratizes legal document creation by providing AI-powered contract generation that transforms complex legal requirements into professionally drafted agreements while maintaining legal accuracy, reducing costs, and accelerating business transactions.

### Key Features
- **Natural Language Processing**: Convert business requirements into legal contracts
- **Multi-Template Support**: Comprehensive library of contract types and variations
- **Intelligent Clause Generation**: Context-aware legal language and term suggestions
- **Compliance Checking**: Automated validation against legal standards
- **Risk Assessment**: Identification and mitigation of contractual risks

### Challenges
- **Legal Accuracy**: Ensuring generated contracts meet professional legal standards
- **Jurisdictional Complexity**: Handling variations in legal requirements across regions
- **Context Understanding**: Interpreting nuanced business relationships and requirements
- **Risk Management**: Identifying potential legal vulnerabilities and liabilities

### Potential Impact
This system transforms legal services accessibility by enabling small businesses and individuals to generate professional contracts, reducing legal costs, accelerating deal closure, and democratizing access to quality legal documentation while maintaining professional standards.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
langchain-anthropic==0.1.0
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
pydantic==2.5.0
jinja2==3.1.2
python-docx==0.8.11
python-dateutil==2.8.2
sqlite3
datetime
json
re
uuid
logging
typing
dataclasses
enum
pathlib
asyncio
````

### Core Implementation

````python
import sqlite3
import json
import logging
import re
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import asyncio

import streamlit as st
import pandas as pd
import plotly.express as px
import numpy as np
from jinja2 import Template, Environment, FileSystemLoader
from docx import Document
from docx.shared import Inches
from dateutil.parser import parse as parse_date

# LangChain imports
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain.prompts import ChatPromptTemplate, PromptTemplate
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from langchain.chains import LLMChain, SequentialChain

# Pydantic models
from pydantic import BaseModel, Field, validator

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ContractType(Enum):
    SERVICE_AGREEMENT = "service_agreement"
    EMPLOYMENT_CONTRACT = "employment_contract"
    NDA = "non_disclosure_agreement"
    SALES_CONTRACT = "sales_contract"
    LEASE_AGREEMENT = "lease_agreement"
    PARTNERSHIP_AGREEMENT = "partnership_agreement"
    CONSULTING_AGREEMENT = "consulting_agreement"
    LICENSING_AGREEMENT = "licensing_agreement"
    VENDOR_AGREEMENT = "vendor_agreement"
    SOFTWARE_LICENSE = "software_license"

class Jurisdiction(Enum):
    US_FEDERAL = "us_federal"
    US_CALIFORNIA = "us_california"
    US_NEW_YORK = "us_new_york"
    US_TEXAS = "us_texas"
    UK = "united_kingdom"
    CANADA = "canada"
    EU_GENERAL = "eu_general"
    AUSTRALIA = "australia"

class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class ContractParty:
    name: str
    entity_type: str  # individual, corporation, llc, partnership
    address: str
    contact_person: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    registration_number: Optional[str] = None
    tax_id: Optional[str] = None

@dataclass
class ContractTerms:
    duration: Optional[str] = None
    payment_amount: Optional[float] = None
    payment_schedule: Optional[str] = None
    deliverables: List[str] = field(default_factory=list)
    milestones: List[str] = field(default_factory=list)
    penalties: List[str] = field(default_factory=list)
    termination_conditions: List[str] = field(default_factory=list)
    intellectual_property: Optional[str] = None
    confidentiality_period: Optional[str] = None
    governing_law: Optional[str] = None

class ContractRequirements(BaseModel):
    """Pydantic model for contract requirements validation."""
    contract_type: str = Field(..., description="Type of contract to generate")
    jurisdiction: str = Field(..., description="Legal jurisdiction for the contract")
    party1: Dict[str, Any] = Field(..., description="First party details")
    party2: Dict[str, Any] = Field(..., description="Second party details")
    terms: Dict[str, Any] = Field(..., description="Contract terms and conditions")
    special_provisions: List[str] = Field(default=[], description="Special clauses or provisions")
    risk_tolerance: str = Field(default="medium", description="Risk tolerance level")

class GeneratedClause(BaseModel):
    """Pydantic model for generated contract clauses."""
    section_name: str = Field(..., description="Name of the contract section")
    clause_text: str = Field(..., description="Generated clause text")
    risk_level: str = Field(..., description="Risk level of this clause")
    justification: str = Field(..., description="Explanation for this clause")
    alternatives: List[str] = Field(default=[], description="Alternative clause options")

class ContractAnalysis(BaseModel):
    """Pydantic model for contract risk analysis."""
    overall_risk: str = Field(..., description="Overall contract risk level")
    risk_factors: List[str] = Field(..., description="Identified risk factors")
    recommendations: List[str] = Field(..., description="Risk mitigation recommendations")
    compliance_issues: List[str] = Field(default=[], description="Potential compliance issues")
    missing_clauses: List[str] = Field(default=[], description="Recommended additional clauses")

@dataclass
class GeneratedContract:
    contract_id: str
    contract_type: ContractType
    jurisdiction: Jurisdiction
    party1: ContractParty
    party2: ContractParty
    terms: ContractTerms
    generated_text: str
    clauses: List[GeneratedClause]
    analysis: ContractAnalysis
    template_used: str
    llm_model: str
    created_at: datetime = field(default_factory=datetime.now)
    version: str = "1.0"

class ContractTemplate:
    """Base class for contract templates."""
    
    def __init__(self, template_name: str, contract_type: ContractType):
        self.template_name = template_name
        self.contract_type = contract_type
        self.template_content = self._load_template()
    
    def _load_template(self) -> str:
        """Load template content. In production, this would load from files."""
        templates = {
            ContractType.SERVICE_AGREEMENT: """
SERVICE AGREEMENT

This Service Agreement ("Agreement") is entered into on {{ effective_date }} by and between:

{{ party1.name }}, a {{ party1.entity_type }} ("Service Provider")
Address: {{ party1.address }}

AND

{{ party2.name }}, a {{ party2.entity_type }} ("Client")  
Address: {{ party2.address }}

1. SERVICES TO BE PROVIDED
The Service Provider agrees to provide the following services:
{% for deliverable in terms.deliverables %}
- {{ deliverable }}
{% endfor %}

2. TERM AND TERMINATION
This Agreement shall commence on {{ effective_date }} and shall continue for {{ terms.duration }}.

3. COMPENSATION
Client agrees to pay Service Provider {{ terms.payment_amount }} according to the following schedule: {{ terms.payment_schedule }}.

4. INTELLECTUAL PROPERTY
{{ terms.intellectual_property }}

5. CONFIDENTIALITY
{% if terms.confidentiality_period %}
Both parties agree to maintain confidentiality for a period of {{ terms.confidentiality_period }}.
{% endif %}

6. GOVERNING LAW
This Agreement shall be governed by the laws of {{ jurisdiction }}.

7. DISPUTE RESOLUTION
{{ dispute_resolution_clause }}

8. GENERAL PROVISIONS
{{ general_provisions }}

IN WITNESS WHEREOF, the parties have executed this Agreement as of the date first written above.

{{ party1.name }}                    {{ party2.name }}
By: ___________________             By: ___________________
Name: {{ party1.contact_person }}    Name: {{ party2.contact_person }}
Title: ________________             Title: ________________
Date: _________________             Date: _________________
""",
            
            ContractType.NDA: """
NON-DISCLOSURE AGREEMENT

This Non-Disclosure Agreement ("Agreement") is entered into on {{ effective_date }} by and between:

{{ party1.name }} ("Disclosing Party")
Address: {{ party1.address }}

AND

{{ party2.name }} ("Receiving Party")
Address: {{ party2.address }}

1. DEFINITION OF CONFIDENTIAL INFORMATION
For purposes of this Agreement, "Confidential Information" means any and all information disclosed by the Disclosing Party to the Receiving Party, including but not limited to:
{{ confidential_info_definition }}

2. OBLIGATIONS OF RECEIVING PARTY
The Receiving Party agrees to:
- Hold all Confidential Information in strict confidence
- Not disclose Confidential Information to any third parties
- Use Confidential Information solely for the purpose of {{ purpose }}

3. TERM
This Agreement shall remain in effect for {{ terms.confidentiality_period }} from the date of execution.

4. REMEDIES
The Receiving Party acknowledges that disclosure of Confidential Information would cause irreparable harm to the Disclosing Party.

5. GOVERNING LAW
This Agreement shall be governed by the laws of {{ jurisdiction }}.

{{ party1.name }}                    {{ party2.name }}
Signature: _______________          Signature: _______________
Date: ___________________          Date: ___________________
""",
            
            ContractType.EMPLOYMENT_CONTRACT: """
EMPLOYMENT AGREEMENT

This Employment Agreement ("Agreement") is entered into on {{ effective_date }} by and between:

{{ party1.name }}, a {{ party1.entity_type }} ("Company")
Address: {{ party1.address }}

AND

{{ party2.name }} ("Employee")
Address: {{ party2.address }}

1. POSITION AND DUTIES
Employee is hired as {{ job_title }} and agrees to perform the following duties:
{% for duty in job_duties %}
- {{ duty }}
{% endfor %}

2. COMPENSATION
Company agrees to pay Employee a salary of ${{ terms.payment_amount }} per {{ payment_frequency }}.

3. BENEFITS
{{ benefits_clause }}

4. TERM OF EMPLOYMENT
This Agreement shall commence on {{ start_date }} and shall continue {{ employment_term }}.

5. TERMINATION
{{ termination_clause }}

6. CONFIDENTIALITY AND NON-COMPETE
{{ confidentiality_clause }}
{{ non_compete_clause }}

7. INTELLECTUAL PROPERTY
Any inventions, patents, or intellectual property created during employment shall belong to the Company.

8. GOVERNING LAW
This Agreement shall be governed by the laws of {{ jurisdiction }}.

{{ party1.name }}                    {{ party2.name }}
By: ___________________             Signature: _______________
Name: {{ party1.contact_person }}    Print Name: {{ party2.name }}
Title: ________________             Date: ___________________
Date: _________________
"""
        }
        
        return templates.get(self.contract_type, "Template not found for this contract type.")
    
    def render(self, context: Dict[str, Any]) -> str:
        """Render template with provided context."""
        try:
            template = Template(self.template_content)
            return template.render(**context)
        except Exception as e:
            logger.error(f"Template rendering error: {e}")
            return f"Error rendering template: {e}"

class LegalClauseGenerator:
    """Generate specific legal clauses using LLM."""
    
    def __init__(self, llm):
        self.llm = llm
        self._initialize_prompts()
    
    def _initialize_prompts(self):
        """Initialize prompt templates for clause generation."""
        
        self.clause_generation_prompt = ChatPromptTemplate.from_template("""
You are an expert legal contract drafting attorney. Generate a professionally written legal clause for the following requirements:

Contract Type: {contract_type}
Jurisdiction: {jurisdiction}
Clause Type: {clause_type}
Specific Requirements: {requirements}
Risk Tolerance: {risk_tolerance}

Instructions:
1. Write a complete, legally sound clause
2. Use appropriate legal terminology for the jurisdiction
3. Include necessary conditions and exceptions
4. Consider the specified risk tolerance level
5. Ensure the clause is enforceable and clear

Generated Clause:
""")
        
        self.risk_analysis_prompt = ChatPromptTemplate.from_template("""
As a legal risk assessment expert, analyze the following contract clause for potential risks and issues:

Clause: {clause_text}
Contract Type: {contract_type}
Jurisdiction: {jurisdiction}

Provide:
1. Risk Level (low, medium, high, critical)
2. Specific risk factors identified
3. Potential legal vulnerabilities
4. Recommendations for improvement
5. Alternative language if needed

Analysis:
""")
        
        self.compliance_check_prompt = ChatPromptTemplate.from_template("""
You are a legal compliance specialist. Review this contract clause for compliance with relevant laws and regulations:

Clause: {clause_text}
Contract Type: {contract_type}
Jurisdiction: {jurisdiction}
Industry: {industry}

Check for:
1. Compliance with local laws and regulations
2. Industry-specific requirements
3. Consumer protection considerations
4. Employment law compliance (if applicable)
5. Data protection and privacy laws

Compliance Assessment:
""")
    
    def generate_clause(self, clause_type: str, requirements: str, contract_type: str, 
                       jurisdiction: str, risk_tolerance: str = "medium") -> GeneratedClause:
        """Generate a specific legal clause."""
        try:
            # Generate the clause
            response = self.llm.invoke(
                self.clause_generation_prompt.format(
                    contract_type=contract_type,
                    jurisdiction=jurisdiction,
                    clause_type=clause_type,
                    requirements=requirements,
                    risk_tolerance=risk_tolerance
                )
            )
            
            clause_text = response.content.strip()
            
            # Analyze the generated clause
            risk_analysis = self.llm.invoke(
                self.risk_analysis_prompt.format(
                    clause_text=clause_text,
                    contract_type=contract_type,
                    jurisdiction=jurisdiction
                )
            )
            
            # Extract risk level from analysis (simplified)
            risk_level = "medium"  # Default
            if "high risk" in risk_analysis.content.lower() or "critical" in risk_analysis.content.lower():
                risk_level = "high"
            elif "low risk" in risk_analysis.content.lower():
                risk_level = "low"
            
            return GeneratedClause(
                section_name=clause_type,
                clause_text=clause_text,
                risk_level=risk_level,
                justification=risk_analysis.content[:200] + "...",
                alternatives=[]  # Could generate alternatives
            )
        
        except Exception as e:
            logger.error(f"Clause generation error: {e}")
            return GeneratedClause(
                section_name=clause_type,
                clause_text=f"Error generating clause: {e}",
                risk_level="high",
                justification="Generation failed",
                alternatives=[]
            )

class ContractGenerator:
    """Main contract generation engine using prompt chaining."""
    
    def __init__(self, llm, clause_generator: LegalClauseGenerator):
        self.llm = llm
        self.clause_generator = clause_generator
        self._initialize_chains()
    
    def _initialize_chains(self):
        """Initialize prompt chains for contract generation."""
        
        # Chain 1: Requirements Analysis
        self.requirements_analysis_prompt = ChatPromptTemplate.from_template("""
Analyze the following contract requirements and identify all necessary clauses and provisions:

Contract Type: {contract_type}
Jurisdiction: {jurisdiction}
Party 1: {party1_info}
Party 2: {party2_info}
Terms: {terms_info}
Special Provisions: {special_provisions}

Provide a comprehensive list of required clauses and sections for this contract, considering:
1. Legal requirements for this contract type in the specified jurisdiction
2. Standard industry practices
3. Risk mitigation provisions
4. Compliance requirements

Required Clauses:
""")
        
        # Chain 2: Content Planning
        self.content_planning_prompt = ChatPromptTemplate.from_template("""
Based on the required clauses identified, create a detailed content plan for the contract:

Required Clauses: {required_clauses}
Contract Details: {contract_details}

For each clause, specify:
1. Detailed content requirements
2. Key terms to include
3. Specific legal language needed
4. Cross-references to other clauses

Content Plan:
""")
        
        # Chain 3: Final Assembly
        self.assembly_prompt = ChatPromptTemplate.from_template("""
Assemble the final contract document using the following components:

Template Structure: {template_structure}
Generated Clauses: {generated_clauses}
Content Plan: {content_plan}

Create a complete, professionally formatted legal contract that:
1. Follows proper legal document structure
2. Uses consistent terminology throughout
3. Includes all necessary provisions
4. Maintains logical flow and organization
5. Ensures all cross-references are correct

Final Contract:
""")
    
    def generate_contract(self, requirements: ContractRequirements) -> GeneratedContract:
        """Generate a complete contract using prompt chaining."""
        try:
            # Step 1: Analyze requirements
            logger.info("Step 1: Analyzing contract requirements")
            requirements_analysis = self.llm.invoke(
                self.requirements_analysis_prompt.format(
                    contract_type=requirements.contract_type,
                    jurisdiction=requirements.jurisdiction,
                    party1_info=str(requirements.party1),
                    party2_info=str(requirements.party2),
                    terms_info=str(requirements.terms),
                    special_provisions=", ".join(requirements.special_provisions)
                )
            )
            
            # Step 2: Create content plan
            logger.info("Step 2: Creating content plan")
            content_plan = self.llm.invoke(
                self.content_planning_prompt.format(
                    required_clauses=requirements_analysis.content,
                    contract_details=str(requirements.dict())
                )
            )
            
            # Step 3: Generate specific clauses
            logger.info("Step 3: Generating specific clauses")
            generated_clauses = []
            
            # Generate key clauses based on contract type
            clause_types = self._get_required_clauses(requirements.contract_type)
            
            for clause_type in clause_types:
                clause = self.clause_generator.generate_clause(
                    clause_type=clause_type,
                    requirements=str(requirements.terms),
                    contract_type=requirements.contract_type,
                    jurisdiction=requirements.jurisdiction,
                    risk_tolerance=requirements.risk_tolerance
                )
                generated_clauses.append(clause)
            
            # Step 4: Load and render template
            logger.info("Step 4: Assembling final contract")
            template = ContractTemplate(
                template_name=f"{requirements.contract_type}_template",
                contract_type=ContractType(requirements.contract_type)
            )
            
            # Prepare context for template rendering
            context = self._prepare_template_context(requirements, generated_clauses)
            
            # Render base template
            base_contract = template.render(context)
            
            # Step 5: Final assembly and enhancement
            final_contract = self.llm.invoke(
                self.assembly_prompt.format(
                    template_structure=base_contract,
                    generated_clauses="\n".join([clause.clause_text for clause in generated_clauses]),
                    content_plan=content_plan.content
                )
            )
            
            # Step 6: Risk analysis
            logger.info("Step 5: Performing risk analysis")
            analysis = self._analyze_contract_risk(final_contract.content, requirements)
            
            # Create contract parties
            party1 = ContractParty(**requirements.party1)
            party2 = ContractParty(**requirements.party2)
            
            # Create contract terms
            terms = ContractTerms(**requirements.terms)
            
            # Create final contract object
            contract = GeneratedContract(
                contract_id=str(uuid.uuid4()),
                contract_type=ContractType(requirements.contract_type),
                jurisdiction=Jurisdiction(requirements.jurisdiction),
                party1=party1,
                party2=party2,
                terms=terms,
                generated_text=final_contract.content,
                clauses=generated_clauses,
                analysis=analysis,
                template_used=template.template_name,
                llm_model=str(self.llm.model_name) if hasattr(self.llm, 'model_name') else "unknown"
            )
            
            logger.info(f"Contract generation completed: {contract.contract_id}")
            return contract
        
        except Exception as e:
            logger.error(f"Contract generation error: {e}")
            raise Exception(f"Failed to generate contract: {e}")
    
    def _get_required_clauses(self, contract_type: str) -> List[str]:
        """Get required clauses for specific contract type."""
        clause_mapping = {
            "service_agreement": [
                "payment_terms", "deliverables", "termination", "intellectual_property", 
                "liability_limitation", "dispute_resolution"
            ],
            "non_disclosure_agreement": [
                "confidential_information", "obligations", "term", "remedies", "exceptions"
            ],
            "employment_contract": [
                "job_duties", "compensation", "benefits", "termination", 
                "confidentiality", "non_compete", "intellectual_property"
            ],
            "sales_contract": [
                "purchase_price", "delivery_terms", "warranties", "risk_of_loss",
                "payment_terms", "dispute_resolution"
            ]
        }
        
        return clause_mapping.get(contract_type, ["general_terms", "governing_law"])
    
    def _prepare_template_context(self, requirements: ContractRequirements, 
                                 clauses: List[GeneratedClause]) -> Dict[str, Any]:
        """Prepare context dictionary for template rendering."""
        return {
            "effective_date": datetime.now().strftime("%B %d, %Y"),
            "party1": requirements.party1,
            "party2": requirements.party2,
            "terms": requirements.terms,
            "jurisdiction": requirements.jurisdiction.replace("_", " ").title(),
            "generated_clauses": {clause.section_name: clause.clause_text for clause in clauses},
            "dispute_resolution_clause": "Any disputes shall be resolved through binding arbitration.",
            "general_provisions": "This Agreement constitutes the entire agreement between the parties."
        }
    
    def _analyze_contract_risk(self, contract_text: str, 
                              requirements: ContractRequirements) -> ContractAnalysis:
        """Analyze contract for risks and compliance issues."""
        try:
            risk_prompt = ChatPromptTemplate.from_template("""
Perform a comprehensive risk analysis of this contract:

Contract Text: {contract_text}
Contract Type: {contract_type}
Jurisdiction: {jurisdiction}

Analyze for:
1. Overall risk level (low, medium, high, critical)
2. Specific risk factors
3. Compliance issues
4. Missing important clauses
5. Recommendations for improvement

Provide analysis in the following format:
Overall Risk: [level]
Risk Factors: [list]
Recommendations: [list]
Compliance Issues: [list]
Missing Clauses: [list]
""")
            
            analysis_response = self.llm.invoke(
                risk_prompt.format(
                    contract_text=contract_text[:3000],  # Limit length
                    contract_type=requirements.contract_type,
                    jurisdiction=requirements.jurisdiction
                )
            )
            
            # Parse the analysis response (simplified parsing)
            analysis_text = analysis_response.content
            
            # Extract overall risk level
            overall_risk = "medium"  # Default
            if "overall risk: high" in analysis_text.lower():
                overall_risk = "high"
            elif "overall risk: low" in analysis_text.lower():
                overall_risk = "low"
            elif "overall risk: critical" in analysis_text.lower():
                overall_risk = "critical"
            
            # Extract other components (simplified)
            risk_factors = ["Standard contractual risks identified"]
            recommendations = ["Review with legal counsel before execution"]
            compliance_issues = []
            missing_clauses = []
            
            return ContractAnalysis(
                overall_risk=overall_risk,
                risk_factors=risk_factors,
                recommendations=recommendations,
                compliance_issues=compliance_issues,
                missing_clauses=missing_clauses
            )
        
        except Exception as e:
            logger.error(f"Risk analysis error: {e}")
            return ContractAnalysis(
                overall_risk="high",
                risk_factors=[f"Analysis error: {e}"],
                recommendations=["Manual legal review required"],
                compliance_issues=["Unable to verify compliance"],
                missing_clauses=["Unable to identify missing clauses"]
            )

class ContractDatabase:
    """Database for storing generated contracts."""
    
    def __init__(self, db_path: str = "contracts.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize database tables."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Contracts table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS contracts (
                    contract_id TEXT PRIMARY KEY,
                    contract_type TEXT,
                    jurisdiction TEXT,
                    party1_name TEXT,
                    party2_name TEXT,
                    generated_text TEXT,
                    risk_level TEXT,
                    template_used TEXT,
                    llm_model TEXT,
                    created_at TEXT,
                    version TEXT
                )
            """)
            
            # Contract clauses table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS contract_clauses (
                    clause_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    contract_id TEXT,
                    section_name TEXT,
                    clause_text TEXT,
                    risk_level TEXT,
                    justification TEXT,
                    FOREIGN KEY (contract_id) REFERENCES contracts (contract_id)
                )
            """)
            
            # Contract analysis table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS contract_analysis (
                    analysis_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    contract_id TEXT,
                    overall_risk TEXT,
                    risk_factors TEXT,
                    recommendations TEXT,
                    compliance_issues TEXT,
                    missing_clauses TEXT,
                    FOREIGN KEY (contract_id) REFERENCES contracts (contract_id)
                )
            """)
            
            conn.commit()
    
    def save_contract(self, contract: GeneratedContract):
        """Save contract to database."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Save main contract
                cursor.execute("""
                    INSERT OR REPLACE INTO contracts 
                    (contract_id, contract_type, jurisdiction, party1_name, party2_name,
                     generated_text, risk_level, template_used, llm_model, created_at, version)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    contract.contract_id,
                    contract.contract_type.value,
                    contract.jurisdiction.value,
                    contract.party1.name,
                    contract.party2.name,
                    contract.generated_text,
                    contract.analysis.overall_risk,
                    contract.template_used,
                    contract.llm_model,
                    contract.created_at.isoformat(),
                    contract.version
                ))
                
                # Save clauses
                for clause in contract.clauses:
                    cursor.execute("""
                        INSERT INTO contract_clauses 
                        (contract_id, section_name, clause_text, risk_level, justification)
                        VALUES (?, ?, ?, ?, ?)
                    """, (
                        contract.contract_id,
                        clause.section_name,
                        clause.clause_text,
                        clause.risk_level,
                        clause.justification
                    ))
                
                # Save analysis
                cursor.execute("""
                    INSERT INTO contract_analysis 
                    (contract_id, overall_risk, risk_factors, recommendations, 
                     compliance_issues, missing_clauses)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (
                    contract.contract_id,
                    contract.analysis.overall_risk,
                    json.dumps(contract.analysis.risk_factors),
                    json.dumps(contract.analysis.recommendations),
                    json.dumps(contract.analysis.compliance_issues),
                    json.dumps(contract.analysis.missing_clauses)
                ))
                
                conn.commit()
                logger.info(f"Contract saved: {contract.contract_id}")
        
        except Exception as e:
            logger.error(f"Error saving contract: {e}")
    
    def get_contract(self, contract_id: str) -> Optional[Dict]:
        """Retrieve contract by ID."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM contracts WHERE contract_id = ?", (contract_id,))
                row = cursor.fetchone()
                
                if row:
                    columns = [description[0] for description in cursor.description]
                    return dict(zip(columns, row))
                return None
        
        except Exception as e:
            logger.error(f"Error retrieving contract: {e}")
            return None
    
    def get_all_contracts(self) -> List[Dict]:
        """Retrieve all contracts."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM contracts ORDER BY created_at DESC")
                columns = [description[0] for description in cursor.description]
                results = []
                for row in cursor.fetchall():
                    results.append(dict(zip(columns, row)))
                return results
        
        except Exception as e:
            logger.error(f"Error retrieving contracts: {e}")
            return []

class DocumentExporter:
    """Export contracts to various formats."""
    
    @staticmethod
    def export_to_docx(contract: GeneratedContract, filename: str):
        """Export contract to Word document."""
        try:
            doc = Document()
            
            # Title
            title = doc.add_heading(f'{contract.contract_type.value.replace("_", " ").title()}', 0)
            title.alignment = 1  # Center alignment
            
            # Contract content
            paragraphs = contract.generated_text.split('\n\n')
            for paragraph in paragraphs:
                if paragraph.strip():
                    p = doc.add_paragraph(paragraph.strip())
            
            # Add metadata
            doc.add_page_break()
            doc.add_heading('Document Metadata', level=1)
            doc.add_paragraph(f'Contract ID: {contract.contract_id}')
            doc.add_paragraph(f'Generated: {contract.created_at.strftime("%B %d, %Y at %I:%M %p")}')
            doc.add_paragraph(f'Jurisdiction: {contract.jurisdiction.value.replace("_", " ").title()}')
            doc.add_paragraph(f'Risk Level: {contract.analysis.overall_risk.title()}')
            
            # Save document
            doc.save(filename)
            logger.info(f"Contract exported to: {filename}")
            return filename
        
        except Exception as e:
            logger.error(f"Export error: {e}")
            raise

class LegalContractGeneratorAgent:
    """Main agent orchestrating contract generation."""
    
    def __init__(self, openai_api_key: Optional[str] = None, anthropic_api_key: Optional[str] = None):
        # Initialize LLM
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.1,  # Low temperature for legal accuracy
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        elif anthropic_api_key:
            self.llm = ChatAnthropic(
                temperature=0.1,
                model="claude-3-sonnet-20240229",
                anthropic_api_key=anthropic_api_key
            )
        
        if not self.llm:
            raise ValueError("Either OpenAI or Anthropic API key required")
        
        # Initialize components
        self.database = ContractDatabase()
        self.clause_generator = LegalClauseGenerator(self.llm)
        self.contract_generator = ContractGenerator(self.llm, self.clause_generator)
        self.exporter = DocumentExporter()
    
    def create_contract(self, requirements: Dict[str, Any]) -> GeneratedContract:
        """Create a new contract from requirements."""
        try:
            # Validate requirements
            contract_requirements = ContractRequirements(**requirements)
            
            # Generate contract
            contract = self.contract_generator.generate_contract(contract_requirements)
            
            # Save to database
            self.database.save_contract(contract)
            
            return contract
        
        except Exception as e:
            logger.error(f"Contract creation error: {e}")
            raise
    
    def get_contract_analytics(self) -> Dict[str, Any]:
        """Get analytics about generated contracts."""
        try:
            contracts = self.database.get_all_contracts()
            
            if not contracts:
                return {"total_contracts": 0}
            
            # Basic metrics
            total_contracts = len(contracts)
            
            # Contract type distribution
            type_counts = {}
            risk_counts = {}
            jurisdiction_counts = {}
            
            for contract in contracts:
                contract_type = contract['contract_type']
                type_counts[contract_type] = type_counts.get(contract_type, 0) + 1
                
                risk_level = contract['risk_level']
                risk_counts[risk_level] = risk_counts.get(risk_level, 0) + 1
                
                jurisdiction = contract['jurisdiction']
                jurisdiction_counts[jurisdiction] = jurisdiction_counts.get(jurisdiction, 0) + 1
            
            # Recent activity
            recent_contracts = [c for c in contracts if 
                              datetime.fromisoformat(c['created_at']) > datetime.now() - timedelta(days=30)]
            
            analytics = {
                "total_contracts": total_contracts,
                "recent_contracts": len(recent_contracts),
                "contract_types": type_counts,
                "risk_distribution": risk_counts,
                "jurisdiction_distribution": jurisdiction_counts,
                "avg_contracts_per_day": len(recent_contracts) / 30
            }
            
            return analytics
        
        except Exception as e:
            logger.error(f"Analytics error: {e}")
            return {"error": str(e)}

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Legal Contract Generator",
        page_icon="‚öñÔ∏è",
        layout="wide"
    )
    
    st.title("‚öñÔ∏è Custom Legal Contract Generator Agent")
    st.markdown("**AI-powered legal contract generation with template filling and prompt chaining**")
    
    # Legal disclaimer
    st.warning("""
    **LEGAL DISCLAIMER**: This tool is for informational purposes only and does not constitute legal advice. 
    Generated contracts should be reviewed by qualified legal counsel before use. The creators assume no 
    responsibility for the legal accuracy or enforceability of generated documents.
    """)
    
    # Initialize session state
    if 'agent' not in st.session_state:
        st.session_state['agent'] = None
    if 'generated_contract' not in st.session_state:
        st.session_state['generated_contract'] = None
    
    # Sidebar
    with st.sidebar:
        st.header("üîß Configuration")
        
        api_provider = st.selectbox("AI Provider", ["OpenAI", "Anthropic"])
        
        if api_provider == "OpenAI":
            api_key = st.text_input("OpenAI API Key", type="password")
            if st.button("Initialize Agent") and api_key:
                try:
                    st.session_state['agent'] = LegalContractGeneratorAgent(openai_api_key=api_key)
                    st.success("Agent initialized with OpenAI!")
                except Exception as e:
                    st.error(f"Initialization failed: {e}")
        else:
            api_key = st.text_input("Anthropic API Key", type="password")
            if st.button("Initialize Agent") and api_key:
                try:
                    st.session_state['agent'] = LegalContractGeneratorAgent(anthropic_api_key=api_key)
                    st.success("Agent initialized with Anthropic!")
                except Exception as e:
                    st.error(f"Initialization failed: {e}")
        
        st.header("üìö Contract Templates")
        st.info("Available templates:")
        for contract_type in ContractType:
            st.write(f"‚Ä¢ {contract_type.value.replace('_', ' ').title()}")
    
    if not st.session_state['agent']:
        st.info("üëà Please configure and initialize the Contract Generator Agent")
        return
    
    agent = st.session_state['agent']
    
    # Main tabs
    tab1, tab2, tab3, tab4 = st.tabs(["üìù Generate Contract", "üìä Analytics", "üíæ Contract Library", "‚öôÔ∏è Settings"])
    
    with tab1:
        st.header("üìù Contract Generation")
        
        # Contract type selection
        contract_type = st.selectbox(
            "Contract Type",
            [ct.value for ct in ContractType],
            format_func=lambda x: x.replace('_', ' ').title()
        )
        
        # Jurisdiction selection
        jurisdiction = st.selectbox(
            "Jurisdiction",
            [j.value for j in Jurisdiction],
            format_func=lambda x: x.replace('_', ' ').title()
        )
        
        # Party information
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Party 1 Information")
            party1_name = st.text_input("Name/Company Name", key="p1_name")
            party1_type = st.selectbox("Entity Type", 
                                     ["individual", "corporation", "llc", "partnership"], 
                                     key="p1_type")
            party1_address = st.text_area("Address", key="p1_address")
            party1_contact = st.text_input("Contact Person", key="p1_contact")
            party1_email = st.text_input("Email", key="p1_email")
        
        with col2:
            st.subheader("Party 2 Information")
            party2_name = st.text_input("Name/Company Name", key="p2_name")
            party2_type = st.selectbox("Entity Type", 
                                     ["individual", "corporation", "llc", "partnership"], 
                                     key="p2_type")
            party2_address = st.text_area("Address", key="p2_address")
            party2_contact = st.text_input("Contact Person", key="p2_contact")
            party2_email = st.text_input("Email", key="p2_email")
        
        # Contract terms
        st.subheader("Contract Terms")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            duration = st.text_input("Contract Duration", placeholder="e.g., 1 year, 6 months")
            payment_amount = st.number_input("Payment Amount ($)", min_value=0.0, value=0.0)
        
        with col2:
            payment_schedule = st.selectbox("Payment Schedule", 
                                          ["monthly", "quarterly", "annually", "upon completion", "milestone-based"])
            confidentiality_period = st.text_input("Confidentiality Period", placeholder="e.g., 2 years")
        
        with col3:
            risk_tolerance = st.selectbox("Risk Tolerance", ["low", "medium", "high"])
        
        # Deliverables and provisions
        st.subheader("Additional Details")
        
        deliverables = st.text_area(
            "Deliverables/Services (one per line)",
            placeholder="List main deliverables or services to be provided..."
        )
        
        special_provisions = st.text_area(
            "Special Provisions",
            placeholder="Any special clauses or requirements..."
        )
        
        # Generate contract button
        if st.button("üî® Generate Contract", type="primary"):
            if not all([party1_name, party2_name, party1_address, party2_address]):
                st.error("Please fill in all required party information")
            else:
                with st.spinner("Generating contract... This may take a moment."):
                    try:
                        # Prepare requirements
                        requirements = {
                            "contract_type": contract_type,
                            "jurisdiction": jurisdiction,
                            "party1": {
                                "name": party1_name,
                                "entity_type": party1_type,
                                "address": party1_address,
                                "contact_person": party1_contact,
                                "email": party1_email
                            },
                            "party2": {
                                "name": party2_name,
                                "entity_type": party2_type,
                                "address": party2_address,
                                "contact_person": party2_contact,
                                "email": party2_email
                            },
                            "terms": {
                                "duration": duration,
                                "payment_amount": payment_amount,
                                "payment_schedule": payment_schedule,
                                "deliverables": [d.strip() for d in deliverables.split('\n') if d.strip()],
                                "confidentiality_period": confidentiality_period
                            },
                            "special_provisions": [p.strip() for p in special_provisions.split('\n') if p.strip()],
                            "risk_tolerance": risk_tolerance
                        }
                        
                        # Generate contract
                        contract = agent.create_contract(requirements)
                        st.session_state['generated_contract'] = contract
                        
                        st.success(f"Contract generated successfully! ID: {contract.contract_id}")
                        st.rerun()
                    
                    except Exception as e:
                        st.error(f"Contract generation failed: {e}")
        
        # Display generated contract
        if st.session_state['generated_contract']:
            contract = st.session_state['generated_contract']
            
            st.subheader("üìÑ Generated Contract")
            
            # Contract metrics
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Contract ID", contract.contract_id[:8] + "...")
            with col2:
                st.metric("Risk Level", contract.analysis.overall_risk.title())
            with col3:
                st.metric("Clauses Generated", len(contract.clauses))
            with col4:
                st.metric("Template Used", contract.template_used.split('_')[0].title())
            
            # Contract text
            with st.expander("üìÑ Contract Text", expanded=True):
                st.text_area("", value=contract.generated_text, height=400, disabled=True)
            
            # Risk analysis
            with st.expander("‚ö†Ô∏è Risk Analysis"):
                st.write(f"**Overall Risk Level:** {contract.analysis.overall_risk.title()}")
                
                if contract.analysis.risk_factors:
                    st.write("**Risk Factors:**")
                    for factor in contract.analysis.risk_factors:
                        st.write(f"‚Ä¢ {factor}")
                
                if contract.analysis.recommendations:
                    st.write("**Recommendations:**")
                    for rec in contract.analysis.recommendations:
                        st.write(f"‚Ä¢ {rec}")
            
            # Generated clauses
            with st.expander("üìã Generated Clauses"):
                for clause in contract.clauses:
                    st.subheader(clause.section_name.replace('_', ' ').title())
                    st.write(clause.clause_text)
                    st.caption(f"Risk Level: {clause.risk_level} | {clause.justification}")
                    st.divider()
            
            # Export options
            st.subheader("üì§ Export Options")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                if st.button("üìÑ Export to Word"):
                    try:
                        filename = f"contract_{contract.contract_id[:8]}.docx"
                        agent.exporter.export_to_docx(contract, filename)
                        
                        with open(filename, "rb") as file:
                            st.download_button(
                                label="Download Word Document",
                                data=file.read(),
                                file_name=filename,
                                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                            )
                    except Exception as e:
                        st.error(f"Export failed: {e}")
            
            with col2:
                if st.button("üìÑ Export as Text"):
                    st.download_button(
                        label="Download Text File",
                        data=contract.generated_text,
                        file_name=f"contract_{contract.contract_id[:8]}.txt",
                        mime="text/plain"
                    )
            
            with col3:
                if st.button("üìÑ Export as JSON"):
                    contract_dict = {
                        "contract_id": contract.contract_id,
                        "contract_type": contract.contract_type.value,
                        "jurisdiction": contract.jurisdiction.value,
                        "parties": {
                            "party1": contract.party1.__dict__,
                            "party2": contract.party2.__dict__
                        },
                        "terms": contract.terms.__dict__,
                        "generated_text": contract.generated_text,
                        "analysis": contract.analysis.__dict__,
                        "created_at": contract.created_at.isoformat()
                    }
                    
                    st.download_button(
                        label="Download JSON",
                        data=json.dumps(contract_dict, indent=2),
                        file_name=f"contract_{contract.contract_id[:8]}.json",
                        mime="application/json"
                    )
    
    with tab2:
        st.header("üìä Contract Analytics")
        
        if st.button("üìà Generate Analytics"):
            with st.spinner("Analyzing contract data..."):
                analytics = agent.get_contract_analytics()
                
                if 'error' not in analytics:
                    # Key metrics
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("Total Contracts", analytics.get('total_contracts', 0))
                    with col2:
                        st.metric("Recent Contracts", analytics.get('recent_contracts', 0))
                    with col3:
                        st.metric("Avg per Day", f"{analytics.get('avg_contracts_per_day', 0):.1f}")
                    with col4:
                        risk_dist = analytics.get('risk_distribution', {})
                        high_risk = risk_dist.get('high', 0) + risk_dist.get('critical', 0)
                        st.metric("High Risk Contracts", high_risk)
                    
                    # Contract type distribution
                    if analytics.get('contract_types'):
                        st.subheader("üìã Contract Type Distribution")
                        
                        types_df = pd.DataFrame(
                            list(analytics['contract_types'].items()),
                            columns=['Type', 'Count']
                        )
                        types_df['Type'] = types_df['Type'].str.replace('_', ' ').str.title()
                        
                        fig = px.pie(types_df, values='Count', names='Type', 
                                   title='Contracts by Type')
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # Risk distribution
                    if analytics.get('risk_distribution'):
                        st.subheader("‚ö†Ô∏è Risk Level Distribution")
                        
                        risk_df = pd.DataFrame(
                            list(analytics['risk_distribution'].items()),
                            columns=['Risk Level', 'Count']
                        )
                        risk_df['Risk Level'] = risk_df['Risk Level'].str.title()
                        
                        fig = px.bar(risk_df, x='Risk Level', y='Count', 
                                   title='Contracts by Risk Level',
                                   color='Risk Level',
                                   color_discrete_map={
                                       'Low': 'green',
                                       'Medium': 'orange', 
                                       'High': 'red',
                                       'Critical': 'darkred'
                                   })
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # Jurisdiction distribution
                    if analytics.get('jurisdiction_distribution'):
                        st.subheader("üåç Jurisdiction Distribution")
                        
                        jurisdiction_df = pd.DataFrame(
                            list(analytics['jurisdiction_distribution'].items()),
                            columns=['Jurisdiction', 'Count']
                        )
                        jurisdiction_df['Jurisdiction'] = jurisdiction_df['Jurisdiction'].str.replace('_', ' ').str.title()
                        
                        fig = px.bar(jurisdiction_df, x='Count', y='Jurisdiction', 
                                   orientation='h',
                                   title='Contracts by Jurisdiction')
                        st.plotly_chart(fig, use_container_width=True)
                else:
                    st.error(analytics['error'])
    
    with tab3:
        st.header("üíæ Contract Library")
        
        # Load contracts
        contracts = agent.database.get_all_contracts()
        
        if contracts:
            st.subheader(f"üìö Contract Collection ({len(contracts)} contracts)")
            
            # Search and filter
            col1, col2, col3 = st.columns(3)
            
            with col1:
                search_term = st.text_input("üîç Search contracts", placeholder="Search by party name or type...")
            
            with col2:
                filter_type = st.selectbox("Filter by Type", 
                                         ["All"] + [ct.value for ct in ContractType],
                                         format_func=lambda x: x.replace('_', ' ').title() if x != "All" else x)
            
            with col3:
                filter_risk = st.selectbox("Filter by Risk", 
                                         ["All", "low", "medium", "high", "critical"])
            
            # Apply filters
            filtered_contracts = contracts
            
            if search_term:
                filtered_contracts = [c for c in filtered_contracts 
                                    if search_term.lower() in c['party1_name'].lower() 
                                    or search_term.lower() in c['party2_name'].lower()
                                    or search_term.lower() in c['contract_type'].lower()]
            
            if filter_type != "All":
                filtered_contracts = [c for c in filtered_contracts if c['contract_type'] == filter_type]
            
            if filter_risk != "All":
                filtered_contracts = [c for c in filtered_contracts if c['risk_level'] == filter_risk]
            
            # Display contracts
            for contract in filtered_contracts[:20]:  # Limit to 20 for performance
                with st.expander(f"{contract['contract_type'].replace('_', ' ').title()} - {contract['party1_name']} & {contract['party2_name']}"):
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.write(f"**Contract ID:** {contract['contract_id'][:8]}...")
                        st.write(f"**Type:** {contract['contract_type'].replace('_', ' ').title()}")
                    
                    with col2:
                        st.write(f"**Risk Level:** {contract['risk_level'].title()}")
                        st.write(f"**Jurisdiction:** {contract['jurisdiction'].replace('_', ' ').title()}")
                    
                    with col3:
                        created_date = datetime.fromisoformat(contract['created_at'])
                        st.write(f"**Created:** {created_date.strftime('%Y-%m-%d %H:%M')}")
                        st.write(f"**Template:** {contract['template_used']}")
                    
                    # Contract preview
                    if st.button(f"üëÅÔ∏è View Contract", key=f"view_{contract['contract_id']}"):
                        st.text_area("Contract Text", 
                                   value=contract['generated_text'][:1000] + "...", 
                                   height=200, 
                                   disabled=True,
                                   key=f"preview_{contract['contract_id']}")
        else:
            st.info("No contracts in the library yet. Generate your first contract in the 'Generate Contract' tab!")
    
    with tab4:
        st.header("‚öôÔ∏è Settings & Configuration")
        
        # Model settings
        st.subheader("ü§ñ AI Model Settings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            generation_temperature = st.slider("Generation Temperature", 0.0, 1.0, 0.1, 0.1,
                                              help="Lower = more conservative, Higher = more creative")
            
            max_tokens = st.number_input("Max Tokens per Response", 1000, 8000, 4000,
                                       help="Maximum length of generated responses")
        
        with col2:
            enable_risk_analysis = st.checkbox("Enable Risk Analysis", True,
                                             help="Automatically analyze contracts for risks")
            
            enable_compliance_check = st.checkbox("Enable Compliance Checking", True,
                                                 help="Check contracts for compliance issues")
        
        # Template settings
        st.subheader("üìã Template Settings")
        
        default_jurisdiction = st.selectbox("Default Jurisdiction", 
                                          [j.value for j in Jurisdiction],
                                          format_func=lambda x: x.replace('_', ' ').title())
        
        include_metadata = st.checkbox("Include Metadata in Exports", True,
                                     help="Add generation details to exported documents")
        
        # Database settings
        st.subheader("üíæ Database Settings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üìä Database Statistics"):
                contracts = agent.database.get_all_contracts()
                st.info(f"Total contracts: {len(contracts)}")
                
                if contracts:
                    total_size = sum(len(c['generated_text']) for c in contracts)
                    st.info(f"Total text: {total_size:,} characters")
        
        with col2:
            if st.button("üóëÔ∏è Clear Database", type="secondary"):
                if st.button("‚ö†Ô∏è Confirm Clear", type="primary"):
                    st.warning("Database clearing would be implemented here")
        
        # Legal disclaimer settings
        st.subheader("‚öñÔ∏è Legal Settings")
        
        show_disclaimers = st.checkbox("Show Legal Disclaimers", True,
                                     help="Display legal disclaimers on generated contracts")
        
        require_review_notice = st.checkbox("Require Legal Review Notice", True,
                                          help="Add notice that contracts should be reviewed by counsel")
        
        # Export settings
        st.subheader("üì§ Export Settings")
        
        default_format = st.selectbox("Default Export Format", 
                                    ["Word Document", "PDF", "Text", "JSON"])
        
        include_analysis = st.checkbox("Include Risk Analysis in Exports", True,
                                     help="Add risk analysis to exported documents")
        
        if st.button("üíæ Save Settings"):
            st.success("Settings saved successfully!")

if __name__ == "__main__":
    main()
````

## Project Summary

The Custom Legal Contract Generator Agent revolutionizes legal document creation through AI-powered template filling and prompt chaining, enabling automated generation of professionally drafted contracts while maintaining legal accuracy and compliance standards across multiple jurisdictions.

### Key Value Propositions:
- **Intelligent Generation**: LLM-powered contract drafting with legal terminology and structure
- **Template Flexibility**: Comprehensive library of customizable legal document templates
- **Risk Assessment**: Automated analysis and identification of contractual risks and compliance issues
- **Prompt Chaining**: Sequential AI reasoning for complex legal logic and clause validation

### Technical Architecture:
The system integrates LangChain for prompt orchestration, Jinja2 for template processing, SQLite for contract storage, and multiple LLM providers for robust contract generation, creating a scalable legal automation platform that democratizes access to professional contract drafting while maintaining legal standards through automated validation and risk assessment workflows.