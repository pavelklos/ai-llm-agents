<small>Claude Sonnet 4 **(Smart City Infrastructure Management - Multi-Agent Syst√©m)**</small>
# Smart City Infrastructure Management

## Key Concepts Explanation

### Sensor Data Simulation
Simulace senzorov√Ωch dat p≈ôedstavuje vytv√°≈ôen√≠ realistick√Ωch dat ze senzor≈Ø mƒõsta jako jsou dopravn√≠ kamery, energetick√© mƒõ≈ôiƒçe, bezpeƒçnostn√≠ syst√©my a environment√°ln√≠ senzory. Tato data slou≈æ√≠ jako vstupn√≠ informace pro AI agenty.

### AI Agents
AI agenti jsou autonomn√≠ software entity, kter√© mohou vn√≠mat prost≈ôed√≠, rozhodovat se a vykon√°vat akce. V kontextu smart city ka≈æd√Ω agent spravuje specifickou oblast infrastruktury a komunikuje s ostatn√≠mi agenty.

### Planning
Pl√°nov√°n√≠ zahrnuje strategick√© rozhodov√°n√≠ agent≈Ø o budouc√≠ch akc√≠ch na z√°kladƒõ aktu√°ln√≠ch dat a predikovan√Ωch trend≈Ø. Pou≈æ√≠vaj√≠ se algoritmy pro optimalizaci zdroj≈Ø a predikci probl√©m≈Ø.

### Multi-Agent Communication
Komunikace mezi agenty umo≈æ≈àuje koordinaci ƒçinnost√≠, sd√≠len√≠ informac√≠ a kolaborativn√≠ ≈ôe≈°en√≠ probl√©m≈Ø. Agenti si vymƒõ≈àuj√≠ zpr√°vy o stavech syst√©m≈Ø a koordinuj√≠ spoleƒçn√© akce.

### UMAP/GraphQL
UMAP slou≈æ√≠ pro vizualizaci a anal√Ωzu vysokodimenzion√°ln√≠ch dat ze senzor≈Ø. GraphQL poskytuje flexibiln√≠ API pro dotazov√°n√≠ a manipulaci dat nap≈ô√≠ƒç r≈Øzn√Ωmi syst√©my mƒõsta.

### Decision Making
Rozhodov√°n√≠ zahrnuje algoritmy pro v√Ωbƒõr optim√°ln√≠ch akc√≠ na z√°kladƒõ dostupn√Ωch dat, predikƒçn√≠ch model≈Ø a definovan√Ωch c√≠l≈Ø pro ka≈ædou oblast infrastruktury.

## Comprehensive Project Explanation

Projekt Smart City Infrastructure Management p≈ôedstavuje komplexn√≠ syst√©m pro autonomn√≠ spr√°vu mƒõstsk√© infrastruktury pomoc√≠ multi-agent syst√©mu. Hlavn√≠m c√≠lem je vytvo≈ôen√≠ inteligentn√≠ s√≠tƒõ AI agent≈Ø, kte≈ô√≠ spolupracuj√≠ p≈ôi optimalizaci dopravy, energetiky a bezpeƒçnosti mƒõsta.

### C√≠le projektu:
- **Automatizace spr√°vy infrastruktury** - Sn√≠≈æen√≠ pot≈ôeby manu√°ln√≠ch z√°sah≈Ø
- **Optimalizace zdroj≈Ø** - Efektivn√≠ vyu≈æit√≠ energie, dopravn√≠ch tras a bezpeƒçnostn√≠ch syst√©m≈Ø  
- **Prediktivn√≠ √∫dr≈æba** - Vƒçasn√© rozpozn√°n√≠ a prevence probl√©m≈Ø
- **Koordinace mezi syst√©my** - Synchronizace r≈Øzn√Ωch mƒõstsk√Ωch slu≈æeb

### V√Ωzvy:
- **Komplexnost dat** - Zpracov√°n√≠ velk√Ωch objem≈Ø heterogenn√≠ch senzorov√Ωch dat
- **Real-time rozhodov√°n√≠** - Rychl√© reakce na mƒõn√≠c√≠ se podm√≠nky
- **Interoperabilita** - Zaji≈°tƒõn√≠ komunikace mezi r≈Øzn√Ωmi syst√©my
- **≈†k√°lovatelnost** - Podpora r≈Østu mƒõsta a p≈ôid√°v√°n√≠ nov√Ωch syst√©m≈Ø

### Potenci√°ln√≠ dopad:
- Sn√≠≈æen√≠ energetick√© spot≈ôeby o 15-25%
- Zlep≈°en√≠ dopravn√≠ho toku o 20-30%
- Rychlej≈°√≠ reakce na bezpeƒçnostn√≠ incidenty
- Vy≈°≈°√≠ kvalita ≈æivota obyvatel

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import random
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum
import numpy as np
import pandas as pd
from pydantic import BaseModel
import uvicorn
from fastapi import FastAPI, WebSocket
import strawberry
from strawberry.fastapi import GraphQLRouter
import umap
from sklearn.preprocessing import StandardScaler
import plotly.express as px
import plotly.graph_objects as go

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# === Data Models ===
class AlertLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class SensorData:
    sensor_id: str
    timestamp: datetime
    sensor_type: str
    location: tuple
    value: float
    unit: str
    metadata: Dict[str, Any] = None

@dataclass
class AgentAction:
    action_id: str
    agent_id: str
    action_type: str
    parameters: Dict[str, Any]
    timestamp: datetime
    expected_outcome: str

@dataclass
class CityAlert:
    alert_id: str
    alert_type: str
    level: AlertLevel
    location: tuple
    description: str
    timestamp: datetime
    affected_systems: List[str]

# === Sensor Data Simulator ===
class SensorDataSimulator:
    def __init__(self):
        self.sensors = self._initialize_sensors()
        self.base_time = datetime.now()
        
    def _initialize_sensors(self) -> Dict[str, Dict]:
        return {
            # Dopravn√≠ senzory
            "traffic_001": {"type": "traffic_flow", "location": (50.0755, 14.4378), "normal_range": (50, 200)},
            "traffic_002": {"type": "traffic_flow", "location": (50.0865, 14.4214), "normal_range": (30, 150)},
            "speed_001": {"type": "avg_speed", "location": (50.0755, 14.4378), "normal_range": (25, 60)},
            
            # Energetick√© senzory
            "power_001": {"type": "power_consumption", "location": (50.0875, 14.4214), "normal_range": (800, 1200)},
            "power_002": {"type": "power_consumption", "location": (50.0755, 14.4378), "normal_range": (600, 1000)},
            "solar_001": {"type": "solar_generation", "location": (50.0865, 14.4214), "normal_range": (0, 500)},
            
            # Bezpeƒçnostn√≠ senzory
            "security_001": {"type": "crowd_density", "location": (50.0755, 14.4378), "normal_range": (10, 100)},
            "security_002": {"type": "noise_level", "location": (50.0865, 14.4214), "normal_range": (40, 80)},
            "camera_001": {"type": "incident_detection", "location": (50.0875, 14.4214), "normal_range": (0, 1)},
            
            # Environment√°ln√≠ senzory
            "air_001": {"type": "air_quality", "location": (50.0755, 14.4378), "normal_range": (20, 100)},
            "temp_001": {"type": "temperature", "location": (50.0865, 14.4214), "normal_range": (-10, 35)},
        }
    
    def generate_sensor_data(self, hours_back: int = 0) -> List[SensorData]:
        """Generuje realistick√° senzorov√° data"""
        data = []
        current_time = self.base_time - timedelta(hours=hours_back)
        
        for sensor_id, sensor_config in self.sensors.items():
            # Z√°kladn√≠ hodnota s denn√≠m cyklem
            hour = current_time.hour
            daily_factor = self._get_daily_factor(sensor_config["type"], hour)
            
            min_val, max_val = sensor_config["normal_range"]
            base_value = min_val + (max_val - min_val) * daily_factor
            
            # P≈ôid√°n√≠ n√°hodn√©ho ≈°umu
            noise = random.gauss(0, (max_val - min_val) * 0.1)
            value = max(0, base_value + noise)
            
            # Simulace anom√°li√≠ (5% pravdƒõpodobnost)
            if random.random() < 0.05:
                anomaly_factor = random.choice([0.3, 2.5])
                value *= anomaly_factor
            
            unit = self._get_unit(sensor_config["type"])
            
            sensor_data = SensorData(
                sensor_id=sensor_id,
                timestamp=current_time,
                sensor_type=sensor_config["type"],
                location=sensor_config["location"],
                value=round(value, 2),
                unit=unit,
                metadata={"weather": "clear", "day_of_week": current_time.weekday()}
            )
            data.append(sensor_data)
        
        return data
    
    def _get_daily_factor(self, sensor_type: str, hour: int) -> float:
        """Vrac√≠ faktor pro denn√≠ cyklus podle typu senzoru"""
        if sensor_type in ["traffic_flow", "avg_speed"]:
            # Dopravn√≠ ≈°piƒçka r√°no a veƒçer
            if 7 <= hour <= 9 or 17 <= hour <= 19:
                return 0.9
            elif 10 <= hour <= 16:
                return 0.6
            else:
                return 0.3
        elif sensor_type == "power_consumption":
            # Vy≈°≈°√≠ spot≈ôeba veƒçer
            if 18 <= hour <= 22:
                return 0.9
            elif 6 <= hour <= 8:
                return 0.7
            else:
                return 0.5
        elif sensor_type == "solar_generation":
            # Sol√°rn√≠ generace podle slunce
            if 6 <= hour <= 18:
                return abs(np.sin(np.pi * (hour - 6) / 12))
            else:
                return 0.0
        else:
            return 0.5
    
    def _get_unit(self, sensor_type: str) -> str:
        units = {
            "traffic_flow": "vehicles/hour",
            "avg_speed": "km/h",
            "power_consumption": "kW",
            "solar_generation": "kW",
            "crowd_density": "people/m¬≤",
            "noise_level": "dB",
            "incident_detection": "binary",
            "air_quality": "AQI",
            "temperature": "¬∞C"
        }
        return units.get(sensor_type, "units")

# === Base Agent Class ===
class BaseAgent:
    def __init__(self, agent_id: str, agent_type: str):
        self.agent_id = agent_id
        self.agent_type = agent_type
        self.knowledge_base = {}
        self.action_history = []
        self.communication_channel = None
        
    async def process_sensor_data(self, sensor_data: List[SensorData]) -> List[AgentAction]:
        """Zpracuje senzorov√° data a vr√°t√≠ akce"""
        raise NotImplementedError
    
    async def communicate(self, message: Dict[str, Any], target_agent: str = None):
        """Komunikuje s ostatn√≠mi agenty"""
        if self.communication_channel:
            await self.communication_channel.send_message(
                sender=self.agent_id,
                target=target_agent,
                message=message
            )
    
    def update_knowledge(self, key: str, value: Any):
        """Aktualizuje znalostn√≠ b√°zi agenta"""
        self.knowledge_base[key] = value
        logger.info(f"Agent {self.agent_id} updated knowledge: {key}")

# === Traffic Management Agent ===
class TrafficAgent(BaseAgent):
    def __init__(self):
        super().__init__("traffic_agent", "traffic_management")
        self.traffic_lights = {}
        self.congestion_threshold = 150
        
    async def process_sensor_data(self, sensor_data: List[SensorData]) -> List[AgentAction]:
        actions = []
        traffic_data = [s for s in sensor_data if s.sensor_type in ["traffic_flow", "avg_speed"]]
        
        for data in traffic_data:
            if data.sensor_type == "traffic_flow" and data.value > self.congestion_threshold:
                # Detekce kongence
                action = AgentAction(
                    action_id=f"traffic_optimize_{data.sensor_id}_{int(data.timestamp.timestamp())}",
                    agent_id=self.agent_id,
                    action_type="optimize_traffic_light_timing",
                    parameters={
                        "location": data.location,
                        "current_flow": data.value,
                        "green_time_increase": 30
                    },
                    timestamp=datetime.now(),
                    expected_outcome="reduce_congestion"
                )
                actions.append(action)
                
                # Komunikace s energetick√Ωm agentem
                await self.communicate({
                    "type": "traffic_alert",
                    "location": data.location,
                    "congestion_level": data.value,
                    "action": "traffic_light_optimization"
                }, "energy_agent")
            
            elif data.sensor_type == "avg_speed" and data.value < 15:
                # Velmi pomal√° doprava
                action = AgentAction(
                    action_id=f"speed_alert_{data.sensor_id}_{int(data.timestamp.timestamp())}",
                    agent_id=self.agent_id,
                    action_type="emergency_traffic_management",
                    parameters={
                        "location": data.location,
                        "avg_speed": data.value,
                        "action": "deploy_traffic_management_team"
                    },
                    timestamp=datetime.now(),
                    expected_outcome="improve_traffic_flow"
                )
                actions.append(action)
        
        return actions

# === Energy Management Agent ===
class EnergyAgent(BaseAgent):
    def __init__(self):
        super().__init__("energy_agent", "energy_management")
        self.energy_threshold = 1100
        self.solar_efficiency = 0.8
        
    async def process_sensor_data(self, sensor_data: List[SensorData]) -> List[AgentAction]:
        actions = []
        energy_data = [s for s in sensor_data if s.sensor_type in ["power_consumption", "solar_generation"]]
        
        total_consumption = sum(d.value for d in energy_data if d.sensor_type == "power_consumption")
        total_generation = sum(d.value for d in energy_data if d.sensor_type == "solar_generation")
        
        if total_consumption > self.energy_threshold:
            # Vysok√° spot≈ôeba energie
            action = AgentAction(
                action_id=f"energy_optimize_{int(datetime.now().timestamp())}",
                agent_id=self.agent_id,
                action_type="load_balancing",
                parameters={
                    "total_consumption": total_consumption,
                    "total_generation": total_generation,
                    "load_reduction_target": 0.15
                },
                timestamp=datetime.now(),
                expected_outcome="reduce_energy_consumption"
            )
            actions.append(action)
            
            # Komunikace s bezpeƒçnostn√≠m agentem o sn√≠≈æen√≠ osvƒõtlen√≠
            await self.communicate({
                "type": "energy_optimization",
                "action": "reduce_street_lighting",
                "reduction_percentage": 20
            }, "security_agent")
        
        # Optimalizace sol√°rn√≠ energie
        if total_generation > 0:
            solar_efficiency = total_generation / (total_generation + 100)  # Simulace
            if solar_efficiency < self.solar_efficiency:
                action = AgentAction(
                    action_id=f"solar_optimize_{int(datetime.now().timestamp())}",
                    agent_id=self.agent_id,
                    action_type="solar_panel_optimization",
                    parameters={
                        "current_efficiency": solar_efficiency,
                        "target_efficiency": self.solar_efficiency,
                        "maintenance_required": True
                    },
                    timestamp=datetime.now(),
                    expected_outcome="improve_solar_efficiency"
                )
                actions.append(action)
        
        return actions

# === Security Management Agent ===
class SecurityAgent(BaseAgent):
    def __init__(self):
        super().__init__("security_agent", "security_management")
        self.crowd_threshold = 80
        self.noise_threshold = 75
        
    async def process_sensor_data(self, sensor_data: List[SensorData]) -> List[AgentAction]:
        actions = []
        security_data = [s for s in sensor_data if s.sensor_type in ["crowd_density", "noise_level", "incident_detection"]]
        
        for data in security_data:
            if data.sensor_type == "crowd_density" and data.value > self.crowd_threshold:
                # Vysok√° hustota lid√≠
                action = AgentAction(
                    action_id=f"crowd_management_{data.sensor_id}_{int(data.timestamp.timestamp())}",
                    agent_id=self.agent_id,
                    action_type="crowd_control",
                    parameters={
                        "location": data.location,
                        "crowd_density": data.value,
                        "action": "deploy_additional_security"
                    },
                    timestamp=datetime.now(),
                    expected_outcome="manage_crowd_safely"
                )
                actions.append(action)
                
                # Komunikace s dopravn√≠m agentem
                await self.communicate({
                    "type": "crowd_alert",
                    "location": data.location,
                    "crowd_density": data.value,
                    "recommended_action": "redirect_traffic"
                }, "traffic_agent")
            
            elif data.sensor_type == "noise_level" and data.value > self.noise_threshold:
                # Vysok√° hladina hluku
                action = AgentAction(
                    action_id=f"noise_control_{data.sensor_id}_{int(data.timestamp.timestamp())}",
                    agent_id=self.agent_id,
                    action_type="noise_management",
                    parameters={
                        "location": data.location,
                        "noise_level": data.value,
                        "action": "investigate_noise_source"
                    },
                    timestamp=datetime.now(),
                    expected_outcome="reduce_noise_level"
                )
                actions.append(action)
            
            elif data.sensor_type == "incident_detection" and data.value == 1:
                # Detekce incidentu
                action = AgentAction(
                    action_id=f"incident_response_{data.sensor_id}_{int(data.timestamp.timestamp())}",
                    agent_id=self.agent_id,
                    action_type="emergency_response",
                    parameters={
                        "location": data.location,
                        "incident_type": "detected",
                        "priority": "high"
                    },
                    timestamp=datetime.now(),
                    expected_outcome="resolve_incident"
                )
                actions.append(action)
        
        return actions

# === Communication Channel ===
class CommunicationChannel:
    def __init__(self):
        self.message_queue = asyncio.Queue()
        self.subscribers = {}
        
    def subscribe(self, agent_id: str, agent: BaseAgent):
        """P≈ôihl√°s√≠ agenta k odbƒõru zpr√°v"""
        self.subscribers[agent_id] = agent
        agent.communication_channel = self
        
    async def send_message(self, sender: str, target: str, message: Dict[str, Any]):
        """Ode≈°le zpr√°vu mezi agenty"""
        await self.message_queue.put({
            "sender": sender,
            "target": target,
            "message": message,
            "timestamp": datetime.now()
        })
        logger.info(f"Message sent from {sender} to {target}: {message['type']}")
    
    async def process_messages(self):
        """Zpracov√°v√° zpr√°vy v komunikaƒçn√≠m kan√°lu"""
        while True:
            try:
                message_data = await asyncio.wait_for(self.message_queue.get(), timeout=1.0)
                target_agent = self.subscribers.get(message_data["target"])
                if target_agent:
                    await self._deliver_message(target_agent, message_data)
            except asyncio.TimeoutError:
                continue
    
    async def _deliver_message(self, agent: BaseAgent, message_data: Dict[str, Any]):
        """Doruƒç√≠ zpr√°vu konkr√©tn√≠mu agentovi"""
        message = message_data["message"]
        sender = message_data["sender"]
        
        # Agent m≈Ø≈æe reagovat na zpr√°vu
        if hasattr(agent, 'handle_message'):
            await agent.handle_message(sender, message)
        
        # Aktualizace znalostn√≠ b√°ze
        agent.update_knowledge(f"message_from_{sender}", message)

# === UMAP Data Analysis ===
class UMAPAnalyzer:
    def __init__(self):
        self.umap_model = None
        self.scaler = StandardScaler()
        
    def analyze_sensor_data(self, sensor_data_history: List[List[SensorData]]) -> Dict[str, Any]:
        """Analyzuje senzorov√° data pomoc√≠ UMAP"""
        # P≈ô√≠prava dat pro UMAP
        features = []
        labels = []
        
        for data_batch in sensor_data_history:
            for sensor_data in data_batch:
                feature_vector = self._extract_features(sensor_data)
                features.append(feature_vector)
                labels.append(sensor_data.sensor_type)
        
        if len(features) < 10:  # Nedostatek dat
            return {"status": "insufficient_data"}
        
        # Normalizace dat
        features_array = np.array(features)
        features_scaled = self.scaler.fit_transform(features_array)
        
        # UMAP redukce dimenzionality
        self.umap_model = umap.UMAP(n_components=2, random_state=42)
        embedding = self.umap_model.fit_transform(features_scaled)
        
        # Vytvo≈ôen√≠ vizualizace
        df = pd.DataFrame({
            'x': embedding[:, 0],
            'y': embedding[:, 1],
            'sensor_type': labels,
            'value': [f[0] for f in features]  # Prvn√≠ feature je hodnota
        })
        
        return {
            "status": "success",
            "embedding": embedding.tolist(),
            "dataframe": df,
            "clusters_detected": len(set(labels))
        }
    
    def _extract_features(self, sensor_data: SensorData) -> List[float]:
        """Extrahuje features ze sensorov√Ωch dat"""
        features = [
            sensor_data.value,
            sensor_data.timestamp.hour,
            sensor_data.timestamp.weekday(),
            sensor_data.location[0],  # latitude
            sensor_data.location[1],  # longitude
        ]
        
        # P≈ôid√°n√≠ type-specific features
        if sensor_data.sensor_type in ["traffic_flow", "avg_speed"]:
            features.extend([1, 0, 0])  # traffic category
        elif sensor_data.sensor_type in ["power_consumption", "solar_generation"]:
            features.extend([0, 1, 0])  # energy category
        else:
            features.extend([0, 0, 1])  # security/environmental category
            
        return features

# === GraphQL Schema ===
@strawberry.type
class SensorDataType:
    sensor_id: str
    timestamp: str
    sensor_type: str
    location: List[float]
    value: float
    unit: str

@strawberry.type
class AgentActionType:
    action_id: str
    agent_id: str
    action_type: str
    timestamp: str
    expected_outcome: str

@strawberry.type
class CityStatsType:
    total_sensors: int
    active_agents: int
    recent_actions: int
    avg_response_time: float

@strawberry.type
class Query:
    @strawberry.field
    def sensor_data(self, sensor_type: Optional[str] = None) -> List[SensorDataType]:
        # Simulace dotazu na senzorov√° data
        simulator = SensorDataSimulator()
        data = simulator.generate_sensor_data()
        
        if sensor_type:
            data = [s for s in data if s.sensor_type == sensor_type]
        
        return [
            SensorDataType(
                sensor_id=s.sensor_id,
                timestamp=s.timestamp.isoformat(),
                sensor_type=s.sensor_type,
                location=[s.location[0], s.location[1]],
                value=s.value,
                unit=s.unit
            ) for s in data
        ]
    
    @strawberry.field
    def city_stats(self) -> CityStatsType:
        return CityStatsType(
            total_sensors=11,
            active_agents=3,
            recent_actions=random.randint(5, 25),
            avg_response_time=random.uniform(0.5, 2.0)
        )

# === Multi-Agent System Orchestrator ===
class SmartCityOrchestrator:
    def __init__(self):
        self.agents = {}
        self.communication_channel = CommunicationChannel()
        self.sensor_simulator = SensorDataSimulator()
        self.umap_analyzer = UMAPAnalyzer()
        self.sensor_data_history = []
        self.action_history = []
        self.alerts = []
        
        # Inicializace agent≈Ø
        self._initialize_agents()
        
    def _initialize_agents(self):
        """Inicializuje v≈°echny agenty"""
        self.agents["traffic_agent"] = TrafficAgent()
        self.agents["energy_agent"] = EnergyAgent()
        self.agents["security_agent"] = SecurityAgent()
        
        # Registrace agent≈Ø do komunikaƒçn√≠ho kan√°lu
        for agent_id, agent in self.agents.items():
            self.communication_channel.subscribe(agent_id, agent)
    
    async def run_simulation_cycle(self) -> Dict[str, Any]:
        """Spust√≠ jeden cyklus simulace"""
        logger.info("Starting simulation cycle")
        
        # 1. Generov√°n√≠ senzorov√Ωch dat
        sensor_data = self.sensor_simulator.generate_sensor_data()
        self.sensor_data_history.append(sensor_data)
        
        # Udr≈æov√°n√≠ historie (posledn√≠ 100 cykl≈Ø)
        if len(self.sensor_data_history) > 100:
            self.sensor_data_history.pop(0)
        
        # 2. Zpracov√°n√≠ dat agenty
        all_actions = []
        for agent_id, agent in self.agents.items():
            try:
                actions = await agent.process_sensor_data(sensor_data)
                all_actions.extend(actions)
                logger.info(f"Agent {agent_id} generated {len(actions)} actions")
            except Exception as e:
                logger.error(f"Error in agent {agent_id}: {str(e)}")
        
        self.action_history.extend(all_actions)
        
        # 3. Zpracov√°n√≠ komunikace mezi agenty
        await self._process_inter_agent_communication()
        
        # 4. Anal√Ωza dat pomoc√≠ UMAP (ka≈æd√Ωch 10 cykl≈Ø)
        umap_results = None
        if len(self.sensor_data_history) >= 10 and len(self.sensor_data_history) % 10 == 0:
            umap_results = self.umap_analyzer.analyze_sensor_data(
                self.sensor_data_history[-10:]
            )
        
        # 5. Generov√°n√≠ alert≈Ø
        alerts = self._generate_alerts(sensor_data, all_actions)
        self.alerts.extend(alerts)
        
        return {
            "timestamp": datetime.now().isoformat(),
            "sensor_data_count": len(sensor_data),
            "actions_generated": len(all_actions),
            "alerts_generated": len(alerts),
            "umap_analysis": umap_results,
            "active_agents": len(self.agents)
        }
    
    async def _process_inter_agent_communication(self):
        """Zpracuje komunikaci mezi agenty"""
        try:
            await asyncio.wait_for(
                self.communication_channel.process_messages(),
                timeout=0.1
            )
        except asyncio.TimeoutError:
            pass  # ≈Ω√°dn√© zpr√°vy ke zpracov√°n√≠
    
    def _generate_alerts(self, sensor_data: List[SensorData], actions: List[AgentAction]) -> List[CityAlert]:
        """Generuje mƒõstsk√© alerty na z√°kladƒõ dat a akc√≠"""
        alerts = []
        
        # Alert pro kritick√© hodnoty senzor≈Ø
        for data in sensor_data:
            alert_level = self._determine_alert_level(data)
            if alert_level != AlertLevel.LOW:
                alert = CityAlert(
                    alert_id=f"sensor_alert_{data.sensor_id}_{int(data.timestamp.timestamp())}",
                    alert_type=f"{data.sensor_type}_anomaly",
                    level=alert_level,
                    location=data.location,
                    description=f"Abnormal {data.sensor_type} reading: {data.value} {data.unit}",
                    timestamp=datetime.now(),
                    affected_systems=[data.sensor_type]
                )
                alerts.append(alert)
        
        # Alert pro kritick√© akce
        critical_actions = [a for a in actions if "emergency" in a.action_type]
        for action in critical_actions:
            alert = CityAlert(
                alert_id=f"action_alert_{action.action_id}",
                alert_type="emergency_action",
                level=AlertLevel.HIGH,
                location=action.parameters.get("location", (0, 0)),
                description=f"Emergency action triggered: {action.action_type}",
                timestamp=datetime.now(),
                affected_systems=[action.agent_id]
            )
            alerts.append(alert)
        
        return alerts
    
    def _determine_alert_level(self, sensor_data: SensorData) -> AlertLevel:
        """Urƒç√≠ √∫rove≈à alertu na z√°kladƒõ senzorov√Ωch dat"""
        # Simulace logiky pro urƒçen√≠ √∫rovnƒõ alertu
        if sensor_data.sensor_type == "traffic_flow" and sensor_data.value > 180:
            return AlertLevel.HIGH
        elif sensor_data.sensor_type == "power_consumption" and sensor_data.value > 1150:
            return AlertLevel.MEDIUM
        elif sensor_data.sensor_type == "incident_detection" and sensor_data.value == 1:
            return AlertLevel.CRITICAL
        elif sensor_data.sensor_type == "air_quality" and sensor_data.value > 90:
            return AlertLevel.HIGH
        else:
            return AlertLevel.LOW
    
    def get_system_status(self) -> Dict[str, Any]:
        """Vr√°t√≠ aktu√°ln√≠ status cel√©ho syst√©mu"""
        recent_actions = [a for a in self.action_history if 
                         (datetime.now() - a.timestamp).seconds < 3600]  # Posledn√≠ hodina
        
        recent_alerts = [a for a in self.alerts if 
                        (datetime.now() - a.timestamp).seconds < 3600]  # Posledn√≠ hodina
        
        return {
            "system_status": "operational",
            "active_agents": len(self.agents),
            "total_sensors": len(self.sensor_simulator.sensors),
            "recent_actions": len(recent_actions),
            "recent_alerts": len(recent_alerts),
            "data_history_length": len(self.sensor_data_history),
            "uptime": "operational"
        }

# === FastAPI Application ===
def create_app() -> FastAPI:
    app = FastAPI(title="Smart City Infrastructure Management", version="1.0.0")
    
    # GraphQL endpoint
    schema = strawberry.Schema(query=Query)
    graphql_app = GraphQLRouter(schema)
    app.include_router(graphql_app, prefix="/graphql")
    
    # Orchestrator instance
    orchestrator = SmartCityOrchestrator()
    
    @app.get("/")
    async def root():
        return {"message": "Smart City Infrastructure Management System"}
    
    @app.get("/status")
    async def get_status():
        return orchestrator.get_system_status()
    
    @app.post("/simulate")
    async def run_simulation():
        result = await orchestrator.run_simulation_cycle()
        return result
    
    @app.get("/sensors")
    async def get_sensor_data():
        data = orchestrator.sensor_simulator.generate_sensor_data()
        return [asdict(s) for s in data]
    
    @app.get("/alerts")
    async def get_alerts():
        recent_alerts = [a for a in orchestrator.alerts if 
                        (datetime.now() - a.timestamp).seconds < 3600]
        return [asdict(a) for a in recent_alerts]
    
    @app.websocket("/ws")
    async def websocket_endpoint(websocket: WebSocket):
        await websocket.accept()
        try:
            while True:
                # Spust√≠ simulaƒçn√≠ cyklus a po≈°le v√Ωsledky
                result = await orchestrator.run_simulation_cycle()
                await websocket.send_text(json.dumps(result, default=str))
                await asyncio.sleep(5)  # 5 sekund mezi cykly
        except Exception as e:
            logger.error(f"WebSocket error: {str(e)}")
            await websocket.close()
    
    return app

# === Main Execution ===
async def main():
    """Hlavn√≠ funkce pro spu≈°tƒõn√≠ simulace"""
    logger.info("Initializing Smart City Infrastructure Management System")
    
    # Vytvo≈ôen√≠ orchestr√°toru
    orchestrator = SmartCityOrchestrator()
    
    # Spu≈°tƒõn√≠ nƒõkolika simulaƒçn√≠ch cykl≈Ø
    for i in range(5):
        logger.info(f"Running simulation cycle {i+1}")
        result = await orchestrator.run_simulation_cycle()
        
        print(f"\n=== Simulation Cycle {i+1} Results ===")
        print(f"Timestamp: {result['timestamp']}")
        print(f"Sensor data points: {result['sensor_data_count']}")
        print(f"Actions generated: {result['actions_generated']}")
        print(f"Alerts generated: {result['alerts_generated']}")
        print(f"Active agents: {result['active_agents']}")
        
        if result.get('umap_analysis'):
            print(f"UMAP analysis: {result['umap_analysis']['status']}")
        
        # Status syst√©mu
        status = orchestrator.get_system_status()
        print(f"System status: {status['system_status']}")
        print(f"Recent actions: {status['recent_actions']}")
        print(f"Recent alerts: {status['recent_alerts']}")
        
        await asyncio.sleep(2)  # Pauza mezi cykly
    
    logger.info("Simulation completed successfully")

if __name__ == "__main__":
    # Spu≈°tƒõn√≠ simulace
    asyncio.run(main())
    
    # Pro spu≈°tƒõn√≠ FastAPI serveru pou≈æijte:
    # uvicorn smart_city_agents:create_app --host 0.0.0.0 --port 8000 --reload
````

````python
# Smart City Infrastructure Management Dependencies
fastapi==0.104.1
uvicorn[standard]==0.24.0
strawberry-graphql[fastapi]==0.206.0
pydantic==2.5.0
numpy==1.24.3
pandas==2.1.3
scikit-learn==1.3.2
umap-learn==0.5.4
plotly==5.17.0
asyncio==3.4.3
python-multipart==0.0.6
websockets==12.0
aiofiles==23.2.1
python-dotenv==1.0.0
````

````python
import asyncio
import json
from smart_city_agents import SmartCityOrchestrator, create_app
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def run_extended_simulation():
    """Spust√≠ roz≈°√≠≈ôenou simulaci s pokroƒçil√Ωmi anal√Ωzami"""
    orchestrator = SmartCityOrchestrator()
    
    print("üèôÔ∏è  Smart City Infrastructure Management System")
    print("=" * 60)
    
    simulation_results = []
    
    for cycle in range(10):
        print(f"\nüîÑ Simulation Cycle {cycle + 1}/10")
        print("-" * 40)
        
        result = await orchestrator.run_simulation_cycle()
        simulation_results.append(result)
        
        # V√Ωpis detailn√≠ch v√Ωsledk≈Ø
        print(f"‚è∞ Timestamp: {result['timestamp']}")
        print(f"üìä Sensor readings: {result['sensor_data_count']}")
        print(f"ü§ñ Agent actions: {result['actions_generated']}")
        print(f"üö® New alerts: {result['alerts_generated']}")
        
        # UMAP anal√Ωza (kdy≈æ je dostupn√°)
        if result.get('umap_analysis') and result['umap_analysis'].get('status') == 'success':
            umap_result = result['umap_analysis']
            print(f"üß† UMAP Analysis: {umap_result['clusters_detected']} clusters detected")
        
        # Status jednotliv√Ωch agent≈Ø
        print("\nü§ñ Agent Status:")
        for agent_id, agent in orchestrator.agents.items():
            recent_actions = len([a for a in orchestrator.action_history 
                                if a.agent_id == agent_id and 
                                (len(orchestrator.action_history) - orchestrator.action_history.index(a)) <= 10])
            print(f"  - {agent_id}: {recent_actions} recent actions")
        
        # Alerty
        if result['alerts_generated'] > 0:
            print(f"\nüö® Latest Alerts:")
            recent_alerts = orchestrator.alerts[-result['alerts_generated']:]
            for alert in recent_alerts:
                print(f"  - {alert.alert_type}: {alert.level.value} ({alert.location})")
        
        await asyncio.sleep(1)
    
    # Fin√°ln√≠ statistiky
    print("\n" + "=" * 60)
    print("üìà SIMULATION SUMMARY")
    print("=" * 60)
    
    total_actions = sum(r['actions_generated'] for r in simulation_results)
    total_alerts = sum(r['alerts_generated'] for r in simulation_results)
    
    print(f"üî¢ Total cycles: {len(simulation_results)}")
    print(f"‚ö° Total actions: {total_actions}")
    print(f"üö® Total alerts: {total_alerts}")
    print(f"üìä Avg actions per cycle: {total_actions/len(simulation_results):.1f}")
    print(f"üéØ System efficiency: {((total_actions - total_alerts)/total_actions*100):.1f}%")
    
    # Nejaktivnƒõj≈°√≠ agenti
    agent_actions = {}
    for action in orchestrator.action_history:
        agent_actions[action.agent_id] = agent_actions.get(action.agent_id, 0) + 1
    
    print("\nüèÜ Most Active Agents:")
    for agent_id, count in sorted(agent_actions.items(), key=lambda x: x[1], reverse=True):
        print(f"  - {agent_id}: {count} actions")
    
    return simulation_results

if __name__ == "__main__":
    asyncio.run(run_extended_simulation())
````

## Project Summary

Projekt Smart City Infrastructure Management p≈ôedstavuje pokroƒçil√Ω multi-agent syst√©m pro autonomn√≠ spr√°vu mƒõstsk√© infrastruktury. Syst√©m vyu≈æ√≠v√° modern√≠ technologie vƒçetnƒõ FastAPI, GraphQL, UMAP a WebSocket komunikace pro real-time monitoring a optimalizaci.

### Kl√≠ƒçov√© v√Ωhody:
- **Autonomn√≠ rozhodov√°n√≠** - AI agenti nez√°visle ≈ôe≈°√≠ probl√©my ve sv√Ωch dom√©n√°ch
- **Kolaborativn√≠ p≈ô√≠stup** - Agenti komunikuj√≠ a koordinuj√≠ sv√© akce  
- **Prediktivn√≠ anal√Ωzy** - UMAP umo≈æ≈àuje identifikaci vzorc≈Ø a anom√°li√≠
- **≈†k√°lovatelnost** - Modul√°rn√≠ architektura podporuje p≈ôid√°v√°n√≠ nov√Ωch agent≈Ø
- **Real-time monitoring** - WebSocket spojen√≠ pro okam≈æit√© aktualizace

### Technick√© inovace:
- Asynchronn√≠ komunikace mezi agenty
- GraphQL API pro flexibiln√≠ dotazov√°n√≠ dat
- UMAP pro pokroƒçilou anal√Ωzu vysokodimenzion√°ln√≠ch dat
- Modul√°rn√≠ architektura s jasnƒõ oddƒõlen√Ωmi zodpovƒõdnostmi

### Praktick√© vyu≈æit√≠:
Syst√©m je p≈ôipraven pro nasazen√≠ v re√°ln√Ωch smart city projektech s mo≈ænost√≠ integrace s existuj√≠c√≠mi mƒõstsk√Ωmi syst√©my. Poskytuje foundation pro budov√°n√≠ inteligentn√≠ch mƒõst s autonomn√≠ infrastrukturou.