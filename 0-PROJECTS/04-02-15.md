<small>Claude Sonnet 4 **(Personal Life Coach Bot)**</small>
# Personal Life Coach Bot

## Key Concepts Explanation

### Conversational Memory Management
Sophisticated system for maintaining context across conversations, storing personal insights, relationship dynamics, and behavioral patterns to provide consistent, personalized coaching that builds upon previous interactions and maintains understanding of the user's journey.

### Adaptive Goal Framework
Dynamic goal-setting methodology that adjusts objectives based on user progress, life circumstances, and evolving priorities, incorporating SMART criteria while remaining flexible to accommodate personal growth and changing life situations.

### Emotional Intelligence Processing
AI-driven emotional analysis that recognizes mood patterns, stress indicators, and emotional triggers from user communications, enabling empathetic responses and targeted interventions for emotional well-being and personal development.

### Habit Formation Analytics
Data-driven approach to building and maintaining positive habits through behavioral science principles, tracking micro-behaviors, identifying trigger patterns, and providing personalized strategies for sustainable lifestyle changes.

### Reflective Journaling System
Structured digital journaling platform that guides users through self-reflection processes, analyzes patterns in thoughts and behaviors, and provides insights for personal growth and decision-making clarity.

### Personalized Coaching Methodology
Adaptive coaching framework that tailors advice, strategies, and interventions based on individual personality types, learning styles, life circumstances, and personal values to maximize effectiveness and engagement.

## Comprehensive Project Explanation

### Objectives
The Personal Life Coach Bot aims to democratize access to personalized life coaching by providing intelligent, empathetic, and adaptive guidance for personal development, goal achievement, and overall life satisfaction through continuous engagement and personalized insights.

### Key Features
- **Intelligent Conversation Management**: Context-aware dialogue that remembers personal details, preferences, and ongoing challenges
- **Dynamic Goal Setting**: Flexible goal framework with progress tracking and adaptive milestone adjustment
- **Mood and Wellness Monitoring**: Emotional state analysis with personalized interventions and coping strategies
- **Habit Formation Support**: Evidence-based habit building with behavioral triggers and progress analytics
- **Reflective Journaling**: Guided self-reflection with pattern recognition and insight generation
- **Daily Planning Assistance**: Personalized daily schedules aligned with goals and energy levels

### Challenges
- **Privacy and Trust**: Maintaining user confidence while handling sensitive personal information
- **Emotional Sensitivity**: Providing appropriate responses to mental health concerns without overstepping boundaries
- **Personalization Balance**: Offering specific guidance while avoiding assumptions or stereotyping
- **Motivation Sustainability**: Maintaining long-term user engagement and preventing coaching fatigue
- **Context Accuracy**: Ensuring memory systems maintain accurate and relevant personal information
- **Ethical Boundaries**: Distinguishing between life coaching and professional therapy requirements

### Potential Impact
This system can make personalized life coaching accessible to millions, reduce mental health stigma through normalized self-improvement practices, provide early intervention for emotional wellness, and create sustainable behavior change through intelligent habit formation and goal achievement support.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
streamlit==1.29.0
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
sqlite3
chromadb==0.4.18
sentence-transformers==2.2.2
textblob==0.17.1
nltk==3.8.1
spacy==3.7.2
scikit-learn==1.3.2
python-dotenv==1.0.0
pydantic==2.5.0
datetime
schedule==1.2.0
emoji==2.8.0
wordcloud==1.9.2
seaborn==0.12.2
matplotlib==3.8.2
````

### Core Implementation

````python
import os
import json
import sqlite3
import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.prompts import ChatPromptTemplate
from langchain.memory import ConversationBufferWindowMemory
import chromadb
from chromadb.config import Settings
from sentence_transformers import SentenceTransformer
from textblob import TextBlob
import schedule
import emoji
from wordcloud import WordCloud
import matplotlib.pyplot as plt
import seaborn as sns

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class GoalStatus(Enum):
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    PAUSED = "paused"
    CANCELLED = "cancelled"

class GoalCategory(Enum):
    HEALTH = "health"
    CAREER = "career"
    RELATIONSHIPS = "relationships"
    PERSONAL_GROWTH = "personal_growth"
    FINANCE = "finance"
    EDUCATION = "education"
    HOBBIES = "hobbies"

class MoodType(Enum):
    VERY_NEGATIVE = -2
    NEGATIVE = -1
    NEUTRAL = 0
    POSITIVE = 1
    VERY_POSITIVE = 2

class HabitFrequency(Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    CUSTOM = "custom"

@dataclass
class Goal:
    goal_id: str
    title: str
    description: str
    category: GoalCategory
    target_date: datetime
    status: GoalStatus
    progress: float = 0.0
    milestones: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

@dataclass
class Habit:
    habit_id: str
    name: str
    description: str
    frequency: HabitFrequency
    target_count: int
    current_streak: int = 0
    best_streak: int = 0
    completion_dates: List[datetime] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class JournalEntry:
    entry_id: str
    content: str
    mood_score: float
    emotions: List[str]
    insights: List[str]
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class UserProfile:
    user_id: str
    name: str
    personality_type: str
    core_values: List[str]
    life_areas_focus: List[GoalCategory]
    coaching_preferences: Dict[str, Any]
    created_at: datetime = field(default_factory=datetime.now)

class EmotionalAnalyzer:
    """Analyze emotional content and patterns."""
    
    def __init__(self):
        self.emotion_keywords = {
            'happy': ['happy', 'joy', 'excited', 'cheerful', 'delighted', 'pleased'],
            'sad': ['sad', 'depressed', 'down', 'unhappy', 'melancholy', 'blue'],
            'angry': ['angry', 'mad', 'furious', 'irritated', 'annoyed', 'frustrated'],
            'anxious': ['anxious', 'worried', 'nervous', 'stressed', 'tense', 'concerned'],
            'calm': ['calm', 'peaceful', 'relaxed', 'serene', 'tranquil', 'composed'],
            'motivated': ['motivated', 'inspired', 'determined', 'driven', 'energized'],
            'grateful': ['grateful', 'thankful', 'appreciative', 'blessed', 'lucky']
        }
    
    def analyze_mood(self, text: str) -> Dict[str, Any]:
        """Analyze mood and emotions from text."""
        try:
            # Sentiment analysis
            blob = TextBlob(text)
            sentiment_score = blob.sentiment.polarity
            
            # Emotion detection
            emotions_detected = []
            text_lower = text.lower()
            
            for emotion, keywords in self.emotion_keywords.items():
                if any(keyword in text_lower for keyword in keywords):
                    emotions_detected.append(emotion)
            
            # Mood classification
            if sentiment_score > 0.5:
                mood_type = MoodType.VERY_POSITIVE
            elif sentiment_score > 0.1:
                mood_type = MoodType.POSITIVE
            elif sentiment_score > -0.1:
                mood_type = MoodType.NEUTRAL
            elif sentiment_score > -0.5:
                mood_type = MoodType.NEGATIVE
            else:
                mood_type = MoodType.VERY_NEGATIVE
            
            return {
                'sentiment_score': sentiment_score,
                'mood_type': mood_type,
                'emotions': emotions_detected,
                'confidence': abs(sentiment_score)
            }
            
        except Exception as e:
            logger.error(f"Mood analysis error: {e}")
            return {
                'sentiment_score': 0.0,
                'mood_type': MoodType.NEUTRAL,
                'emotions': [],
                'confidence': 0.0
            }
    
    def get_mood_insights(self, mood_history: List[Tuple[datetime, float]]) -> Dict[str, Any]:
        """Analyze mood patterns over time."""
        if len(mood_history) < 7:
            return {'insufficient_data': True}
        
        # Convert to DataFrame for analysis
        df = pd.DataFrame(mood_history, columns=['date', 'mood_score'])
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')
        
        # Calculate metrics
        current_avg = df['mood_score'].tail(7).mean()
        overall_avg = df['mood_score'].mean()
        trend = self._calculate_trend(df['mood_score'].values)
        volatility = df['mood_score'].std()
        
        # Identify patterns
        patterns = self._identify_mood_patterns(df)
        
        return {
            'current_weekly_avg': current_avg,
            'overall_avg': overall_avg,
            'trend': trend,
            'volatility': volatility,
            'patterns': patterns,
            'total_entries': len(df)
        }
    
    def _calculate_trend(self, values: np.ndarray) -> str:
        """Calculate mood trend."""
        if len(values) < 2:
            return "stable"
        
        # Simple linear regression
        x = np.arange(len(values))
        slope = np.polyfit(x, values, 1)[0]
        
        if slope > 0.01:
            return "improving"
        elif slope < -0.01:
            return "declining"
        else:
            return "stable"
    
    def _identify_mood_patterns(self, df: pd.DataFrame) -> List[str]:
        """Identify mood patterns."""
        patterns = []
        
        # Day of week patterns
        df['day_of_week'] = df['date'].dt.day_name()
        daily_avg = df.groupby('day_of_week')['mood_score'].mean()
        
        worst_day = daily_avg.idxmin()
        best_day = daily_avg.idxmax()
        
        if daily_avg[worst_day] < -0.2:
            patterns.append(f"Mood tends to be lower on {worst_day}s")
        
        if daily_avg[best_day] > 0.2:
            patterns.append(f"Mood tends to be higher on {best_day}s")
        
        return patterns

class MemoryManager:
    """Manage conversation memory and user context."""
    
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.db_path = f"memory_{user_id}.db"
        self.embeddings = OpenAIEmbeddings()
        self.init_database()
        
        # Initialize vector database for semantic memory
        self.chroma_client = chromadb.Client(Settings(anonymized_telemetry=False))
        try:
            self.collection = self.chroma_client.get_collection(f"memory_{user_id}")
        except:
            self.collection = self.chroma_client.create_collection(f"memory_{user_id}")
    
    def init_database(self):
        """Initialize SQLite database for structured memory."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create tables
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS conversations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            user_message TEXT,
            bot_response TEXT,
            mood_score REAL,
            topics TEXT
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_facts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            fact_type TEXT,
            fact_value TEXT,
            confidence REAL,
            source TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS goals (
            goal_id TEXT PRIMARY KEY,
            title TEXT,
            description TEXT,
            category TEXT,
            target_date DATETIME,
            status TEXT,
            progress REAL,
            created_at DATETIME,
            updated_at DATETIME
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS habits (
            habit_id TEXT PRIMARY KEY,
            name TEXT,
            description TEXT,
            frequency TEXT,
            target_count INTEGER,
            current_streak INTEGER,
            best_streak INTEGER,
            created_at DATETIME
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS journal_entries (
            entry_id TEXT PRIMARY KEY,
            content TEXT,
            mood_score REAL,
            emotions TEXT,
            insights TEXT,
            created_at DATETIME
        )
        ''')
        
        conn.commit()
        conn.close()
    
    def save_conversation(self, user_message: str, bot_response: str, 
                         mood_score: float = 0.0, topics: List[str] = None):
        """Save conversation to memory."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        topics_str = json.dumps(topics) if topics else ""
        
        cursor.execute('''
        INSERT INTO conversations (user_message, bot_response, mood_score, topics)
        VALUES (?, ?, ?, ?)
        ''', (user_message, bot_response, mood_score, topics_str))
        
        # Add to vector database for semantic search
        try:
            conversation_text = f"User: {user_message}\nBot: {bot_response}"
            self.collection.add(
                documents=[conversation_text],
                metadatas=[{"timestamp": datetime.now().isoformat(), "mood": mood_score}],
                ids=[f"conv_{datetime.now().timestamp()}"]
            )
        except Exception as e:
            logger.error(f"Vector storage error: {e}")
        
        conn.commit()
        conn.close()
    
    def save_user_fact(self, fact_type: str, fact_value: str, 
                      confidence: float = 1.0, source: str = "conversation"):
        """Save user fact to memory."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT OR REPLACE INTO user_facts (fact_type, fact_value, confidence, source)
        VALUES (?, ?, ?, ?)
        ''', (fact_type, fact_value, confidence, source))
        
        conn.commit()
        conn.close()
    
    def get_relevant_context(self, query: str, limit: int = 5) -> List[Dict[str, Any]]:
        """Retrieve relevant context for current conversation."""
        try:
            # Semantic search
            results = self.collection.query(
                query_texts=[query],
                n_results=limit
            )
            
            context = []
            if results['documents'] and results['documents'][0]:
                for doc, metadata in zip(results['documents'][0], results['metadatas'][0]):
                    context.append({
                        'content': doc,
                        'metadata': metadata
                    })
            
            return context
            
        except Exception as e:
            logger.error(f"Context retrieval error: {e}")
            return []
    
    def get_user_facts(self, fact_type: str = None) -> List[Dict[str, Any]]:
        """Retrieve user facts."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if fact_type:
            cursor.execute('SELECT * FROM user_facts WHERE fact_type = ?', (fact_type,))
        else:
            cursor.execute('SELECT * FROM user_facts ORDER BY timestamp DESC LIMIT 20')
        
        facts = []
        for row in cursor.fetchall():
            facts.append({
                'id': row[0],
                'fact_type': row[1],
                'fact_value': row[2],
                'confidence': row[3],
                'source': row[4],
                'timestamp': row[5]
            })
        
        conn.close()
        return facts

class GoalManager:
    """Manage user goals and progress tracking."""
    
    def __init__(self, memory_manager: MemoryManager):
        self.memory = memory_manager
    
    def create_goal(self, title: str, description: str, category: GoalCategory,
                   target_date: datetime, milestones: List[str] = None) -> Goal:
        """Create a new goal."""
        goal_id = f"goal_{datetime.now().timestamp()}"
        
        goal = Goal(
            goal_id=goal_id,
            title=title,
            description=description,
            category=category,
            target_date=target_date,
            status=GoalStatus.NOT_STARTED,
            milestones=milestones or []
        )
        
        self._save_goal(goal)
        return goal
    
    def update_goal_progress(self, goal_id: str, progress: float, 
                           status: GoalStatus = None) -> bool:
        """Update goal progress."""
        try:
            conn = sqlite3.connect(self.memory.db_path)
            cursor = conn.cursor()
            
            if status:
                cursor.execute('''
                UPDATE goals SET progress = ?, status = ?, updated_at = ?
                WHERE goal_id = ?
                ''', (progress, status.value, datetime.now(), goal_id))
            else:
                cursor.execute('''
                UPDATE goals SET progress = ?, updated_at = ?
                WHERE goal_id = ?
                ''', (progress, datetime.now(), goal_id))
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            logger.error(f"Goal update error: {e}")
            return False
    
    def get_goals(self, status: GoalStatus = None) -> List[Goal]:
        """Retrieve goals."""
        conn = sqlite3.connect(self.memory.db_path)
        cursor = conn.cursor()
        
        if status:
            cursor.execute('SELECT * FROM goals WHERE status = ?', (status.value,))
        else:
            cursor.execute('SELECT * FROM goals ORDER BY created_at DESC')
        
        goals = []
        for row in cursor.fetchall():
            goals.append(Goal(
                goal_id=row[0],
                title=row[1],
                description=row[2],
                category=GoalCategory(row[3]),
                target_date=datetime.fromisoformat(row[4]),
                status=GoalStatus(row[5]),
                progress=row[6],
                created_at=datetime.fromisoformat(row[7]),
                updated_at=datetime.fromisoformat(row[8])
            ))
        
        conn.close()
        return goals
    
    def _save_goal(self, goal: Goal):
        """Save goal to database."""
        conn = sqlite3.connect(self.memory.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT OR REPLACE INTO goals 
        (goal_id, title, description, category, target_date, status, progress, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            goal.goal_id, goal.title, goal.description, goal.category.value,
            goal.target_date.isoformat(), goal.status.value, goal.progress,
            goal.created_at.isoformat(), goal.updated_at.isoformat()
        ))
        
        conn.commit()
        conn.close()
    
    def get_goal_analytics(self) -> Dict[str, Any]:
        """Get goal analytics and insights."""
        goals = self.get_goals()
        
        if not goals:
            return {'no_goals': True}
        
        # Calculate metrics
        total_goals = len(goals)
        completed_goals = len([g for g in goals if g.status == GoalStatus.COMPLETED])
        in_progress_goals = len([g for g in goals if g.status == GoalStatus.IN_PROGRESS])
        
        # Category distribution
        category_counts = {}
        for goal in goals:
            category_counts[goal.category.value] = category_counts.get(goal.category.value, 0) + 1
        
        # Average progress
        active_goals = [g for g in goals if g.status in [GoalStatus.IN_PROGRESS, GoalStatus.NOT_STARTED]]
        avg_progress = np.mean([g.progress for g in active_goals]) if active_goals else 0
        
        return {
            'total_goals': total_goals,
            'completed_goals': completed_goals,
            'in_progress_goals': in_progress_goals,
            'completion_rate': completed_goals / total_goals if total_goals > 0 else 0,
            'category_distribution': category_counts,
            'average_progress': avg_progress,
            'goals_data': goals
        }

class HabitTracker:
    """Track and manage user habits."""
    
    def __init__(self, memory_manager: MemoryManager):
        self.memory = memory_manager
    
    def create_habit(self, name: str, description: str, 
                    frequency: HabitFrequency, target_count: int = 1) -> Habit:
        """Create a new habit."""
        habit_id = f"habit_{datetime.now().timestamp()}"
        
        habit = Habit(
            habit_id=habit_id,
            name=name,
            description=description,
            frequency=frequency,
            target_count=target_count
        )
        
        self._save_habit(habit)
        return habit
    
    def log_habit_completion(self, habit_id: str, completion_date: datetime = None) -> bool:
        """Log habit completion."""
        if not completion_date:
            completion_date = datetime.now()
        
        try:
            # Update habit completion in database
            conn = sqlite3.connect(self.memory.db_path)
            cursor = conn.cursor()
            
            # Get current habit data
            cursor.execute('SELECT * FROM habits WHERE habit_id = ?', (habit_id,))
            habit_data = cursor.fetchone()
            
            if not habit_data:
                return False
            
            # Update streak logic would go here
            # For simplicity, we'll increment current_streak
            new_streak = habit_data[5] + 1  # current_streak + 1
            best_streak = max(new_streak, habit_data[6])  # best_streak
            
            cursor.execute('''
            UPDATE habits SET current_streak = ?, best_streak = ?
            WHERE habit_id = ?
            ''', (new_streak, best_streak, habit_id))
            
            # Store completion record
            cursor.execute('''
            INSERT INTO habit_completions (habit_id, completion_date)
            VALUES (?, ?)
            ''', (habit_id, completion_date.isoformat()))
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            logger.error(f"Habit completion error: {e}")
            return False
    
    def get_habits(self) -> List[Habit]:
        """Retrieve all habits."""
        conn = sqlite3.connect(self.memory.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM habits ORDER BY created_at DESC')
        
        habits = []
        for row in cursor.fetchall():
            habits.append(Habit(
                habit_id=row[0],
                name=row[1],
                description=row[2],
                frequency=HabitFrequency(row[3]),
                target_count=row[4],
                current_streak=row[5],
                best_streak=row[6],
                created_at=datetime.fromisoformat(row[7])
            ))
        
        conn.close()
        return habits
    
    def _save_habit(self, habit: Habit):
        """Save habit to database."""
        conn = sqlite3.connect(self.memory.db_path)
        cursor = conn.cursor()
        
        # Create habit_completions table if not exists
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS habit_completions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            habit_id TEXT,
            completion_date DATETIME,
            FOREIGN KEY (habit_id) REFERENCES habits (habit_id)
        )
        ''')
        
        cursor.execute('''
        INSERT OR REPLACE INTO habits 
        (habit_id, name, description, frequency, target_count, current_streak, best_streak, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            habit.habit_id, habit.name, habit.description, habit.frequency.value,
            habit.target_count, habit.current_streak, habit.best_streak,
            habit.created_at.isoformat()
        ))
        
        conn.commit()
        conn.close()

class LifeCoachBot:
    """Main life coach bot with conversation and guidance capabilities."""
    
    def __init__(self, openai_api_key: str, user_id: str):
        self.llm = ChatOpenAI(
            temperature=0.7,
            model_name="gpt-4",
            openai_api_key=openai_api_key
        )
        
        self.user_id = user_id
        self.memory = MemoryManager(user_id)
        self.goal_manager = GoalManager(self.memory)
        self.habit_tracker = HabitTracker(self.memory)
        self.emotion_analyzer = EmotionalAnalyzer()
        
        # Coaching prompts
        self.coaching_prompt = ChatPromptTemplate.from_template("""
        You are a professional life coach having a conversation with your client.
        
        Context about the client:
        {user_context}
        
        Recent conversation context:
        {conversation_context}
        
        Current client message: {user_message}
        
        Respond as a supportive, insightful life coach. Provide:
        1. Empathetic understanding of their situation
        2. Thoughtful questions to promote self-reflection
        3. Actionable advice when appropriate
        4. Encouragement and motivation
        5. Reference to their goals and progress when relevant
        
        Keep your response conversational, supportive, and focused on their growth.
        """)
        
        self.goal_setting_prompt = ChatPromptTemplate.from_template("""
        Help the client set a SMART goal based on their request: {goal_request}
        
        Client context: {user_context}
        
        Guide them to create a goal that is:
        - Specific: Clear and well-defined
        - Measurable: Has concrete criteria for progress
        - Achievable: Realistic given their circumstances
        - Relevant: Aligned with their values and priorities
        - Time-bound: Has a clear deadline
        
        Ask clarifying questions if needed and suggest a structured goal.
        """)
    
    def process_message(self, message: str) -> Dict[str, Any]:
        """Process user message and generate response."""
        try:
            # Analyze emotion
            emotion_analysis = self.emotion_analyzer.analyze_mood(message)
            
            # Get relevant context
            context = self.memory.get_relevant_context(message)
            user_facts = self.memory.get_user_facts()
            
            # Prepare context strings
            user_context = self._format_user_context(user_facts)
            conversation_context = self._format_conversation_context(context)
            
            # Generate response based on message intent
            intent = self._classify_intent(message)
            
            if intent == "goal_setting":
                response = self._handle_goal_setting(message, user_context)
            elif intent == "progress_check":
                response = self._handle_progress_check(message)
            elif intent == "emotional_support":
                response = self._handle_emotional_support(message, user_context, conversation_context)
            else:
                response = self._handle_general_coaching(message, user_context, conversation_context)
            
            # Save conversation
            self.memory.save_conversation(
                message, 
                response['content'], 
                emotion_analysis['sentiment_score']
            )
            
            return {
                'response': response['content'],
                'emotion_analysis': emotion_analysis,
                'intent': intent,
                'suggestions': response.get('suggestions', [])
            }
            
        except Exception as e:
            logger.error(f"Message processing error: {e}")
            return {
                'response': "I apologize, but I'm having trouble processing your message right now. Could you please try again?",
                'error': str(e)
            }
    
    def _classify_intent(self, message: str) -> str:
        """Classify user message intent."""
        message_lower = message.lower()
        
        goal_keywords = ['goal', 'want to', 'plan to', 'achieve', 'accomplish']
        progress_keywords = ['progress', 'how am i doing', 'check', 'status', 'update']
        emotional_keywords = ['feel', 'emotion', 'mood', 'sad', 'happy', 'stressed', 'worried']
        
        if any(keyword in message_lower for keyword in goal_keywords):
            return "goal_setting"
        elif any(keyword in message_lower for keyword in progress_keywords):
            return "progress_check"
        elif any(keyword in message_lower for keyword in emotional_keywords):
            return "emotional_support"
        else:
            return "general_coaching"
    
    def _handle_goal_setting(self, message: str, user_context: str) -> Dict[str, Any]:
        """Handle goal setting conversations."""
        response = self.llm.invoke(self.goal_setting_prompt.format(
            goal_request=message,
            user_context=user_context
        ))
        
        return {
            'content': response.content,
            'suggestions': ['Create a specific goal', 'Set milestones', 'Choose target date']
        }
    
    def _handle_progress_check(self, message: str) -> Dict[str, Any]:
        """Handle progress checking requests."""
        # Get goal analytics
        goal_analytics = self.goal_manager.get_goal_analytics()
        habits = self.habit_tracker.get_habits()
        
        progress_summary = self._generate_progress_summary(goal_analytics, habits)
        
        response = f"""
        Here's your current progress summary:
        
        {progress_summary}
        
        What specific area would you like to discuss or work on?
        """
        
        return {
            'content': response,
            'suggestions': ['Review goals', 'Update progress', 'Plan next steps']
        }
    
    def _handle_emotional_support(self, message: str, user_context: str, 
                                conversation_context: str) -> Dict[str, Any]:
        """Handle emotional support requests."""
        # Enhanced prompt for emotional support
        emotional_prompt = f"""
        The client is sharing something emotional. Here's what they said: {message}
        
        Context: {user_context}
        Recent conversation: {conversation_context}
        
        Respond with empathy, validation, and appropriate support. If they seem distressed,
        gently ask if they need professional help. Focus on active listening and emotional validation.
        """
        
        response = self.llm.invoke(emotional_prompt)
        
        return {
            'content': response.content,
            'suggestions': ['Journal about feelings', 'Practice self-care', 'Talk to someone']
        }
    
    def _handle_general_coaching(self, message: str, user_context: str, 
                               conversation_context: str) -> Dict[str, Any]:
        """Handle general coaching conversations."""
        response = self.llm.invoke(self.coaching_prompt.format(
            user_message=message,
            user_context=user_context,
            conversation_context=conversation_context
        ))
        
        return {
            'content': response.content,
            'suggestions': ['Reflect on values', 'Set new goals', 'Track habits']
        }
    
    def _format_user_context(self, user_facts: List[Dict[str, Any]]) -> str:
        """Format user facts into context string."""
        if not user_facts:
            return "No previous context available."
        
        context_parts = []
        for fact in user_facts[:10]:  # Limit to recent facts
            context_parts.append(f"{fact['fact_type']}: {fact['fact_value']}")
        
        return "\n".join(context_parts)
    
    def _format_conversation_context(self, context: List[Dict[str, Any]]) -> str:
        """Format conversation context."""
        if not context:
            return "No recent conversation context."
        
        context_parts = []
        for item in context[:3]:  # Limit to recent context
            context_parts.append(item['content'][:200] + "...")
        
        return "\n---\n".join(context_parts)
    
    def _generate_progress_summary(self, goal_analytics: Dict[str, Any], 
                                 habits: List[Habit]) -> str:
        """Generate progress summary."""
        if goal_analytics.get('no_goals'):
            goals_summary = "No goals set yet."
        else:
            goals_summary = f"""
            Goals: {goal_analytics['completed_goals']}/{goal_analytics['total_goals']} completed
            Completion rate: {goal_analytics['completion_rate']:.1%}
            Average progress: {goal_analytics['average_progress']:.1%}
            """
        
        habits_summary = f"Active habits: {len(habits)}"
        if habits:
            avg_streak = np.mean([h.current_streak for h in habits])
            habits_summary += f"\nAverage streak: {avg_streak:.1f} days"
        
        return f"{goals_summary}\n{habits_summary}"

def create_sample_data(user_id: str) -> Dict[str, Any]:
    """Create sample data for demonstration."""
    return {
        'goals': [
            {
                'title': 'Learn Python Programming',
                'description': 'Complete online Python course and build a project',
                'category': 'education',
                'target_date': (datetime.now() + timedelta(days=90)).isoformat(),
                'progress': 25.0
            },
            {
                'title': 'Run 5K Race',
                'description': 'Train for and complete a 5K running race',
                'category': 'health',
                'target_date': (datetime.now() + timedelta(days=60)).isoformat(),
                'progress': 45.0
            }
        ],
        'habits': [
            {
                'name': 'Daily Reading',
                'description': 'Read for 30 minutes each day',
                'frequency': 'daily',
                'current_streak': 7
            },
            {
                'name': 'Exercise',
                'description': 'Work out 3 times per week',
                'frequency': 'weekly',
                'current_streak': 3
            }
        ]
    }

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Personal Life Coach Bot",
        page_icon="ðŸŽ¯",
        layout="wide"
    )
    
    st.title("ðŸŽ¯ Personal Life Coach Bot")
    st.markdown("Your AI-powered personal development companion")
    
    # Sidebar
    with st.sidebar:
        st.header("âš™ï¸ Configuration")
        openai_api_key = st.text_input("OpenAI API Key", type="password")
        user_id = st.text_input("User ID", value="user_demo")
        
        st.header("ðŸ”§ Quick Actions")
        if st.button("ðŸ“Š Load Sample Data"):
            st.session_state['sample_data'] = create_sample_data(user_id)
            st.success("Sample data loaded!")
        
        if st.button("ðŸ—‘ï¸ Clear Memory"):
            if f"coach_{user_id}" in st.session_state:
                del st.session_state[f"coach_{user_id}"]
            st.success("Memory cleared!")
    
    if not openai_api_key:
        st.warning("Please enter your OpenAI API key in the sidebar to continue.")
        return
    
    # Initialize coach
    if f"coach_{user_id}" not in st.session_state:
        try:
            st.session_state[f"coach_{user_id}"] = LifeCoachBot(openai_api_key, user_id)
        except Exception as e:
            st.error(f"Error initializing coach: {e}")
            return
    
    coach = st.session_state[f"coach_{user_id}"]
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "ðŸ’¬ Chat with Coach",
        "ðŸŽ¯ Goals & Progress",
        "ðŸƒ Habit Tracking",
        "ðŸ“ Journal & Insights",
        "ðŸ“Š Analytics Dashboard"
    ])
    
    with tab1:
        st.header("ðŸ’¬ Chat with Your Life Coach")
        
        # Chat interface
        if "messages" not in st.session_state:
            st.session_state.messages = [
                {"role": "assistant", "content": "Hello! I'm your personal life coach. I'm here to help you achieve your goals, develop positive habits, and navigate life's challenges. What would you like to talk about today?"}
            ]
        
        # Display chat messages
        for message in st.session_state.messages:
            with st.chat_message(message["role"]):
                st.markdown(message["content"])
        
        # Chat input
        if user_input := st.chat_input("Share what's on your mind..."):
            # Add user message to chat
            st.session_state.messages.append({"role": "user", "content": user_input})
            
            # Display user message
            with st.chat_message("user"):
                st.markdown(user_input)
            
            # Process message and get response
            with st.chat_message("assistant"):
                with st.spinner("Thinking..."):
                    try:
                        response_data = coach.process_message(user_input)
                        response = response_data['response']
                        
                        st.markdown(response)
                        
                        # Show emotion analysis
                        if 'emotion_analysis' in response_data:
                            emotion = response_data['emotion_analysis']
                            if emotion['emotions']:
                                st.caption(f"Detected emotions: {', '.join(emotion['emotions'])}")
                        
                        # Show suggestions
                        if 'suggestions' in response_data and response_data['suggestions']:
                            st.caption("ðŸ’¡ Suggestions:")
                            for suggestion in response_data['suggestions']:
                                st.caption(f"â€¢ {suggestion}")
                        
                        # Add assistant response to chat
                        st.session_state.messages.append({"role": "assistant", "content": response})
                        
                    except Exception as e:
                        error_msg = f"I apologize, but I encountered an error: {str(e)}"
                        st.error(error_msg)
                        st.session_state.messages.append({"role": "assistant", "content": error_msg})
        
        # Quick prompts
        st.subheader("ðŸ’­ Quick Conversation Starters")
        
        quick_prompts = [
            "I want to set a new goal",
            "I'm feeling stressed about work",
            "How can I build better habits?",
            "I need motivation to exercise",
            "I want to improve my work-life balance"
        ]
        
        cols = st.columns(len(quick_prompts))
        for i, prompt in enumerate(quick_prompts):
            with cols[i]:
                if st.button(prompt, key=f"prompt_{i}"):
                    # Trigger chat with this prompt
                    st.session_state.messages.append({"role": "user", "content": prompt})
                    st.rerun()
    
    with tab2:
        st.header("ðŸŽ¯ Goals & Progress Management")
        
        # Goal creation
        st.subheader("ðŸ“ Create New Goal")
        
        with st.form("create_goal"):
            col1, col2 = st.columns(2)
            
            with col1:
                goal_title = st.text_input("Goal Title")
                goal_category = st.selectbox("Category", [cat.value.title() for cat in GoalCategory])
            
            with col2:
                target_date = st.date_input("Target Date", value=datetime.now() + timedelta(days=30))
                goal_description = st.text_area("Description")
            
            if st.form_submit_button("ðŸŽ¯ Create Goal"):
                if goal_title and goal_description:
                    try:
                        category_enum = GoalCategory(goal_category.lower())
                        target_datetime = datetime.combine(target_date, datetime.min.time())
                        
                        goal = coach.goal_manager.create_goal(
                            goal_title, goal_description, category_enum, target_datetime
                        )
                        
                        st.success(f"Goal '{goal_title}' created successfully!")
                        
                    except Exception as e:
                        st.error(f"Error creating goal: {e}")
        
        # Display existing goals
        st.subheader("ðŸ“‹ Your Goals")
        
        try:
            goals = coach.goal_manager.get_goals()
            
            if goals:
                for goal in goals:
                    with st.expander(f"{goal.title} ({goal.status.value.title()})"):
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            st.write(f"**Category:** {goal.category.value.title()}")
                            st.write(f"**Target Date:** {goal.target_date.strftime('%Y-%m-%d')}")
                        
                        with col2:
                            st.write(f"**Progress:** {goal.progress:.1f}%")
                            progress_bar = st.progress(goal.progress / 100)
                        
                        with col3:
                            new_progress = st.slider(
                                f"Update Progress", 
                                0, 100, int(goal.progress),
                                key=f"progress_{goal.goal_id}"
                            )
                            
                            if st.button(f"Update", key=f"update_{goal.goal_id}"):
                                if coach.goal_manager.update_goal_progress(goal.goal_id, new_progress):
                                    st.success("Progress updated!")
                                    st.rerun()
                        
                        st.write(f"**Description:** {goal.description}")
            else:
                st.info("No goals set yet. Create your first goal above!")
                
        except Exception as e:
            st.error(f"Error loading goals: {e}")
        
        # Goal analytics
        st.subheader("ðŸ“Š Goal Analytics")
        
        try:
            analytics = coach.goal_manager.get_goal_analytics()
            
            if not analytics.get('no_goals'):
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Total Goals", analytics['total_goals'])
                with col2:
                    st.metric("Completed", analytics['completed_goals'])
                with col3:
                    st.metric("Completion Rate", f"{analytics['completion_rate']:.1%}")
                with col4:
                    st.metric("Avg Progress", f"{analytics['average_progress']:.1f}%")
                
                # Category distribution
                if analytics['category_distribution']:
                    fig = px.pie(
                        values=list(analytics['category_distribution'].values()),
                        names=list(analytics['category_distribution'].keys()),
                        title="Goals by Category"
                    )
                    st.plotly_chart(fig, use_container_width=True)
                    
        except Exception as e:
            st.error(f"Error loading analytics: {e}")
    
    with tab3:
        st.header("ðŸƒ Habit Tracking")
        
        # Habit creation
        st.subheader("âž• Create New Habit")
        
        with st.form("create_habit"):
            col1, col2 = st.columns(2)
            
            with col1:
                habit_name = st.text_input("Habit Name")
                habit_frequency = st.selectbox("Frequency", [freq.value.title() for freq in HabitFrequency])
            
            with col2:
                habit_description = st.text_area("Description")
                target_count = st.number_input("Target Count", min_value=1, value=1)
            
            if st.form_submit_button("ðŸŽ¯ Create Habit"):
                if habit_name:
                    try:
                        frequency_enum = HabitFrequency(habit_frequency.lower())
                        
                        habit = coach.habit_tracker.create_habit(
                            habit_name, habit_description, frequency_enum, target_count
                        )
                        
                        st.success(f"Habit '{habit_name}' created successfully!")
                        
                    except Exception as e:
                        st.error(f"Error creating habit: {e}")
        
        # Display existing habits
        st.subheader("ðŸ“ˆ Your Habits")
        
        try:
            habits = coach.habit_tracker.get_habits()
            
            if habits:
                for habit in habits:
                    with st.expander(f"{habit.name} (Streak: {habit.current_streak})"):
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            st.write(f"**Frequency:** {habit.frequency.value.title()}")
                            st.write(f"**Target:** {habit.target_count}")
                        
                        with col2:
                            st.write(f"**Current Streak:** {habit.current_streak}")
                            st.write(f"**Best Streak:** {habit.best_streak}")
                        
                        with col3:
                            if st.button(f"âœ… Mark Complete", key=f"complete_{habit.habit_id}"):
                                if coach.habit_tracker.log_habit_completion(habit.habit_id):
                                    st.success("Habit logged!")
                                    st.rerun()
                        
                        st.write(f"**Description:** {habit.description}")
            else:
                st.info("No habits tracked yet. Create your first habit above!")
                
        except Exception as e:
            st.error(f"Error loading habits: {e}")
    
    with tab4:
        st.header("ðŸ“ Journal & Personal Insights")
        
        # Journal entry
        st.subheader("âœï¸ New Journal Entry")
        
        journal_content = st.text_area(
            "How are you feeling today? What's on your mind?",
            height=150,
            placeholder="Share your thoughts, feelings, and reflections..."
        )
        
        if st.button("ðŸ’¾ Save Entry"):
            if journal_content:
                try:
                    # Analyze emotions
                    emotion_analysis = coach.emotion_analyzer.analyze_mood(journal_content)
                    
                    # Create journal entry
                    entry = JournalEntry(
                        entry_id=f"entry_{datetime.now().timestamp()}",
                        content=journal_content,
                        mood_score=emotion_analysis['sentiment_score'],
                        emotions=emotion_analysis['emotions'],
                        insights=[]  # Would be generated by LLM
                    )
                    
                    # Save to memory (simplified)
                    coach.memory.save_conversation(
                        f"Journal: {journal_content}",
                        "Journal entry recorded",
                        emotion_analysis['sentiment_score']
                    )
                    
                    st.success("Journal entry saved!")
                    
                    # Show emotion analysis
                    st.subheader("ðŸ§  Emotion Analysis")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.metric("Mood Score", f"{emotion_analysis['sentiment_score']:.2f}")
                        
                        if emotion_analysis['sentiment_score'] > 0.1:
                            st.success("Positive mood detected ðŸ˜Š")
                        elif emotion_analysis['sentiment_score'] < -0.1:
                            st.warning("Negative mood detected ðŸ˜”")
                        else:
                            st.info("Neutral mood detected ðŸ˜")
                    
                    with col2:
                        if emotion_analysis['emotions']:
                            st.write("**Detected Emotions:**")
                            for emotion in emotion_analysis['emotions']:
                                st.write(f"â€¢ {emotion.title()}")
                        else:
                            st.write("No specific emotions detected")
                    
                except Exception as e:
                    st.error(f"Error saving entry: {e}")
        
        # Mood insights
        st.subheader("ðŸ“Š Mood Insights")
        
        # Mock mood data for visualization
        dates = pd.date_range(start='2024-01-01', end='2024-01-30', freq='D')
        mood_scores = np.random.normal(0.2, 0.5, len(dates)).clip(-1, 1)
        
        mood_df = pd.DataFrame({
            'Date': dates,
            'Mood Score': mood_scores,
            'Mood': ['Positive' if score > 0.1 else 'Negative' if score < -0.1 else 'Neutral' for score in mood_scores]
        })
        
        # Mood trend chart
        fig = px.line(mood_df, x='Date', y='Mood Score', 
                     title='Mood Trends Over Time',
                     color_discrete_sequence=['#1f77b4'])
        fig.add_hline(y=0, line_dash="dash", line_color="gray")
        st.plotly_chart(fig, use_container_width=True)
        
        # Mood distribution
        col1, col2 = st.columns(2)
        
        with col1:
            mood_counts = mood_df['Mood'].value_counts()
            fig = px.pie(values=mood_counts.values, names=mood_counts.index,
                        title="Mood Distribution")
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            avg_mood = mood_df['Mood Score'].mean()
            st.metric("Average Mood", f"{avg_mood:.2f}")
            
            recent_trend = mood_df['Mood Score'].tail(7).mean() - mood_df['Mood Score'].head(7).mean()
            if recent_trend > 0.1:
                st.success("ðŸ“ˆ Mood trending upward!")
            elif recent_trend < -0.1:
                st.warning("ðŸ“‰ Mood trending downward")
            else:
                st.info("ðŸ“Š Mood stable")
    
    with tab5:
        st.header("ðŸ“Š Analytics Dashboard")
        
        # Overall metrics
        st.subheader("ðŸŽ¯ Personal Development Overview")
        
        # Mock data for demonstration
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Days Active", "24", "â†—ï¸ +2")
        with col2:
            st.metric("Goals Completed", "3", "â†—ï¸ +1")
        with col3:
            st.metric("Habit Streak", "7", "â†’ 0")
        with col4:
            st.metric("Avg Mood", "+0.3", "â†—ï¸ +0.1")
        
        # Progress visualization
        st.subheader("ðŸ“ˆ Progress Over Time")
        
        # Create sample progress data
        progress_dates = pd.date_range(start='2024-01-01', periods=30, freq='D')
        goal_progress = np.cumsum(np.random.normal(2, 1, 30)).clip(0, 100)
        habit_completion = np.random.binomial(1, 0.7, 30) * 100
        
        progress_df = pd.DataFrame({
            'Date': progress_dates,
            'Goal Progress': goal_progress,
            'Habit Completion': habit_completion
        })
        
        fig = px.line(progress_df, x='Date', y=['Goal Progress', 'Habit Completion'],
                     title='Progress Tracking Over Time')
        st.plotly_chart(fig, use_container_width=True)
        
        # Insights and recommendations
        st.subheader("ðŸ’¡ Personalized Insights")
        
        insights = [
            "ðŸŽ¯ You're making great progress on your learning goals! Consider setting a more challenging target.",
            "ðŸƒ Your exercise habit has been consistent for 7 days. This is a great foundation to build on.",
            "ðŸ˜Š Your mood has been trending positive this week. Keep up the good work!",
            "ðŸ“… You tend to be most productive on Tuesday and Wednesday. Plan important tasks accordingly.",
            "ðŸŽ¨ Consider adding a creative hobby to your routine for better work-life balance."
        ]
        
        for insight in insights:
            st.info(insight)
        
        # Weekly summary
        st.subheader("ðŸ“… Weekly Summary")
        
        summary_data = {
            'Metric': ['Goals Worked On', 'Habits Completed', 'Journal Entries', 'Mood Rating'],
            'This Week': [5, 21, 4, 7.8],
            'Last Week': [4, 18, 3, 7.2],
            'Change': ['+1', '+3', '+1', '+0.6']
        }
        
        summary_df = pd.DataFrame(summary_data)
        st.table(summary_df)
        
        # Export options
        st.subheader("ðŸ“¤ Export & Backup")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("ðŸ“„ Export Progress Report"):
                st.success("Progress report would be generated and downloaded")
        
        with col2:
            if st.button("ðŸ’¾ Backup Data"):
                st.success("Data backup would be created")
        
        with col3:
            if st.button("ðŸ“§ Email Summary"):
                st.success("Weekly summary would be emailed")

if __name__ == "__main__":
    main()
````

### Environment Configuration

````python
OPENAI_API_KEY=your_openai_api_key_here
````

## Project Summary

The Personal Life Coach Bot represents a comprehensive AI-powered personal development platform that democratizes access to professional life coaching through intelligent conversation, goal management, and behavioral insights. By combining advanced NLP, emotional analysis, and memory management, it provides personalized guidance that adapts to individual needs and growth patterns.

### Key Value Propositions:
- **Intelligent Memory System**: Maintains context across conversations for consistent, personalized coaching experiences
- **Adaptive Goal Framework**: Dynamic goal setting and tracking that evolves with user progress and circumstances  
- **Emotional Intelligence**: Advanced mood analysis and emotional support with appropriate intervention strategies
- **Habit Formation Science**: Evidence-based habit building with behavioral triggers and progress analytics
- **Comprehensive Analytics**: Data-driven insights for personal development patterns and optimization opportunities

### Technical Highlights:
- ChromaDB integration for semantic memory and context retrieval across conversations
- SQLite database for structured storage of goals, habits, and user facts with relationship mapping
- Advanced sentiment analysis using TextBlob with custom emotion detection algorithms
- LangChain framework for sophisticated prompt engineering and conversation management
- Real-time analytics dashboard with progress visualization and trend analysis
- Modular architecture supporting extensibility for additional coaching methodologies and integrations

This system demonstrates how AI can provide accessible, personalized life coaching that maintains the depth and continuity of human coaching relationships while offering 24/7 availability and data-driven insights for sustainable personal growth and goal achievement.