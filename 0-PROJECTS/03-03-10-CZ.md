<small>Claude Sonnet 4 **(Historical Events Explorer - RAG systém pro historický výzkum)**</small>
# Historical Events Explorer

## Klíčové koncepty

### RAG (Retrieval-Augmented Generation)
**RAG** je architektonický vzor, který kombinuje vyhledávání relevantních informací z externí databáze znalostí s generativními schopnostmi jazykových modelů. Umožňuje AI poskytovat přesné odpovědi založené na faktických datech.

### Wikipedia/Archive.org integrace
**Wikipedia** a **Archive.org** slouží jako bohaté zdroje historických informací. Wikipedia poskytuje strukturované encyklopedické články, zatímco Archive.org obsahuje historické dokumenty a archivy.

### Time-aware embeddings
**Časově vědomé vektory** jsou speciální reprezentace textu, které zachycují nejen sémantický obsah, ale i časový kontext událostí. Umožňují efektivní vyhledávání podle časových období.

### PostgreSQL s pgvector
**PostgreSQL** s rozšířením **pgvector** poskytuje robustní řešení pro ukládání a vyhledávání vektorových reprezentací s pokročilými SQL funkcionalitami.

### Gemini Pro
**Gemini Pro** je pokročilý jazykový model od Google, který poskytuje vysokou kvalitu generování textu a analýzu komplexních historických kontextů.

## Komplexní vysvětlení projektu

**Historical Events Explorer** je sofistikovaný RAG systém navržený pro zodpovídání komplexních historických dotazů s přesnou citací zdrojů a časovými liniemi. Projekt řeší výzvu poskytování fakticky správných, kontextuálně bohatých odpovědí na historické otázky.

### Hlavní cíle:
- **Přesnost**: Odpovědi založené na ověřených historických zdrojích
- **Kontextualita**: Zahrnutí časových souvislostí a příčinných vztahů
- **Sledovatelnost**: Jasné citace a odkazy na původní zdroje
- **Škálovatelnost**: Schopnost pracovat s rozsáhlými historickými databázemi

### Architektonické výzvy:
- **Časová komplexita**: Historické události se překrývají a ovlivňují navzájem
- **Kvalita zdrojů**: Nutnost ověřování reliability historických informací
- **Multimodální data**: Kombinace textů, dat a geografických informací
- **Kontextuální vyhledávání**: Nalezení relevantních informací napříč různými časovými obdobími

## Komplexní implementace s Python

````python
langchain==0.1.0
langchain-google-genai==0.1.0
wikipedia==1.4.0
requests==2.31.0
psycopg2-binary==2.9.7
pgvector==0.2.0
sentence-transformers==2.2.2
python-dotenv==1.0.0
streamlit==1.29.0
plotly==5.17.0
pandas==2.1.0
````

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
    DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://user:password@localhost:5432/historical_events")
    EMBEDDING_MODEL = "sentence-transformers/all-MiniLM-L6-v2"
    MAX_CONTEXT_LENGTH = 4000
    TOP_K_RESULTS = 5
    
    # Historical periods for time-aware processing
    HISTORICAL_PERIODS = {
        "ancient": (-3000, 500),
        "medieval": (500, 1500),
        "early_modern": (1500, 1800),
        "modern": (1800, 1950),
        "contemporary": (1950, 2024)
    }
````

````python
import psycopg2
from psycopg2.extras import RealDictCursor
import json
from typing import List, Dict, Optional
import logging

class HistoricalDatabase:
    def __init__(self, connection_string: str):
        self.connection_string = connection_string
        self.setup_database()
    
    def setup_database(self):
        """Inicializace databáze s pgvector rozšířením"""
        try:
            with psycopg2.connect(self.connection_string) as conn:
                with conn.cursor() as cur:
                    # Vytvoření pgvector rozšíření
                    cur.execute("CREATE EXTENSION IF NOT EXISTS vector;")
                    
                    # Tabulka pro historické události
                    cur.execute("""
                        CREATE TABLE IF NOT EXISTS historical_events (
                            id SERIAL PRIMARY KEY,
                            title VARCHAR(500) NOT NULL,
                            content TEXT NOT NULL,
                            date_start INTEGER,
                            date_end INTEGER,
                            location VARCHAR(200),
                            source_url VARCHAR(500),
                            source_type VARCHAR(50),
                            embedding vector(384),
                            created_at TIMESTAMP DEFAULT NOW()
                        );
                    """)
                    
                    # Index pro vektorové vyhledávání
                    cur.execute("""
                        CREATE INDEX IF NOT EXISTS historical_events_embedding_idx 
                        ON historical_events USING ivfflat (embedding vector_cosine_ops)
                        WITH (lists = 100);
                    """)
                    
                    # Index pro časové vyhledávání
                    cur.execute("""
                        CREATE INDEX IF NOT EXISTS historical_events_date_idx 
                        ON historical_events (date_start, date_end);
                    """)
                    
                conn.commit()
                logging.info("Databáze úspěšně inicializována")
        except Exception as e:
            logging.error(f"Chyba při inicializaci databáze: {e}")
            raise
    
    def insert_event(self, event_data: Dict) -> int:
        """Vložení historické události do databáze"""
        try:
            with psycopg2.connect(self.connection_string) as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        INSERT INTO historical_events 
                        (title, content, date_start, date_end, location, source_url, source_type, embedding)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                        RETURNING id;
                    """, (
                        event_data['title'],
                        event_data['content'],
                        event_data.get('date_start'),
                        event_data.get('date_end'),
                        event_data.get('location'),
                        event_data.get('source_url'),
                        event_data.get('source_type'),
                        event_data['embedding']
                    ))
                    event_id = cur.fetchone()[0]
                    conn.commit()
                    return event_id
        except Exception as e:
            logging.error(f"Chyba při vkládání události: {e}")
            raise
    
    def search_similar_events(self, query_embedding: List[float], 
                            date_range: Optional[tuple] = None, 
                            limit: int = 5) -> List[Dict]:
        """Vyhledávání podobných událostí pomocí vektorové podobnosti"""
        try:
            with psycopg2.connect(self.connection_string) as conn:
                with conn.cursor(cursor_factory=RealDictCursor) as cur:
                    where_clause = ""
                    params = [query_embedding, limit]
                    
                    if date_range:
                        where_clause = """
                            WHERE (date_start <= %s AND date_end >= %s) 
                            OR (date_start >= %s AND date_start <= %s)
                        """
                        params = [query_embedding] + list(date_range) * 2 + [limit]
                    
                    cur.execute(f"""
                        SELECT id, title, content, date_start, date_end, 
                               location, source_url, source_type,
                               1 - (embedding <=> %s) as similarity
                        FROM historical_events
                        {where_clause}
                        ORDER BY embedding <=> %s
                        LIMIT %s;
                    """, params)
                    
                    return [dict(row) for row in cur.fetchall()]
        except Exception as e:
            logging.error(f"Chyba při vyhledávání: {e}")
            return []
````

````python
import wikipedia
import requests
from typing import List, Dict, Optional
import re
from datetime import datetime
import logging
from sentence_transformers import SentenceTransformer

class HistoricalDataCollector:
    def __init__(self, embedding_model_name: str):
        self.embedding_model = SentenceTransformer(embedding_model_name)
        wikipedia.set_lang("en")  # Pro lepší dostupnost historických článků
    
    def extract_dates_from_text(self, text: str) -> tuple:
        """Extrakce dat z textu pomocí regex"""
        # Vzory pro různé formáty dat
        year_patterns = [
            r'\b(\d{4})\b',  # Čtyřciferný rok
            r'\b(\d{1,2})\s+(century|Century)\b',  # Století
            r'\b(\d{1,4})\s*(BC|AD|BCE|CE)\b'  # BC/AD formát
        ]
        
        dates = []
        for pattern in year_patterns:
            matches = re.findall(pattern, text)
            for match in matches:
                if isinstance(match, tuple):
                    match = match[0]
                try:
                    year = int(match)
                    if 1 <= year <= 2024:
                        dates.append(year)
                except ValueError:
                    continue
        
        if dates:
            return min(dates), max(dates)
        return None, None
    
    def collect_wikipedia_events(self, search_terms: List[str]) -> List[Dict]:
        """Sběr historických událostí z Wikipedie"""
        events = []
        
        for term in search_terms:
            try:
                # Vyhledání stránek
                search_results = wikipedia.search(term, results=3)
                
                for title in search_results:
                    try:
                        page = wikipedia.page(title)
                        
                        # Extrakce základních informací
                        content = page.content[:2000]  # Omezení délky
                        date_start, date_end = self.extract_dates_from_text(content)
                        
                        # Generování embeddingu
                        embedding = self.embedding_model.encode(
                            f"{page.title} {content}"
                        ).tolist()
                        
                        event = {
                            'title': page.title,
                            'content': content,
                            'date_start': date_start,
                            'date_end': date_end,
                            'source_url': page.url,
                            'source_type': 'wikipedia',
                            'embedding': embedding
                        }
                        
                        events.append(event)
                        logging.info(f"Zpracován článek: {page.title}")
                        
                    except wikipedia.exceptions.PageError:
                        logging.warning(f"Stránka nenalezena: {title}")
                        continue
                    except Exception as e:
                        logging.error(f"Chyba při zpracování {title}: {e}")
                        continue
                        
            except Exception as e:
                logging.error(f"Chyba při vyhledávání {term}: {e}")
                continue
        
        return events
    
    def collect_sample_historical_events(self) -> List[Dict]:
        """Sběr ukázkových historických událostí"""
        historical_topics = [
            "Berlin Wall fall 1989",
            "World War II",
            "American Civil War",
            "French Revolution",
            "Industrial Revolution",
            "Cold War",
            "Renaissance period",
            "Roman Empire fall",
            "Black Death plague",
            "Discovery of America 1492"
        ]
        
        return self.collect_wikipedia_events(historical_topics)
````

````python
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import Document
from typing import List, Dict, Optional
import logging
from datetime import datetime

class HistoricalRAGSystem:
    def __init__(self, database, gemini_api_key: str, embedding_model):
        self.db = database
        self.llm = ChatGoogleGenerativeAI(
            model="gemini-pro",
            google_api_key=gemini_api_key,
            temperature=0.1
        )
        self.embedding_model = embedding_model
        
        self.prompt_template = ChatPromptTemplate.from_messages([
            ("system", """Jsi expert na historii. Tvým úkolem je odpovědět na otázky o historických událostech 
            na základě poskytnutých zdrojů. Vždy uveď zdroje a vytvoř časovou linii relevantních událostí.
            
            Pravidla:
            1. Odpovídej pouze na základě poskytnutých zdrojů
            2. Uveď jasné citace zdrojů
            3. Vytvoř chronologickou časovou linii
            4. Objasni příčinné souvislosti
            5. Pokud informace nejsou dostačující, řekni to jasně"""),
            ("user", """Otázka: {question}
            
            Relevantní historické zdroje:
            {sources}
            
            Odpověz v češtině s časovou linií a citacemi zdrojů.""")
        ])
    
    def parse_temporal_context(self, question: str) -> Optional[tuple]:
        """Extrakce časového kontextu z otázky"""
        import re
        
        # Vzory pro roky a období
        year_pattern = r'\b(1[0-9]{3}|20[0-2][0-9])\b'
        period_patterns = {
            'středověk': (500, 1500),
            'renesance': (1400, 1600),
            'osvícenství': (1650, 1800),
            'průmyslová revoluce': (1760, 1840),
            'první světová válka': (1914, 1918),
            'druhá světová válka': (1939, 1945),
            'studená válka': (1947, 1991)
        }
        
        # Hledání konkrétních let
        years = re.findall(year_pattern, question.lower())
        if years:
            year = int(years[0])
            return (year - 50, year + 50)  # Kontext ±50 let
        
        # Hledání historických období
        for period, date_range in period_patterns.items():
            if period in question.lower():
                return date_range
        
        return None
    
    def retrieve_relevant_events(self, question: str, top_k: int = 5) -> List[Dict]:
        """Vyhledání relevantních historických událostí"""
        try:
            # Generování embeddingu pro otázku
            question_embedding = self.embedding_model.encode(question).tolist()
            
            # Extrakce časového kontextu
            date_range = self.parse_temporal_context(question)
            
            # Vyhledání podobných událostí
            events = self.db.search_similar_events(
                query_embedding=question_embedding,
                date_range=date_range,
                limit=top_k
            )
            
            logging.info(f"Nalezeno {len(events)} relevantních událostí")
            return events
            
        except Exception as e:
            logging.error(f"Chyba při vyhledávání událostí: {e}")
            return []
    
    def format_sources(self, events: List[Dict]) -> str:
        """Formátování zdrojů pro prompt"""
        sources = []
        for i, event in enumerate(events, 1):
            date_info = ""
            if event.get('date_start') and event.get('date_end'):
                date_info = f" ({event['date_start']}-{event['date_end']})"
            elif event.get('date_start'):
                date_info = f" ({event['date_start']})"
            
            source = f"""
Zdroj {i}: {event['title']}{date_info}
Obsah: {event['content'][:500]}...
URL: {event.get('source_url', 'N/A')}
Relevance: {event.get('similarity', 0):.3f}
            """
            sources.append(source)
        
        return "\n".join(sources)
    
    def generate_answer(self, question: str) -> Dict:
        """Generování odpovědi na historickou otázku"""
        try:
            # Vyhledání relevantních událostí
            events = self.retrieve_relevant_events(question)
            
            if not events:
                return {
                    "answer": "Omlouvám se, ale v databázi jsem nenašel relevantní informace k vaší otázce.",
                    "sources": [],
                    "timeline": []
                }
            
            # Formátování zdrojů
            sources_text = self.format_sources(events)
            
            # Generování odpovědi
            messages = self.prompt_template.format_messages(
                question=question,
                sources=sources_text
            )
            
            response = self.llm.invoke(messages)
            
            # Příprava časové linie
            timeline = []
            for event in events:
                if event.get('date_start'):
                    timeline.append({
                        'date': event['date_start'],
                        'event': event['title'],
                        'description': event['content'][:200] + '...'
                    })
            
            timeline.sort(key=lambda x: x['date'])
            
            return {
                "answer": response.content,
                "sources": events,
                "timeline": timeline,
                "question": question
            }
            
        except Exception as e:
            logging.error(f"Chyba při generování odpovědi: {e}")
            return {
                "answer": f"Došlo k chybě při zpracování otázky: {str(e)}",
                "sources": [],
                "timeline": []
            }
````

````python
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd
from datetime import datetime
import logging
from config import Config
from database import HistoricalDatabase
from data_collector import HistoricalDataCollector
from rag_system import HistoricalRAGSystem
from sentence_transformers import SentenceTransformer

# Konfigurace logování
logging.basicConfig(level=logging.INFO)

@st.cache_resource
def initialize_system():
    """Inicializace RAG systému"""
    try:
        # Inicializace komponent
        db = HistoricalDatabase(Config.DATABASE_URL)
        embedding_model = SentenceTransformer(Config.EMBEDDING_MODEL)
        rag_system = HistoricalRAGSystem(db, Config.GEMINI_API_KEY, embedding_model)
        
        return db, embedding_model, rag_system
    except Exception as e:
        st.error(f"Chyba při inicializaci systému: {e}")
        return None, None, None

def load_sample_data(db, collector):
    """Načtení ukázkových dat"""
    if st.button("Načíst ukázková historická data"):
        with st.spinner("Sbírání historických dat z Wikipedie..."):
            events = collector.collect_sample_historical_events()
            
            progress_bar = st.progress(0)
            for i, event in enumerate(events):
                try:
                    db.insert_event(event)
                    progress_bar.progress((i + 1) / len(events))
                except Exception as e:
                    st.error(f"Chyba při ukládání události: {e}")
            
            st.success(f"Úspěšně načteno {len(events)} historických událostí!")

def display_timeline(timeline_data):
    """Zobrazení časové linie událostí"""
    if not timeline_data:
        return
    
    df = pd.DataFrame(timeline_data)
    
    # Vytvoření časové linie pomocí Plotly
    fig = go.Figure()
    
    fig.add_trace(go.Scatter(
        x=df['date'],
        y=[1] * len(df),
        mode='markers+text',
        text=df['event'],
        textposition="top center",
        marker=dict(size=10, color='red'),
        hovertemplate='<b>%{text}</b><br>Rok: %{x}<br>%{customdata}<extra></extra>',
        customdata=df['description']
    ))
    
    fig.update_layout(
        title="Časová linie historických událostí",
        xaxis_title="Rok",
        yaxis=dict(visible=False),
        height=400,
        showlegend=False
    )
    
    st.plotly_chart(fig, use_container_width=True)

def main():
    st.set_page_config(
        page_title="Historical Events Explorer",
        page_icon="🏛️",
        layout="wide"
    )
    
    st.title("🏛️ Historical Events Explorer")
    st.markdown("**RAG systém pro komplexní historické dotazy s časovými liniemi**")
    
    # Inicializace systému
    db, embedding_model, rag_system = initialize_system()
    
    if not all([db, embedding_model, rag_system]):
        st.error("Nepodařilo se inicializovat systém. Zkontrolujte konfiguraci.")
        return
    
    # Postranní panel pro správu dat
    with st.sidebar:
        st.header("📚 Správa dat")
        
        collector = HistoricalDataCollector(Config.EMBEDDING_MODEL)
        load_sample_data(db, collector)
        
        st.markdown("---")
        st.markdown("**Příklady otázek:**")
        st.markdown("- Co způsobilo pád Berlínské zdi?")
        st.markdown("- Jak probíhala Francouzská revoluce?")
        st.markdown("- Jaké byly příčiny první světové války?")
    
    # Hlavní rozhraní
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.header("🔍 Historický dotaz")
        
        question = st.text_area(
            "Položte svou historickou otázku:",
            placeholder="Například: Co způsobilo pád Berlínské zdi?",
            height=100
        )
        
        if st.button("Vyhledat odpověď", type="primary"):
            if question:
                with st.spinner("Analyzujem historické zdroje..."):
                    result = rag_system.generate_answer(question)
                
                # Zobrazení odpovědi
                st.subheader("📖 Odpověď")
                st.write(result["answer"])
                
                # Zobrazení časové linie
                if result["timeline"]:
                    st.subheader("⏱️ Časová linie")
                    display_timeline(result["timeline"])
                
                # Zobrazení zdrojů
                if result["sources"]:
                    st.subheader("📚 Zdroje")
                    for i, source in enumerate(result["sources"], 1):
                        with st.expander(f"Zdroj {i}: {source['title']}"):
                            col_a, col_b = st.columns([3, 1])
                            with col_a:
                                st.write(source['content'][:300] + "...")
                            with col_b:
                                if source.get('date_start'):
                                    st.metric("Rok", source['date_start'])
                                if source.get('similarity'):
                                    st.metric("Relevance", f"{source['similarity']:.3f}")
                            
                            if source.get('source_url'):
                                st.markdown(f"[Odkaz na zdroj]({source['source_url']})")
            else:
                st.warning("Prosím, zadejte svou otázku.")
    
    with col2:
        st.header("📊 Statistiky")
        
        # Zobrazení statistik systému
        try:
            import psycopg2
            with psycopg2.connect(Config.DATABASE_URL) as conn:
                with conn.cursor() as cur:
                    cur.execute("SELECT COUNT(*) FROM historical_events")
                    total_events = cur.fetchone()[0]
                    
                    cur.execute("SELECT COUNT(DISTINCT source_type) FROM historical_events")
                    source_types = cur.fetchone()[0]
            
            st.metric("Celkem událostí", total_events)
            st.metric("Typy zdrojů", source_types)
            
        except Exception as e:
            st.error(f"Chyba při načítání statistik: {e}")

if __name__ == "__main__":
    main()
````

````python
import subprocess
import sys
import os

def setup_environment():
    """Nastavení prostředí a instalace závislostí"""
    print("🔧 Nastavování prostředí...")
    
    # Instalace závislostí
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])
    
    # Vytvoření .env souboru pokud neexistuje
    if not os.path.exists('.env'):
        with open('.env', 'w') as f:
            f.write("""# Historical Events Explorer Configuration
GEMINI_API_KEY=your_gemini_api_key_here
DATABASE_URL=postgresql://user:password@localhost:5432/historical_events
""")
        print("📝 Vytvořen .env soubor - nastavte své API klíče!")

def run_application():
    """Spuštění Streamlit aplikace"""
    print("🚀 Spouštění Historical Events Explorer...")
    os.chdir('src')
    subprocess.run([sys.executable, "-m", "streamlit", "run", "main.py"])

if __name__ == "__main__":
    setup_environment()
    run_application()
````

## Shrnutí projektu

**Historical Events Explorer** představuje pokročilý RAG systém, který revolucionizuje způsob, jakým lidé zkoumají historii. Projekt úspěšně kombinuje moderní AI technologie s rozsáhlými historickými databázemi pro poskytování přesných, kontextuálně bohatých odpovědí.

### Klíčové přínosy:
- **Faktická přesnost** díky RAG architektuře a citacím zdrojů
- **Časový kontext** prostřednictvím time-aware embeddingů a časových linií
- **Škálovatelnost** s PostgreSQL a vektorovým vyhledáváním
- **Uživatelská přívětivost** s intuitivním Streamlit rozhraním

### Technologické inovace:
- Integrace Wikipedia a Archive.org jako autoritativních zdrojů
- Pokročilé vektorové vyhledávání s pgvector
- Časově vědomé embeddingy pro historický kontext
- Gemini Pro pro kvalitní generování odpovědí

Projekt demonstruje, jak AI může zpřístupnit komplexní historické znalosti širokému publiku, zachovávajíc přitom vědeckou rigoróznost a sledovatelnost zdrojů.