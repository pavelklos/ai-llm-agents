<small>Claude Sonnet 4 **(Platforma pro objevov치n칤 a anal칳zu hudby s RAG technologi칤)**</small>
# Music Discovery and Analysis Platform

## 1. N치zev projektu

**MusicRAG** - Inteligentn칤 platforma pro objevov치n칤 hudby, anal칳zu a personalizovan칠 doporu캜en칤 vyu쮂셨aj칤c칤 RAG (Retrieval-Augmented Generation) technologii.

## 2. Vysv캩tlen칤 kl칤캜ov칳ch koncept콢

### RAG (Retrieval-Augmented Generation)
Hybridn칤 p콏칤stup kombinuj칤c칤 vyhled치v치n칤 relevantn칤ch informac칤 z datab치ze s generativn칤 AI pro vytv치콏en칤 kontextov캩 p콏esn칳ch odpov캩d칤.

### Spotify API
Rozhran칤 pro p콏칤stup k datab치zi Spotify obsahuj칤c칤 informace o um캩lc칤ch, albech, skladb치ch a playlistech.

### Last.fm Data
Platforma pro sledov치n칤 hudebn칤ch preferenc칤 u쬴vatel콢 a z칤sk치v치n칤 statistik o poslechu.

### Klasifikace 쮂멽r콢
Automatick칠 kategorizov치n칤 hudby do 쮂멽r콢 pomoc칤 anal칳zy audio charakteristik a metadat.

### Anal칳za text콢
Zpracov치n칤 a interpretace text콢 p칤sn칤 pro extrakci t칠mat, n치lad a v칳znam콢.

## 3. Komplexn칤 vysv캩tlen칤 projektu

### C칤le projektu
Vytvo콏it inteligentn칤 hudebn칤 platformu, kter치 kombinuje tradi캜n칤 hudebn칤 datab치ze s pokro캜ilou AI pro poskytov치n칤 personalizovan칳ch doporu캜en칤, hlubok칳ch anal칳z a objevov치n칤 nov칠 hudby.

### Hlavn칤 v칳zvy
- Integrace heterogenn칤ch hudebn칤ch datov칳ch zdroj콢
- Zpracov치n칤 velk칳ch objem콢 audio a textov칳ch dat
- Zaji코t캩n칤 relevantnosti doporu캜en칤 v re치ln칠m 캜ase
- 맒치lovatelnost pro miliony u쬴vatel콢

### Potenci치ln칤 dopad
Revoluce v zp콢sobu, jak칳m lid칠 objevuj칤 a interaguj칤 s hudbou, poskytnut칤 hlub코칤ch vhled콢 do hudebn칤ch trend콢 a um캩leck칠 tvorby.

## 4. Komplexn칤 p콏칤klad implementace v Pythonu

### Instalace z치vislost칤

````python
# requirements.txt
langchain==0.1.0
chromadb==0.4.22
openai==1.12.0
spotipy==2.22.1
requests==2.31.0
pandas==2.0.3
numpy==1.24.3
scikit-learn==1.3.0
fastapi==0.104.1
uvicorn==0.24.0
python-dotenv==1.0.0
pydantic==2.5.0
````

### Hlavn칤 implementace

````python
import os
import json
import logging
from typing import List, Dict, Optional, Any
from dataclasses import dataclass
from datetime import datetime

import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import requests
import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

import chromadb
from chromadb.utils import embedding_functions
import openai
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.chat_models import ChatOpenAI
from langchain.schema import Document
from langchain.prompts import ChatPromptTemplate

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class MusicEntity:
    """Datov치 struktura pro hudebn칤 entitu"""
    id: str
    name: str
    type: str  # artist, album, track
    genres: List[str]
    description: str
    metadata: Dict[str, Any]

class MusicDataCollector:
    """Kolektor hudebn칤ch dat ze Spotify a Last.fm"""
    
    def __init__(self, spotify_client_id: str, spotify_client_secret: str, lastfm_api_key: str):
        # Spotify konfigurace
        credentials = SpotifyClientCredentials(
            client_id=spotify_client_id,
            client_secret=spotify_client_secret
        )
        self.spotify = spotipy.Spotify(client_credentials_manager=credentials)
        self.lastfm_api_key = lastfm_api_key
        self.lastfm_base_url = "http://ws.audioscrobbler.com/2.0/"
    
    def get_artist_info(self, artist_name: str) -> Optional[MusicEntity]:
        """Z칤sk치n칤 informac칤 o um캩lci ze Spotify"""
        try:
            results = self.spotify.search(q=artist_name, type='artist', limit=1)
            if not results['artists']['items']:
                return None
            
            artist = results['artists']['items'][0]
            
            # Z칤sk치n칤 bio z Last.fm
            bio = self._get_lastfm_artist_bio(artist_name)
            
            return MusicEntity(
                id=artist['id'],
                name=artist['name'],
                type='artist',
                genres=artist.get('genres', []),
                description=bio,
                metadata={
                    'popularity': artist.get('popularity', 0),
                    'followers': artist.get('followers', {}).get('total', 0),
                    'spotify_url': artist.get('external_urls', {}).get('spotify', ''),
                    'images': artist.get('images', [])
                }
            )
        except Exception as e:
            logger.error(f"Chyba p콏i z칤sk치v치n칤 informac칤 o um캩lci {artist_name}: {e}")
            return None
    
    def _get_lastfm_artist_bio(self, artist_name: str) -> str:
        """Z칤sk치n칤 biografie um캩lce z Last.fm"""
        try:
            params = {
                'method': 'artist.getinfo',
                'artist': artist_name,
                'api_key': self.lastfm_api_key,
                'format': 'json'
            }
            
            response = requests.get(self.lastfm_base_url, params=params)
            data = response.json()
            
            if 'artist' in data and 'bio' in data['artist']:
                return data['artist']['bio'].get('summary', '')
            
            return f"Popul치rn칤 um캩lec {artist_name} bez dostupn칠 biografie."
            
        except Exception as e:
            logger.error(f"Chyba p콏i z칤sk치v치n칤 biografie z Last.fm: {e}")
            return f"Um캩lec {artist_name} - informace nejsou dostupn칠."

class MusicVectorStore:
    """Vektorov치 datab치ze pro hudebn칤 data"""
    
    def __init__(self, collection_name: str = "music_collection"):
        self.client = chromadb.PersistentClient(path="./music_db")
        self.embedding_function = embedding_functions.OpenAIEmbeddingFunction(
            api_key=os.getenv("OPENAI_API_KEY"),
            model_name="text-embedding-ada-002"
        )
        
        # Vytvo콏en칤 nebo z칤sk치n칤 kolekce
        try:
            self.collection = self.client.get_collection(
                name=collection_name,
                embedding_function=self.embedding_function
            )
        except:
            self.collection = self.client.create_collection(
                name=collection_name,
                embedding_function=self.embedding_function
            )
    
    def add_music_entities(self, entities: List[MusicEntity]) -> None:
        """P콏id치n칤 hudebn칤ch entit do vektorov칠 datab치ze"""
        documents = []
        metadatas = []
        ids = []
        
        for entity in entities:
            # Vytvo콏en칤 textov칠ho popisu pro embedding
            text_content = f"{entity.name} ({entity.type})\n"
            text_content += f"콯치nry: {', '.join(entity.genres)}\n"
            text_content += f"Popis: {entity.description}"
            
            documents.append(text_content)
            metadatas.append({
                'id': entity.id,
                'name': entity.name,
                'type': entity.type,
                'genres': json.dumps(entity.genres),
                **entity.metadata
            })
            ids.append(f"{entity.type}_{entity.id}")
        
        try:
            self.collection.add(
                documents=documents,
                metadatas=metadatas,
                ids=ids
            )
            logger.info(f"P콏id치no {len(entities)} hudebn칤ch entit do datab치ze")
        except Exception as e:
            logger.error(f"Chyba p콏i p콏id치v치n칤 do datab치ze: {e}")
    
    def search_similar(self, query: str, n_results: int = 5) -> List[Dict]:
        """Vyhled치n칤 podobn칳ch hudebn칤ch entit"""
        try:
            results = self.collection.query(
                query_texts=[query],
                n_results=n_results,
                include=['documents', 'metadatas', 'distances']
            )
            
            return [
                {
                    'document': doc,
                    'metadata': meta,
                    'distance': dist
                }
                for doc, meta, dist in zip(
                    results['documents'][0],
                    results['metadatas'][0],
                    results['distances'][0]
                )
            ]
        except Exception as e:
            logger.error(f"Chyba p콏i vyhled치v치n칤: {e}")
            return []

class MusicAnalyzer:
    """Analyz치tor pro hudebn칤 obsah a doporu캜en칤"""
    
    def __init__(self):
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0.3,
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )
        
        self.analysis_prompt = ChatPromptTemplate.from_template(
            """Jsi expert na hudbu a hudebn칤 anal칳zu. Na z치klad캩 poskytnut칳ch informac칤 o um캩lc칤ch a p칤sn칤ch:

Kontext:
{context}

U쬴vatelsk칳 dotaz: {query}

Prove캞 anal칳zu a poskytni:
1. Detailn칤 odpov캩캞 na dotaz
2. Hudebn칤 doporu캜en칤 zalo쬰n치 na kontextu
3. Zaj칤mav칠 souvislosti a poznatky
4. Odkazy na podobn칠 um캩lce nebo 쮂멽ry

Odpov캩z v 캜e코tin캩 a bu캞 konkr칠tn칤 a u쬴te캜n칳."""
        )
    
    def analyze_query(self, query: str, context_docs: List[Dict]) -> str:
        """Anal칳za dotazu s kontextem z RAG"""
        try:
            # P콏칤prava kontextu
            context_text = "\n\n".join([
                f"N치zev: {doc['metadata'].get('name', 'N/A')}\n"
                f"Typ: {doc['metadata'].get('type', 'N/A')}\n"
                f"Obsah: {doc['document'][:500]}..."
                for doc in context_docs
            ])
            
            # Generov치n칤 odpov캩di
            messages = self.analysis_prompt.format_messages(
                context=context_text,
                query=query
            )
            
            response = self.llm(messages)
            return response.content
            
        except Exception as e:
            logger.error(f"Chyba p콏i anal칳ze dotazu: {e}")
            return "Omlouv치me se, do코lo k chyb캩 p콏i zpracov치n칤 va코eho dotazu."

class GenreClassifier:
    """Klasifik치tor hudebn칤ch 쮂멽r콢"""
    
    def __init__(self):
        self.genre_keywords = {
            'rock': ['kytara', 'bic칤', 'rock', 'metal', 'punk', 'alternative'],
            'pop': ['pop', 'mainstream', 'komerce', 'hit', 'radio'],
            'jazz': ['jazz', 'improvizace', 'swing', 'blues', 'fusion'],
            'classical': ['klasick치', 'orchestr', 'symfonie', 'opera', 'komorn칤'],
            'electronic': ['elektronick치', 'synth', 'beat', 'techno', 'house'],
            'folk': ['folk', 'lidov치', 'akustick치', 'tradice', 'country']
        }
        
        self.vectorizer = TfidfVectorizer(max_features=1000, stop_words=None)
    
    def classify_genres(self, text: str) -> List[str]:
        """Klasifikace 쮂멽r콢 na z치klad캩 textu"""
        text_lower = text.lower()
        detected_genres = []
        
        for genre, keywords in self.genre_keywords.items():
            if any(keyword in text_lower for keyword in keywords):
                detected_genres.append(genre)
        
        return detected_genres if detected_genres else ['nezn치m칳']

class MusicRAGPlatform:
    """Hlavn칤 t콏칤da platformy pro hudebn칤 RAG"""
    
    def __init__(self):
        self.data_collector = MusicDataCollector(
            spotify_client_id=os.getenv("SPOTIFY_CLIENT_ID"),
            spotify_client_secret=os.getenv("SPOTIFY_CLIENT_SECRET"),
            lastfm_api_key=os.getenv("LASTFM_API_KEY")
        )
        
        self.vector_store = MusicVectorStore()
        self.analyzer = MusicAnalyzer()
        self.genre_classifier = GenreClassifier()
    
    def initialize_sample_data(self):
        """Inicializace s uk치zkov칳mi daty"""
        sample_artists = [
            "The Beatles", "Radiohead", "Miles Davis", 
            "Mozart", "Daft Punk", "Bob Dylan"
        ]
        
        entities = []
        for artist_name in sample_artists:
            entity = self.data_collector.get_artist_info(artist_name)
            if entity:
                entities.append(entity)
        
        if entities:
            self.vector_store.add_music_entities(entities)
            logger.info(f"Inicializov치no {len(entities)} um캩lc콢")
    
    def process_music_query(self, query: str) -> Dict[str, Any]:
        """Zpracov치n칤 hudebn칤ho dotazu pomoc칤 RAG"""
        try:
            # Vyhled치n칤 relevantn칤ch dokument콢
            similar_docs = self.vector_store.search_similar(query, n_results=5)
            
            # Anal칳za pomoc칤 LLM
            analysis = self.analyzer.analyze_query(query, similar_docs)
            
            # Klasifikace 쮂멽r콢 v dotazu
            detected_genres = self.genre_classifier.classify_genres(query)
            
            return {
                'query': query,
                'analysis': analysis,
                'similar_content': similar_docs,
                'detected_genres': detected_genres,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Chyba p콏i zpracov치n칤 dotazu: {e}")
            return {
                'query': query,
                'analysis': f"Chyba p콏i zpracov치n칤: {str(e)}",
                'similar_content': [],
                'detected_genres': [],
                'timestamp': datetime.now().isoformat()
            }

# FastAPI aplikace
app = FastAPI(title="MusicRAG Platform", version="1.0.0")

# Inicializace platformy
platform = None

@app.on_event("startup")
async def startup_event():
    """Startup event pro inicializaci platformy"""
    global platform
    platform = MusicRAGPlatform()
    platform.initialize_sample_data()

class QueryRequest(BaseModel):
    query: str

class QueryResponse(BaseModel):
    query: str
    analysis: str
    similar_content: List[Dict]
    detected_genres: List[str]
    timestamp: str

@app.post("/analyze", response_model=QueryResponse)
async def analyze_music_query(request: QueryRequest):
    """Endpoint pro anal칳zu hudebn칤ch dotaz콢"""
    if not platform:
        raise HTTPException(status_code=500, detail="Platforma nen칤 inicializov치na")
    
    result = platform.process_music_query(request.query)
    return QueryResponse(**result)

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

if __name__ == "__main__":
    # Nastaven칤 environment variables (v produkci pou쬴jte .env soubor)
    os.environ.setdefault("OPENAI_API_KEY", "your-openai-api-key")
    os.environ.setdefault("SPOTIFY_CLIENT_ID", "your-spotify-client-id")
    os.environ.setdefault("SPOTIFY_CLIENT_SECRET", "your-spotify-client-secret")
    os.environ.setdefault("LASTFM_API_KEY", "your-lastfm-api-key")
    
    # Spu코t캩n칤 aplikace
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### Pou쬴t칤 a testov치n칤

````python
import asyncio
import json
from music_rag_platform import MusicRAGPlatform

async def test_platform():
    """Test funkcionalit platformy"""
    platform = MusicRAGPlatform()
    
    # Inicializace dat
    platform.initialize_sample_data()
    
    # Testovac칤 dotazy
    test_queries = [
        "Doporu캜 mi podobnou hudbu jako The Beatles",
        "Jak칳 je rozd칤l mezi jazzem a bluesem?",
        "Kdo ovlivnil vznik elektronick칠 hudby?",
        "Nejlep코칤 rockov칠 skupiny 90. let"
    ]
    
    for query in test_queries:
        print(f"\n游꿧 Dotaz: {query}")
        result = platform.process_music_query(query)
        print(f"游늵 Anal칳za: {result['analysis'][:200]}...")
        print(f"游꿮 콯치nry: {result['detected_genres']}")

if __name__ == "__main__":
    asyncio.run(test_platform())
````

## 5. Shrnut칤 projektu

### Hodnota projektu
MusicRAG p콏edstavuje pr콢lomov칳 p콏칤stup k hudebn칤mu objevov치n칤, kter칳 kombinuje rozs치hl칠 datab치ze s inteligentn칤 anal칳zou AI pro poskytov치n칤 personalizovan칳ch a kontextov캩 relevantn칤ch hudebn칤ch doporu캜en칤.

### Kl칤캜ov칠 p콏칤nosy
- **Inteligentn칤 doporu캜en칤**: RAG technologie umo쮄갓je p콏esn캩j코칤 a relevantn캩j코칤 doporu캜en칤 na z치klad캩 kontextu
- **Multimod치ln칤 anal칳za**: Kombinace textov칳ch, audio a metadata pro komplexn칤 pohled na hudbu
- **맒치lovatelnost**: Architektura p콏ipraven치 pro r콢st s miliony u쬴vatel콢 a skladeb
- **Personalizace**: Adaptivn칤 syst칠m u캜칤c칤 se z u쬴vatelsk칳ch preferenc칤

### Technologick칠 inovace
- Vyu쬴t칤 vector datab치z칤 pro efektivn칤 vyhled치v치n칤 podobnosti
- Integrace m칰ltiple API zdroj콢 pro bohat치 data
- Modern칤 AI frameworky pro pokro캜ilou anal칳zu
- RESTful API pro snadnou integraci

Platforma p콏edstavuje budoucnost hudebn칤ho objevov치n칤, kde AI asistuje u쬴vatel콢m v nalezen칤 nov칠 hudby a hlub코칤m porozum캩n칤 hudebn칤mu um캩n칤.