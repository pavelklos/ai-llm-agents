<small>Claude Sonnet 4 **(Enterprise Knowledge Assistant - RAG Syst√©m pro Firemn√≠ Dokumentaci)**</small>
# Enterprise Knowledge Assistant

## Kl√≠ƒçov√© Koncepty

### RAG (Retrieval-Augmented Generation)
**RAG** je architektura, kter√° kombinuje vyhled√°v√°n√≠ relevantn√≠ch informac√≠ z datab√°ze znalost√≠ s generativn√≠mi schopnostmi velk√Ωch jazykov√Ωch model≈Ø. Proces prob√≠h√° ve dvou f√°z√≠ch:
1. **Retrieval** - Vyhled√°n√≠ relevantn√≠ch dokument≈Ø pomoc√≠ s√©mantick√©ho vyhled√°v√°n√≠
2. **Generation** - Generov√°n√≠ odpovƒõdi na z√°kladƒõ nalezen√Ωch dokument≈Ø a dotazu

### FAISS (Facebook AI Similarity Search)
Knihovna pro efektivn√≠ s√©mantick√© vyhled√°v√°n√≠ ve velk√Ωch kolekc√≠ch vektor≈Ø. Umo≈æ≈àuje rychl√© nalezen√≠ podobn√Ωch dokument≈Ø na z√°kladƒõ jejich vektorov√© reprezentace.

### LangChain
Framework pro v√Ωvoj aplikac√≠ vyu≈æ√≠vaj√≠c√≠ch velk√© jazykov√© modely. Poskytuje n√°stroje pro ≈ôetƒõzen√≠ operac√≠, spr√°vu dokument≈Ø a integraci s r≈Øzn√Ωmi datov√Ωmi zdroji.

### Vector Embeddings
ƒå√≠seln√© reprezentace text≈Ø v mnohodimenzion√°ln√≠m prostoru, kde s√©manticky podobn√© texty maj√≠ podobn√© vektory. Umo≈æ≈àuj√≠ efektivn√≠ s√©mantick√© vyhled√°v√°n√≠.

### Slack Integration
Integrace chatbota do Slack workspace umo≈æ≈àuje u≈æivatel≈Øm p≈ôirozenƒõ komunikovat s AI asistentem p≈ô√≠mo v jejich pracovn√≠m prost≈ôed√≠.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Enterprise Knowledge Assistant je pokroƒçil√Ω RAG syst√©m navr≈æen√Ω pro automatizaci p≈ô√≠stupu k firemn√≠m znalostem. Hlavn√≠ c√≠le zahrnuj√≠:

- **Centralizace znalost√≠**: Sjednocen√≠ p≈ô√≠stupu k r≈Øzn√Ωm zdroj≈Øm firemn√≠ dokumentace
- **Zv√Ω≈°en√≠ produktivity**: Rychl√© nalezen√≠ relevantn√≠ch informac√≠ bez manu√°ln√≠ho prohled√°v√°n√≠
- **Democratizace znalost√≠**: Zp≈ô√≠stupnƒõn√≠ expertn√≠ch informac√≠ v≈°em zamƒõstnanc≈Øm
- **Redukce opakuj√≠c√≠ch se dotaz≈Ø**: Automatizovan√© odpovƒõdi na ƒçast√© ot√°zky

### V√Ωzvy a ≈òe≈°en√≠

**1. Heterogenn√≠ datov√© zdroje**
- *V√Ωzva*: R≈Øzn√© form√°ty dokument≈Ø (PDF, DOCX, Wiki, HTML)
- *≈òe≈°en√≠*: Unifikovan√© parsov√°n√≠ pomoc√≠ LangChain document loaders

**2. S√©mantick√° p≈ôesnost**
- *V√Ωzva*: Nalezen√≠ kontextovƒõ relevantn√≠ch informac√≠
- *≈òe≈°en√≠*: Pokroƒçil√© embedding modely a chunk strategie

**3. ≈†k√°lovatelnost**
- *V√Ωzva*: Zpracov√°n√≠ velk√Ωch objem≈Ø dokument≈Ø
- *≈òe≈°en√≠*: FAISS indexov√°n√≠ s optimalizovan√Ωmi vyhled√°vac√≠mi algoritmy

**4. Bezpeƒçnost**
- *V√Ωzva*: Kontrola p≈ô√≠stupu k citliv√Ωm informac√≠m
- *≈òe≈°en√≠*: Role-based access control a audit logging

### Dopad na Organizaci
Implementace p≈ôinese mƒõ≈ôiteln√© benefity:
- **40-60% redukce ƒçasu** na vyhled√°v√°n√≠ informac√≠
- **Zlep≈°en√≠ employee onboardingu** d√≠ky rychl√©mu p≈ô√≠stupu k dokumentaci
- **Sn√≠≈æen√≠ z√°tƒõ≈æe** na IT support a experty
- **Konzistentn√≠ odpovƒõdi** nap≈ô√≠ƒç organizac√≠

## Komplexn√≠ Python Implementace

### Z√°vislosti a Setup

````python
langchain==0.1.0
langchain-community==0.0.13
langchain-openai==0.0.5
faiss-cpu==1.7.4
openai==1.10.0
slack-sdk==3.25.0
python-dotenv==1.0.0
PyPDF2==3.0.1
python-docx==1.1.0
chromadb==0.4.22
sentence-transformers==2.2.2
fastapi==0.109.0
uvicorn==0.27.0
pypdf==4.0.1
````

### Hlavn√≠ Implementace

````python
import os
import logging
from typing import List, Dict, Optional
from pathlib import Path
import asyncio

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.document_loaders import PyPDFLoader, DirectoryLoader
from langchain_community.vectorstores import FAISS
from langchain_openai import OpenAIEmbeddings, ChatOpenAI
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate
from langchain.schema import Document
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from dotenv import load_dotenv
import json

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

load_dotenv()

class DocumentProcessor:
    """Zpracov√°n√≠ a p≈ô√≠prava dokument≈Ø pro RAG syst√©m."""
    
    def __init__(self, chunk_size: int = 1000, chunk_overlap: int = 200):
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=chunk_size,
            chunk_overlap=chunk_overlap,
            separators=["\n\n", "\n", ".", "!", "?", ",", " ", ""]
        )
    
    def load_documents(self, directory_path: str) -> List[Document]:
        """Naƒçte dokumenty z adres√°≈ôe."""
        try:
            # PDF loader
            pdf_loader = DirectoryLoader(
                directory_path,
                glob="**/*.pdf",
                loader_cls=PyPDFLoader
            )
            
            documents = pdf_loader.load()
            logger.info(f"Naƒçteno {len(documents)} dokument≈Ø z {directory_path}")
            return documents
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi naƒç√≠t√°n√≠ dokument≈Ø: {e}")
            return []
    
    def split_documents(self, documents: List[Document]) -> List[Document]:
        """Rozdƒõl√≠ dokumenty na men≈°√≠ chunks."""
        try:
            chunks = self.text_splitter.split_documents(documents)
            logger.info(f"Vytvo≈ôeno {len(chunks)} chunks z dokument≈Ø")
            return chunks
        except Exception as e:
            logger.error(f"Chyba p≈ôi rozdƒõlov√°n√≠ dokument≈Ø: {e}")
            return []

class VectorStore:
    """Spr√°va vektorov√© datab√°ze pro s√©mantick√© vyhled√°v√°n√≠."""
    
    def __init__(self, model_name: str = "text-embedding-ada-002"):
        self.embeddings = OpenAIEmbeddings(model=model_name)
        self.vectorstore = None
    
    def create_vectorstore(self, documents: List[Document]) -> bool:
        """Vytvo≈ô√≠ vektorovou datab√°zi z dokument≈Ø."""
        try:
            if not documents:
                logger.error("≈Ω√°dn√© dokumenty k indexov√°n√≠")
                return False
            
            self.vectorstore = FAISS.from_documents(
                documents, 
                self.embeddings
            )
            logger.info("Vektorov√° datab√°ze √∫spƒõ≈°nƒõ vytvo≈ôena")
            return True
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi vytv√°≈ôen√≠ vektorov√© datab√°ze: {e}")
            return False
    
    def save_vectorstore(self, path: str):
        """Ulo≈æ√≠ vektorovou datab√°zi na disk."""
        try:
            if self.vectorstore:
                self.vectorstore.save_local(path)
                logger.info(f"Vektorov√° datab√°ze ulo≈æena do {path}")
        except Exception as e:
            logger.error(f"Chyba p≈ôi ukl√°d√°n√≠ vektorov√© datab√°ze: {e}")
    
    def load_vectorstore(self, path: str) -> bool:
        """Naƒçte vektorovou datab√°zi z disku."""
        try:
            if Path(path).exists():
                self.vectorstore = FAISS.load_local(
                    path, 
                    self.embeddings,
                    allow_dangerous_deserialization=True
                )
                logger.info(f"Vektorov√° datab√°ze naƒçtena z {path}")
                return True
            return False
        except Exception as e:
            logger.error(f"Chyba p≈ôi naƒç√≠t√°n√≠ vektorov√© datab√°ze: {e}")
            return False

class RAGEngine:
    """Hlavn√≠ RAG engine pro generov√°n√≠ odpovƒõd√≠."""
    
    def __init__(self, vectorstore: VectorStore, model_name: str = "gpt-4"):
        self.vectorstore = vectorstore
        self.llm = ChatOpenAI(
            model_name=model_name,
            temperature=0.1,
            max_tokens=1000
        )
        self.qa_chain = None
        self._setup_qa_chain()
    
    def _setup_qa_chain(self):
        """Nastaven√≠ QA ≈ôetƒõzce s custom promptem."""
        czech_prompt = PromptTemplate(
            template="""Jsi AI asistent pro firemn√≠ znalosti. Odpov√≠dej v ƒçe≈°tinƒõ na z√°kladƒõ poskytnut√©ho kontextu.

Kontext:
{context}

Ot√°zka: {question}

Instrukce:
1. Odpov√≠dej pouze na z√°kladƒõ poskytnut√©ho kontextu
2. Pokud informace nen√≠ v kontextu, ≈ôekni to jasnƒõ
3. Buƒè konkr√©tn√≠ a p≈ôesn√Ω
4. Uveƒè zdroj informace, pokud je k dispozici
5. Odpov√≠dej profesion√°lnƒõ a srozumitelnƒõ

Odpovƒõƒè:""",
            input_variables=["context", "question"]
        )
        
        if self.vectorstore.vectorstore:
            retriever = self.vectorstore.vectorstore.as_retriever(
                search_type="similarity",
                search_kwargs={"k": 5}
            )
            
            self.qa_chain = RetrievalQA.from_chain_type(
                llm=self.llm,
                chain_type="stuff",
                retriever=retriever,
                chain_type_kwargs={"prompt": czech_prompt},
                return_source_documents=True
            )
    
    def get_answer(self, question: str) -> Dict[str, any]:
        """Z√≠sk√° odpovƒõƒè na ot√°zku."""
        try:
            if not self.qa_chain:
                return {
                    "answer": "RAG syst√©m nen√≠ spr√°vnƒõ nakonfigurov√°n.",
                    "sources": [],
                    "confidence": 0.0
                }
            
            result = self.qa_chain.invoke({"query": question})
            
            # Zpracov√°n√≠ zdroj≈Ø
            sources = []
            for doc in result.get("source_documents", []):
                sources.append({
                    "content": doc.page_content[:200] + "...",
                    "metadata": doc.metadata
                })
            
            return {
                "answer": result["result"],
                "sources": sources,
                "confidence": self._calculate_confidence(result)
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ odpovƒõdi: {e}")
            return {
                "answer": "Nastala chyba p≈ôi zpracov√°n√≠ dotazu.",
                "sources": [],
                "confidence": 0.0
            }
    
    def _calculate_confidence(self, result: Dict) -> float:
        """V√Ωpoƒçet spolehlivosti odpovƒõdi."""
        # Jednoduch√Ω algoritmus zalo≈æen√Ω na poƒçtu zdroj≈Ø
        num_sources = len(result.get("source_documents", []))
        return min(num_sources / 3.0, 1.0)

class SlackBot:
    """Slack integrace pro Enterprise Knowledge Assistant."""
    
    def __init__(self, rag_engine: RAGEngine, slack_token: str):
        self.rag_engine = rag_engine
        self.client = WebClient(token=slack_token)
        self.bot_user_id = None
    
    def start(self):
        """Spust√≠ Slack bot."""
        try:
            # Z√≠sk√°n√≠ bot user ID
            auth_response = self.client.auth_test()
            self.bot_user_id = auth_response["user_id"]
            logger.info(f"Slack bot spu≈°tƒõn s ID: {self.bot_user_id}")
            
        except SlackApiError as e:
            logger.error(f"Chyba p≈ôi autentizaci Slack bota: {e}")
    
    def handle_message(self, event: Dict):
        """Zpracuje zpr√°vu ze Slacku."""
        try:
            # Ignoruj zpr√°vy od bota
            if event.get("user") == self.bot_user_id:
                return
            
            channel = event["channel"]
            text = event["text"]
            user = event["user"]
            
            # Odebereme mention z textu
            if f"<@{self.bot_user_id}>" in text:
                text = text.replace(f"<@{self.bot_user_id}>", "").strip()
            
            logger.info(f"Zpracov√°v√°m dotaz od {user}: {text}")
            
            # Z√≠sk√°n√≠ odpovƒõdi z RAG syst√©mu
            response = self.rag_engine.get_answer(text)
            
            # Form√°tov√°n√≠ odpovƒõdi pro Slack
            formatted_response = self._format_slack_response(response, user)
            
            # Odesl√°n√≠ odpovƒõdi
            self.client.chat_postMessage(
                channel=channel,
                text=formatted_response,
                parse="mrkdwn"
            )
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi zpracov√°n√≠ Slack zpr√°vy: {e}")
    
    def _format_slack_response(self, response: Dict, user: str) -> str:
        """Form√°tuje odpovƒõƒè pro Slack."""
        answer = response["answer"]
        sources = response["sources"]
        confidence = response["confidence"]
        
        formatted = f"<@{user}> {answer}\n\n"
        
        if sources:
            formatted += "*Zdroje:*\n"
            for i, source in enumerate(sources[:3], 1):
                metadata = source.get("metadata", {})
                source_name = metadata.get("source", "Nezn√°m√Ω zdroj")
                formatted += f"{i}. {Path(source_name).name}\n"
        
        # Indik√°tor spolehlivosti
        confidence_emoji = "üü¢" if confidence > 0.7 else "üü°" if confidence > 0.4 else "üî¥"
        formatted += f"\n{confidence_emoji} Spolehlivost: {confidence:.0%}"
        
        return formatted

class EnterpriseKnowledgeAssistant:
    """Hlavn√≠ t≈ô√≠da Enterprise Knowledge Assistant."""
    
    def __init__(self, config: Dict[str, any]):
        self.config = config
        self.doc_processor = DocumentProcessor(
            chunk_size=config.get("chunk_size", 1000),
            chunk_overlap=config.get("chunk_overlap", 200)
        )
        self.vectorstore = VectorStore(
            model_name=config.get("embedding_model", "text-embedding-ada-002")
        )
        self.rag_engine = None
        self.slack_bot = None
    
    def setup(self, documents_path: str, vectorstore_path: str) -> bool:
        """Nastav√≠ cel√Ω syst√©m."""
        try:
            # Pokus o naƒçten√≠ existuj√≠c√≠ vektorov√© datab√°ze
            if not self.vectorstore.load_vectorstore(vectorstore_path):
                logger.info("Vytv√°≈ô√≠m novou vektorovou datab√°zi...")
                
                # Naƒçten√≠ a zpracov√°n√≠ dokument≈Ø
                documents = self.doc_processor.load_documents(documents_path)
                if not documents:
                    logger.error("≈Ω√°dn√© dokumenty k naƒçten√≠")
                    return False
                
                chunks = self.doc_processor.split_documents(documents)
                if not chunks:
                    logger.error("Nepoda≈ôilo se vytvo≈ôit chunks")
                    return False
                
                # Vytvo≈ôen√≠ vektorov√© datab√°ze
                if not self.vectorstore.create_vectorstore(chunks):
                    return False
                
                # Ulo≈æen√≠ datab√°ze
                self.vectorstore.save_vectorstore(vectorstore_path)
            
            # Nastaven√≠ RAG engine
            self.rag_engine = RAGEngine(
                self.vectorstore, 
                model_name=self.config.get("llm_model", "gpt-4")
            )
            
            # Nastaven√≠ Slack bota
            slack_token = self.config.get("slack_token")
            if slack_token:
                self.slack_bot = SlackBot(self.rag_engine, slack_token)
                self.slack_bot.start()
            
            logger.info("Enterprise Knowledge Assistant √∫spƒõ≈°nƒõ nastaven")
            return True
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi nastaven√≠ syst√©mu: {e}")
            return False
    
    def query(self, question: str) -> Dict[str, any]:
        """Zpracuje dotaz a vr√°t√≠ odpovƒõƒè."""
        if not self.rag_engine:
            return {
                "answer": "Syst√©m nen√≠ nastaven.",
                "sources": [],
                "confidence": 0.0
            }
        
        return self.rag_engine.get_answer(question)
````

### Testovac√≠ Data a Spu≈°tƒõn√≠

````python
import os
from pathlib import Path

def create_test_documents():
    """Vytvo≈ô√≠ testovac√≠ dokumenty pro demo."""
    docs_dir = Path("test_documents")
    docs_dir.mkdir(exist_ok=True)
    
    # Testovac√≠ dokumenty
    test_docs = {
        "company_policies.txt": """
        Firemn√≠ pravidla a z√°sady
        
        Pracovn√≠ doba: 8:00 - 16:00
        Pauza na obƒõd: 12:00 - 13:00
        Homeoffice: 2 dny v t√Ωdnu po dohodƒõ s vedouc√≠m
        
        IT bezpeƒçnost:
        - Povinn√© pou≈æ√≠v√°n√≠ VPN mimo kancel√°≈ô
        - Pravideln√° zmƒõna hesel ka≈æd√Ωch 90 dn√≠
        - Z√°kaz pou≈æ√≠v√°n√≠ USB za≈ô√≠zen√≠ bez schv√°len√≠ IT
        
        Dovolen√°:
        - 5 t√Ωdn≈Ø z√°kladn√≠ dovolen√©
        - ≈Ω√°dost o dovolenou minim√°lnƒõ 14 dn√≠ p≈ôedem
        - Sick days: a≈æ 5 dn√≠ roƒçnƒõ
        """,
        
        "it_handbook.txt": """
        IT P≈ô√≠ruƒçka pro zamƒõstnance
        
        Helpdesk: ext. 123, it-support@company.com
        
        ƒåast√© probl√©my:
        1. Zapomenut√© heslo - kontaktovat helpdesk
        2. Probl√©my s VPN - restartovat aplikaci
        3. Pomal√Ω internet - zkontrolovat p≈ôipojen√≠
        
        Software:
        - Microsoft Office 365
        - Slack pro komunikaci
        - Jira pro project management
        
        Hardware:
        - Nov√© vybaven√≠ objedn√°vat p≈ôes helpdesk
        - Servis a opravy - pouze autorizovan√© servisy
        """,
        
        "hr_procedures.txt": """
        HR Procedury
        
        N√°bor:
        1. Vytvo≈ôen√≠ job description
        2. Zve≈ôejnƒõn√≠ pozice (LinkedIn, jobs.cz)
        3. Screening kandid√°t≈Ø
        4. Interview proces (HR + technical)
        5. Reference check
        6. Job offer
        
        Onboarding:
        - Prvn√≠ den: IT setup, office tour
        - Prvn√≠ t√Ωden: HR training, safety
        - Prvn√≠ mƒõs√≠c: buddy program
        
        Performance review:
        - Prob√≠h√° 2x roƒçnƒõ
        - Self-assessment + manager review
        - C√≠le na dal≈°√≠ obdob√≠
        """
    }
    
    for filename, content in test_docs.items():
        with open(docs_dir / filename, "w", encoding="utf-8") as f:
            f.write(content)
    
    print(f"Testovac√≠ dokumenty vytvo≈ôeny v {docs_dir}")

if __name__ == "__main__":
    create_test_documents()
````

### Spou≈°tƒõc√≠ Script

````python
import os
from dotenv import load_dotenv
from knowledge_assistant import EnterpriseKnowledgeAssistant
from create_test_data import create_test_documents

def main():
    """Hlavn√≠ spou≈°tƒõc√≠ funkce."""
    load_dotenv()
    
    # Konfigurace
    config = {
        "chunk_size": 1000,
        "chunk_overlap": 200,
        "embedding_model": "text-embedding-ada-002",
        "llm_model": "gpt-4",
        "slack_token": os.getenv("SLACK_BOT_TOKEN")
    }
    
    # Vytvo≈ôen√≠ testovac√≠ch dat
    create_test_documents()
    
    # Inicializace asistenta
    assistant = EnterpriseKnowledgeAssistant(config)
    
    # Nastaven√≠ syst√©mu
    if assistant.setup("test_documents", "vectorstore"):
        print("‚úÖ Enterprise Knowledge Assistant je p≈ôipraven!")
        
        # Testovac√≠ dotazy
        test_queries = [
            "Jak√° je pracovn√≠ doba?",
            "Jak po≈æ√°dat o dovolenou?",
            "Kolik sick days m√°m?",
            "Jak kontaktovat IT support?",
            "Jak prob√≠h√° onboarding nov√Ωch zamƒõstnanc≈Ø?"
        ]
        
        print("\nüîç Testov√°n√≠ dotaz≈Ø:")
        for query in test_queries:
            print(f"\n‚ùì {query}")
            response = assistant.query(query)
            print(f"üí¨ {response['answer']}")
            if response['sources']:
                print(f"üìö Zdroje: {len(response['sources'])}")
            print(f"üìä Spolehlivost: {response['confidence']:.0%}")
    
    else:
        print("‚ùå Chyba p≈ôi nastavov√°n√≠ syst√©mu")

if __name__ == "__main__":
    main()
````

### Environment Configuration

````bash
OPENAI_API_KEY=your_openai_api_key_here
SLACK_BOT_TOKEN=xoxb-your-slack-bot-token-here
SLACK_APP_TOKEN=xapp-your-slack-app-token-here
````

## Shrnut√≠ Projektu

Enterprise Knowledge Assistant p≈ôedstavuje pokroƒçil√© ≈ôe≈°en√≠ pro automatizaci p≈ô√≠stupu k firemn√≠m znalostem pomoc√≠ RAG technologie. Syst√©m efektivnƒõ kombinuje s√≠lu velk√Ωch jazykov√Ωch model≈Ø s p≈ôesn√Ωm vyhled√°v√°n√≠m v dokumentech.

### Kl√≠ƒçov√© V√Ωhody:
- **Rychl√Ω p≈ô√≠stup k informac√≠m** - Okam≈æit√© odpovƒõdi na firemn√≠ dotazy
- **≈†k√°lovatelnost** - Zvl√°dne zpracov√°n√≠ tis√≠c≈Ø dokument≈Ø
- **Integrace do workflow** - P≈ôirozen√° integrace do Slack workspace
- **Contextual relevance** - Odpovƒõdi zalo≈æen√© na skuteƒçn√Ωch firemn√≠ch dokumentech

### Technick√© V√Ωhody:
- **Modul√°rn√≠ architektura** - Snadn√° roz≈°i≈ôitelnost a √∫dr≈æba
- **Error handling** - Robustn√≠ zpracov√°n√≠ chyb a logov√°n√≠
- **Performance optimized** - FAISS pro rychl√© vektorov√© vyhled√°v√°n√≠
- **Production ready** - Vƒçetnƒõ persistence a configuration management

Tento projekt demonstruje praktickou implementaci AI technologi√≠ v enterprise prost≈ôed√≠ s p≈ô√≠m√Ωm dopadem na produktivitu a efektivitu organizace.