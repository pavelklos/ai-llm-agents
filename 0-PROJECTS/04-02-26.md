<small>Claude Sonnet 4 **(AI-Powered Therapy Simulator)**</small>
# AI-Powered Therapy Simulator

## Key Concepts Explanation

### Empathetic AI Agents
Advanced conversational AI systems designed to understand, recognize, and respond appropriately to human emotions through natural language processing, sentiment analysis, and emotional intelligence modeling. These agents employ therapeutic communication techniques, active listening patterns, and empathetic response generation to create supportive, non-judgmental interactions that mirror professional therapeutic relationships.

### Therapeutic Memory Systems
Sophisticated memory architectures that maintain context across therapy sessions, tracking emotional patterns, progress indicators, recurring themes, and therapeutic goals. The system stores and retrieves relevant conversation history, emotional states, coping strategies, and breakthrough moments to provide continuity and personalized therapeutic experiences over time.

### Emotional Feedback Mechanisms
Real-time emotion detection and response systems that analyze user input for emotional indicators, mood patterns, and psychological states through sentiment analysis, emotional classification, and behavioral pattern recognition. Provides adaptive responses, mood tracking, and emotional validation while maintaining therapeutic boundaries and safety protocols.

### Cognitive Behavioral Therapy (CBT) Integration
Implementation of evidence-based therapeutic frameworks including CBT techniques, mindfulness exercises, cognitive restructuring, and behavioral activation strategies. The system guides users through structured therapeutic interventions, thought pattern analysis, and skills-building exercises based on established psychological methodologies.

### Crisis Detection and Safety Protocols
Intelligent monitoring systems that identify potential mental health crises, suicidal ideation, self-harm indicators, and emergency situations through pattern recognition and keyword analysis. Implements appropriate safety responses, resource provision, and professional referral protocols while maintaining user privacy and therapeutic trust.

### Therapeutic Session Management
Comprehensive session orchestration handling conversation flow, therapeutic technique selection, progress tracking, and intervention timing. Manages session structure, therapeutic goals, homework assignments, and follow-up scheduling while adapting to individual user needs and therapeutic progress.

## Comprehensive Project Explanation

### Objectives
The AI-Powered Therapy Simulator aims to provide accessible, confidential, and supportive mental health resources through sophisticated AI that can offer therapeutic conversations, emotional support, and evidence-based interventions while maintaining appropriate boundaries and safety standards for mental health care.

### Key Features
- **Empathetic Conversation Management**: Natural, supportive dialogue with emotional intelligence and therapeutic communication skills
- **Persistent Memory and Context**: Continuous tracking of user progress, patterns, and therapeutic history across sessions
- **Evidence-Based Interventions**: Integration of CBT, mindfulness, and other therapeutic techniques with guided exercises
- **Emotional State Monitoring**: Real-time emotion detection with mood tracking and pattern analysis
- **Crisis Safety Protocols**: Automatic detection of crisis situations with appropriate resource provision and referrals
- **Personalized Therapeutic Plans**: Adaptive treatment approaches based on individual needs and progress

### Challenges
- **Ethical Boundaries**: Maintaining appropriate therapeutic boundaries while avoiding replacement of professional care
- **Safety and Crisis Management**: Accurately detecting crisis situations and providing appropriate immediate responses
- **Emotional Accuracy**: Precisely understanding complex emotional states and providing appropriate empathetic responses
- **Privacy and Confidentiality**: Protecting sensitive mental health information while enabling therapeutic continuity
- **Cultural Sensitivity**: Adapting therapeutic approaches to diverse cultural backgrounds and belief systems
- **Professional Integration**: Complementing rather than replacing professional mental health care services

### Potential Impact
This system can increase mental health care accessibility, provide immediate support during crisis situations, reduce stigma around seeking help, offer continuous monitoring and support between professional sessions, and serve as an educational tool for understanding mental health concepts and coping strategies.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
langchain-community==0.0.10
chromadb==0.4.18
sentence-transformers==2.2.2
numpy==1.24.3
pandas==2.1.4
matplotlib==3.8.2
seaborn==0.13.0
plotly==5.17.0
nltk==3.8.1
textblob==0.17.1
vaderSentiment==3.3.2
transformers==4.36.0
torch==2.1.0
scikit-learn==1.3.2
datetime
uuid
logging
typing
dataclasses
enum
re
json
hashlib
asyncio
````

### Core Implementation

````python
import os
import json
import uuid
import logging
import hashlib
import re
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go

# NLP and sentiment analysis
import nltk
from textblob import TextBlob
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification

# Vector storage and similarity
import chromadb
from sentence_transformers import SentenceTransformer

# LangChain components
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.memory import ConversationSummaryBufferMemory
from langchain_community.vectorstores import Chroma

# ML utilities
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EmotionalState(Enum):
    HAPPY = "happy"
    SAD = "sad"
    ANGRY = "angry"
    ANXIOUS = "anxious"
    FEARFUL = "fearful"
    CONFUSED = "confused"
    HOPEFUL = "hopeful"
    FRUSTRATED = "frustrated"
    CALM = "calm"
    OVERWHELMED = "overwhelmed"

class CrisisLevel(Enum):
    LOW = "low"
    MODERATE = "moderate"
    HIGH = "high"
    CRITICAL = "critical"

class TherapeuticTechnique(Enum):
    CBT = "cognitive_behavioral_therapy"
    MINDFULNESS = "mindfulness"
    ACTIVE_LISTENING = "active_listening"
    COGNITIVE_RESTRUCTURING = "cognitive_restructuring"
    BEHAVIORAL_ACTIVATION = "behavioral_activation"
    GROUNDING = "grounding_techniques"
    VALIDATION = "emotional_validation"

class SessionPhase(Enum):
    OPENING = "opening"
    EXPLORATION = "exploration"
    INTERVENTION = "intervention"
    INTEGRATION = "integration"
    CLOSING = "closing"

@dataclass
class EmotionalAnalysis:
    primary_emotion: EmotionalState
    emotion_intensity: float  # 0-1
    sentiment_score: float  # -1 to 1
    emotional_complexity: float  # 0-1
    crisis_indicators: List[str]
    crisis_level: CrisisLevel
    confidence: float

@dataclass
class TherapeuticGoal:
    goal_id: str
    description: str
    target_behaviors: List[str]
    progress_metrics: Dict[str, float]
    created_date: datetime
    target_date: Optional[datetime] = None
    status: str = "active"

@dataclass
class SessionNote:
    session_id: str
    timestamp: datetime
    user_input: str
    ai_response: str
    emotional_state: EmotionalState
    techniques_used: List[TherapeuticTechnique]
    crisis_level: CrisisLevel
    progress_indicators: Dict[str, float]
    session_phase: SessionPhase
    key_insights: List[str] = field(default_factory=list)

@dataclass
class UserProfile:
    user_id: str
    created_date: datetime
    goals: List[TherapeuticGoal]
    session_history: List[SessionNote]
    emotional_patterns: Dict[str, Any]
    coping_strategies: List[str]
    triggers: List[str]
    preferences: Dict[str, Any]
    safety_plan: Dict[str, Any] = field(default_factory=dict)

class EmotionalAnalyzer:
    """Analyzes emotional content and crisis indicators in user messages."""
    
    def __init__(self):
        # Initialize sentiment analyzers
        self.vader_analyzer = SentimentIntensityAnalyzer()
        
        # Download required NLTK data
        try:
            nltk.download('vader_lexicon', quiet=True)
            nltk.download('punkt', quiet=True)
        except:
            pass
        
        # Initialize emotion classifier
        try:
            self.emotion_classifier = pipeline(
                "text-classification",
                model="j-hartmann/emotion-english-distilroberta-base",
                device=-1  # CPU
            )
        except:
            logger.warning("Emotion classifier not available")
            self.emotion_classifier = None
        
        # Crisis indicators
        self.crisis_keywords = {
            CrisisLevel.CRITICAL: [
                'suicide', 'kill myself', 'end my life', 'want to die',
                'harm myself', 'self-harm', 'cut myself', 'overdose'
            ],
            CrisisLevel.HIGH: [
                'hopeless', 'worthless', 'no point', 'give up',
                'can\'t go on', 'nothing matters', 'better off dead'
            ],
            CrisisLevel.MODERATE: [
                'very depressed', 'extremely sad', 'panic attack',
                'can\'t cope', 'losing control', 'scared'
            ]
        }
        
        # Emotion mapping
        self.emotion_mapping = {
            'joy': EmotionalState.HAPPY,
            'happiness': EmotionalState.HAPPY,
            'sadness': EmotionalState.SAD,
            'anger': EmotionalState.ANGRY,
            'fear': EmotionalState.FEARFUL,
            'anxiety': EmotionalState.ANXIOUS,
            'surprise': EmotionalState.CONFUSED,
            'disgust': EmotionalState.FRUSTRATED
        }
    
    def analyze_emotional_content(self, text: str) -> EmotionalAnalysis:
        """Comprehensive emotional analysis of user input."""
        try:
            # Basic sentiment analysis
            vader_scores = self.vader_analyzer.polarity_scores(text)
            sentiment_score = vader_scores['compound']
            
            # Emotion classification
            primary_emotion, emotion_intensity = self._classify_emotion(text)
            
            # Crisis detection
            crisis_indicators, crisis_level = self._detect_crisis_indicators(text)
            
            # Calculate emotional complexity
            emotional_complexity = self._calculate_emotional_complexity(text)
            
            # Overall confidence
            confidence = self._calculate_confidence(text, vader_scores)
            
            return EmotionalAnalysis(
                primary_emotion=primary_emotion,
                emotion_intensity=emotion_intensity,
                sentiment_score=sentiment_score,
                emotional_complexity=emotional_complexity,
                crisis_indicators=crisis_indicators,
                crisis_level=crisis_level,
                confidence=confidence
            )
            
        except Exception as e:
            logger.error(f"Emotional analysis error: {e}")
            return self._create_default_analysis()
    
    def _classify_emotion(self, text: str) -> Tuple[EmotionalState, float]:
        """Classify primary emotion and intensity."""
        if self.emotion_classifier:
            try:
                results = self.emotion_classifier(text)
                if results:
                    top_emotion = results[0]
                    emotion_label = top_emotion['label'].lower()
                    intensity = top_emotion['score']
                    
                    # Map to our emotion states
                    mapped_emotion = self.emotion_mapping.get(
                        emotion_label, EmotionalState.CALM
                    )
                    
                    return mapped_emotion, intensity
            except:
                pass
        
        # Fallback: sentiment-based emotion classification
        blob = TextBlob(text)
        polarity = blob.sentiment.polarity
        
        if polarity > 0.3:
            return EmotionalState.HAPPY, abs(polarity)
        elif polarity < -0.3:
            return EmotionalState.SAD, abs(polarity)
        else:
            return EmotionalState.CALM, 0.5
    
    def _detect_crisis_indicators(self, text: str) -> Tuple[List[str], CrisisLevel]:
        """Detect crisis indicators and determine crisis level."""
        text_lower = text.lower()
        detected_indicators = []
        max_crisis_level = CrisisLevel.LOW
        
        # Check for crisis keywords
        for level, keywords in self.crisis_keywords.items():
            for keyword in keywords:
                if keyword in text_lower:
                    detected_indicators.append(keyword)
                    if level.value > max_crisis_level.value:
                        max_crisis_level = level
        
        # Additional pattern matching
        crisis_patterns = [
            r'\bi\s+want\s+to\s+die\b',
            r'\bkill\s+myself\b',
            r'\bend\s+it\s+all\b',
            r'\bno\s+hope\b',
            r'\bcan\'?t\s+take\s+it\b'
        ]
        
        for pattern in crisis_patterns:
            if re.search(pattern, text_lower):
                detected_indicators.append(f"pattern: {pattern}")
                if max_crisis_level == CrisisLevel.LOW:
                    max_crisis_level = CrisisLevel.MODERATE
        
        return detected_indicators, max_crisis_level
    
    def _calculate_emotional_complexity(self, text: str) -> float:
        """Calculate emotional complexity based on mixed emotions."""
        if not self.emotion_classifier:
            return 0.5
        
        try:
            results = self.emotion_classifier(text)
            if len(results) > 1:
                # Calculate entropy of emotion probabilities
                scores = [result['score'] for result in results]
                entropy = -sum(p * np.log2(p + 1e-10) for p in scores)
                return min(entropy / np.log2(len(scores)), 1.0)
        except:
            pass
        
        return 0.5
    
    def _calculate_confidence(self, text: str, vader_scores: Dict) -> float:
        """Calculate overall confidence in analysis."""
        # Base confidence on text length and vader certainty
        text_length_score = min(len(text.split()) / 20, 1.0)
        vader_certainty = max(abs(vader_scores['pos'] - vader_scores['neg']), 0.1)
        
        return (text_length_score + vader_certainty) / 2
    
    def _create_default_analysis(self) -> EmotionalAnalysis:
        """Create default analysis for error cases."""
        return EmotionalAnalysis(
            primary_emotion=EmotionalState.CALM,
            emotion_intensity=0.5,
            sentiment_score=0.0,
            emotional_complexity=0.5,
            crisis_indicators=[],
            crisis_level=CrisisLevel.LOW,
            confidence=0.3
        )

class TherapeuticMemory:
    """Manages therapeutic context and session memory."""
    
    def __init__(self, embedding_model: str = "all-MiniLM-L6-v2"):
        # Initialize embedding model
        self.embedding_model = SentenceTransformer(embedding_model)
        
        # Initialize vector database
        self.chroma_client = chromadb.Client()
        try:
            self.collection = self.chroma_client.get_collection("therapy_sessions")
        except:
            self.collection = self.chroma_client.create_collection(
                name="therapy_sessions",
                metadata={"description": "Therapeutic session memories"}
            )
        
        # Session context
        self.current_session_context = {}
        self.conversation_buffer = []
        
    def store_session_memory(self, session_note: SessionNote, user_id: str):
        """Store session memory in vector database."""
        try:
            # Create document for storage
            document = f"Session {session_note.session_id}: User said '{session_note.user_input}'. AI responded with therapeutic approach using {', '.join([t.value for t in session_note.techniques_used])}. Emotional state: {session_note.emotional_state.value}. Key insights: {', '.join(session_note.key_insights)}"
            
            # Generate embedding
            embedding = self.embedding_model.encode(document).tolist()
            
            # Store in vector database
            self.collection.add(
                documents=[document],
                embeddings=[embedding],
                metadatas=[{
                    "user_id": user_id,
                    "session_id": session_note.session_id,
                    "timestamp": session_note.timestamp.isoformat(),
                    "emotional_state": session_note.emotional_state.value,
                    "crisis_level": session_note.crisis_level.value,
                    "techniques_used": json.dumps([t.value for t in session_note.techniques_used])
                }],
                ids=[f"{user_id}_{session_note.session_id}_{session_note.timestamp.timestamp()}"]
            )
            
        except Exception as e:
            logger.error(f"Memory storage error: {e}")
    
    def retrieve_relevant_memories(self, query: str, user_id: str, n_results: int = 5) -> List[Dict]:
        """Retrieve relevant past session memories."""
        try:
            # Generate query embedding
            query_embedding = self.embedding_model.encode(query).tolist()
            
            # Search for relevant memories
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results,
                where={"user_id": user_id}
            )
            
            # Format results
            memories = []
            if results['documents']:
                for i, document in enumerate(results['documents'][0]):
                    metadata = results['metadatas'][0][i]
                    memories.append({
                        'content': document,
                        'metadata': metadata,
                        'similarity': results['distances'][0][i] if 'distances' in results else 0.0
                    })
            
            return memories
            
        except Exception as e:
            logger.error(f"Memory retrieval error: {e}")
            return []
    
    def update_session_context(self, key: str, value: Any):
        """Update current session context."""
        self.current_session_context[key] = value
    
    def get_session_summary(self, user_id: str, last_n_sessions: int = 3) -> str:
        """Generate summary of recent sessions."""
        try:
            # Retrieve recent memories
            recent_memories = self.collection.query(
                query_embeddings=[self.embedding_model.encode("recent session summary").tolist()],
                n_results=last_n_sessions * 5,
                where={"user_id": user_id}
            )
            
            if not recent_memories['documents']:
                return "No previous session history available."
            
            # Combine recent session content
            session_content = []
            for document in recent_memories['documents'][0][:last_n_sessions * 2]:
                session_content.append(document)
            
            summary = f"Recent session themes: {' | '.join(session_content[:3])}"
            return summary
            
        except Exception as e:
            logger.error(f"Session summary error: {e}")
            return "Unable to retrieve session summary."

class TherapeuticAgent:
    """Main therapeutic AI agent with empathetic responses."""
    
    def __init__(self, openai_api_key: str = None):
        self.emotional_analyzer = EmotionalAnalyzer()
        self.memory_system = TherapeuticMemory()
        
        # Initialize LLM
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.7,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        else:
            self.llm = None
        
        # Therapeutic techniques
        self.therapeutic_techniques = {
            TherapeuticTechnique.CBT: self._apply_cbt_technique,
            TherapeuticTechnique.MINDFULNESS: self._apply_mindfulness_technique,
            TherapeuticTechnique.ACTIVE_LISTENING: self._apply_active_listening,
            TherapeuticTechnique.COGNITIVE_RESTRUCTURING: self._apply_cognitive_restructuring,
            TherapeuticTechnique.GROUNDING: self._apply_grounding_technique,
            TherapeuticTechnique.VALIDATION: self._apply_validation
        }
        
        # Crisis resources
        self.crisis_resources = {
            CrisisLevel.CRITICAL: [
                "National Suicide Prevention Lifeline: 988",
                "Crisis Text Line: Text HOME to 741741",
                "Emergency Services: 911"
            ],
            CrisisLevel.HIGH: [
                "National Suicide Prevention Lifeline: 988",
                "Crisis Text Line: Text HOME to 741741",
                "SAMHSA Helpline: 1-800-662-4357"
            ],
            CrisisLevel.MODERATE: [
                "Crisis Text Line: Text HOME to 741741",
                "SAMHSA Helpline: 1-800-662-4357"
            ]
        }
        
        # Initialize prompts
        self._initialize_therapeutic_prompts()
    
    def _initialize_therapeutic_prompts(self):
        """Initialize therapeutic conversation prompts."""
        self.therapeutic_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are a highly trained, empathetic AI therapy assistant. Your role is to provide supportive, 
            non-judgmental therapeutic conversation while maintaining appropriate boundaries.
            
            Core Principles:
            1. Always maintain empathy and validation
            2. Use evidence-based therapeutic techniques
            3. Recognize and respond to emotional states
            4. Maintain professional boundaries
            5. Prioritize user safety and well-being
            6. Encourage professional help when appropriate
            
            Current session context:
            - User's emotional state: {emotional_state}
            - Crisis level: {crisis_level}
            - Session phase: {session_phase}
            - Previous context: {session_context}
            - Relevant memories: {relevant_memories}
            
            Therapeutic approach to use: {therapeutic_technique}
            
            Remember:
            - This is NOT a replacement for professional therapy
            - Encourage professional help for serious concerns
            - Provide crisis resources when needed
            - Maintain confidentiality and respect
            """),
            HumanMessagePromptTemplate.from_template("{user_input}")
        ])
        
        self.crisis_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            CRISIS RESPONSE MODE ACTIVATED
            
            The user has expressed content indicating a mental health crisis. Your response must:
            1. Acknowledge their pain with deep empathy
            2. Validate their feelings without judgment
            3. Emphasize that help is available
            4. Provide immediate crisis resources
            5. Encourage immediate professional contact
            6. Express hope and care
            
            Crisis level: {crisis_level}
            Crisis indicators: {crisis_indicators}
            
            Be gentle, caring, and direct about the importance of getting help.
            """),
            HumanMessagePromptTemplate.from_template("{user_input}")
        ])
    
    def process_therapeutic_interaction(self, user_input: str, user_id: str, 
                                     session_id: str = None) -> Dict[str, Any]:
        """Process user input and generate therapeutic response."""
        try:
            if not session_id:
                session_id = str(uuid.uuid4())
            
            # Analyze emotional content
            emotional_analysis = self.emotional_analyzer.analyze_emotional_content(user_input)
            
            # Handle crisis situations
            if emotional_analysis.crisis_level in [CrisisLevel.HIGH, CrisisLevel.CRITICAL]:
                return self._handle_crisis_response(
                    user_input, emotional_analysis, user_id, session_id
                )
            
            # Retrieve relevant memories
            relevant_memories = self.memory_system.retrieve_relevant_memories(
                user_input, user_id, n_results=3
            )
            
            # Select appropriate therapeutic technique
            technique = self._select_therapeutic_technique(emotional_analysis, relevant_memories)
            
            # Generate therapeutic response
            response = self._generate_therapeutic_response(
                user_input, emotional_analysis, technique, relevant_memories, user_id
            )
            
            # Create session note
            session_note = SessionNote(
                session_id=session_id,
                timestamp=datetime.now(),
                user_input=user_input,
                ai_response=response,
                emotional_state=emotional_analysis.primary_emotion,
                techniques_used=[technique],
                crisis_level=emotional_analysis.crisis_level,
                progress_indicators=self._calculate_progress_indicators(emotional_analysis),
                session_phase=SessionPhase.EXPLORATION,
                key_insights=self._extract_key_insights(user_input, emotional_analysis)
            )
            
            # Store in memory
            self.memory_system.store_session_memory(session_note, user_id)
            
            return {
                'response': response,
                'emotional_analysis': emotional_analysis,
                'technique_used': technique,
                'session_note': session_note,
                'crisis_level': emotional_analysis.crisis_level,
                'recommendations': self._generate_recommendations(emotional_analysis)
            }
            
        except Exception as e:
            logger.error(f"Therapeutic interaction error: {e}")
            return self._create_error_response()
    
    def _handle_crisis_response(self, user_input: str, emotional_analysis: EmotionalAnalysis,
                               user_id: str, session_id: str) -> Dict[str, Any]:
        """Handle crisis-level responses with immediate resources."""
        try:
            if self.llm:
                crisis_response = self.llm.invoke(self.crisis_prompt.format(
                    crisis_level=emotional_analysis.crisis_level.value,
                    crisis_indicators=', '.join(emotional_analysis.crisis_indicators),
                    user_input=user_input
                ))
                response = crisis_response.content
            else:
                response = self._generate_crisis_fallback_response(emotional_analysis)
            
            # Add crisis resources
            resources = self.crisis_resources.get(emotional_analysis.crisis_level, [])
            if resources:
                response += f"\n\nImmediate Resources:\n" + "\n".join(f"‚Ä¢ {resource}" for resource in resources)
            
            # Create crisis session note
            session_note = SessionNote(
                session_id=session_id,
                timestamp=datetime.now(),
                user_input=user_input,
                ai_response=response,
                emotional_state=emotional_analysis.primary_emotion,
                techniques_used=[TherapeuticTechnique.VALIDATION],
                crisis_level=emotional_analysis.crisis_level,
                progress_indicators={'crisis_detected': 1.0},
                session_phase=SessionPhase.EXPLORATION,
                key_insights=['Crisis situation detected', 'Immediate support provided']
            )
            
            # Store crisis interaction
            self.memory_system.store_session_memory(session_note, user_id)
            
            return {
                'response': response,
                'emotional_analysis': emotional_analysis,
                'technique_used': TherapeuticTechnique.VALIDATION,
                'session_note': session_note,
                'crisis_level': emotional_analysis.crisis_level,
                'is_crisis': True,
                'crisis_resources': resources
            }
            
        except Exception as e:
            logger.error(f"Crisis response error: {e}")
            return self._create_crisis_error_response()
    
    def _select_therapeutic_technique(self, emotional_analysis: EmotionalAnalysis,
                                    relevant_memories: List[Dict]) -> TherapeuticTechnique:
        """Select appropriate therapeutic technique based on context."""
        # Crisis handling
        if emotional_analysis.crisis_level != CrisisLevel.LOW:
            return TherapeuticTechnique.VALIDATION
        
        # Emotion-based technique selection
        technique_mapping = {
            EmotionalState.ANXIOUS: TherapeuticTechnique.GROUNDING,
            EmotionalState.SAD: TherapeuticTechnique.VALIDATION,
            EmotionalState.ANGRY: TherapeuticTechnique.COGNITIVE_RESTRUCTURING,
            EmotionalState.OVERWHELMED: TherapeuticTechnique.MINDFULNESS,
            EmotionalState.CONFUSED: TherapeuticTechnique.ACTIVE_LISTENING,
            EmotionalState.FRUSTRATED: TherapeuticTechnique.CBT
        }
        
        selected_technique = technique_mapping.get(
            emotional_analysis.primary_emotion,
            TherapeuticTechnique.ACTIVE_LISTENING
        )
        
        # Adjust based on recent history
        if relevant_memories:
            recent_techniques = []
            for memory in relevant_memories[:2]:
                metadata = memory.get('metadata', {})
                if 'techniques_used' in metadata:
                    try:
                        techniques = json.loads(metadata['techniques_used'])
                        recent_techniques.extend(techniques)
                    except:
                        pass
            
            # Avoid repeating the same technique too often
            if selected_technique.value in recent_techniques[-3:]:
                alternatives = [t for t in TherapeuticTechnique if t != selected_technique]
                if alternatives:
                    selected_technique = alternatives[0]
        
        return selected_technique
    
    def _generate_therapeutic_response(self, user_input: str, emotional_analysis: EmotionalAnalysis,
                                     technique: TherapeuticTechnique, relevant_memories: List[Dict],
                                     user_id: str) -> str:
        """Generate therapeutic response using selected technique."""
        try:
            if self.llm:
                # Prepare context
                session_context = self.memory_system.get_session_summary(user_id)
                memory_context = " | ".join([mem['content'][:100] for mem in relevant_memories[:2]])
                
                response = self.llm.invoke(self.therapeutic_prompt.format(
                    emotional_state=emotional_analysis.primary_emotion.value,
                    crisis_level=emotional_analysis.crisis_level.value,
                    session_phase=SessionPhase.EXPLORATION.value,
                    session_context=session_context,
                    relevant_memories=memory_context,
                    therapeutic_technique=technique.value,
                    user_input=user_input
                ))
                
                base_response = response.content
            else:
                base_response = self._generate_fallback_response(emotional_analysis)
            
            # Apply specific therapeutic technique
            technique_enhancement = self.therapeutic_techniques.get(technique, lambda x, y: "")
            enhanced_response = technique_enhancement(base_response, emotional_analysis)
            
            return enhanced_response if enhanced_response else base_response
            
        except Exception as e:
            logger.error(f"Response generation error: {e}")
            return self._generate_fallback_response(emotional_analysis)
    
    def _apply_cbt_technique(self, base_response: str, emotional_analysis: EmotionalAnalysis) -> str:
        """Apply CBT techniques to the response."""
        cbt_additions = [
            "\n\nLet's explore the thoughts behind these feelings. What thoughts went through your mind when this happened?",
            "\n\nCan we examine whether this thought is helpful or realistic? Sometimes our first thoughts aren't the whole story.",
            "\n\nWhat evidence do you have for and against this thought?"
        ]
        
        if emotional_analysis.sentiment_score < -0.3:
            return base_response + cbt_additions[0]
        elif emotional_analysis.primary_emotion == EmotionalState.ANXIOUS:
            return base_response + cbt_additions[1]
        else:
            return base_response + cbt_additions[2]
    
    def _apply_mindfulness_technique(self, base_response: str, emotional_analysis: EmotionalAnalysis) -> str:
        """Apply mindfulness techniques."""
        mindfulness_exercises = [
            "\n\nLet's try a brief mindfulness exercise. Can you take three deep breaths with me and notice what you're experiencing right now?",
            "\n\nWhat are you noticing in your body right now? Sometimes tuning into physical sensations can help ground us.",
            "\n\nCan you observe these feelings without trying to change them? Just notice them with curiosity and kindness."
        ]
        
        return base_response + mindfulness_exercises[0]
    
    def _apply_active_listening(self, base_response: str, emotional_analysis: EmotionalAnalysis) -> str:
        """Apply active listening techniques."""
        listening_responses = [
            "\n\nI hear that you're really struggling with this. Can you tell me more about what this experience is like for you?",
            "\n\nIt sounds like this is really important to you. What matters most to you about this situation?",
            "\n\nI want to make sure I understand. You're feeling [emotion] because [situation]. Is that right?"
        ]
        
        emotion = emotional_analysis.primary_emotion.value
        return base_response + listening_responses[0].replace('[emotion]', emotion)
    
    def _apply_cognitive_restructuring(self, base_response: str, emotional_analysis: EmotionalAnalysis) -> str:
        """Apply cognitive restructuring techniques."""
        restructuring_prompts = [
            "\n\nWhat would you tell a friend who was going through the same situation?",
            "\n\nAre there other ways to look at this situation? What might be some alternative perspectives?",
            "\n\nWhat would be a more balanced way to think about this?"
        ]
        
        return base_response + restructuring_prompts[0]
    
    def _apply_grounding_technique(self, base_response: str, emotional_analysis: EmotionalAnalysis) -> str:
        """Apply grounding techniques for anxiety."""
        grounding_exercise = "\n\nLet's try the 5-4-3-2-1 grounding technique: Name 5 things you can see, 4 things you can touch, 3 things you can hear, 2 things you can smell, and 1 thing you can taste."
        
        return base_response + grounding_exercise
    
    def _apply_validation(self, base_response: str, emotional_analysis: EmotionalAnalysis) -> str:
        """Apply emotional validation."""
        validation_statements = [
            f"\n\nYour feelings of {emotional_analysis.primary_emotion.value} are completely valid and understandable.",
            "\n\nIt makes perfect sense that you would feel this way given what you're going through.",
            "\n\nThank you for sharing something so personal with me. Your courage in speaking about this is admirable."
        ]
        
        return base_response + validation_statements[0]
    
    def _calculate_progress_indicators(self, emotional_analysis: EmotionalAnalysis) -> Dict[str, float]:
        """Calculate session progress indicators."""
        return {
            'emotional_awareness': emotional_analysis.confidence,
            'crisis_stability': 1.0 - (emotional_analysis.crisis_level.value / 4),
            'engagement_level': min(emotional_analysis.emotion_intensity + 0.3, 1.0),
            'emotional_regulation': 1.0 - emotional_analysis.emotion_intensity if emotional_analysis.sentiment_score < 0 else emotional_analysis.emotion_intensity
        }
    
    def _extract_key_insights(self, user_input: str, emotional_analysis: EmotionalAnalysis) -> List[str]:
        """Extract key insights from the interaction."""
        insights = []
        
        # Emotional insights
        if emotional_analysis.emotion_intensity > 0.7:
            insights.append(f"High emotional intensity detected: {emotional_analysis.primary_emotion.value}")
        
        if emotional_analysis.emotional_complexity > 0.6:
            insights.append("Complex emotional state with mixed feelings")
        
        # Content insights
        if len(user_input.split()) > 50:
            insights.append("Detailed sharing - strong engagement")
        
        # Crisis insights
        if emotional_analysis.crisis_indicators:
            insights.append("Crisis indicators present - safety focus needed")
        
        return insights
    
    def _generate_recommendations(self, emotional_analysis: EmotionalAnalysis) -> List[str]:
        """Generate session recommendations."""
        recommendations = []
        
        if emotional_analysis.crisis_level != CrisisLevel.LOW:
            recommendations.append("Consider professional crisis support")
        
        if emotional_analysis.primary_emotion == EmotionalState.ANXIOUS:
            recommendations.append("Practice grounding techniques between sessions")
        elif emotional_analysis.primary_emotion == EmotionalState.SAD:
            recommendations.append("Consider mood tracking and self-care activities")
        
        if emotional_analysis.emotional_complexity > 0.6:
            recommendations.append("Explore mixed emotions in future sessions")
        
        return recommendations
    
    def _generate_fallback_response(self, emotional_analysis: EmotionalAnalysis) -> str:
        """Generate fallback response when LLM unavailable."""
        emotion = emotional_analysis.primary_emotion.value
        
        fallback_responses = {
            EmotionalState.SAD: f"I can hear the sadness in your words, and I want you to know that your feelings are valid. It's okay to feel {emotion} sometimes.",
            EmotionalState.ANXIOUS: f"I notice you're feeling {emotion}, and that can be really difficult. You're not alone in this feeling.",
            EmotionalState.ANGRY: f"It sounds like you're experiencing {emotion}, and that's understandable. These feelings are telling us something important.",
            EmotionalState.HAPPY: f"I'm glad to hear some positivity in your message. It's wonderful when we can experience {emotion}.",
        }
        
        return fallback_responses.get(
            emotional_analysis.primary_emotion,
            f"Thank you for sharing your feelings with me. I'm here to listen and support you through whatever you're experiencing."
        )
    
    def _generate_crisis_fallback_response(self, emotional_analysis: EmotionalAnalysis) -> str:
        """Generate crisis fallback response."""
        return """I'm deeply concerned about what you're sharing with me. Your pain is real and valid, but I want you to know that you don't have to go through this alone. 

There are people who care and want to help you right now. Please consider reaching out to a crisis counselor who can provide immediate support.

Your life has value, and there are ways to work through these feelings. Professional help can make a real difference."""
    
    def _create_error_response(self) -> Dict[str, Any]:
        """Create error response."""
        return {
            'response': "I'm having some technical difficulties right now, but I want you to know that I'm here for you. If you're in crisis, please contact emergency services or a crisis hotline immediately.",
            'emotional_analysis': self.emotional_analyzer._create_default_analysis(),
            'technique_used': TherapeuticTechnique.VALIDATION,
            'crisis_level': CrisisLevel.LOW,
            'error': True
        }
    
    def _create_crisis_error_response(self) -> Dict[str, Any]:
        """Create crisis error response."""
        return {
            'response': "I'm experiencing technical difficulties, but your safety is my priority. Please contact emergency services (911) or the National Suicide Prevention Lifeline (988) immediately for support.",
            'is_crisis': True,
            'crisis_resources': self.crisis_resources[CrisisLevel.CRITICAL],
            'error': True
        }

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="AI Therapy Simulator",
        page_icon="üß†",
        layout="wide"
    )
    
    st.title("üß† AI-Powered Therapy Simulator")
    st.markdown("A supportive AI companion for mental health conversations and emotional support")
    
    # Disclaimer
    st.warning("""
    ‚ö†Ô∏è **Important Disclaimer**: This AI system is for educational and support purposes only. 
    It is NOT a replacement for professional mental healthcare. If you're experiencing a mental health crisis, 
    please contact emergency services or a mental health professional immediately.
    
    **Crisis Resources:**
    - National Suicide Prevention Lifeline: 988
    - Crisis Text Line: Text HOME to 741741
    - Emergency Services: 911
    """)
    
    # Initialize session state
    if 'user_id' not in st.session_state:
        st.session_state['user_id'] = str(uuid.uuid4())
    
    if 'session_id' not in st.session_state:
        st.session_state['session_id'] = str(uuid.uuid4())
    
    if 'conversation_history' not in st.session_state:
        st.session_state['conversation_history'] = []
    
    if 'therapeutic_agent' not in st.session_state:
        openai_key = st.sidebar.text_input("OpenAI API Key (Optional)", type="password")
        with st.spinner("Initializing AI Therapy System..."):
            st.session_state['therapeutic_agent'] = TherapeuticAgent(openai_key)
    
    agent = st.session_state['therapeutic_agent']
    
    # Sidebar
    with st.sidebar:
        st.header("üíô Session Info")
        
        st.write(f"**Session ID:** {st.session_state['session_id'][:8]}...")
        st.write(f"**Messages:** {len(st.session_state['conversation_history'])}")
        
        if st.button("üîÑ New Session"):
            st.session_state['session_id'] = str(uuid.uuid4())
            st.session_state['conversation_history'] = []
            st.rerun()
        
        st.header("üÜò Crisis Resources")
        st.markdown("""
        **Immediate Help:**
        - üÜò Emergency: 911
        - ‚òéÔ∏è Suicide Prevention: 988
        - üí¨ Crisis Text: Text HOME to 741741
        - üß† SAMHSA: 1-800-662-4357
        """)
        
        st.header("‚ÑπÔ∏è How to Use")
        st.markdown("""
        1. Share your thoughts and feelings openly
        2. The AI will respond with empathy and support
        3. Try different therapeutic techniques
        4. Remember: This supplements, not replaces, professional care
        """)
    
    # Main interface
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.header("üí¨ Therapeutic Conversation")
        
        # Chat interface
        for i, entry in enumerate(st.session_state['conversation_history']):
            # User message
            st.chat_message("user").write(entry['user_input'])
            
            # AI response
            with st.chat_message("assistant"):
                st.write(entry['ai_response'])
                
                # Show emotional analysis if available
                if 'emotional_analysis' in entry:
                    ea = entry['emotional_analysis']
                    with st.expander("üìä Emotional Analysis"):
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("Primary Emotion", ea.primary_emotion.value.title())
                        with col2:
                            st.metric("Intensity", f"{ea.emotion_intensity:.1%}")
                        with col3:
                            st.metric("Crisis Level", ea.crisis_level.value.title())
        
        # Input area
        user_input = st.chat_input("Share your thoughts and feelings...")
        
        if user_input:
            with st.spinner("Processing your message with care..."):
                # Process with therapeutic agent
                result = agent.process_therapeutic_interaction(
                    user_input,
                    st.session_state['user_id'],
                    st.session_state['session_id']
                )
                
                # Add to conversation history
                conversation_entry = {
                    'user_input': user_input,
                    'ai_response': result['response'],
                    'emotional_analysis': result.get('emotional_analysis'),
                    'technique_used': result.get('technique_used'),
                    'timestamp': datetime.now(),
                    'crisis_level': result.get('crisis_level')
                }
                
                st.session_state['conversation_history'].append(conversation_entry)
                
                # Handle crisis situations
                if result.get('is_crisis'):
                    st.error("üÜò **Crisis Detected** - Please consider immediate professional support")
                    if 'crisis_resources' in result:
                        st.info("**Immediate Resources:**\n" + "\n".join(result['crisis_resources']))
                
                st.rerun()
    
    with col2:
        st.header("üìä Session Analytics")
        
        if st.session_state['conversation_history']:
            # Emotional trends
            emotions = []
            intensities = []
            timestamps = []
            
            for entry in st.session_state['conversation_history']:
                if 'emotional_analysis' in entry and entry['emotional_analysis']:
                    ea = entry['emotional_analysis']
                    emotions.append(ea.primary_emotion.value)
                    intensities.append(ea.emotion_intensity)
                    timestamps.append(entry['timestamp'])
            
            if emotions:
                # Emotion distribution
                emotion_counts = pd.Series(emotions).value_counts()
                fig = px.pie(
                    values=emotion_counts.values,
                    names=emotion_counts.index,
                    title="Emotional States"
                )
                fig.update_layout(height=300)
                st.plotly_chart(fig, use_container_width=True)
                
                # Intensity over time
                if len(intensities) > 1:
                    fig = px.line(
                        x=range(len(intensities)),
                        y=intensities,
                        title="Emotional Intensity",
                        labels={'x': 'Message', 'y': 'Intensity'}
                    )
                    fig.update_layout(height=300)
                    st.plotly_chart(fig, use_container_width=True)
                
                # Session metrics
                st.subheader("üìà Session Metrics")
                
                avg_intensity = np.mean(intensities)
                max_intensity = max(intensities)
                
                st.metric("Average Intensity", f"{avg_intensity:.1%}")
                st.metric("Peak Intensity", f"{max_intensity:.1%}")
                
                # Techniques used
                techniques = []
                for entry in st.session_state['conversation_history']:
                    if 'technique_used' in entry and entry['technique_used']:
                        techniques.append(entry['technique_used'].value)
                
                if techniques:
                    technique_counts = pd.Series(techniques).value_counts()
                    st.subheader("üõ†Ô∏è Techniques Used")
                    for technique, count in technique_counts.items():
                        st.write(f"‚Ä¢ {technique.replace('_', ' ').title()}: {count}")
        
        else:
            st.info("Start a conversation to see analytics")
    
    # Additional features
    st.header("üåü Additional Features")
    
    tab1, tab2, tab3 = st.tabs(["üéØ Therapeutic Goals", "üìö Resources", "üîç Session History"])
    
    with tab1:
        st.subheader("Set Therapeutic Goals")
        
        goal_description = st.text_area("What would you like to work on?", 
                                       placeholder="e.g., Managing anxiety, improving mood, building coping skills")
        
        if st.button("Add Goal"):
            if goal_description:
                st.success(f"Goal added: {goal_description}")
            else:
                st.error("Please enter a goal description")
    
    with tab2:
        st.subheader("Mental Health Resources")
        
        resources = {
            "üÜò Crisis Support": [
                "National Suicide Prevention Lifeline: 988",
                "Crisis Text Line: Text HOME to 741741",
                "SAMHSA National Helpline: 1-800-662-4357"
            ],
            "üßò Self-Care": [
                "Mindfulness meditation apps (Headspace, Calm)",
                "Grounding techniques (5-4-3-2-1 method)",
                "Deep breathing exercises",
                "Progressive muscle relaxation"
            ],
            "üìñ Educational": [
                "National Institute of Mental Health (NIMH)",
                "Mental Health America",
                "Anxiety and Depression Association of America"
            ]
        }
        
        for category, resource_list in resources.items():
            with st.expander(category):
                for resource in resource_list:
                    st.write(f"‚Ä¢ {resource}")
    
    with tab3:
        st.subheader("Session History")
        
        if st.session_state['conversation_history']:
            for i, entry in enumerate(st.session_state['conversation_history']):
                with st.expander(f"Exchange {i+1} - {entry['timestamp'].strftime('%H:%M:%S')}"):
                    st.write("**You:**", entry['user_input'])
                    st.write("**AI:**", entry['ai_response'][:200] + "..." if len(entry['ai_response']) > 200 else entry['ai_response'])
                    
                    if 'emotional_analysis' in entry and entry['emotional_analysis']:
                        ea = entry['emotional_analysis']
                        st.write(f"**Emotion:** {ea.primary_emotion.value} ({ea.emotion_intensity:.1%})")
                        st.write(f"**Technique:** {entry.get('technique_used', {}).value if entry.get('technique_used') else 'N/A'}")
        else:
            st.info("No conversation history available")

if __name__ == "__main__":
    main()
````

## Project Summary

The AI-Powered Therapy Simulator represents a sophisticated mental health support system that combines empathetic AI conversation, therapeutic techniques, and crisis safety protocols to provide accessible, confidential emotional support through advanced natural language processing and psychological intervention frameworks.

### Key Value Propositions:
- **Empathetic AI Conversation**: Advanced emotional intelligence with therapeutic communication patterns, active listening, and validation techniques for supportive mental health interactions
- **Evidence-Based Interventions**: Integration of CBT, mindfulness, cognitive restructuring, and grounding techniques with personalized therapeutic approach selection
- **Persistent Therapeutic Memory**: Comprehensive session tracking with emotional pattern analysis, progress monitoring, and contextual conversation continuity
- **Crisis Detection and Safety**: Real-time crisis indicator monitoring with immediate resource provision, safety protocols, and professional referral systems
- **Emotional Analytics and Insights**: Detailed emotional state analysis with intensity tracking, progress visualization, and therapeutic outcome measurement

### Technical Highlights:
- Advanced emotional analysis using VADER sentiment analysis, emotion classification transformers, and crisis keyword detection with confidence scoring
- Vector-based therapeutic memory system using ChromaDB and sentence transformers for relevant context retrieval and session continuity
- LangChain-powered therapeutic conversation generation with OpenAI GPT-4 integration for professional-level empathetic responses
- Comprehensive crisis management system with escalating safety protocols, immediate resource provision, and emergency contact recommendations
- Interactive Streamlit interface providing secure therapeutic conversations, emotional analytics, goal tracking, and crisis resource access
- Modular architecture supporting integration of additional therapeutic techniques, safety protocols, and professional mental health systems

This system democratizes access to mental health support while maintaining appropriate therapeutic boundaries, providing immediate crisis intervention, and serving as a valuable complement to professional mental healthcare services for improved emotional well-being and accessibility.