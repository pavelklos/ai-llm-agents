<small>Claude Sonnet 4 **(Epidemic Response Coordinator - Multi-Agent Syst√©m pro Koordinaci Epidemiologick√© Odpovƒõdi)**</small>
# Epidemic Response Coordinator

## Kl√≠ƒçov√© Koncepty

### Multi-Agent Syst√©m (MAS)
Distribuovan√Ω syst√©m autonomn√≠ch AI agent≈Ø, kte≈ô√≠ spolupracuj√≠ na ≈ôe≈°en√≠ komplexn√≠ch probl√©m≈Ø. Ka≈æd√Ω agent m√° specifick√© role a schopnosti.

### Epidemiologick√© Modelov√°n√≠
Matematick√© a statistick√© metody pro simulaci ≈°√≠≈ôen√≠ nemoc√≠ v populaci, zahrnuj√≠c√≠ modely SIR (Susceptible-Infectious-Recovered).

### Optimalizace Alokace Zdroj≈Ø
Algoritmy pro efektivn√≠ rozdƒõlen√≠ omezen√Ωch zdroj≈Ø (l√©ka≈ôsk√Ω person√°l, l√©ky, l≈Ø≈æka) na z√°kladƒõ predikovan√Ωch pot≈ôeb.

### Simulace Politik
Modelov√°n√≠ dopad≈Ø r≈Øzn√Ωch ve≈ôejnozdravotn√≠ch opat≈ôen√≠ (lockdown, oƒçkov√°n√≠, testov√°n√≠) na pr≈Øbƒõh epidemie.

### Kooperativn√≠ AI
Mechanismy umo≈æ≈àuj√≠c√≠ spolupr√°ci mezi AI agenty p≈ôi sd√≠len√≠ informac√≠ a koordinaci aktivit.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

Epidemic Response Coordinator je pokroƒçil√Ω multi-agent syst√©m navr≈æen√Ω pro podporu rozhodov√°n√≠ bƒõhem epidemiologick√Ωch kriz√≠. Syst√©m kombinuje nƒõkolik specializovan√Ωch AI agent≈Ø, kte≈ô√≠ spolupracuj√≠ na anal√Ωze epidemiologick√Ωch dat, predikci ≈°√≠≈ôen√≠ nemoc√≠ a optimalizaci intervenc√≠.

### Hlavn√≠ C√≠le:
- **Rychl√° anal√Ωza dat**: Real-time zpracov√°n√≠ epidemiologick√Ωch dat z r≈Øzn√Ωch zdroj≈Ø
- **Predikce ≈°√≠≈ôen√≠**: Vyu≈æit√≠ pokroƒçil√Ωch model≈Ø pro predikci v√Ωvoje epidemie
- **Optimalizace zdroj≈Ø**: Efektivn√≠ alokace zdravotnick√Ωch zdroj≈Ø podle pot≈ôeb
- **Simulace sc√©n√°≈ô≈Ø**: Vyhodnocen√≠ dopad≈Ø r≈Øzn√Ωch intervenc√≠ p≈ôed jejich implementac√≠

### V√Ωzvy:
- **Komplexita dat**: Integrace heterogenn√≠ch datov√Ωch zdroj≈Ø
- **Nejistota**: ≈òe≈°en√≠ vysok√© m√≠ry nejistoty v epidemiologick√Ωch predikc√≠ch
- **Rychlost rozhodov√°n√≠**: Poskytov√°n√≠ vƒçasn√Ωch doporuƒçen√≠ v kritick√Ωch situac√≠ch
- **Koordinace**: Zaji≈°tƒõn√≠ efektivn√≠ komunikace mezi agenty

### Potenci√°ln√≠ Dopad:
Syst√©m m≈Ø≈æe v√Ωznamnƒõ zlep≈°it efektivitu epidemiologick√© odpovƒõdi, sn√≠≈æit poƒçet obƒõt√≠ a ekonomick√© dopady pandemi√≠ prost≈ôednictv√≠m data-driven rozhodov√°n√≠.

## Komplexn√≠ P≈ô√≠klad s Python Implementac√≠

````python
import asyncio
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from dataclasses import dataclass
from langchain.llms import OpenAI
from langchain.agents import Tool
from langchain.memory import ConversationBufferMemory
from crewai import Agent, Task, Crew
import plotly.graph_objects as go
import logging

# Nastaven√≠ logov√°n√≠
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class EpidemicData:
    """Struktura pro epidemiologick√° data"""
    region: str
    date: datetime
    susceptible: int
    infectious: int
    recovered: int
    deaths: int
    population: int
    
@dataclass
class Resource:
    """Struktura pro zdravotnick√© zdroje"""
    resource_type: str
    quantity: int
    location: str
    availability: float

@dataclass
class Intervention:
    """Struktura pro intervence"""
    intervention_type: str
    intensity: float
    duration: int
    cost: float
    effectiveness: float

class SIRModel:
    """SIR model pro simulaci ≈°√≠≈ôen√≠ nemoci"""
    
    def __init__(self, beta: float = 0.3, gamma: float = 0.1):
        self.beta = beta  # M√≠ra p≈ôenosu
        self.gamma = gamma  # M√≠ra uzdraven√≠
    
    def simulate(self, S0: int, I0: int, R0: int, days: int) -> List[Dict]:
        """Simuluje ≈°√≠≈ôen√≠ nemoci pomoc√≠ SIR modelu"""
        N = S0 + I0 + R0
        S, I, R = S0, I0, R0
        results = []
        
        for day in range(days):
            dS = -self.beta * S * I / N
            dI = self.beta * S * I / N - self.gamma * I
            dR = self.gamma * I
            
            S += dS
            I += dI
            R += dR
            
            results.append({
                'day': day,
                'susceptible': max(0, int(S)),
                'infectious': max(0, int(I)),
                'recovered': max(0, int(R))
            })
        
        return results

class DataAnalystAgent:
    """Agent pro anal√Ωzu epidemiologick√Ωch dat"""
    
    def __init__(self):
        self.name = "Data Analyst"
        self.memory = ConversationBufferMemory()
    
    def analyze_trends(self, data: List[EpidemicData]) -> Dict:
        """Analyzuje trendy v epidemiologick√Ωch datech"""
        if not data:
            return {"error": "≈Ω√°dn√° data k anal√Ωze"}
        
        df = pd.DataFrame([
            {
                'date': d.date,
                'infectious': d.infectious,
                'region': d.region
            } for d in data
        ])
        
        # V√Ωpoƒçet trend≈Ø
        growth_rate = df.groupby('region')['infectious'].pct_change().mean()
        peak_infections = df.groupby('region')['infectious'].max()
        
        analysis = {
            'growth_rate': float(growth_rate) if not np.isnan(growth_rate) else 0.0,
            'peak_infections': int(peak_infections.iloc[0]) if len(peak_infections) > 0 else 0,
            'trend': 'rostouc√≠' if growth_rate > 0.05 else 'klesaj√≠c√≠' if growth_rate < -0.05 else 'stabiln√≠'
        }
        
        logger.info(f"Anal√Ωza trend≈Ø dokonƒçena: {analysis}")
        return analysis

class PredictionAgent:
    """Agent pro predikci ≈°√≠≈ôen√≠ nemoci"""
    
    def __init__(self):
        self.name = "Prediction Specialist"
        self.sir_model = SIRModel()
    
    def predict_spread(self, current_data: EpidemicData, days: int = 30) -> List[Dict]:
        """Predikuje ≈°√≠≈ôen√≠ nemoci na n√°sleduj√≠c√≠ch X dn√≠"""
        try:
            predictions = self.sir_model.simulate(
                S0=current_data.susceptible,
                I0=current_data.infectious,
                R0=current_data.recovered,
                days=days
            )
            
            logger.info(f"Predikce na {days} dn√≠ dokonƒçena pro region {current_data.region}")
            return predictions
        
        except Exception as e:
            logger.error(f"Chyba p≈ôi predikci: {e}")
            return []

class ResourceOptimizerAgent:
    """Agent pro optimalizaci alokace zdroj≈Ø"""
    
    def __init__(self):
        self.name = "Resource Optimizer"
    
    def optimize_allocation(self, resources: List[Resource], 
                          predictions: List[Dict], 
                          regions: List[str]) -> Dict:
        """Optimalizuje alokaci zdroj≈Ø na z√°kladƒõ predikc√≠"""
        try:
            if not predictions or not resources:
                return {"error": "Nedostateƒçn√° data pro optimalizaci"}
            
            # Jednoduch√Ω algoritmus alokace podle predikovan√Ωch pot≈ôeb
            total_resources = sum(r.quantity for r in resources)
            max_infections = max([p['infectious'] for p in predictions])
            
            allocation = {}
            for region in regions:
                # Alokace podle pomƒõru predikovan√Ωch infekc√≠
                region_need = max_infections * 0.1  # 10% z peak infekc√≠
                allocation[region] = {
                    'hospital_beds': int(region_need * 0.05),
                    'medical_staff': int(region_need * 0.02),
                    'equipment': int(region_need * 0.03)
                }
            
            logger.info(f"Optimalizace zdroj≈Ø dokonƒçena pro {len(regions)} region≈Ø")
            return allocation
        
        except Exception as e:
            logger.error(f"Chyba p≈ôi optimalizaci zdroj≈Ø: {e}")
            return {}

class PolicySimulatorAgent:
    """Agent pro simulaci politik a intervenc√≠"""
    
    def __init__(self):
        self.name = "Policy Simulator"
    
    def simulate_intervention(self, baseline_prediction: List[Dict], 
                            intervention: Intervention) -> Dict:
        """Simuluje dopad intervence na ≈°√≠≈ôen√≠ nemoci"""
        try:
            # Modifikace SIR parametr≈Ø podle typu intervence
            effectiveness = intervention.effectiveness
            
            if intervention.intervention_type == "lockdown":
                modified_beta = 0.3 * (1 - effectiveness)
            elif intervention.intervention_type == "vaccination":
                # Sn√≠≈æen√≠ susceptible populace
                modified_beta = 0.3 * (1 - effectiveness * 0.5)
            else:
                modified_beta = 0.3 * (1 - effectiveness * 0.3)
            
            # Nov√° simulace s modifikovan√Ωmi parametry
            modified_model = SIRModel(beta=modified_beta, gamma=0.1)
            
            if baseline_prediction:
                initial = baseline_prediction[0]
                modified_prediction = modified_model.simulate(
                    S0=initial['susceptible'],
                    I0=initial['infectious'],
                    R0=initial['recovered'],
                    days=len(baseline_prediction)
                )
                
                # Porovn√°n√≠ s baseline
                baseline_peak = max([p['infectious'] for p in baseline_prediction])
                modified_peak = max([p['infectious'] for p in modified_prediction])
                
                impact = {
                    'intervention': intervention.intervention_type,
                    'baseline_peak': baseline_peak,
                    'modified_peak': modified_peak,
                    'reduction_percent': ((baseline_peak - modified_peak) / baseline_peak) * 100,
                    'cost_effectiveness': (baseline_peak - modified_peak) / intervention.cost if intervention.cost > 0 else 0
                }
                
                logger.info(f"Simulace intervence {intervention.intervention_type} dokonƒçena")
                return impact
            
            return {"error": "≈Ω√°dn√° baseline predikce"}
        
        except Exception as e:
            logger.error(f"Chyba p≈ôi simulaci intervence: {e}")
            return {}

class EpidemicResponseCoordinator:
    """Hlavn√≠ koordin√°tor multi-agent syst√©mu"""
    
    def __init__(self):
        self.data_analyst = DataAnalystAgent()
        self.predictor = PredictionAgent()
        self.resource_optimizer = ResourceOptimizerAgent()
        self.policy_simulator = PolicySimulatorAgent()
        
        # Inicializace testovac√≠ch dat
        self.sample_data = self._generate_sample_data()
        self.sample_resources = self._generate_sample_resources()
        self.sample_interventions = self._generate_sample_interventions()
    
    def _generate_sample_data(self) -> List[EpidemicData]:
        """Generuje uk√°zkov√° epidemiologick√° data"""
        data = []
        base_date = datetime.now() - timedelta(days=30)
        
        for i in range(30):
            data.append(EpidemicData(
                region="Praha",
                date=base_date + timedelta(days=i),
                susceptible=1000000 - i * 1000,
                infectious=100 + i * 50,
                recovered=i * 45,
                deaths=i * 5,
                population=1000000
            ))
        
        return data
    
    def _generate_sample_resources(self) -> List[Resource]:
        """Generuje uk√°zkov√© zdroje"""
        return [
            Resource("hospital_beds", 1000, "Praha", 0.8),
            Resource("ventilators", 200, "Praha", 0.9),
            Resource("medical_staff", 500, "Praha", 0.7),
            Resource("test_kits", 10000, "Praha", 0.95)
        ]
    
    def _generate_sample_interventions(self) -> List[Intervention]:
        """Generuje uk√°zkov√© intervence"""
        return [
            Intervention("lockdown", 0.8, 14, 1000000, 0.7),
            Intervention("vaccination", 0.9, 90, 5000000, 0.85),
            Intervention("mask_mandate", 0.3, 60, 100000, 0.4),
            Intervention("contact_tracing", 0.5, 30, 500000, 0.6)
        ]
    
    async def coordinate_response(self) -> Dict:
        """Koordinuje celkovou epidemiologickou odpovƒõƒè"""
        try:
            logger.info("Spou≈°t√≠m koordinaci epidemiologick√© odpovƒõdi...")
            
            # Krok 1: Anal√Ωza souƒçasn√Ωch dat
            current_analysis = self.data_analyst.analyze_trends(self.sample_data)
            
            # Krok 2: Predikce v√Ωvoje
            current_state = self.sample_data[-1]  # Nejnovƒõj≈°√≠ data
            predictions = self.predictor.predict_spread(current_state, days=30)
            
            # Krok 3: Optimalizace zdroj≈Ø
            resource_allocation = self.resource_optimizer.optimize_allocation(
                self.sample_resources, predictions, ["Praha"]
            )
            
            # Krok 4: Simulace intervenc√≠
            intervention_impacts = []
            for intervention in self.sample_interventions[:2]:  # Test prvn√≠ch 2
                impact = self.policy_simulator.simulate_intervention(
                    predictions, intervention
                )
                if 'error' not in impact:
                    intervention_impacts.append(impact)
            
            # Krok 5: Synt√©za doporuƒçen√≠
            recommendations = self._generate_recommendations(
                current_analysis, predictions, resource_allocation, intervention_impacts
            )
            
            final_report = {
                'timestamp': datetime.now().isoformat(),
                'current_analysis': current_analysis,
                'predictions_summary': {
                    'peak_day': predictions[np.argmax([p['infectious'] for p in predictions])]['day'] if predictions else 0,
                    'peak_infections': max([p['infectious'] for p in predictions]) if predictions else 0
                },
                'resource_allocation': resource_allocation,
                'intervention_impacts': intervention_impacts,
                'recommendations': recommendations
            }
            
            logger.info("Koordinace epidemiologick√© odpovƒõdi dokonƒçena")
            return final_report
        
        except Exception as e:
            logger.error(f"Chyba p≈ôi koordinaci: {e}")
            return {'error': str(e)}
    
    def _generate_recommendations(self, analysis: Dict, predictions: List[Dict], 
                                resources: Dict, interventions: List[Dict]) -> List[str]:
        """Generuje doporuƒçen√≠ na z√°kladƒõ anal√Ωz"""
        recommendations = []
        
        if analysis.get('trend') == 'rostouc√≠':
            recommendations.append("VYSOK√Å PRIORITA: Implementovat okam≈æit√° opat≈ôen√≠ pro zpomalen√≠ ≈°√≠≈ôen√≠")
        
        if predictions and max([p['infectious'] for p in predictions]) > 1000:
            recommendations.append("VAROV√ÅN√ç: Predikce ukazuje vysok√Ω poƒçet infekc√≠, p≈ôipravit dodateƒçn√© zdroje")
        
        # Naj√≠t nejefektivnƒõj≈°√≠ intervenci
        if interventions:
            best_intervention = max(interventions, 
                                  key=lambda x: x.get('cost_effectiveness', 0))
            recommendations.append(
                f"DOPORUƒåENO: Implementovat {best_intervention.get('intervention', 'N/A')} "
                f"s oƒçek√°van√Ωm sn√≠≈æen√≠m o {best_intervention.get('reduction_percent', 0):.1f}%"
            )
        
        if not recommendations:
            recommendations.append("Situace je stabiln√≠, pokraƒçovat v monitorov√°n√≠")
        
        return recommendations

# Uk√°zka pou≈æit√≠
async def main():
    """Hlavn√≠ funkce pro demonstraci syst√©mu"""
    coordinator = EpidemicResponseCoordinator()
    
    print("=== EPIDEMIC RESPONSE COORDINATOR ===")
    print("Spou≈°t√≠m multi-agent syst√©m pro koordinaci epidemiologick√© odpovƒõdi...\n")
    
    # Spu≈°tƒõn√≠ koordinace
    result = await coordinator.coordinate_response()
    
    if 'error' in result:
        print(f"CHYBA: {result['error']}")
        return
    
    # V√Ωpis v√Ωsledk≈Ø
    print("üìä ANAL√ùZA SOUƒåASN√â SITUACE:")
    analysis = result['current_analysis']
    print(f"  ‚Ä¢ Trend: {analysis.get('trend', 'N/A')}")
    print(f"  ‚Ä¢ M√≠ra r≈Østu: {analysis.get('growth_rate', 0):.3f}")
    print(f"  ‚Ä¢ Peak infekc√≠: {analysis.get('peak_infections', 0)}")
    
    print("\nüîÆ PREDIKCE:")
    pred_summary = result['predictions_summary']
    print(f"  ‚Ä¢ Peak oƒçek√°v√°n den: {pred_summary['peak_day']}")
    print(f"  ‚Ä¢ Max infekc√≠: {pred_summary['peak_infections']}")
    
    print("\nüíä ALOKACE ZDROJ≈Æ:")
    for region, allocation in result['resource_allocation'].items():
        print(f"  ‚Ä¢ {region}:")
        for resource, amount in allocation.items():
            print(f"    - {resource}: {amount}")
    
    print("\nüéØ HODNOCEN√ç INTERVENC√ç:")
    for impact in result['intervention_impacts']:
        print(f"  ‚Ä¢ {impact['intervention']}:")
        print(f"    - Sn√≠≈æen√≠: {impact['reduction_percent']:.1f}%")
        print(f"    - Cost-effectiveness: {impact['cost_effectiveness']:.2f}")
    
    print("\nüí° DOPORUƒåEN√ç:")
    for i, rec in enumerate(result['recommendations'], 1):
        print(f"  {i}. {rec}")
    
    print(f"\n‚úÖ Anal√Ωza dokonƒçena: {result['timestamp']}")

if __name__ == "__main__":
    asyncio.run(main())
````

````python
langchain>=0.1.0
crewai>=0.1.0
numpy>=1.24.0
pandas>=2.0.0
plotly>=5.17.0
openai>=1.0.0
asyncio
dataclasses
logging
datetime
typing
````

````python
"""
INSTRUKCE PRO NASTAVEN√ç EPIDEMIC RESPONSE COORDINATOR

1. Instalace z√°vislost√≠:
   pip install -r requirements.txt

2. Nastaven√≠ promƒõnn√Ωch prost≈ôed√≠:
   export OPENAI_API_KEY="your-openai-api-key"

3. Spu≈°tƒõn√≠ syst√©mu:
   python epidemic_coordinator.py

4. Roz≈°√≠≈ôen√≠ syst√©mu:
   - P≈ôipojen√≠ skuteƒçn√Ωch dat p≈ôes API
   - Integrace s geografick√Ωmi syst√©my
   - Pokroƒçil√© ML modely pro predikci
   - Real-time dashboard

ARCHITEKTONICK√â ROZHODNUT√ç:
- Multi-agent architektura pro modularitu
- Asynchronn√≠ zpracov√°n√≠ pro ≈°k√°lovatelnost
- SIR model jako z√°klad epidemiologick√Ωch simulac√≠
- Dataclass struktury pro type safety
- Comprehensive error handling
"""
````

## Shrnut√≠ Projektu

Epidemic Response Coordinator p≈ôedstavuje inovativn√≠ p≈ô√≠stup k ≈ô√≠zen√≠ epidemiologick√Ωch kriz√≠ prost≈ôednictv√≠m koordinace specializovan√Ωch AI agent≈Ø. Syst√©m kombinuje:

### Kl√≠ƒçov√© Hodnoty:
- **Rychl√° anal√Ωza**: Real-time zpracov√°n√≠ epidemiologick√Ωch dat
- **Prediktivn√≠ schopnosti**: Pokroƒçil√© modelov√°n√≠ ≈°√≠≈ôen√≠ nemoc√≠
- **Optimalizace zdroj≈Ø**: Efektivn√≠ alokace zdravotnick√Ωch kapacit
- **Simulace politik**: Vyhodnocen√≠ dopad≈Ø intervenc√≠ p≈ôed implementac√≠

### Technologick√© V√Ωhody:
- **Modularita**: Nez√°visl√≠ agenti umo≈æ≈àuj√≠ snadn√© roz≈°√≠≈ôen√≠
- **≈†k√°lovatelnost**: Asynchronn√≠ architektura pro high-performance
- **Spolehlivost**: Robustn√≠ error handling a logging
- **Flexibilita**: Podpora r≈Øzn√Ωch typ≈Ø dat a model≈Ø

### Praktick√© Vyu≈æit√≠:
Syst√©m m≈Ø≈æe b√Ωt nasazen v ministerstvech zdravotnictv√≠, region√°ln√≠ch hygienick√Ωch stanic√≠ch nebo mezin√°rodn√≠ch organizac√≠ch pro podporu evidence-based rozhodov√°n√≠ bƒõhem pandemi√≠. P≈ôin√°≈°√≠ v√Ωznamn√© zlep≈°en√≠ v rychlosti a kvalitƒõ epidemiologick√© odpovƒõdi.