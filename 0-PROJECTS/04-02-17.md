<small>Claude Sonnet 4 **(Movie Script Analyzer and Generator)**</small>
# Movie Script Analyzer and Generator

## Key Concepts Explanation

### Screenplay Format Analysis
Systematic parsing and understanding of industry-standard screenplay structures including scene headings, action lines, character names, dialogue, and parentheticals, ensuring compliance with Final Draft and other professional formatting conventions while extracting narrative elements for computational analysis.

### Genre Classification and Detection
Machine learning-based categorization system that analyzes dialogue patterns, action descriptions, character archetypes, and narrative structures to automatically identify and classify scripts across multiple genres including drama, comedy, thriller, horror, and hybrid classifications with confidence scoring.

### Story Arc and Narrative Structure Analysis
Computational analysis of dramatic storytelling elements including three-act structure identification, plot point detection, character development tracking, conflict escalation patterns, and resolution mapping using natural language processing and narrative theory frameworks.

### Character Development Profiling
Advanced character analysis system that tracks dialogue patterns, emotional arcs, relationship dynamics, and behavioral consistency across screenplay scenes, generating comprehensive character profiles including voice recognition, motivation mapping, and development trajectory analysis.

### Dialogue Generation and Voice Matching
AI-powered dialogue creation system that learns character-specific speech patterns, maintains voice consistency, and generates contextually appropriate conversations while preserving genre conventions, emotional authenticity, and narrative progression requirements.

### Scene Structure and Pacing Analysis
Intelligent evaluation of scene construction including beat timing, tension curves, information revelation patterns, and dramatic pacing to ensure optimal storytelling flow and audience engagement through data-driven insights and industry best practices.

## Comprehensive Project Explanation

### Objectives
The Movie Script Analyzer and Generator aims to revolutionize screenplay development by providing intelligent analysis tools for writers, producers, and studios, enabling automated script evaluation, genre optimization, character development insights, and AI-assisted content generation that maintains creative authenticity while meeting industry standards.

### Key Features
- **Format Compliance Validation**: Automated checking of screenplay formatting against industry standards
- **Multi-Genre Classification**: Sophisticated genre detection with hybrid classification capabilities
- **Narrative Structure Analysis**: Three-act structure identification and story beat mapping
- **Character Arc Tracking**: Comprehensive character development and consistency analysis
- **Dialogue Pattern Recognition**: Voice identification and speech pattern analysis for each character
- **Scene-by-Scene Breakdown**: Detailed analysis of pacing, tension, and dramatic effectiveness
- **AI-Powered Script Generation**: Context-aware dialogue and scene generation tools
- **Comparative Analysis**: Benchmarking against successful scripts in similar genres

### Challenges
- **Format Complexity**: Screenplay formatting has strict industry conventions with subtle variations
- **Subjective Analysis**: Creative elements like character development resist purely quantitative measurement
- **Genre Ambiguity**: Modern scripts often blend multiple genres requiring nuanced classification
- **Voice Authenticity**: Generating dialogue that feels natural while maintaining character consistency
- **Cultural Context**: Understanding cultural references, period-appropriate language, and demographic authenticity
- **Creative vs Commercial Balance**: Balancing artistic vision with market-driven optimization recommendations

### Potential Impact
This system can democratize access to professional script analysis, accelerate the development process for writers, provide objective feedback for iterative improvement, assist producers in project evaluation, and potentially discover overlooked gems through systematic analysis that might be missed in traditional script reading processes.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
streamlit==1.29.0
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
scikit-learn==1.3.2
nltk==3.8.1
spacy==3.7.2
textblob==0.17.1
transformers==4.36.0
torch==2.1.0
matplotlib==3.8.2
seaborn==0.12.2
wordcloud==1.9.2
regex==2023.10.3
python-dotenv==1.0.0
pydantic==2.5.0
beautifulsoup4==4.12.2
requests==2.31.0
textstat==0.7.3
networkx==3.2.1
collections
json
re
logging
datetime
pathlib
typing
dataclasses
enum
io
````

### Core Implementation

````python
import os
import re
import json
import logging
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# NLP and ML
import nltk
import spacy
from textblob import TextBlob
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import MultinomialNB
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import networkx as nx

# LLM Integration
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import BaseOutputParser

# Visualization
import matplotlib.pyplot as plt
import seaborn as sns
from wordcloud import WordCloud

# Text processing
import textstat
from collections import Counter, defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Download required NLTK data
try:
    nltk.download('punkt', quiet=True)
    nltk.download('averaged_perceptron_tagger', quiet=True)
    nltk.download('vader_lexicon', quiet=True)
    nltk.download('stopwords', quiet=True)
except:
    pass

class ScriptGenre(Enum):
    DRAMA = "drama"
    COMEDY = "comedy"
    THRILLER = "thriller"
    HORROR = "horror"
    ACTION = "action"
    ROMANCE = "romance"
    SCI_FI = "sci-fi"
    FANTASY = "fantasy"
    MYSTERY = "mystery"
    WESTERN = "western"
    DOCUMENTARY = "documentary"
    UNKNOWN = "unknown"

class ScriptFormat(Enum):
    SCENE_HEADING = "scene_heading"
    ACTION = "action"
    CHARACTER = "character"
    DIALOGUE = "dialogue"
    PARENTHETICAL = "parenthetical"
    TRANSITION = "transition"
    UNKNOWN = "unknown"

class ActStructure(Enum):
    ACT_I = "act_1"
    ACT_II_A = "act_2a"
    ACT_II_B = "act_2b"
    ACT_III = "act_3"

@dataclass
class ScriptLine:
    line_number: int
    content: str
    format_type: ScriptFormat
    character: Optional[str] = None
    scene_number: Optional[int] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Character:
    name: str
    dialogue_lines: List[str] = field(default_factory=list)
    first_appearance: int = 0
    last_appearance: int = 0
    total_lines: int = 0
    emotional_profile: Dict[str, float] = field(default_factory=dict)
    relationships: Dict[str, float] = field(default_factory=dict)

@dataclass
class Scene:
    scene_number: int
    heading: str
    location: str
    time: str
    lines: List[ScriptLine] = field(default_factory=list)
    characters: List[str] = field(default_factory=list)
    page_count: float = 0.0
    tension_score: float = 0.0
    dialogue_ratio: float = 0.0

@dataclass
class ScriptAnalysis:
    total_pages: int
    total_scenes: int
    total_characters: int
    genre_predictions: Dict[str, float]
    act_structure: Dict[str, Tuple[int, int]]
    character_analysis: Dict[str, Character]
    scene_analysis: List[Scene]
    pacing_analysis: Dict[str, Any]
    dialogue_statistics: Dict[str, Any]

class ScreenplayParser:
    """Parse and format screenplay text into structured components."""
    
    def __init__(self):
        # Regex patterns for screenplay elements
        self.patterns = {
            'scene_heading': re.compile(r'^(INT\.|EXT\.|FADE IN:|FADE OUT:|CUT TO:)', re.IGNORECASE),
            'character': re.compile(r'^[A-Z][A-Z\s\.]+$'),
            'parenthetical': re.compile(r'^\([^)]+\)$'),
            'transition': re.compile(r'^(FADE IN:|FADE OUT:|CUT TO:|DISSOLVE TO:)', re.IGNORECASE),
            'action': re.compile(r'^[A-Z]'),
        }
        
        # Load spaCy model
        try:
            self.nlp = spacy.load("en_core_web_sm")
        except OSError:
            logger.warning("spaCy model not found. Some features may be limited.")
            self.nlp = None
    
    def parse_script(self, script_text: str) -> List[ScriptLine]:
        """Parse screenplay text into structured lines."""
        lines = script_text.split('\n')
        structured_lines = []
        current_character = None
        scene_number = 0
        
        for i, line in enumerate(lines):
            line = line.strip()
            
            if not line:  # Skip empty lines
                continue
            
            # Determine line format
            format_type = self._classify_line_format(line)
            
            # Track scene numbers
            if format_type == ScriptFormat.SCENE_HEADING:
                scene_number += 1
                current_character = None
            
            # Track current character for dialogue
            if format_type == ScriptFormat.CHARACTER:
                current_character = line.strip()
            
            script_line = ScriptLine(
                line_number=i + 1,
                content=line,
                format_type=format_type,
                character=current_character if format_type == ScriptFormat.DIALOGUE else None,
                scene_number=scene_number
            )
            
            structured_lines.append(script_line)
        
        return structured_lines
    
    def _classify_line_format(self, line: str) -> ScriptFormat:
        """Classify line format based on screenplay conventions."""
        line_clean = line.strip()
        
        if not line_clean:
            return ScriptFormat.UNKNOWN
        
        # Scene heading
        if self.patterns['scene_heading'].match(line_clean):
            return ScriptFormat.SCENE_HEADING
        
        # Transition
        if self.patterns['transition'].match(line_clean):
            return ScriptFormat.TRANSITION
        
        # Parenthetical
        if self.patterns['parenthetical'].match(line_clean):
            return ScriptFormat.PARENTHETICAL
        
        # Character name (all caps, possibly with extensions)
        if (self.patterns['character'].match(line_clean) and 
            len(line_clean) < 50 and 
            not line_clean.endswith('.')):
            return ScriptFormat.CHARACTER
        
        # Action (starts with capital letter, longer than character names)
        if (line_clean[0].isupper() and 
            (len(line_clean) > 50 or '.' in line_clean)):
            return ScriptFormat.ACTION
        
        # Default to dialogue
        return ScriptFormat.DIALOGUE
    
    def extract_scenes(self, script_lines: List[ScriptLine]) -> List[Scene]:
        """Extract scenes from parsed script lines."""
        scenes = []
        current_scene = None
        
        for line in script_lines:
            if line.format_type == ScriptFormat.SCENE_HEADING:
                # Save previous scene
                if current_scene:
                    scenes.append(current_scene)
                
                # Parse scene heading
                location, time = self._parse_scene_heading(line.content)
                
                # Start new scene
                current_scene = Scene(
                    scene_number=line.scene_number,
                    heading=line.content,
                    location=location,
                    time=time,
                    lines=[line]
                )
            elif current_scene:
                current_scene.lines.append(line)
                
                # Track characters in scene
                if line.character and line.character not in current_scene.characters:
                    current_scene.characters.append(line.character)
        
        # Add last scene
        if current_scene:
            scenes.append(current_scene)
        
        # Calculate scene statistics
        for scene in scenes:
            scene.page_count = self._estimate_page_count(scene.lines)
            scene.dialogue_ratio = self._calculate_dialogue_ratio(scene.lines)
            scene.tension_score = self._analyze_tension(scene.lines)
        
        return scenes
    
    def _parse_scene_heading(self, heading: str) -> Tuple[str, str]:
        """Parse location and time from scene heading."""
        # Basic parsing - can be enhanced
        parts = heading.split(' - ')
        location = parts[0].replace('INT.', '').replace('EXT.', '').strip()
        time = parts[1] if len(parts) > 1 else 'UNKNOWN'
        
        return location, time
    
    def _estimate_page_count(self, lines: List[ScriptLine]) -> float:
        """Estimate page count for scene (rough calculation)."""
        total_chars = sum(len(line.content) for line in lines)
        # Rough estimate: 250 words per page, 5 chars per word
        return total_chars / (250 * 5)
    
    def _calculate_dialogue_ratio(self, lines: List[ScriptLine]) -> float:
        """Calculate ratio of dialogue to action in scene."""
        dialogue_lines = sum(1 for line in lines if line.format_type == ScriptFormat.DIALOGUE)
        total_lines = len(lines)
        
        return dialogue_lines / total_lines if total_lines > 0 else 0.0
    
    def _analyze_tension(self, lines: List[ScriptLine]) -> float:
        """Analyze tension level in scene (simplified approach)."""
        tension_words = [
            'fight', 'scream', 'run', 'chase', 'danger', 'threat', 'fear',
            'urgent', 'quickly', 'suddenly', 'shock', 'surprise', 'attack'
        ]
        
        total_words = 0
        tension_count = 0
        
        for line in lines:
            words = line.content.lower().split()
            total_words += len(words)
            tension_count += sum(1 for word in words if word in tension_words)
        
        return tension_count / total_words if total_words > 0 else 0.0

class GenreClassifier:
    """Classify screenplay genre using machine learning."""
    
    def __init__(self):
        self.vectorizer = TfidfVectorizer(max_features=5000, stop_words='english')
        self.classifier = RandomForestClassifier(n_estimators=100, random_state=42)
        self.is_trained = False
        
        # Genre keywords for rule-based classification
        self.genre_keywords = {
            ScriptGenre.COMEDY: [
                'laugh', 'funny', 'joke', 'hilarious', 'comic', 'humor',
                'silly', 'ridiculous', 'absurd', 'wit', 'sarcasm'
            ],
            ScriptGenre.THRILLER: [
                'suspense', 'tension', 'mystery', 'chase', 'escape',
                'danger', 'threat', 'paranoid', 'surveillance', 'conspiracy'
            ],
            ScriptGenre.HORROR: [
                'scream', 'blood', 'death', 'monster', 'ghost', 'evil',
                'terror', 'nightmare', 'haunted', 'demon', 'supernatural'
            ],
            ScriptGenre.ACTION: [
                'fight', 'explosion', 'chase', 'gun', 'battle', 'combat',
                'weapon', 'war', 'soldier', 'mission', 'tactical'
            ],
            ScriptGenre.ROMANCE: [
                'love', 'kiss', 'heart', 'romantic', 'relationship',
                'passion', 'intimate', 'wedding', 'date', 'valentine'
            ],
            ScriptGenre.DRAMA: [
                'emotional', 'family', 'relationship', 'conflict', 'struggle',
                'personal', 'character', 'human', 'social', 'psychological'
            ]
        }
    
    def train_classifier(self, training_data: List[Tuple[str, ScriptGenre]]):
        """Train the genre classifier with labeled data."""
        if len(training_data) < 10:
            logger.warning("Insufficient training data for ML classifier")
            return
        
        texts = [text for text, _ in training_data]
        labels = [genre.value for _, genre in training_data]
        
        # Vectorize texts
        X = self.vectorizer.fit_transform(texts)
        
        # Train classifier
        self.classifier.fit(X, labels)
        self.is_trained = True
        
        logger.info(f"Trained classifier with {len(training_data)} samples")
    
    def classify_genre(self, script_text: str) -> Dict[str, float]:
        """Classify script genre with confidence scores."""
        # Rule-based classification
        rule_scores = self._rule_based_classification(script_text)
        
        # ML-based classification (if trained)
        ml_scores = {}
        if self.is_trained:
            try:
                X = self.vectorizer.transform([script_text])
                probabilities = self.classifier.predict_proba(X)[0]
                classes = self.classifier.classes_
                
                ml_scores = dict(zip(classes, probabilities))
            except Exception as e:
                logger.warning(f"ML classification failed: {e}")
        
        # Combine scores (weighted average)
        combined_scores = {}
        all_genres = set(list(rule_scores.keys()) + list(ml_scores.keys()))
        
        for genre in all_genres:
            rule_score = rule_scores.get(genre, 0.0)
            ml_score = ml_scores.get(genre, 0.0)
            
            # Weight: 60% rule-based, 40% ML (if available)
            if ml_scores:
                combined_scores[genre] = 0.6 * rule_score + 0.4 * ml_score
            else:
                combined_scores[genre] = rule_score
        
        # Normalize scores
        total_score = sum(combined_scores.values())
        if total_score > 0:
            combined_scores = {k: v/total_score for k, v in combined_scores.items()}
        
        return combined_scores
    
    def _rule_based_classification(self, script_text: str) -> Dict[str, float]:
        """Rule-based genre classification using keywords."""
        text_lower = script_text.lower()
        words = text_lower.split()
        
        genre_scores = {}
        
        for genre, keywords in self.genre_keywords.items():
            score = sum(1 for word in words if word in keywords)
            # Normalize by text length
            normalized_score = score / len(words) if words else 0
            genre_scores[genre.value] = normalized_score
        
        return genre_scores

class CharacterAnalyzer:
    """Analyze character development and relationships."""
    
    def __init__(self):
        try:
            self.nlp = spacy.load("en_core_web_sm")
        except OSError:
            self.nlp = None
            logger.warning("spaCy model not available for character analysis")
    
    def analyze_characters(self, script_lines: List[ScriptLine]) -> Dict[str, Character]:
        """Perform comprehensive character analysis."""
        characters = {}
        
        # Extract basic character information
        for line in script_lines:
            if line.format_type == ScriptFormat.DIALOGUE and line.character:
                char_name = line.character.strip()
                
                if char_name not in characters:
                    characters[char_name] = Character(
                        name=char_name,
                        first_appearance=line.line_number
                    )
                
                char = characters[char_name]
                char.dialogue_lines.append(line.content)
                char.last_appearance = line.line_number
                char.total_lines += 1
        
        # Analyze each character
        for char_name, character in characters.items():
            character.emotional_profile = self._analyze_emotional_profile(character.dialogue_lines)
            character.relationships = self._analyze_relationships(character, characters)
        
        return characters
    
    def _analyze_emotional_profile(self, dialogue_lines: List[str]) -> Dict[str, float]:
        """Analyze emotional profile of character dialogue."""
        emotions = {
            'positive': 0.0,
            'negative': 0.0,
            'neutral': 0.0,
            'anger': 0.0,
            'joy': 0.0,
            'fear': 0.0,
            'sadness': 0.0
        }
        
        if not dialogue_lines:
            return emotions
        
        # Use TextBlob for basic sentiment analysis
        total_sentiment = 0
        positive_count = 0
        negative_count = 0
        neutral_count = 0
        
        # Emotion keywords
        emotion_keywords = {
            'anger': ['angry', 'mad', 'furious', 'rage', 'annoyed', 'irritated'],
            'joy': ['happy', 'excited', 'delighted', 'cheerful', 'pleased'],
            'fear': ['scared', 'afraid', 'terrified', 'nervous', 'worried'],
            'sadness': ['sad', 'depressed', 'crying', 'tears', 'grief']
        }
        
        for line in dialogue_lines:
            # Sentiment analysis
            blob = TextBlob(line)
            sentiment = blob.sentiment.polarity
            
            total_sentiment += sentiment
            
            if sentiment > 0.1:
                positive_count += 1
            elif sentiment < -0.1:
                negative_count += 1
            else:
                neutral_count += 1
            
            # Emotion detection
            line_lower = line.lower()
            for emotion, keywords in emotion_keywords.items():
                if any(keyword in line_lower for keyword in keywords):
                    emotions[emotion] += 1
        
        # Normalize scores
        total_lines = len(dialogue_lines)
        emotions['positive'] = positive_count / total_lines
        emotions['negative'] = negative_count / total_lines
        emotions['neutral'] = neutral_count / total_lines
        
        for emotion in ['anger', 'joy', 'fear', 'sadness']:
            emotions[emotion] = emotions[emotion] / total_lines
        
        return emotions
    
    def _analyze_relationships(self, character: Character, 
                             all_characters: Dict[str, Character]) -> Dict[str, float]:
        """Analyze relationships between characters (simplified)."""
        relationships = {}
        
        # This is a simplified relationship analysis
        # In practice, you'd analyze co-occurrence in scenes, dialogue exchanges, etc.
        
        for other_name, other_char in all_characters.items():
            if other_name != character.name:
                # Simple metric: inverse of appearance time difference
                time_diff = abs(character.first_appearance - other_char.first_appearance)
                relationship_strength = 1.0 / (1.0 + time_diff / 100)
                relationships[other_name] = relationship_strength
        
        return relationships

class StoryStructureAnalyzer:
    """Analyze story structure and narrative arc."""
    
    def __init__(self):
        # Standard three-act structure percentages
        self.act_boundaries = {
            ActStructure.ACT_I: (0.0, 0.25),      # First 25%
            ActStructure.ACT_II_A: (0.25, 0.5),   # 25-50%
            ActStructure.ACT_II_B: (0.5, 0.75),   # 50-75%
            ActStructure.ACT_III: (0.75, 1.0)     # Last 25%
        }
    
    def analyze_structure(self, scenes: List[Scene]) -> Dict[str, Any]:
        """Analyze overall story structure."""
        total_pages = sum(scene.page_count for scene in scenes)
        
        # Determine act boundaries
        act_structure = self._determine_act_structure(scenes, total_pages)
        
        # Analyze pacing
        pacing_analysis = self._analyze_pacing(scenes)
        
        # Identify plot points
        plot_points = self._identify_plot_points(scenes, act_structure)
        
        return {
            'total_pages': total_pages,
            'act_structure': act_structure,
            'pacing_analysis': pacing_analysis,
            'plot_points': plot_points,
            'scene_count': len(scenes)
        }
    
    def _determine_act_structure(self, scenes: List[Scene], 
                               total_pages: float) -> Dict[str, Tuple[int, int]]:
        """Determine act boundaries based on page counts."""
        act_structure = {}
        current_page = 0
        
        for act, (start_pct, end_pct) in self.act_boundaries.items():
            start_page = int(total_pages * start_pct)
            end_page = int(total_pages * end_pct)
            
            # Find corresponding scene numbers
            start_scene = 1
            end_scene = len(scenes)
            
            page_count = 0
            for i, scene in enumerate(scenes):
                if page_count >= start_page and start_scene == 1:
                    start_scene = i + 1
                
                page_count += scene.page_count
                
                if page_count >= end_page:
                    end_scene = i + 1
                    break
            
            act_structure[act.value] = (start_scene, end_scene)
        
        return act_structure
    
    def _analyze_pacing(self, scenes: List[Scene]) -> Dict[str, Any]:
        """Analyze pacing throughout the script."""
        page_counts = [scene.page_count for scene in scenes]
        tension_scores = [scene.tension_score for scene in scenes]
        dialogue_ratios = [scene.dialogue_ratio for scene in scenes]
        
        return {
            'avg_scene_length': np.mean(page_counts) if page_counts else 0,
            'scene_length_variance': np.var(page_counts) if page_counts else 0,
            'avg_tension': np.mean(tension_scores) if tension_scores else 0,
            'tension_progression': tension_scores,
            'avg_dialogue_ratio': np.mean(dialogue_ratios) if dialogue_ratios else 0,
            'pacing_rhythm': self._calculate_pacing_rhythm(page_counts)
        }
    
    def _calculate_pacing_rhythm(self, page_counts: List[float]) -> str:
        """Determine pacing rhythm pattern."""
        if not page_counts or len(page_counts) < 3:
            return "insufficient_data"
        
        # Calculate variance in scene lengths
        variance = np.var(page_counts)
        
        if variance < 0.1:
            return "consistent"
        elif variance < 0.5:
            return "moderate_variation"
        else:
            return "high_variation"
    
    def _identify_plot_points(self, scenes: List[Scene], 
                            act_structure: Dict[str, Tuple[int, int]]) -> Dict[str, int]:
        """Identify key plot points in the story."""
        plot_points = {}
        
        # Inciting incident (end of Act I)
        if 'act_1' in act_structure:
            _, act1_end = act_structure['act_1']
            plot_points['inciting_incident'] = act1_end
        
        # Midpoint (middle of Act II)
        if 'act_2a' in act_structure and 'act_2b' in act_structure:
            _, act2a_end = act_structure['act_2a']
            plot_points['midpoint'] = act2a_end
        
        # Climax (near end of Act III)
        if 'act_3' in act_structure:
            act3_start, act3_end = act_structure['act_3']
            climax_scene = int(act3_start + (act3_end - act3_start) * 0.8)
            plot_points['climax'] = climax_scene
        
        return plot_points

class DialogueGenerator:
    """Generate dialogue using LLM with character voice consistency."""
    
    def __init__(self, llm: ChatOpenAI):
        self.llm = llm
        
        # Dialogue generation prompts
        self.character_voice_prompt = ChatPromptTemplate.from_template("""
        Analyze the following dialogue samples to understand the character's voice:
        
        Character: {character_name}
        Dialogue samples:
        {dialogue_samples}
        
        Describe this character's speaking style, including:
        1. Vocabulary level and word choice
        2. Sentence structure and length
        3. Emotional tone and attitude
        4. Speech patterns or quirks
        5. Background/education level indicators
        
        Character voice profile:
        """)
        
        self.dialogue_generation_prompt = ChatPromptTemplate.from_template("""
        Generate dialogue for the character based on their established voice profile:
        
        Character: {character_name}
        Voice Profile: {voice_profile}
        
        Scene Context: {scene_context}
        Other Characters Present: {other_characters}
        
        Previous Dialogue:
        {previous_dialogue}
        
        Generate 2-3 lines of dialogue that:
        1. Maintains the character's established voice
        2. Advances the scene/story
        3. Feels natural and authentic
        4. Fits the genre and tone
        
        Generated Dialogue:
        """)
    
    def analyze_character_voice(self, character: Character) -> str:
        """Analyze character's voice from existing dialogue."""
        if not character.dialogue_lines:
            return "No dialogue samples available for voice analysis."
        
        # Sample dialogue for analysis (limit to avoid token limits)
        dialogue_samples = "\n".join(character.dialogue_lines[:10])
        
        try:
            response = self.llm.invoke(self.character_voice_prompt.format(
                character_name=character.name,
                dialogue_samples=dialogue_samples
            ))
            
            return response.content
            
        except Exception as e:
            logger.error(f"Voice analysis error: {e}")
            return f"Error analyzing voice for {character.name}"
    
    def generate_dialogue(self, character_name: str, voice_profile: str,
                         scene_context: str, other_characters: List[str],
                         previous_dialogue: str = "") -> str:
        """Generate new dialogue for character."""
        try:
            response = self.llm.invoke(self.dialogue_generation_prompt.format(
                character_name=character_name,
                voice_profile=voice_profile,
                scene_context=scene_context,
                other_characters=", ".join(other_characters),
                previous_dialogue=previous_dialogue
            ))
            
            return response.content
            
        except Exception as e:
            logger.error(f"Dialogue generation error: {e}")
            return f"Error generating dialogue for {character_name}"

class ScriptAnalyzer:
    """Main script analysis orchestrator."""
    
    def __init__(self, openai_api_key: str):
        self.llm = ChatOpenAI(
            temperature=0.7,
            model_name="gpt-4",
            openai_api_key=openai_api_key
        )
        
        # Initialize components
        self.parser = ScreenplayParser()
        self.genre_classifier = GenreClassifier()
        self.character_analyzer = CharacterAnalyzer()
        self.structure_analyzer = StoryStructureAnalyzer()
        self.dialogue_generator = DialogueGenerator(self.llm)
        
        # Training data for genre classifier
        self._load_sample_training_data()
    
    def _load_sample_training_data(self):
        """Load sample training data for genre classification."""
        # In a real implementation, this would load from a dataset
        sample_training_data = [
            ("The hero fights against overwhelming odds to save the world from destruction.", ScriptGenre.ACTION),
            ("Two lovers meet in unexpected circumstances and find true love.", ScriptGenre.ROMANCE),
            ("A detective investigates a series of mysterious murders in the city.", ScriptGenre.THRILLER),
            ("Strange supernatural forces threaten a small town's residents.", ScriptGenre.HORROR),
            ("A dysfunctional family comes together for a wedding celebration.", ScriptGenre.COMEDY),
            ("A character struggles with personal demons and life choices.", ScriptGenre.DRAMA),
        ]
        
        self.genre_classifier.train_classifier(sample_training_data)
    
    def analyze_script(self, script_text: str) -> ScriptAnalysis:
        """Perform comprehensive script analysis."""
        try:
            # Parse script
            script_lines = self.parser.parse_script(script_text)
            scenes = self.parser.extract_scenes(script_lines)
            
            # Genre classification
            genre_predictions = self.genre_classifier.classify_genre(script_text)
            
            # Character analysis
            character_analysis = self.character_analyzer.analyze_characters(script_lines)
            
            # Structure analysis
            structure_data = self.structure_analyzer.analyze_structure(scenes)
            
            # Dialogue statistics
            dialogue_stats = self._calculate_dialogue_statistics(script_lines)
            
            # Create analysis result
            analysis = ScriptAnalysis(
                total_pages=int(structure_data['total_pages']),
                total_scenes=len(scenes),
                total_characters=len(character_analysis),
                genre_predictions=genre_predictions,
                act_structure=structure_data['act_structure'],
                character_analysis=character_analysis,
                scene_analysis=scenes,
                pacing_analysis=structure_data['pacing_analysis'],
                dialogue_statistics=dialogue_stats
            )
            
            return analysis
            
        except Exception as e:
            logger.error(f"Script analysis error: {e}")
            raise
    
    def _calculate_dialogue_statistics(self, script_lines: List[ScriptLine]) -> Dict[str, Any]:
        """Calculate dialogue-related statistics."""
        dialogue_lines = [line for line in script_lines if line.format_type == ScriptFormat.DIALOGUE]
        action_lines = [line for line in script_lines if line.format_type == ScriptFormat.ACTION]
        
        total_words = sum(len(line.content.split()) for line in dialogue_lines)
        total_chars = sum(len(line.content) for line in dialogue_lines)
        
        # Calculate readability
        dialogue_text = " ".join(line.content for line in dialogue_lines)
        readability_score = textstat.flesch_reading_ease(dialogue_text) if dialogue_text else 0
        
        return {
            'total_dialogue_lines': len(dialogue_lines),
            'total_action_lines': len(action_lines),
            'dialogue_to_action_ratio': len(dialogue_lines) / len(action_lines) if action_lines else 0,
            'avg_words_per_dialogue': total_words / len(dialogue_lines) if dialogue_lines else 0,
            'total_dialogue_words': total_words,
            'total_dialogue_characters': total_chars,
            'readability_score': readability_score
        }
    
    def generate_script_report(self, analysis: ScriptAnalysis) -> str:
        """Generate comprehensive analysis report."""
        try:
            report_prompt = f"""
            Generate a comprehensive script analysis report based on the following data:
            
            Basic Information:
            - Total Pages: {analysis.total_pages}
            - Total Scenes: {analysis.total_scenes}
            - Total Characters: {analysis.total_characters}
            
            Genre Predictions: {analysis.genre_predictions}
            
            Top Characters by Lines:
            {self._format_character_summary(analysis.character_analysis)}
            
            Pacing Analysis: {analysis.pacing_analysis}
            
            Dialogue Statistics: {analysis.dialogue_statistics}
            
            Provide analysis covering:
            1. Overall assessment and strengths
            2. Genre classification and marketability
            3. Character development evaluation
            4. Pacing and structure analysis
            5. Dialogue quality assessment
            6. Recommendations for improvement
            7. Industry standard comparisons
            
            Professional Script Analysis Report:
            """
            
            response = self.llm.invoke(report_prompt)
            return response.content
            
        except Exception as e:
            logger.error(f"Report generation error: {e}")
            return f"Error generating report: {str(e)}"
    
    def _format_character_summary(self, character_analysis: Dict[str, Character]) -> str:
        """Format character summary for report."""
        sorted_chars = sorted(character_analysis.values(), 
                            key=lambda x: x.total_lines, reverse=True)
        
        summary_lines = []
        for char in sorted_chars[:5]:  # Top 5 characters
            summary_lines.append(f"- {char.name}: {char.total_lines} lines")
        
        return "\n".join(summary_lines)

def create_sample_script() -> str:
    """Create a sample screenplay for demonstration."""
    return """
FADE IN:

EXT. COFFEE SHOP - DAY

A bustling street corner coffee shop. SARAH (28), a determined journalist, sits at an outdoor table with her laptop.

SARAH
(frustrated, to herself)
Come on, where's the story in this?

MIKE (30), charming but mysterious, approaches with two coffee cups.

MIKE
Mind if I join you? You look like you could use some company.

SARAH
(suspicious)
Do I know you?

MIKE
Mike Chen. I work nearby. I noticed you here every morning for the past week.

SARAH
Sarah Martinez. And you're observant.

MIKE
(sitting down)
Journalist?

SARAH
How did you--?

MIKE
The laptop, the intense concentration, the frustrated muttering. Dead giveaway.

Sarah laughs despite herself.

SARAH
Guilty as charged. Working on a story about corporate corruption, but I'm hitting dead ends.

MIKE
(hesitating)
What kind of corruption?

SARAH
Tech company. Zenith Corp. Ever heard of them?

Mike's expression changes subtly.

MIKE
(carefully)
Can't say I have. What's the angle?

SARAH
Insider trading, falsified reports. But my source went cold.

MIKE
Maybe your source had good reason.

SARAH
What do you mean?

MIKE
(standing)
Some stories are dangerous, Sarah. Be careful.

He walks away quickly, leaving Sarah puzzled.

SARAH
(calling after him)
Wait! What do you know?

But Mike disappears into the crowd.

FADE OUT.
"""

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Movie Script Analyzer",
        page_icon="ðŸŽ¬",
        layout="wide"
    )
    
    st.title("ðŸŽ¬ Movie Script Analyzer and Generator")
    st.markdown("Professional screenplay analysis and AI-powered content generation")
    
    # Sidebar
    with st.sidebar:
        st.header("âš™ï¸ Configuration")
        openai_api_key = st.text_input("OpenAI API Key", type="password")
        
        st.header("ðŸ“„ Script Input")
        input_method = st.radio("Input Method", ["Upload File", "Paste Text", "Use Sample"])
        
        if input_method == "Upload File":
            uploaded_file = st.file_uploader("Upload Script", type=['txt', 'pdf'])
        elif input_method == "Use Sample":
            if st.button("Load Sample Script"):
                st.session_state['sample_script'] = create_sample_script()
                st.success("Sample script loaded!")
    
    if not openai_api_key:
        st.warning("Please enter your OpenAI API key to continue.")
        return
    
    # Initialize analyzer
    if 'analyzer' not in st.session_state:
        try:
            st.session_state['analyzer'] = ScriptAnalyzer(openai_api_key)
        except Exception as e:
            st.error(f"Error initializing analyzer: {e}")
            return
    
    analyzer = st.session_state['analyzer']
    
    # Get script text
    script_text = ""
    
    if input_method == "Paste Text":
        script_text = st.text_area("Paste your screenplay here:", height=300)
    elif input_method == "Use Sample" and 'sample_script' in st.session_state:
        script_text = st.session_state['sample_script']
        st.text_area("Sample Script Preview:", value=script_text[:500] + "...", height=200, disabled=True)
    elif input_method == "Upload File" and uploaded_file:
        try:
            script_text = uploaded_file.read().decode('utf-8')
            st.text_area("Uploaded Script Preview:", value=script_text[:500] + "...", height=200, disabled=True)
        except Exception as e:
            st.error(f"Error reading file: {e}")
    
    if not script_text:
        st.info("Please provide a screenplay to analyze.")
        return
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "ðŸ“Š Script Analysis",
        "ðŸŽ­ Character Analysis", 
        "ðŸ“ˆ Structure & Pacing",
        "ðŸŽ¨ Dialogue Generator",
        "ðŸ“‹ Professional Report"
    ])
    
    # Perform analysis
    if 'current_analysis' not in st.session_state or st.button("ðŸ” Analyze Script", type="primary"):
        with st.spinner("Analyzing screenplay..."):
            try:
                analysis = analyzer.analyze_script(script_text)
                st.session_state['current_analysis'] = analysis
                st.success("Analysis complete!")
            except Exception as e:
                st.error(f"Analysis failed: {e}")
                return
    
    if 'current_analysis' not in st.session_state:
        st.info("Click 'Analyze Script' to begin analysis.")
        return
    
    analysis = st.session_state['current_analysis']
    
    with tab1:
        st.header("ðŸ“Š Script Analysis Overview")
        
        # Basic statistics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Total Pages", analysis.total_pages)
        with col2:
            st.metric("Total Scenes", analysis.total_scenes)
        with col3:
            st.metric("Characters", analysis.total_characters)
        with col4:
            dialogue_ratio = analysis.dialogue_statistics.get('dialogue_to_action_ratio', 0)
            st.metric("Dialogue/Action Ratio", f"{dialogue_ratio:.2f}")
        
        # Genre classification
        st.subheader("ðŸŽ­ Genre Classification")
        
        if analysis.genre_predictions:
            # Sort genres by confidence
            sorted_genres = sorted(analysis.genre_predictions.items(), 
                                 key=lambda x: x[1], reverse=True)
            
            # Display top genres
            for genre, confidence in sorted_genres[:5]:
                st.progress(confidence, text=f"{genre.title()}: {confidence:.1%}")
            
            # Genre visualization
            fig = px.bar(
                x=[genre.title() for genre, _ in sorted_genres],
                y=[conf for _, conf in sorted_genres],
                title="Genre Classification Confidence",
                labels={'x': 'Genre', 'y': 'Confidence Score'}
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Dialogue statistics
        st.subheader("ðŸ’¬ Dialogue Statistics")
        
        dialogue_stats = analysis.dialogue_statistics
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("Total Dialogue Lines", dialogue_stats.get('total_dialogue_lines', 0))
            st.metric("Total Words", dialogue_stats.get('total_dialogue_words', 0))
            st.metric("Avg Words per Line", f"{dialogue_stats.get('avg_words_per_dialogue', 0):.1f}")
        
        with col2:
            st.metric("Action Lines", dialogue_stats.get('total_action_lines', 0))
            readability = dialogue_stats.get('readability_score', 0)
            st.metric("Readability Score", f"{readability:.1f}")
            
            if readability > 60:
                st.success("Easy to read")
            elif readability > 30:
                st.warning("Moderate difficulty")
            else:
                st.error("Difficult to read")
    
    with tab2:
        st.header("ðŸŽ­ Character Analysis")
        
        if analysis.character_analysis:
            # Character overview
            st.subheader("ðŸ‘¥ Character Overview")
            
            character_data = []
            for char_name, character in analysis.character_analysis.items():
                character_data.append({
                    'Character': char_name,
                    'Total Lines': character.total_lines,
                    'First Appearance': character.first_appearance,
                    'Last Appearance': character.last_appearance,
                    'Screen Time': character.last_appearance - character.first_appearance
                })
            
            char_df = pd.DataFrame(character_data)
            char_df = char_df.sort_values('Total Lines', ascending=False)
            st.dataframe(char_df, use_container_width=True)
            
            # Character lines visualization
            fig = px.bar(
                char_df.head(10),
                x='Character',
                y='Total Lines',
                title="Character Dialogue Distribution (Top 10)"
            )
            fig.update_xaxes(tickangle=45)
            st.plotly_chart(fig, use_container_width=True)
            
            # Individual character analysis
            st.subheader("ðŸ” Individual Character Analysis")
            
            selected_char = st.selectbox(
                "Select Character for Detailed Analysis",
                list(analysis.character_analysis.keys())
            )
            
            if selected_char:
                character = analysis.character_analysis[selected_char]
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.write(f"**Character:** {character.name}")
                    st.write(f"**Total Lines:** {character.total_lines}")
                    st.write(f"**First Appearance:** Line {character.first_appearance}")
                    st.write(f"**Last Appearance:** Line {character.last_appearance}")
                
                with col2:
                    if character.emotional_profile:
                        st.write("**Emotional Profile:**")
                        for emotion, score in character.emotional_profile.items():
                            if score > 0:
                                st.write(f"- {emotion.title()}: {score:.1%}")
                
                # Sample dialogue
                if character.dialogue_lines:
                    st.write("**Sample Dialogue:**")
                    for i, line in enumerate(character.dialogue_lines[:3]):
                        st.write(f"{i+1}. {line}")
                
                # Character voice analysis
                if st.button(f"ðŸŽ¤ Analyze Voice Profile for {selected_char}"):
                    with st.spinner("Analyzing character voice..."):
                        try:
                            voice_profile = analyzer.dialogue_generator.analyze_character_voice(character)
                            st.write("**Voice Profile:**")
                            st.write(voice_profile)
                        except Exception as e:
                            st.error(f"Voice analysis failed: {e}")
        else:
            st.info("No characters found in the script.")
    
    with tab3:
        st.header("ðŸ“ˆ Structure & Pacing Analysis")
        
        # Act structure
        st.subheader("ðŸŽ¬ Three-Act Structure")
        
        if analysis.act_structure:
            act_data = []
            for act, (start_scene, end_scene) in analysis.act_structure.items():
                act_data.append({
                    'Act': act.replace('_', ' ').title(),
                    'Start Scene': start_scene,
                    'End Scene': end_scene,
                    'Scene Count': end_scene - start_scene + 1
                })
            
            act_df = pd.DataFrame(act_data)
            st.dataframe(act_df, use_container_width=True)
            
            # Act structure visualization
            fig = px.bar(
                act_df,
                x='Act',
                y='Scene Count',
                title="Scenes per Act",
                color='Act'
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Pacing analysis
        st.subheader("âš¡ Pacing Analysis")
        
        pacing = analysis.pacing_analysis
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Avg Scene Length", f"{pacing.get('avg_scene_length', 0):.1f} pages")
        with col2:
            st.metric("Avg Tension Level", f"{pacing.get('avg_tension', 0):.3f}")
        with col3:
            st.metric("Pacing Rhythm", pacing.get('pacing_rhythm', 'Unknown'))
        
        # Tension progression
        if 'tension_progression' in pacing and pacing['tension_progression']:
            fig = px.line(
                x=list(range(1, len(pacing['tension_progression']) + 1)),
                y=pacing['tension_progression'],
                title="Tension Progression Throughout Script",
                labels={'x': 'Scene Number', 'y': 'Tension Score'}
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Scene analysis
        st.subheader("ðŸŽ¯ Scene-by-Scene Analysis")
        
        if analysis.scene_analysis:
            scene_data = []
            for i, scene in enumerate(analysis.scene_analysis[:10]):  # First 10 scenes
                scene_data.append({
                    'Scene': i + 1,
                    'Location': scene.location,
                    'Time': scene.time,
                    'Characters': len(scene.characters),
                    'Page Count': f"{scene.page_count:.1f}",
                    'Dialogue Ratio': f"{scene.dialogue_ratio:.1%}",
                    'Tension Score': f"{scene.tension_score:.3f}"
                })
            
            scene_df = pd.DataFrame(scene_data)
            st.dataframe(scene_df, use_container_width=True)
    
    with tab4:
        st.header("ðŸŽ¨ AI Dialogue Generator")
        
        if analysis.character_analysis:
            st.subheader("ðŸ’¬ Generate New Dialogue")
            
            # Character selection
            character_names = list(analysis.character_analysis.keys())
            selected_character = st.selectbox("Select Character", character_names)
            
            # Scene context
            scene_context = st.text_area(
                "Scene Context",
                placeholder="Describe the situation, setting, and what's happening in the scene..."
            )
            
            # Other characters
            other_characters = st.multiselect(
                "Other Characters in Scene",
                [name for name in character_names if name != selected_character]
            )
            
            # Previous dialogue
            previous_dialogue = st.text_area(
                "Previous Dialogue (optional)",
                placeholder="Previous lines of dialogue for context..."
            )
            
            if st.button("ðŸŽ­ Generate Dialogue"):
                if selected_character and scene_context:
                    with st.spinner("Generating dialogue..."):
                        try:
                            # Get character voice profile
                            character = analysis.character_analysis[selected_character]
                            voice_profile = analyzer.dialogue_generator.analyze_character_voice(character)
                            
                            # Generate dialogue
                            generated_dialogue = analyzer.dialogue_generator.generate_dialogue(
                                selected_character,
                                voice_profile,
                                scene_context,
                                other_characters,
                                previous_dialogue
                            )
                            
                            st.subheader("âœ¨ Generated Dialogue")
                            st.write(f"**{selected_character}**")
                            st.write(generated_dialogue)
                            
                        except Exception as e:
                            st.error(f"Dialogue generation failed: {e}")
                else:
                    st.warning("Please select a character and provide scene context.")
            
            # Character voice profiles
            st.subheader("ðŸŽ¤ Character Voice Profiles")
            
            for char_name in character_names[:3]:  # Show first 3 characters
                with st.expander(f"Voice Profile: {char_name}"):
                    character = analysis.character_analysis[char_name]
                    
                    if st.button(f"Analyze Voice", key=f"voice_{char_name}"):
                        with st.spinner(f"Analyzing {char_name}'s voice..."):
                            try:
                                voice_profile = analyzer.dialogue_generator.analyze_character_voice(character)
                                st.write(voice_profile)
                            except Exception as e:
                                st.error(f"Voice analysis failed: {e}")
        else:
            st.info("No characters available for dialogue generation.")
    
    with tab5:
        st.header("ðŸ“‹ Professional Analysis Report")
        
        if st.button("ðŸ“„ Generate Comprehensive Report"):
            with st.spinner("Generating professional analysis report..."):
                try:
                    report = analyzer.generate_script_report(analysis)
                    
                    st.subheader("ðŸ“Š Professional Script Analysis Report")
                    st.markdown(report)
                    
                    # Download report
                    st.download_button(
                        label="ðŸ“¥ Download Report",
                        data=report,
                        file_name="script_analysis_report.txt",
                        mime="text/plain"
                    )
                    
                except Exception as e:
                    st.error(f"Report generation failed: {e}")
        
        # Analysis summary
        st.subheader("ðŸ“ˆ Quick Analysis Summary")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**Script Metrics:**")
            st.write(f"â€¢ Pages: {analysis.total_pages}")
            st.write(f"â€¢ Scenes: {analysis.total_scenes}")
            st.write(f"â€¢ Characters: {analysis.total_characters}")
            
            if analysis.genre_predictions:
                top_genre = max(analysis.genre_predictions.items(), key=lambda x: x[1])
                st.write(f"â€¢ Primary Genre: {top_genre[0].title()} ({top_genre[1]:.1%})")
        
        with col2:
            st.write("**Key Insights:**")
            
            # Dialogue quality
            readability = analysis.dialogue_statistics.get('readability_score', 0)
            if readability > 60:
                st.write("âœ… Dialogue is easily readable")
            else:
                st.write("âš ï¸ Dialogue may need simplification")
            
            # Character distribution
            if analysis.character_analysis:
                main_chars = [char for char in analysis.character_analysis.values() 
                            if char.total_lines > 10]
                st.write(f"â€¢ {len(main_chars)} major characters identified")
            
            # Pacing
            pacing_rhythm = analysis.pacing_analysis.get('pacing_rhythm', '')
            if pacing_rhythm == 'consistent':
                st.write("âœ… Consistent pacing throughout")
            elif pacing_rhythm == 'high_variation':
                st.write("âš ï¸ Highly variable scene pacing")
        
        # Industry comparisons
        st.subheader("ðŸ­ Industry Standard Comparisons")
        
        # Page count comparison
        if analysis.total_pages < 90:
            st.warning("âš ï¸ Script may be too short for feature film (industry standard: 90-120 pages)")
        elif analysis.total_pages > 120:
            st.warning("âš ï¸ Script may be too long for feature film")
        else:
            st.success("âœ… Page count within industry standard range")
        
        # Character count
        main_character_count = len([char for char in analysis.character_analysis.values() 
                                  if char.total_lines > 20])
        if main_character_count > 8:
            st.warning("âš ï¸ Many main characters may confuse audience")
        else:
            st.success("âœ… Manageable number of main characters")

if __name__ == "__main__":
    main()
````

### Environment Configuration

````python
OPENAI_API_KEY=your_openai_api_key_here
````

## Project Summary

The Movie Script Analyzer and Generator represents a comprehensive AI-powered tool that revolutionizes screenplay development and analysis. By combining advanced natural language processing, machine learning classification, and intelligent content generation, it provides professional-grade insights that were previously available only through expensive script coverage services or experienced industry professionals.

### Key Value Propositions:
- **Professional Format Analysis**: Automated parsing and validation of industry-standard screenplay formatting with detailed structural breakdown
- **Multi-Genre Classification**: Sophisticated genre detection using both rule-based and machine learning approaches for accurate categorization
- **Character Development Insights**: Deep analysis of character arcs, dialogue patterns, and relationship dynamics with voice consistency tracking
- **Story Structure Evaluation**: Three-act structure analysis with pacing assessment and plot point identification following industry standards
- **AI-Powered Content Generation**: Context-aware dialogue generation that maintains character voice authenticity and narrative consistency

### Technical Highlights:
- Advanced regex-based screenplay parsing supporting multiple formatting conventions and industry standards
- Hybrid genre classification combining TF-IDF vectorization with RandomForest classification and rule-based keyword analysis
- spaCy and NLTK integration for sophisticated natural language processing and sentiment analysis
- LangChain-powered dialogue generation with character voice profiling and consistency maintenance
- Comprehensive visualization suite using Plotly for tension progression, character development, and pacing analysis
- Professional report generation providing actionable insights for writers, producers, and development executives

This system demonstrates how AI can democratize access to professional script analysis tools while maintaining the nuanced understanding required for creative content evaluation, potentially transforming how screenplays are developed, evaluated, and refined in the entertainment industry.