<small>Claude Sonnet 4 **(Language Learning Agent)**</small>
# Language Learning Agent

## Key Concepts Explanation

### Translation Services
AI-powered translation system using neural machine translation models to provide accurate, context-aware translations between multiple languages with support for idioms, cultural nuances, and domain-specific terminology.

### Spaced Repetition
Evidence-based learning algorithm that optimizes memory retention by scheduling review sessions at increasing intervals, using psychological principles to maximize long-term vocabulary and concept retention.

### Grammar Correction
Advanced natural language processing system that identifies and corrects grammatical errors, syntax issues, and style improvements while providing educational explanations for learning reinforcement.

### Adaptive Learning
Personalized learning system that adjusts difficulty, pacing, and content based on individual progress, learning patterns, and performance analytics to optimize educational outcomes.

### Pronunciation Assessment
Speech recognition and analysis system that evaluates pronunciation accuracy, provides feedback on phonetic correctness, and offers targeted improvement suggestions.

## Comprehensive Project Explanation

### Objectives
The Language Learning Agent creates an intelligent tutoring system that combines translation, adaptive spaced repetition, grammar correction, and pronunciation assessment to provide personalized language learning experiences.

### Key Features
- **Multi-language Translation**: Real-time translation with context awareness
- **Smart Spaced Repetition**: Optimized review scheduling for vocabulary retention
- **Grammar Assistance**: Error detection with educational explanations
- **Progress Tracking**: Comprehensive analytics and adaptive learning paths
- **Interactive Exercises**: Diverse learning activities and assessments

### Challenges
- **Language Complexity**: Handling nuances, idioms, and cultural context
- **Personalization**: Adapting to individual learning styles and pace
- **Content Quality**: Ensuring accurate translations and corrections
- **Engagement**: Maintaining motivation through gamification

### Potential Impact
This system can democratize language education, provide personalized tutoring at scale, improve learning efficiency, and make language acquisition more accessible globally.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
transformers==4.35.0
googletrans==4.0.0
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
nltk==3.8.1
spacy==3.7.2
textblob==0.17.1
fuzzywuzzy==0.18.0
python-levenshtein==0.23.0
datetime
logging
typing
dataclasses
enum
json
re
````

### Core Implementation

````python
import pandas as pd
import numpy as np
import json
import re
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import random
import math

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go

# NLP libraries
import nltk
import spacy
from textblob import TextBlob
from fuzzywuzzy import fuzz

# Translation
from googletrans import Translator

# LLM integration
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Language(Enum):
    ENGLISH = "en"
    SPANISH = "es"
    FRENCH = "fr"
    GERMAN = "de"
    ITALIAN = "it"
    PORTUGUESE = "pt"
    CHINESE = "zh"
    JAPANESE = "ja"
    KOREAN = "ko"
    RUSSIAN = "ru"

class ProficiencyLevel(Enum):
    BEGINNER = "beginner"
    ELEMENTARY = "elementary"
    INTERMEDIATE = "intermediate"
    UPPER_INTERMEDIATE = "upper_intermediate"
    ADVANCED = "advanced"
    PROFICIENT = "proficient"

class ExerciseType(Enum):
    VOCABULARY = "vocabulary"
    GRAMMAR = "grammar"
    TRANSLATION = "translation"
    LISTENING = "listening"
    SPEAKING = "speaking"
    READING = "reading"
    WRITING = "writing"

@dataclass
class LearnerProfile:
    user_id: str
    native_language: Language
    target_language: Language
    proficiency_level: ProficiencyLevel
    learning_goals: List[str]
    daily_study_time: int  # minutes
    preferred_learning_style: str
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class Vocabulary:
    word_id: str
    word: str
    translation: str
    language: Language
    difficulty_level: int  # 1-5
    category: str
    example_sentence: str
    pronunciation: Optional[str] = None
    image_url: Optional[str] = None

@dataclass
class StudySession:
    session_id: str
    user_id: str
    vocabulary_id: str
    exercise_type: ExerciseType
    difficulty: int
    ease_factor: float
    interval: int  # days
    repetitions: int
    last_reviewed: datetime
    next_review: datetime
    correct_answers: int = 0
    total_attempts: int = 0

@dataclass
class GrammarRule:
    rule_id: str
    language: Language
    rule_title: str
    explanation: str
    examples: List[str]
    difficulty_level: int
    category: str

@dataclass
class TranslationPair:
    source_text: str
    target_text: str
    source_language: Language
    target_language: Language
    confidence: float
    context: Optional[str] = None

class TranslationService:
    """Advanced translation service with context awareness."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.translator = Translator()
        self.llm = None
        
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.3,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self._initialize_prompts()
    
    def _initialize_prompts(self):
        """Initialize translation prompts."""
        self.translation_prompt = ChatPromptTemplate.from_template("""
        Translate the following text from {source_lang} to {target_lang}.
        Provide a natural, contextually appropriate translation.
        
        Text: {text}
        Context: {context}
        
        Requirements:
        - Maintain original meaning and tone
        - Use appropriate formality level
        - Consider cultural nuances
        - Provide natural-sounding result
        
        Translation:
        """)
        
        self.explanation_prompt = ChatPromptTemplate.from_template("""
        Explain this translation choice for language learners:
        
        Original ({source_lang}): {original}
        Translation ({target_lang}): {translation}
        
        Provide:
        1. Why this translation was chosen
        2. Alternative translations if any
        3. Cultural or contextual notes
        4. Grammar patterns used
        
        Keep explanation clear and educational.
        """)
    
    def translate_text(self, text: str, source_lang: Language, 
                      target_lang: Language, context: str = "") -> TranslationPair:
        """Translate text with context awareness."""
        try:
            if self.llm and len(text) < 500:  # Use LLM for complex translations
                response = self.llm.invoke(
                    self.translation_prompt.format(
                        source_lang=source_lang.value,
                        target_lang=target_lang.value,
                        text=text,
                        context=context or "General conversation"
                    )
                )
                
                translation = response.content.strip()
                confidence = 0.9  # High confidence for LLM
            else:
                # Use Google Translate as fallback
                result = self.translator.translate(
                    text, 
                    src=source_lang.value, 
                    dest=target_lang.value
                )
                translation = result.text
                confidence = min(result.extra_data.get('confidence', 0.8), 0.8)
            
            return TranslationPair(
                source_text=text,
                target_text=translation,
                source_language=source_lang,
                target_language=target_lang,
                confidence=confidence,
                context=context
            )
        
        except Exception as e:
            logger.error(f"Translation error: {e}")
            return TranslationPair(
                source_text=text,
                target_text="Translation unavailable",
                source_language=source_lang,
                target_language=target_lang,
                confidence=0.0,
                context=context
            )
    
    def get_translation_explanation(self, translation_pair: TranslationPair) -> str:
        """Get explanation for translation choice."""
        if not self.llm:
            return "Translation explanation unavailable without LLM access."
        
        try:
            response = self.llm.invoke(
                self.explanation_prompt.format(
                    source_lang=translation_pair.source_language.value,
                    target_lang=translation_pair.target_language.value,
                    original=translation_pair.source_text,
                    translation=translation_pair.target_text
                )
            )
            
            return response.content
        
        except Exception as e:
            logger.error(f"Translation explanation error: {e}")
            return "Unable to provide explanation at this time."

class SpacedRepetitionSystem:
    """Implementation of SM-2 spaced repetition algorithm."""
    
    def __init__(self):
        self.default_ease_factor = 2.5
        self.min_ease_factor = 1.3
        self.max_ease_factor = 4.0
    
    def calculate_next_review(self, session: StudySession, performance_rating: int) -> StudySession:
        """Calculate next review date based on performance."""
        # Performance rating: 0-5 (0=complete failure, 5=perfect recall)
        
        if performance_rating < 3:
            # Failed recall - reset interval
            session.repetitions = 0
            session.interval = 1
        else:
            # Successful recall
            if session.repetitions == 0:
                session.interval = 1
            elif session.repetitions == 1:
                session.interval = 6
            else:
                session.interval = int(session.interval * session.ease_factor)
            
            session.repetitions += 1
        
        # Update ease factor
        session.ease_factor = max(
            self.min_ease_factor,
            session.ease_factor + (0.1 - (5 - performance_rating) * (0.08 + (5 - performance_rating) * 0.02))
        )
        
        # Set next review date
        session.last_reviewed = datetime.now()
        session.next_review = session.last_reviewed + timedelta(days=session.interval)
        
        return session
    
    def get_due_items(self, sessions: List[StudySession]) -> List[StudySession]:
        """Get items due for review."""
        now = datetime.now()
        return [session for session in sessions if session.next_review <= now]
    
    def prioritize_reviews(self, due_sessions: List[StudySession]) -> List[StudySession]:
        """Prioritize reviews based on difficulty and overdue time."""
        now = datetime.now()
        
        def priority_score(session):
            # Higher score = higher priority
            overdue_hours = (now - session.next_review).total_seconds() / 3600
            difficulty_factor = 6 - session.ease_factor  # Lower ease = higher priority
            
            return overdue_hours + difficulty_factor * 10
        
        return sorted(due_sessions, key=priority_score, reverse=True)

class GrammarChecker:
    """Grammar checking and correction system."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.llm = None
        
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.1,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self._initialize_prompts()
        self._load_grammar_rules()
    
    def _initialize_prompts(self):
        """Initialize grammar checking prompts."""
        self.grammar_prompt = ChatPromptTemplate.from_template("""
        Check the following text for grammar errors and provide corrections:
        
        Language: {language}
        Text: {text}
        
        For each error found, provide:
        1. The incorrect phrase/word
        2. The correction
        3. The grammar rule involved
        4. A brief explanation
        
        If no errors found, state "No grammar errors detected."
        
        Format as:
        ERROR: [incorrect text]
        CORRECTION: [corrected text]
        RULE: [grammar rule]
        EXPLANATION: [brief explanation]
        """)
    
    def _load_grammar_rules(self):
        """Load basic grammar rules for different languages."""
        self.grammar_rules = {
            Language.ENGLISH: [
                GrammarRule(
                    rule_id="en_01",
                    language=Language.ENGLISH,
                    rule_title="Subject-Verb Agreement",
                    explanation="The verb must agree with the subject in number (singular/plural).",
                    examples=["He walks (not walk)", "They walk (not walks)"],
                    difficulty_level=2,
                    category="verb_agreement"
                ),
                GrammarRule(
                    rule_id="en_02",
                    language=Language.ENGLISH,
                    rule_title="Article Usage",
                    explanation="Use 'a/an' for singular countable nouns, 'the' for specific nouns.",
                    examples=["I saw a cat", "The cat was black"],
                    difficulty_level=3,
                    category="articles"
                )
            ],
            Language.SPANISH: [
                GrammarRule(
                    rule_id="es_01",
                    language=Language.SPANISH,
                    rule_title="G√©nero y N√∫mero",
                    explanation="Adjectives must agree with nouns in gender and number.",
                    examples=["Casa blanca", "Casas blancas"],
                    difficulty_level=2,
                    category="agreement"
                )
            ]
        }
    
    def check_grammar(self, text: str, language: Language) -> Dict[str, Any]:
        """Check grammar and provide corrections."""
        try:
            if self.llm:
                response = self.llm.invoke(
                    self.grammar_prompt.format(
                        language=language.value,
                        text=text
                    )
                )
                
                corrections = self._parse_grammar_response(response.content)
            else:
                corrections = self._basic_grammar_check(text, language)
            
            return {
                'original_text': text,
                'corrections': corrections,
                'has_errors': len(corrections) > 0,
                'language': language.value
            }
        
        except Exception as e:
            logger.error(f"Grammar check error: {e}")
            return {
                'original_text': text,
                'corrections': [],
                'has_errors': False,
                'error': str(e)
            }
    
    def _parse_grammar_response(self, response: str) -> List[Dict[str, str]]:
        """Parse LLM grammar response."""
        corrections = []
        lines = response.split('\n')
        
        current_correction = {}
        
        for line in lines:
            line = line.strip()
            if line.startswith('ERROR:'):
                if current_correction:
                    corrections.append(current_correction)
                current_correction = {'error': line.replace('ERROR:', '').strip()}
            elif line.startswith('CORRECTION:'):
                current_correction['correction'] = line.replace('CORRECTION:', '').strip()
            elif line.startswith('RULE:'):
                current_correction['rule'] = line.replace('RULE:', '').strip()
            elif line.startswith('EXPLANATION:'):
                current_correction['explanation'] = line.replace('EXPLANATION:', '').strip()
        
        if current_correction:
            corrections.append(current_correction)
        
        return corrections
    
    def _basic_grammar_check(self, text: str, language: Language) -> List[Dict[str, str]]:
        """Basic grammar checking without LLM."""
        corrections = []
        
        # Simple checks for demonstration
        if language == Language.ENGLISH:
            # Check for common mistakes
            words = text.split()
            
            for i, word in enumerate(words):
                # Simple subject-verb disagreement
                if word.lower() in ['he', 'she', 'it'] and i + 1 < len(words):
                    next_word = words[i + 1].lower()
                    if next_word in ['walk', 'run', 'go'] and not next_word.endswith('s'):
                        corrections.append({
                            'error': f"{word} {next_word}",
                            'correction': f"{word} {next_word}s",
                            'rule': "Subject-verb agreement",
                            'explanation': "Third person singular verbs need 's' ending"
                        })
        
        return corrections

class VocabularyManager:
    """Manage vocabulary learning and progress."""
    
    def __init__(self):
        self.vocabulary_database = {}
        self._initialize_vocabulary()
    
    def _initialize_vocabulary(self):
        """Initialize vocabulary database with sample data."""
        sample_vocab = [
            # English-Spanish pairs
            Vocabulary("en_es_001", "hello", "hola", Language.ENGLISH, 1, "greetings", "Hello, how are you?"),
            Vocabulary("en_es_002", "goodbye", "adi√≥s", Language.ENGLISH, 1, "greetings", "Goodbye, see you later!"),
            Vocabulary("en_es_003", "beautiful", "hermoso", Language.ENGLISH, 2, "adjectives", "The sunset is beautiful."),
            Vocabulary("en_es_004", "difficult", "dif√≠cil", Language.ENGLISH, 3, "adjectives", "This exercise is difficult."),
            Vocabulary("en_es_005", "restaurant", "restaurante", Language.ENGLISH, 2, "places", "Let's go to a restaurant."),
            
            # Spanish words
            Vocabulary("es_001", "casa", "house", Language.SPANISH, 1, "nouns", "Mi casa es grande."),
            Vocabulary("es_002", "agua", "water", Language.SPANISH, 1, "nouns", "Necesito agua."),
            Vocabulary("es_003", "trabajar", "to work", Language.SPANISH, 2, "verbs", "Voy a trabajar ma√±ana."),
            Vocabulary("es_004", "feliz", "happy", Language.SPANISH, 2, "adjectives", "Estoy muy feliz."),
            Vocabulary("es_005", "escuela", "school", Language.SPANISH, 1, "places", "Los ni√±os van a la escuela."),
        ]
        
        for vocab in sample_vocab:
            self.vocabulary_database[vocab.word_id] = vocab
    
    def get_vocabulary_by_level(self, language: Language, level: int) -> List[Vocabulary]:
        """Get vocabulary items by difficulty level."""
        return [
            vocab for vocab in self.vocabulary_database.values()
            if vocab.language == language and vocab.difficulty_level <= level
        ]
    
    def get_vocabulary_by_category(self, language: Language, category: str) -> List[Vocabulary]:
        """Get vocabulary items by category."""
        return [
            vocab for vocab in self.vocabulary_database.values()
            if vocab.language == language and vocab.category == category
        ]
    
    def add_vocabulary(self, vocab: Vocabulary) -> bool:
        """Add new vocabulary item."""
        try:
            self.vocabulary_database[vocab.word_id] = vocab
            return True
        except Exception as e:
            logger.error(f"Error adding vocabulary: {e}")
            return False
    
    def search_vocabulary(self, query: str, language: Language) -> List[Vocabulary]:
        """Search vocabulary by word or translation."""
        results = []
        query_lower = query.lower()
        
        for vocab in self.vocabulary_database.values():
            if vocab.language == language:
                if (query_lower in vocab.word.lower() or 
                    query_lower in vocab.translation.lower()):
                    results.append(vocab)
        
        return results

class LearningExerciseGenerator:
    """Generate various types of learning exercises."""
    
    def __init__(self, vocab_manager: VocabularyManager):
        self.vocab_manager = vocab_manager
    
    def generate_vocabulary_exercise(self, language: Language, level: int, 
                                   exercise_type: str = "multiple_choice") -> Dict[str, Any]:
        """Generate vocabulary exercise."""
        vocab_items = self.vocab_manager.get_vocabulary_by_level(language, level)
        
        if not vocab_items:
            return {"error": "No vocabulary available for this level"}
        
        target_vocab = random.choice(vocab_items)
        
        if exercise_type == "multiple_choice":
            return self._generate_multiple_choice(target_vocab, vocab_items)
        elif exercise_type == "translation":
            return self._generate_translation_exercise(target_vocab)
        elif exercise_type == "fill_blank":
            return self._generate_fill_blank(target_vocab)
        else:
            return {"error": "Unknown exercise type"}
    
    def _generate_multiple_choice(self, target: Vocabulary, all_vocab: List[Vocabulary]) -> Dict[str, Any]:
        """Generate multiple choice exercise."""
        # Get wrong answers
        wrong_answers = [v.translation for v in all_vocab if v.word_id != target.word_id]
        wrong_answers = random.sample(wrong_answers, min(3, len(wrong_answers)))
        
        # Create options
        options = wrong_answers + [target.translation]
        random.shuffle(options)
        
        return {
            "type": "multiple_choice",
            "question": f"What is the translation of '{target.word}'?",
            "word": target.word,
            "options": options,
            "correct_answer": target.translation,
            "example": target.example_sentence,
            "category": target.category,
            "difficulty": target.difficulty_level
        }
    
    def _generate_translation_exercise(self, target: Vocabulary) -> Dict[str, Any]:
        """Generate translation exercise."""
        return {
            "type": "translation",
            "question": f"Translate: {target.word}",
            "word": target.word,
            "correct_answer": target.translation,
            "example": target.example_sentence,
            "category": target.category,
            "difficulty": target.difficulty_level
        }
    
    def _generate_fill_blank(self, target: Vocabulary) -> Dict[str, Any]:
        """Generate fill-in-the-blank exercise."""
        sentence = target.example_sentence
        
        # Replace target word with blank
        if target.word.lower() in sentence.lower():
            modified_sentence = sentence.replace(target.word, "_____")
        else:
            # Create a simple sentence
            modified_sentence = f"The _____ is important."
        
        return {
            "type": "fill_blank",
            "question": f"Fill in the blank:",
            "sentence": modified_sentence,
            "correct_answer": target.word,
            "translation": target.translation,
            "category": target.category,
            "difficulty": target.difficulty_level
        }

class ProgressTracker:
    """Track and analyze learning progress."""
    
    def __init__(self):
        self.user_progress = {}
        self.session_history = {}
    
    def record_session(self, user_id: str, session: StudySession, 
                      performance_rating: int) -> None:
        """Record a study session."""
        if user_id not in self.session_history:
            self.session_history[user_id] = []
        
        session_record = {
            'session_id': session.session_id,
            'vocabulary_id': session.vocabulary_id,
            'exercise_type': session.exercise_type.value,
            'performance_rating': performance_rating,
            'timestamp': datetime.now(),
            'ease_factor': session.ease_factor,
            'interval': session.interval
        }
        
        self.session_history[user_id].append(session_record)
        
        # Update user progress
        self._update_user_progress(user_id)
    
    def _update_user_progress(self, user_id: str) -> None:
        """Update overall user progress statistics."""
        sessions = self.session_history.get(user_id, [])
        
        if not sessions:
            return
        
        # Calculate statistics
        total_sessions = len(sessions)
        recent_sessions = [s for s in sessions if s['timestamp'] > datetime.now() - timedelta(days=7)]
        
        avg_performance = np.mean([s['performance_rating'] for s in sessions])
        recent_performance = np.mean([s['performance_rating'] for s in recent_sessions]) if recent_sessions else 0
        
        # Vocabulary mastery
        vocab_performance = {}
        for session in sessions:
            vocab_id = session['vocabulary_id']
            if vocab_id not in vocab_performance:
                vocab_performance[vocab_id] = []
            vocab_performance[vocab_id].append(session['performance_rating'])
        
        mastered_words = sum(1 for ratings in vocab_performance.values() 
                           if len(ratings) >= 3 and np.mean(ratings[-3:]) >= 4)
        
        self.user_progress[user_id] = {
            'total_sessions': total_sessions,
            'avg_performance': avg_performance,
            'recent_performance': recent_performance,
            'mastered_words': mastered_words,
            'total_vocabulary': len(vocab_performance),
            'study_streak': self._calculate_study_streak(user_id),
            'last_study_date': max(s['timestamp'] for s in sessions) if sessions else None
        }
    
    def _calculate_study_streak(self, user_id: str) -> int:
        """Calculate current study streak in days."""
        sessions = self.session_history.get(user_id, [])
        if not sessions:
            return 0
        
        # Group sessions by date
        session_dates = set()
        for session in sessions:
            session_dates.add(session['timestamp'].date())
        
        # Check consecutive days from today backwards
        current_date = datetime.now().date()
        streak = 0
        
        while current_date in session_dates:
            streak += 1
            current_date -= timedelta(days=1)
        
        return streak
    
    def get_progress_summary(self, user_id: str) -> Dict[str, Any]:
        """Get comprehensive progress summary."""
        return self.user_progress.get(user_id, {
            'total_sessions': 0,
            'avg_performance': 0,
            'recent_performance': 0,
            'mastered_words': 0,
            'total_vocabulary': 0,
            'study_streak': 0,
            'last_study_date': None
        })
    
    def get_learning_analytics(self, user_id: str) -> Dict[str, Any]:
        """Get detailed learning analytics."""
        sessions = self.session_history.get(user_id, [])
        
        if not sessions:
            return {}
        
        # Performance over time
        performance_data = [(s['timestamp'], s['performance_rating']) for s in sessions]
        performance_data.sort(key=lambda x: x[0])
        
        # Exercise type performance
        exercise_performance = {}
        for session in sessions:
            ex_type = session['exercise_type']
            if ex_type not in exercise_performance:
                exercise_performance[ex_type] = []
            exercise_performance[ex_type].append(session['performance_rating'])
        
        return {
            'performance_timeline': performance_data,
            'exercise_type_performance': {
                ex_type: {
                    'avg_performance': np.mean(ratings),
                    'total_attempts': len(ratings)
                }
                for ex_type, ratings in exercise_performance.items()
            },
            'weekly_activity': self._get_weekly_activity(sessions),
            'difficulty_progression': self._get_difficulty_progression(sessions)
        }
    
    def _get_weekly_activity(self, sessions: List[Dict]) -> Dict[str, int]:
        """Get weekly activity statistics."""
        weekly_counts = {}
        
        for session in sessions:
            week_start = session['timestamp'].date() - timedelta(days=session['timestamp'].weekday())
            week_key = week_start.strftime('%Y-%m-%d')
            
            weekly_counts[week_key] = weekly_counts.get(week_key, 0) + 1
        
        return weekly_counts
    
    def _get_difficulty_progression(self, sessions: List[Dict]) -> List[Dict]:
        """Get difficulty progression over time."""
        # This would track how user performance changes with difficulty
        # Simplified implementation
        return [
            {
                'date': session['timestamp'].date().isoformat(),
                'performance': session['performance_rating'],
                'ease_factor': session['ease_factor']
            }
            for session in sessions[-30:]  # Last 30 sessions
        ]

class LanguageLearningAgent:
    """Main language learning agent orchestrating all components."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.translation_service = TranslationService(openai_api_key)
        self.spaced_repetition = SpacedRepetitionSystem()
        self.grammar_checker = GrammarChecker(openai_api_key)
        self.vocab_manager = VocabularyManager()
        self.exercise_generator = LearningExerciseGenerator(self.vocab_manager)
        self.progress_tracker = ProgressTracker()
        
        self.user_sessions = {}  # user_id -> List[StudySession]
    
    def create_learner_profile(self, profile: LearnerProfile) -> bool:
        """Create a new learner profile."""
        try:
            self.user_sessions[profile.user_id] = []
            logger.info(f"Created profile for user {profile.user_id}")
            return True
        except Exception as e:
            logger.error(f"Error creating profile: {e}")
            return False
    
    def get_daily_study_plan(self, user_id: str, target_language: Language,
                           proficiency_level: ProficiencyLevel) -> Dict[str, Any]:
        """Generate daily study plan for user."""
        try:
            # Get due reviews
            user_sessions = self.user_sessions.get(user_id, [])
            due_sessions = self.spaced_repetition.get_due_items(user_sessions)
            prioritized_reviews = self.spaced_repetition.prioritize_reviews(due_sessions)
            
            # Get new vocabulary to learn
            level_num = self._proficiency_to_level(proficiency_level)
            new_vocab = self.vocab_manager.get_vocabulary_by_level(target_language, level_num)
            
            # Create study plan
            study_plan = {
                'date': datetime.now().date().isoformat(),
                'reviews_due': len(due_sessions),
                'new_vocabulary': min(5, len(new_vocab)),  # Learn up to 5 new words
                'recommended_exercises': [
                    self.exercise_generator.generate_vocabulary_exercise(
                        target_language, level_num, "multiple_choice"
                    ),
                    self.exercise_generator.generate_vocabulary_exercise(
                        target_language, level_num, "translation"
                    )
                ],
                'priority_reviews': [
                    {
                        'vocabulary_id': session.vocabulary_id,
                        'word': self._get_word_by_id(session.vocabulary_id),
                        'overdue_days': (datetime.now() - session.next_review).days
                    }
                    for session in prioritized_reviews[:5]
                ]
            }
            
            return study_plan
        
        except Exception as e:
            logger.error(f"Error generating study plan: {e}")
            return {'error': str(e)}
    
    def _proficiency_to_level(self, proficiency: ProficiencyLevel) -> int:
        """Convert proficiency level to numeric level."""
        mapping = {
            ProficiencyLevel.BEGINNER: 1,
            ProficiencyLevel.ELEMENTARY: 2,
            ProficiencyLevel.INTERMEDIATE: 3,
            ProficiencyLevel.UPPER_INTERMEDIATE: 4,
            ProficiencyLevel.ADVANCED: 5,
            ProficiencyLevel.PROFICIENT: 5
        }
        return mapping.get(proficiency, 1)
    
    def _get_word_by_id(self, vocab_id: str) -> str:
        """Get word by vocabulary ID."""
        vocab = self.vocab_manager.vocabulary_database.get(vocab_id)
        return vocab.word if vocab else "Unknown"
    
    def conduct_exercise_session(self, user_id: str, exercise_data: Dict[str, Any],
                               user_answer: str) -> Dict[str, Any]:
        """Conduct an exercise session and update progress."""
        try:
            correct_answer = exercise_data.get('correct_answer', '')
            
            # Evaluate answer
            is_correct, similarity_score = self._evaluate_answer(user_answer, correct_answer)
            
            # Calculate performance rating (0-5)
            if is_correct:
                performance_rating = 5
            elif similarity_score > 0.8:
                performance_rating = 4
            elif similarity_score > 0.6:
                performance_rating = 3
            elif similarity_score > 0.4:
                performance_rating = 2
            else:
                performance_rating = 1
            
            # Record session (simplified - would need actual StudySession object)
            self.progress_tracker.record_session(
                user_id,
                StudySession(
                    session_id=f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    user_id=user_id,
                    vocabulary_id=exercise_data.get('word', 'unknown'),
                    exercise_type=ExerciseType.VOCABULARY,
                    difficulty=exercise_data.get('difficulty', 1),
                    ease_factor=2.5,
                    interval=1,
                    repetitions=0,
                    last_reviewed=datetime.now(),
                    next_review=datetime.now() + timedelta(days=1)
                ),
                performance_rating
            )
            
            return {
                'correct': is_correct,
                'user_answer': user_answer,
                'correct_answer': correct_answer,
                'performance_rating': performance_rating,
                'similarity_score': similarity_score,
                'feedback': self._generate_feedback(is_correct, similarity_score, exercise_data)
            }
        
        except Exception as e:
            logger.error(f"Error in exercise session: {e}")
            return {'error': str(e)}
    
    def _evaluate_answer(self, user_answer: str, correct_answer: str) -> Tuple[bool, float]:
        """Evaluate user answer against correct answer."""
        user_clean = user_answer.strip().lower()
        correct_clean = correct_answer.strip().lower()
        
        # Exact match
        if user_clean == correct_clean:
            return True, 1.0
        
        # Fuzzy matching for partial credit
        similarity = fuzz.ratio(user_clean, correct_clean) / 100.0
        
        # Consider correct if very similar
        is_correct = similarity > 0.9
        
        return is_correct, similarity
    
    def _generate_feedback(self, is_correct: bool, similarity: float, 
                         exercise_data: Dict[str, Any]) -> str:
        """Generate feedback for user answer."""
        if is_correct:
            return "Excellent! That's correct! üéâ"
        elif similarity > 0.8:
            return f"Very close! The correct answer is '{exercise_data.get('correct_answer', '')}'"
        elif similarity > 0.5:
            return f"Good attempt! The correct answer is '{exercise_data.get('correct_answer', '')}'. Try to remember this for next time."
        else:
            return f"Not quite right. The correct answer is '{exercise_data.get('correct_answer', '')}'. Let's practice this more."

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Language Learning Agent",
        page_icon="üåç",
        layout="wide"
    )
    
    st.title("üåç AI Language Learning Agent")
    st.markdown("Personalized language learning with spaced repetition and AI assistance")
    
    # Initialize session state
    if 'agent' not in st.session_state:
        st.session_state['agent'] = None
    if 'learner_profile' not in st.session_state:
        st.session_state['learner_profile'] = None
    if 'current_exercise' not in st.session_state:
        st.session_state['current_exercise'] = None
    
    # Sidebar for configuration
    with st.sidebar:
        st.header("üîß Setup")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Agent") or st.session_state['agent'] is None:
            st.session_state['agent'] = LanguageLearningAgent(openai_key)
            st.success("Language Learning Agent ready!")
        
        st.header("üë§ Learner Profile")
        
        if st.session_state['learner_profile'] is None:
            # Profile creation
            native_lang = st.selectbox("Native Language", ["English", "Spanish", "French", "German"])
            target_lang = st.selectbox("Target Language", ["Spanish", "English", "French", "German"])
            proficiency = st.selectbox("Proficiency Level", [
                "Beginner", "Elementary", "Intermediate", "Upper Intermediate", "Advanced"
            ])
            
            daily_time = st.slider("Daily Study Time (minutes)", 5, 120, 30)
            
            learning_goals = st.multiselect("Learning Goals", [
                "Travel", "Business", "Academic", "Personal Interest", "Career"
            ])
            
            if st.button("Create Profile"):
                # Map to enums
                native_enum = Language[native_lang.upper()]
                target_enum = Language[target_lang.upper()]
                proficiency_enum = ProficiencyLevel[proficiency.upper().replace(" ", "_")]
                
                profile = LearnerProfile(
                    user_id="demo_user",
                    native_language=native_enum,
                    target_language=target_enum,
                    proficiency_level=proficiency_enum,
                    learning_goals=learning_goals,
                    daily_study_time=daily_time,
                    preferred_learning_style="mixed"
                )
                
                st.session_state['learner_profile'] = profile
                if st.session_state['agent']:
                    st.session_state['agent'].create_learner_profile(profile)
                st.success("Profile created!")
                st.rerun()
        else:
            profile = st.session_state['learner_profile']
            st.write(f"**Native:** {profile.native_language.value}")
            st.write(f"**Learning:** {profile.target_language.value}")
            st.write(f"**Level:** {profile.proficiency_level.value}")
            
            if st.button("Reset Profile"):
                st.session_state['learner_profile'] = None
                st.rerun()
    
    if not st.session_state['agent']:
        st.info("üëà Please initialize the agent")
        return
    
    if not st.session_state['learner_profile']:
        st.info("üëà Please create your learner profile")
        return
    
    agent = st.session_state['agent']
    profile = st.session_state['learner_profile']
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üìö Study", "üîÑ Translation", "‚úèÔ∏è Grammar", "üìä Progress", "üéØ Exercises"])
    
    with tab1:
        st.header("üìö Daily Study Plan")
        
        if st.button("Generate Study Plan"):
            study_plan = agent.get_daily_study_plan(
                profile.user_id,
                profile.target_language,
                profile.proficiency_level
            )
            st.session_state['study_plan'] = study_plan
        
        if 'study_plan' in st.session_state:
            plan = st.session_state['study_plan']
            
            if 'error' not in plan:
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("Reviews Due", plan.get('reviews_due', 0))
                with col2:
                    st.metric("New Vocabulary", plan.get('new_vocabulary', 0))
                with col3:
                    st.metric("Study Date", plan.get('date', 'Today'))
                
                # Priority reviews
                if plan.get('priority_reviews'):
                    st.subheader("üî• Priority Reviews")
                    for review in plan['priority_reviews']:
                        st.write(f"‚Ä¢ **{review['word']}** (overdue: {review['overdue_days']} days)")
                
                # Recommended exercises
                if plan.get('recommended_exercises'):
                    st.subheader("üéØ Recommended Exercises")
                    for i, exercise in enumerate(plan['recommended_exercises']):
                        if exercise.get('type'):
                            st.write(f"**{i+1}.** {exercise['type'].replace('_', ' ').title()}")
                            st.write(f"   {exercise.get('question', 'No question available')}")
    
    with tab2:
        st.header("üîÑ Translation Service")
        
        col1, col2 = st.columns(2)
        
        with col1:
            source_lang = st.selectbox("From Language", ["English", "Spanish", "French", "German"], key="trans_from")
            text_to_translate = st.text_area("Text to translate", 
                                           placeholder="Enter text to translate...")
        
        with col2:
            target_lang = st.selectbox("To Language", ["Spanish", "English", "French", "German"], key="trans_to")
            context = st.text_input("Context (optional)", placeholder="e.g., formal business email")
        
        if st.button("Translate") and text_to_translate:
            with st.spinner("Translating..."):
                source_enum = Language[source_lang.upper()]
                target_enum = Language[target_lang.upper()]
                
                translation = agent.translation_service.translate_text(
                    text_to_translate, source_enum, target_enum, context
                )
                
                st.subheader("Translation Result")
                st.write(f"**Original ({source_lang}):** {translation.source_text}")
                st.write(f"**Translation ({target_lang}):** {translation.target_text}")
                st.write(f"**Confidence:** {translation.confidence:.1%}")
                
                # Get explanation if LLM is available
                if agent.translation_service.llm:
                    if st.button("Get Explanation"):
                        explanation = agent.translation_service.get_translation_explanation(translation)
                        st.write("**Explanation:**")
                        st.write(explanation)
    
    with tab3:
        st.header("‚úèÔ∏è Grammar Checker")
        
        text_to_check = st.text_area("Enter text to check for grammar errors",
                                   placeholder="Write in your target language...")
        
        check_language = st.selectbox("Text Language", ["English", "Spanish", "French", "German"], key="grammar_lang")
        
        if st.button("Check Grammar") and text_to_check:
            with st.spinner("Checking grammar..."):
                lang_enum = Language[check_language.upper()]
                
                result = agent.grammar_checker.check_grammar(text_to_check, lang_enum)
                
                if result.get('has_errors'):
                    st.error("Grammar errors found:")
                    
                    for correction in result['corrections']:
                        st.write("---")
                        st.write(f"**Error:** {correction.get('error', 'N/A')}")
                        st.write(f"**Correction:** {correction.get('correction', 'N/A')}")
                        st.write(f"**Rule:** {correction.get('rule', 'N/A')}")
                        st.write(f"**Explanation:** {correction.get('explanation', 'N/A')}")
                else:
                    st.success("No grammar errors detected! ‚úÖ")
    
    with tab4:
        st.header("üìä Learning Progress")
        
        progress = agent.progress_tracker.get_progress_summary(profile.user_id)
        
        # Progress metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Study Sessions", progress.get('total_sessions', 0))
        with col2:
            st.metric("Mastered Words", progress.get('mastered_words', 0))
        with col3:
            st.metric("Study Streak", f"{progress.get('study_streak', 0)} days")
        with col4:
            st.metric("Avg Performance", f"{progress.get('avg_performance', 0):.1f}/5")
        
        # Learning analytics
        if st.button("Show Detailed Analytics"):
            analytics = agent.progress_tracker.get_learning_analytics(profile.user_id)
            
            if analytics:
                # Performance timeline
                if analytics.get('performance_timeline'):
                    st.subheader("üìà Performance Over Time")
                    
                    timeline_data = analytics['performance_timeline']
                    dates = [item[0] for item in timeline_data]
                    scores = [item[1] for item in timeline_data]
                    
                    fig = px.line(x=dates, y=scores, title="Performance Timeline")
                    fig.update_yaxis(range=[0, 5])
                    st.plotly_chart(fig, use_container_width=True)
                
                # Exercise type performance
                if analytics.get('exercise_type_performance'):
                    st.subheader("üéØ Performance by Exercise Type")
                    
                    exercise_data = analytics['exercise_type_performance']
                    types = list(exercise_data.keys())
                    avg_scores = [data['avg_performance'] for data in exercise_data.values()]
                    
                    fig = px.bar(x=types, y=avg_scores, title="Average Performance by Exercise Type")
                    fig.update_yaxis(range=[0, 5])
                    st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("Complete some exercises to see detailed analytics")
    
    with tab5:
        st.header("üéØ Practice Exercises")
        
        exercise_type = st.selectbox("Exercise Type", [
            "Multiple Choice", "Translation", "Fill in the Blank"
        ])
        
        difficulty = st.slider("Difficulty Level", 1, 5, 2)
        
        if st.button("Generate Exercise") or st.session_state['current_exercise'] is None:
            exercise_type_key = exercise_type.lower().replace(" ", "_")
            
            exercise = agent.exercise_generator.generate_vocabulary_exercise(
                profile.target_language,
                difficulty,
                exercise_type_key
            )
            
            st.session_state['current_exercise'] = exercise
        
        # Display current exercise
        if st.session_state['current_exercise']:
            exercise = st.session_state['current_exercise']
            
            if 'error' not in exercise:
                st.subheader(f"üìù {exercise.get('type', '').replace('_', ' ').title()} Exercise")
                
                st.write(f"**Question:** {exercise.get('question', '')}")
                
                if exercise.get('sentence'):
                    st.write(f"**Sentence:** {exercise['sentence']}")
                
                # Handle different exercise types
                if exercise.get('type') == 'multiple_choice':
                    user_answer = st.radio("Choose the correct answer:", exercise.get('options', []))
                else:
                    user_answer = st.text_input("Your answer:")
                
                if st.button("Submit Answer") and user_answer:
                    # Process answer
                    result = agent.conduct_exercise_session(
                        profile.user_id,
                        exercise,
                        user_answer
                    )
                    
                    if result.get('correct'):
                        st.success(result.get('feedback', 'Correct!'))
                    else:
                        st.error(result.get('feedback', 'Try again!'))
                    
                    # Show additional info
                    if exercise.get('example'):
                        st.info(f"**Example:** {exercise['example']}")
                    
                    # Reset for next exercise
                    if st.button("Next Exercise"):
                        st.session_state['current_exercise'] = None
                        st.rerun()
            else:
                st.error(f"Exercise generation error: {exercise['error']}")

if __name__ == "__main__":
    main()
````

## Project Summary

The Language Learning Agent provides comprehensive AI-powered language education through intelligent translation services, spaced repetition algorithms, grammar correction, and adaptive learning systems that personalize the educational experience for optimal language acquisition.

### Key Value Propositions:
- **Intelligent Translation**: Context-aware translation with educational explanations and cultural insights
- **Spaced Repetition**: Scientific memory optimization using SM-2 algorithm for efficient vocabulary retention
- **Grammar Assistance**: Real-time error detection with educational feedback and rule explanations
- **Adaptive Learning**: Personalized study plans based on performance analytics and learning patterns

### Technical Architecture:
The system integrates LangChain for conversational AI, Google Translate API for translation services, advanced NLP models for grammar checking, and mathematical algorithms for spaced repetition, creating a comprehensive language learning platform that adapts to individual learners and provides scientifically-backed educational methodologies.