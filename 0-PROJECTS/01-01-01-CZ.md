<small>Claude Sonnet 4 **(Smart Code Assistant s MCP (Model Context Protocol))**</small>
# Smart Code Assistant

## Kl칤캜ov칠 Koncepty

### Model Context Protocol (MCP)
**Model Context Protocol** je standardizovan칳 protokol pro komunikaci mezi AI modely a extern칤mi syst칠my. Umo쮄갓je AI asistent콢m p콏칤stup k extern칤m dat콢m, n치stroj콢m a slu쬭치m bezpe캜n칳m a strukturovan칳m zp콢sobem.

### IDE Integrace
**Integrace do v칳vojov칠ho prost콏ed칤** zahrnuje vytvo콏en칤 plugin콢 a roz코칤콏en칤, kter치 umo쮄갓j칤 AI asistentovi pracovat p콏칤mo v editoru k칩du, analyzovat projekty a poskytovat kontextov칠 n치vrhy.

### Anal칳za K칩du
**Statick치 a dynamick치 anal칳za** k칩du zahrnuje parsov치n칤 AST (Abstract Syntax Tree), detekci vzor콢, identifikaci probl칠m콢 a n치vrhy vylep코en칤 k칩dov칠 b치ze.

### Git Repozit치콏e
**Spr치va verz칤** a anal칳za historie zm캩n umo쮄갓je AI asistentovi porozum캩t v칳voji projektu, identifikovat trendy a navrhovat optimalizace.

## Komplexn칤 Vysv캩tlen칤 Projektu

### C칤le Projektu
Smart Code Assistant je pokro캜il칳 AI syst칠m navr쬰n칳 pro integraci do v칳vojov칳ch prost콏ed칤 prost콏ednictv칤m Model Context Protocol. Hlavn칤mi c칤li jsou:

- **Automatizace rutinn칤ch 칰loh**: Generov치n칤 dokumentace, refaktoring k칩du, vytv치콏en칤 test콢
- **Zv칳코en칤 produktivity**: Inteligentn칤 n치vrhy k칩du, detekce chyb, optimalizace v칳konu
- **Zlep코en칤 kvality k칩du**: Kontrola best practices, bezpe캜nostn칤 audit, architektonick칠 n치vrhy

### Technick칠 V칳zvy
- **Kontextov칠 porozum캩n칤**: Anal칳za cel칠ho projektu, ne jen jednotliv칳ch soubor콢
- **V칳konnost**: Rychl치 odezva p콏i pr치ci s velk칳mi k칩db치zemi
- **Bezpe캜nost**: Ochrana citliv칠ho k칩du a dat
- **Kompatibilita**: Podpora r콢zn칳ch programovac칤ch jazyk콢 a framework콢

### Potenci치ln칤 Dopad
Projekt m콢쬰 revolucionizovat zp콢sob, jak칳m v칳voj치콏i pracuj칤 s k칩dem, zkr치tit 캜as v칳voje o 30-50% a v칳razn캩 sn칤쬴t po캜et chyb v produk캜n칤m k칩du.

## Komplexn칤 Implementace v Pythonu

### Instalace Z치vislost칤

````python
# requirements.txt
langchain>=0.1.0
langchain-openai>=0.1.0
chromadb>=0.4.0
gitpython>=3.1.0
tree-sitter>=0.20.0
tree-sitter-python>=0.20.0
fastapi>=0.104.0
uvicorn>=0.24.0
pydantic>=2.5.0
asyncio-mqtt>=0.16.0
python-dotenv>=1.0.0
````

### Hlavn칤 Architektura

````python
import asyncio
import json
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum

class MCPMessageType(Enum):
    REQUEST = "request"
    RESPONSE = "response"
    NOTIFICATION = "notification"

@dataclass
class MCPMessage:
    type: MCPMessageType
    id: Optional[str]
    method: str
    params: Dict[str, Any]
    result: Optional[Dict[str, Any]] = None
    error: Optional[Dict[str, Any]] = None

class MCPProtocol:
    def __init__(self):
        self.handlers = {}
        self.connections = set()
    
    def register_handler(self, method: str, handler):
        """Registrace handleru pro specifickou MCP metodu"""
        self.handlers[method] = handler
    
    async def handle_message(self, message: MCPMessage) -> Optional[MCPMessage]:
        """Zpracov치n칤 p콏칤choz칤 MCP zpr치vy"""
        try:
            if message.method in self.handlers:
                result = await self.handlers[message.method](message.params)
                return MCPMessage(
                    type=MCPMessageType.RESPONSE,
                    id=message.id,
                    method=message.method,
                    result=result
                )
            else:
                return MCPMessage(
                    type=MCPMessageType.RESPONSE,
                    id=message.id,
                    method=message.method,
                    error={"code": -32601, "message": "Method not found"}
                )
        except Exception as e:
            return MCPMessage(
                type=MCPMessageType.RESPONSE,
                id=message.id,
                method=message.method,
                error={"code": -32603, "message": str(e)}
            )
````

### Anal칳za K칩du

````python
import ast
import tree_sitter
from tree_sitter import Language, Parser
from typing import List, Dict, Any
import os

class CodeAnalyzer:
    def __init__(self):
        self.python_parser = self._setup_tree_sitter()
        
    def _setup_tree_sitter(self):
        """Nastaven칤 Tree-sitter parseru pro Python"""
        try:
            # P콏edpokl치d치me, 쬰 m치me zkompilovanou Python gramatiku
            PY_LANGUAGE = Language('build/my-languages.so', 'python')
            parser = Parser()
            parser.set_language(PY_LANGUAGE)
            return parser
        except:
            # Fallback na AST parser
            return None
    
    def analyze_file(self, file_path: str) -> Dict[str, Any]:
        """Anal칳za jednoho souboru"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            return {
                'file_path': file_path,
                'functions': self._extract_functions(content),
                'classes': self._extract_classes(content),
                'imports': self._extract_imports(content),
                'complexity': self._calculate_complexity(content),
                'issues': self._detect_issues(content)
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _extract_functions(self, content: str) -> List[Dict[str, Any]]:
        """Extrakce funkc칤 z k칩du"""
        try:
            tree = ast.parse(content)
            functions = []
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    functions.append({
                        'name': node.name,
                        'line_start': node.lineno,
                        'line_end': node.end_lineno,
                        'args': [arg.arg for arg in node.args.args],
                        'docstring': ast.get_docstring(node),
                        'is_async': isinstance(node, ast.AsyncFunctionDef)
                    })
            
            return functions
        except:
            return []
    
    def _extract_classes(self, content: str) -> List[Dict[str, Any]]:
        """Extrakce t콏칤d z k칩du"""
        try:
            tree = ast.parse(content)
            classes = []
            
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    methods = []
                    for item in node.body:
                        if isinstance(item, ast.FunctionDef):
                            methods.append(item.name)
                    
                    classes.append({
                        'name': node.name,
                        'line_start': node.lineno,
                        'line_end': node.end_lineno,
                        'methods': methods,
                        'docstring': ast.get_docstring(node),
                        'bases': [base.id for base in node.bases if hasattr(base, 'id')]
                    })
            
            return classes
        except:
            return []
    
    def _extract_imports(self, content: str) -> List[str]:
        """Extrakce import콢"""
        try:
            tree = ast.parse(content)
            imports = []
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    module = node.module or ''
                    for alias in node.names:
                        imports.append(f"{module}.{alias.name}")
            
            return imports
        except:
            return []
    
    def _calculate_complexity(self, content: str) -> int:
        """V칳po캜et cyklomatick칠 slo쬴tosti"""
        try:
            tree = ast.parse(content)
            complexity = 1  # Z치kladn칤 slo쬴tost
            
            for node in ast.walk(tree):
                if isinstance(node, (ast.If, ast.While, ast.For, ast.Try)):
                    complexity += 1
                elif isinstance(node, ast.BoolOp):
                    complexity += len(node.values) - 1
            
            return complexity
        except:
            return 0
    
    def _detect_issues(self, content: str) -> List[Dict[str, Any]]:
        """Detekce potenci치ln칤ch probl칠m콢 v k칩du"""
        issues = []
        lines = content.split('\n')
        
        for i, line in enumerate(lines, 1):
            # Dlouh칠 콏치dky
            if len(line) > 100:
                issues.append({
                    'type': 'style',
                    'message': '콎치dek je p콏칤li코 dlouh칳 (>100 znak콢)',
                    'line': i,
                    'severity': 'warning'
                })
            
            # TODO koment치콏e
            if 'TODO' in line or 'FIXME' in line:
                issues.append({
                    'type': 'maintenance',
                    'message': 'Nedokon캜en칳 칰kol v k칩du',
                    'line': i,
                    'severity': 'info'
                })
            
            # Pr치zdn칠 except bloky
            if line.strip() == 'except:' or 'except Exception:' in line:
                issues.append({
                    'type': 'error_handling',
                    'message': 'P콏칤li코 obecn칠 zachycen칤 v칳jimek',
                    'line': i,
                    'severity': 'error'
                })
        
        return issues
````

### Git Integrace

````python
import git
from typing import List, Dict, Any
from datetime import datetime, timedelta
import os

class GitAnalyzer:
    def __init__(self, repo_path: str):
        try:
            self.repo = git.Repo(repo_path)
        except git.InvalidGitRepositoryError:
            raise ValueError(f"Neplatn칳 Git repozit치콏: {repo_path}")
    
    def analyze_repository(self) -> Dict[str, Any]:
        """Komplexn칤 anal칳za Git repozit치콏e"""
        return {
            'basic_info': self._get_basic_info(),
            'commit_history': self._analyze_commit_history(),
            'branch_analysis': self._analyze_branches(),
            'contributor_stats': self._analyze_contributors(),
            'file_changes': self._analyze_file_changes(),
            'hotspots': self._identify_hotspots()
        }
    
    def _get_basic_info(self) -> Dict[str, Any]:
        """Z치kladn칤 informace o repozit치콏i"""
        try:
            return {
                'total_commits': len(list(self.repo.iter_commits())),
                'total_branches': len(list(self.repo.branches)),
                'total_tags': len(list(self.repo.tags)),
                'current_branch': self.repo.active_branch.name,
                'remote_url': next(iter(self.repo.remotes.origin.urls), None),
                'last_commit': {
                    'hash': self.repo.head.commit.hexsha[:8],
                    'message': self.repo.head.commit.message.strip(),
                    'author': self.repo.head.commit.author.name,
                    'date': self.repo.head.commit.committed_datetime.isoformat()
                }
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _analyze_commit_history(self, days: int = 30) -> Dict[str, Any]:
        """Anal칳za historie commit콢 za posledn칤ch N dn칤"""
        try:
            since_date = datetime.now() - timedelta(days=days)
            commits = list(self.repo.iter_commits(since=since_date))
            
            daily_stats = {}
            for commit in commits:
                date = commit.committed_datetime.date().isoformat()
                if date not in daily_stats:
                    daily_stats[date] = {'count': 0, 'authors': set()}
                daily_stats[date]['count'] += 1
                daily_stats[date]['authors'].add(commit.author.name)
            
            # Konverze set콢 na listy pro JSON serializaci
            for date in daily_stats:
                daily_stats[date]['authors'] = list(daily_stats[date]['authors'])
            
            return {
                'total_commits': len(commits),
                'daily_stats': daily_stats,
                'avg_commits_per_day': len(commits) / days if days > 0 else 0
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _analyze_branches(self) -> List[Dict[str, Any]]:
        """Anal칳za v캩tv칤"""
        try:
            branches_info = []
            for branch in self.repo.branches:
                try:
                    last_commit = branch.commit
                    branches_info.append({
                        'name': branch.name,
                        'last_commit': {
                            'hash': last_commit.hexsha[:8],
                            'message': last_commit.message.strip(),
                            'author': last_commit.author.name,
                            'date': last_commit.committed_datetime.isoformat()
                        },
                        'commits_ahead': len(list(self.repo.iter_commits(f'{self.repo.active_branch.name}..{branch.name}'))),
                        'commits_behind': len(list(self.repo.iter_commits(f'{branch.name}..{self.repo.active_branch.name}')))
                    })
                except:
                    continue
            return branches_info
        except Exception as e:
            return [{'error': str(e)}]
    
    def _analyze_contributors(self) -> List[Dict[str, Any]]:
        """Anal칳za p콏isp캩vatel콢"""
        try:
            contributors = {}
            for commit in self.repo.iter_commits():
                author = commit.author.name
                if author not in contributors:
                    contributors[author] = {
                        'name': author,
                        'email': commit.author.email,
                        'commits': 0,
                        'lines_added': 0,
                        'lines_removed': 0,
                        'first_commit': commit.committed_datetime,
                        'last_commit': commit.committed_datetime
                    }
                
                contributors[author]['commits'] += 1
                contributors[author]['first_commit'] = min(
                    contributors[author]['first_commit'], 
                    commit.committed_datetime
                )
                contributors[author]['last_commit'] = max(
                    contributors[author]['last_commit'], 
                    commit.committed_datetime
                )
                
                # Anal칳za zm캩n (pokud m치 commit rodi캜e)
                if commit.parents:
                    try:
                        stats = commit.stats.total
                        contributors[author]['lines_added'] += stats['insertions']
                        contributors[author]['lines_removed'] += stats['deletions']
                    except:
                        pass
            
            # Konverze datetime objekt콢 na ISO string
            result = []
            for contributor in contributors.values():
                contributor['first_commit'] = contributor['first_commit'].isoformat()
                contributor['last_commit'] = contributor['last_commit'].isoformat()
                result.append(contributor)
            
            return sorted(result, key=lambda x: x['commits'], reverse=True)
        except Exception as e:
            return [{'error': str(e)}]
    
    def _analyze_file_changes(self) -> List[Dict[str, Any]]:
        """Anal칳za zm캩n soubor콢"""
        try:
            file_stats = {}
            for commit in self.repo.iter_commits():
                if commit.parents:
                    try:
                        for file_path, stats in commit.stats.files.items():
                            if file_path not in file_stats:
                                file_stats[file_path] = {
                                    'path': file_path,
                                    'changes': 0,
                                    'additions': 0,
                                    'deletions': 0
                                }
                            file_stats[file_path]['changes'] += 1
                            file_stats[file_path]['additions'] += stats['insertions']
                            file_stats[file_path]['deletions'] += stats['deletions']
                    except:
                        continue
            
            return sorted(file_stats.values(), key=lambda x: x['changes'], reverse=True)[:20]
        except Exception as e:
            return [{'error': str(e)}]
    
    def _identify_hotspots(self) -> List[Dict[str, Any]]:
        """Identifikace problematick칳ch soubor콢 (hotspots)"""
        try:
            file_changes = self._analyze_file_changes()
            hotspots = []
            
            for file_info in file_changes[:10]:  # Top 10 nejm캩n캩n캩j코칤ch soubor콢
                file_path = file_info['path']
                if os.path.exists(file_path) and file_path.endswith('.py'):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            lines = len(f.readlines())
                        
                        # V칳po캜et "hotspot sk칩re" - v칤ce zm캩n + v칤ce 콏치dk콢 = vy코코칤 riziko
                        hotspot_score = file_info['changes'] * (lines / 100)
                        
                        hotspots.append({
                            'file': file_path,
                            'changes': file_info['changes'],
                            'lines': lines,
                            'hotspot_score': round(hotspot_score, 2),
                            'risk_level': 'high' if hotspot_score > 50 else 'medium' if hotspot_score > 20 else 'low'
                        })
                    except:
                        continue
            
            return sorted(hotspots, key=lambda x: x['hotspot_score'], reverse=True)
        except Exception as e:
            return [{'error': str(e)}]
````

### AI Agent s LangChain

````python
from langchain.agents import AgentType, initialize_agent
from langchain.llms import OpenAI
from langchain.tools import Tool
from langchain.schema import AgentAction, AgentFinish
from typing import List, Dict, Any, Union
import os
from dotenv import load_dotenv

load_dotenv()

class SmartCodeAgent:
    def __init__(self):
        self.llm = OpenAI(
            temperature=0.1,
            openai_api_key=os.getenv('OPENAI_API_KEY')
        )
        self.tools = self._create_tools()
        self.agent = initialize_agent(
            tools=self.tools,
            llm=self.llm,
            agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
            verbose=True,
            max_iterations=3
        )
    
    def _create_tools(self) -> List[Tool]:
        """Vytvo콏en칤 n치stroj콢 pro agenta"""
        return [
            Tool(
                name="analyze_code",
                description="Analyzuje Python k칩d a vrac칤 detailn칤 informace o funkc칤ch, t콏칤d치ch a probl칠mech",
                func=self._analyze_code_tool
            ),
            Tool(
                name="analyze_git_repo",
                description="Analyzuje Git repozit치콏 a vrac칤 statistiky o commitech, v캩tv칤ch a p콏isp캩vatel칤ch",
                func=self._analyze_git_tool
            ),
            Tool(
                name="generate_documentation",
                description="Generuje dokumentaci pro dan칳 k칩d",
                func=self._generate_docs_tool
            ),
            Tool(
                name="suggest_improvements",
                description="Navrhuje vylep코en칤 k칩du na z치klad캩 anal칳zy",
                func=self._suggest_improvements_tool
            ),
            Tool(
                name="generate_tests",
                description="Generuje unit testy pro dan칳 k칩d",
                func=self._generate_tests_tool
            )
        ]
    
    def _analyze_code_tool(self, file_path: str) -> str:
        """N치stroj pro anal칳zu k칩du"""
        try:
            from smart_code_assistant.analyzers.code_analyzer import CodeAnalyzer
            analyzer = CodeAnalyzer()
            result = analyzer.analyze_file(file_path)
            return f"Anal칳za k칩du pro {file_path}:\n{str(result)}"
        except Exception as e:
            return f"Chyba p콏i anal칳ze k칩du: {str(e)}"
    
    def _analyze_git_tool(self, repo_path: str) -> str:
        """N치stroj pro anal칳zu Git repozit치콏e"""
        try:
            from smart_code_assistant.git.git_analyzer import GitAnalyzer
            analyzer = GitAnalyzer(repo_path)
            result = analyzer.analyze_repository()
            return f"Anal칳za Git repozit치콏e {repo_path}:\n{str(result)}"
        except Exception as e:
            return f"Chyba p콏i anal칳ze Git repozit치콏e: {str(e)}"
    
    def _generate_docs_tool(self, code: str) -> str:
        """Generov치n칤 dokumentace"""
        prompt = f"""
        Vygeneruj komplexn칤 dokumentaci pro n치sleduj칤c칤 Python k칩d:
        
        {code}
        
        Zahr켿:
        - Popis 칰캜elu k칩du
        - Parametry funkc칤
        - N치vratov칠 hodnoty
        - P콏칤klady pou쬴t칤
        - Pozn치mky k implementaci
        """
        
        try:
            response = self.llm(prompt)
            return response
        except Exception as e:
            return f"Chyba p콏i generov치n칤 dokumentace: {str(e)}"
    
    def _suggest_improvements_tool(self, code: str) -> str:
        """N치vrhy vylep코en칤 k칩du"""
        prompt = f"""
        Analyzuj n치sleduj칤c칤 Python k칩d a navrhni konkr칠tn칤 vylep코en칤:
        
        {code}
        
        Zam캩콏 se na:
        - V칳konnost
        - 캛itelnost
        - Bezpe캜nost
        - Best practices
        - Architektonick칠 vzory
        """
        
        try:
            response = self.llm(prompt)
            return response
        except Exception as e:
            return f"Chyba p콏i navrhov치n칤 vylep코en칤: {str(e)}"
    
    def _generate_tests_tool(self, code: str) -> str:
        """Generov치n칤 unit test콢"""
        prompt = f"""
        Vygeneruj kompletn칤 unit testy pro n치sleduj칤c칤 Python k칩d pomoc칤 pytest:
        
        {code}
        
        Zahr켿:
        - Testy pro norm치ln칤 p콏칤pady pou쬴t칤
        - Testy pro hrani캜n칤 p콏칤pady
        - Testy pro error handling
        - Mock objekty kde je to pot콏eba
        - Fixtures pro setup/teardown
        """
        
        try:
            response = self.llm(prompt)
            return response
        except Exception as e:
            return f"Chyba p콏i generov치n칤 test콢: {str(e)}"
    
    def process_request(self, request: str, context: Dict[str, Any] = None) -> str:
        """Zpracov치n칤 po쬬davku u쬴vatele"""
        try:
            # P콏id치n칤 kontextu do po쬬davku
            if context:
                enhanced_request = f"""
                Kontext: {context}
                
                Po쬬davek: {request}
                """
            else:
                enhanced_request = request
            
            response = self.agent.run(enhanced_request)
            return response
        except Exception as e:
            return f"Chyba p콏i zpracov치n칤 po쬬davku: {str(e)}"
````

### FastAPI Server

````python
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Dict, Any, Optional, List
import asyncio
import json

from smart_code_assistant.core.mcp_protocol import MCPProtocol, MCPMessage, MCPMessageType
from smart_code_assistant.agents.code_agent import SmartCodeAgent
from smart_code_assistant.analyzers.code_analyzer import CodeAnalyzer
from smart_code_assistant.git.git_analyzer import GitAnalyzer

app = FastAPI(title="Smart Code Assistant API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Glob치ln칤 instance
mcp_protocol = MCPProtocol()
code_agent = SmartCodeAgent()
code_analyzer = CodeAnalyzer()

class AnalyzeCodeRequest(BaseModel):
    file_path: str

class AnalyzeRepoRequest(BaseModel):
    repo_path: str

class AgentRequest(BaseModel):
    request: str
    context: Optional[Dict[str, Any]] = None

class MCPRequest(BaseModel):
    method: str
    params: Dict[str, Any]
    id: Optional[str] = None

@app.post("/api/analyze/code")
async def analyze_code(request: AnalyzeCodeRequest):
    """Anal칳za k칩du"""
    try:
        result = code_analyzer.analyze_file(request.file_path)
        return {"status": "success", "data": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/analyze/repo")
async def analyze_repo(request: AnalyzeRepoRequest):
    """Anal칳za Git repozit치콏e"""
    try:
        git_analyzer = GitAnalyzer(request.repo_path)
        result = git_analyzer.analyze_repository()
        return {"status": "success", "data": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/agent/process")
async def process_agent_request(request: AgentRequest):
    """Zpracov치n칤 po쬬davku AI agentem"""
    try:
        result = code_agent.process_request(request.request, request.context)
        return {"status": "success", "response": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/mcp/request")
async def handle_mcp_request(request: MCPRequest):
    """Zpracov치n칤 MCP po쬬davku"""
    try:
        mcp_message = MCPMessage(
            type=MCPMessageType.REQUEST,
            id=request.id,
            method=request.method,
            params=request.params
        )
        
        response = await mcp_protocol.handle_message(mcp_message)
        
        return {
            "id": response.id,
            "result": response.result,
            "error": response.error
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "Smart Code Assistant"}

# Registrace MCP handler콢
async def handle_analyze_code(params: Dict[str, Any]) -> Dict[str, Any]:
    """MCP handler pro anal칳zu k칩du"""
    file_path = params.get('file_path')
    if not file_path:
        raise ValueError("file_path je povinn칳 parametr")
    
    result = code_analyzer.analyze_file(file_path)
    return result

async def handle_analyze_repo(params: Dict[str, Any]) -> Dict[str, Any]:
    """MCP handler pro anal칳zu repozit치콏e"""
    repo_path = params.get('repo_path')
    if not repo_path:
        raise ValueError("repo_path je povinn칳 parametr")
    
    git_analyzer = GitAnalyzer(repo_path)
    result = git_analyzer.analyze_repository()
    return result

async def handle_agent_request(params: Dict[str, Any]) -> Dict[str, Any]:
    """MCP handler pro AI agenta"""
    request = params.get('request')
    context = params.get('context')
    
    if not request:
        raise ValueError("request je povinn칳 parametr")
    
    result = code_agent.process_request(request, context)
    return {"response": result}

# Registrace handler콢
mcp_protocol.register_handler("analyze_code", handle_analyze_code)
mcp_protocol.register_handler("analyze_repo", handle_analyze_repo)
mcp_protocol.register_handler("agent_request", handle_agent_request)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### Hlavn칤 Aplikace

````python
import asyncio
import argparse
import json
import os
from pathlib import Path

from smart_code_assistant.server.api_server import app
from smart_code_assistant.agents.code_agent import SmartCodeAgent
from smart_code_assistant.analyzers.code_analyzer import CodeAnalyzer
from smart_code_assistant.git.git_analyzer import GitAnalyzer

class SmartCodeAssistant:
    def __init__(self):
        self.code_agent = SmartCodeAgent()
        self.code_analyzer = CodeAnalyzer()
    
    async def interactive_mode(self):
        """Interaktivn칤 re쬴m pro pr치ci s asistentem"""
        print("游뱄 Smart Code Assistant - Interaktivn칤 re쬴m")
        print("P콏칤kazy: analyze <file>, repo <path>, ask <question>, quit")
        
        while True:
            try:
                user_input = input("\n> ").strip()
                
                if user_input.lower() in ['quit', 'exit', 'q']:
                    print("Ukon캜uji asistenta...")
                    break
                
                parts = user_input.split(' ', 1)
                command = parts[0].lower()
                
                if command == 'analyze' and len(parts) > 1:
                    await self.handle_analyze_command(parts[1])
                elif command == 'repo' and len(parts) > 1:
                    await self.handle_repo_command(parts[1])
                elif command == 'ask' and len(parts) > 1:
                    await self.handle_ask_command(parts[1])
                else:
                    print("Nezn치m칳 p콏칤kaz. Pou쬴jte: analyze <file>, repo <path>, ask <question>, quit")
                    
            except KeyboardInterrupt:
                print("\nUkon캜uji asistenta...")
                break
            except Exception as e:
                print(f"Chyba: {e}")
    
    async def handle_analyze_command(self, file_path: str):
        """Zpracov치n칤 p콏칤kazu analyze"""
        if not os.path.exists(file_path):
            print(f"Soubor {file_path} neexistuje.")
            return
        
        print(f"游늵 Analyzuji soubor: {file_path}")
        result = self.code_analyzer.analyze_file(file_path)
        
        print(json.dumps(result, indent=2, ensure_ascii=False))
    
    async def handle_repo_command(self, repo_path: str):
        """Zpracov치n칤 p콏칤kazu repo"""
        if not os.path.exists(repo_path):
            print(f"Adres치콏 {repo_path} neexistuje.")
            return
        
        try:
            print(f"游늳 Analyzuji Git repozit치콏: {repo_path}")
            git_analyzer = GitAnalyzer(repo_path)
            result = git_analyzer.analyze_repository()
            
            print(json.dumps(result, indent=2, ensure_ascii=False))
        except Exception as e:
            print(f"Chyba p콏i anal칳ze repozit치콏e: {e}")
    
    async def handle_ask_command(self, question: str):
        """Zpracov치n칤 p콏칤kazu ask"""
        print(f"游뱂 Zpracov치v치m ot치zku: {question}")
        
        try:
            response = self.code_agent.process_request(question)
            print(f"游눠 Odpov캩캞: {response}")
        except Exception as e:
            print(f"Chyba p콏i zpracov치n칤 ot치zky: {e}")

def main():
    parser = argparse.ArgumentParser(description='Smart Code Assistant')
    parser.add_argument('--mode', choices=['interactive', 'server'], 
                       default='interactive', help='Re쬴m spu코t캩n칤')
    parser.add_argument('--port', type=int, default=8000, 
                       help='Port pro server (pouze v re쬴mu server)')
    parser.add_argument('--host', default='0.0.0.0', 
                       help='Host pro server (pouze v re쬴mu server)')
    
    args = parser.parse_args()
    
    if args.mode == 'interactive':
        assistant = SmartCodeAssistant()
        asyncio.run(assistant.interactive_mode())
    elif args.mode == 'server':
        import uvicorn
        uvicorn.run(app, host=args.host, port=args.port)

if __name__ == "__main__":
    main()
````

### Konfigura캜n칤 Soubory

````python
OPENAI_API_KEY=your_openai_api_key_here
ANTHROPIC_API_KEY=your_anthropic_api_key_here
GITHUB_TOKEN=your_github_token_here
LOG_LEVEL=INFO
````

````python
from setuptools import setup, find_packages

setup(
    name="smart-code-assistant",
    version="1.0.0",
    description="AI-powered code assistant with MCP integration",
    packages=find_packages(),
    install_requires=[
        "langchain>=0.1.0",
        "langchain-openai>=0.1.0",
        "chromadb>=0.4.0",
        "gitpython>=3.1.0",
        "tree-sitter>=0.20.0",
        "tree-sitter-python>=0.20.0",
        "fastapi>=0.104.0",
        "uvicorn>=0.24.0",
        "pydantic>=2.5.0",
        "python-dotenv>=1.0.0",
        "pytest>=7.0.0",
        "black>=23.0.0",
        "flake8>=6.0.0"
    ],
    python_requires=">=3.8",
    entry_points={
        "console_scripts": [
            "smart-code-assistant=smart_code_assistant.main:main",
        ],
    },
)
````

## Shrnut칤 Projektu

### Kl칤캜ov칠 V칳hody
Smart Code Assistant p콏edstavuje revoluci ve zp콢sobu, jak v칳voj치콏i interaguj칤 se sv칳m k칩dem. Kombinuje pokro캜il칠 AI technologie s robustn칤 architekturou zalo쬰nou na Model Context Protocol.

### Technick칠 Inovace
- **MCP Integrace**: Standardizovan치 komunikace s extern칤mi syst칠my
- **Multi-agent Architektura**: Specializovan칠 agenty pro r콢zn칠 칰koly
- **Real-time Anal칳za**: Okam쬴t치 zp캩tn치 vazba o kvalit캩 k칩du
- **Git Intelligence**: Pokro캜il치 anal칳za historie a trend콢 v칳voje

### Praktick칠 Vyu쬴t칤
Projekt m콢쬰 b칳t implementov치n jako:
- **IDE Plugin**: Roz코칤콏en칤 pro VS Code, IntelliJ, PyCharm
- **CI/CD Integrace**: Automatizovan칠 code review a quality gates
- **Standalone Tool**: Nez치visl치 aplikace pro anal칳zu projekt콢
- **API Service**: Mikroservice pro integraci do existuj칤c칤ch syst칠m콢

### M캩콏iteln칠 P콏칤nosy
- **Zv칳코en칤 produktivity o 30-50%**: Automatizace rutinn칤ch 칰loh
- **Sn칤쬰n칤 chyb o 40%**: Proaktivn칤 detekce probl칠m콢
- **Zlep코en칤 kvality k칩du**: Konzistentn칤 aplikace best practices
- **Rychlej코칤 onboarding**: Automatick칠 generov치n칤 dokumentace

Smart Code Assistant p콏edstavuje budoucnost v칳voje softwaru, kde AI asistenti pracuj칤 bok po boku s v칳voj치콏i jako inteligentn칤 partne콏i, kte콏칤 rozum칤 kontextu a pom치haj칤 vytv치콏et lep코칤 k칩d rychleji a efektivn캩ji.