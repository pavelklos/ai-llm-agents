<small>Claude Sonnet 4 **(Interaktivní Vzdělávací Tutor (Všechny Předměty))**</small>
# Interactive Education Tutor (All Subjects)

## Klíčové Koncepty

### Model Context Protocol (MCP)
**Model Context Protocol** je standardizovaný protokol pro správu kontextu v AI aplikacích. Umožňuje efektivní sledování konverzačního kontextu, správu paměti a koordinaci mezi různými komponentami AI systému.

### LangChain
**LangChain** je framework pro vývoj aplikací využívajících velké jazykové modely (LLM). Poskytuje nástroje pro řetězení operací, správu promptů, integraci s externími datovými zdroji a vytváření komplexních AI workflows.

### Long-Term Memory
**Dlouhodobá paměť** v AI systémech umožňuje uchovávání informací napříč jednotlivými sezeními. V kontextu vzdělávacího tutora zahrnuje sledování pokroku studenta, naučených konceptů a personalizačních preferencí.

### Concept Tracking
**Sledování konceptů** je technika monitorování, které vzdělávací koncepty student zvládl, které potřebuje procvičit, a jak se jeho porozumění vyvíjí v čase.

### OpenAI GPT-4o
**GPT-4o** je pokročilý multimodální jazykový model od OpenAI, který dokáže zpracovávat text, obrázky a audio, což umožňuje bohatší vzdělávací interakce.

### Gradio UI
**Gradio** je Python knihovna pro rychlé vytváření webových uživatelských rozhraní pro machine learning modely a AI aplikace.

## Komplexní Vysvětlení Projektu

### Cíle Projektu
Interaktivní Vzdělávací Tutor je pokročilý AI systém navržený pro personalizované vzdělávání napříč všemi předměty. Hlavní cíle zahrnují:

- **Adaptivní učení**: Přizpůsobení tempa a stylu výuky individuálním potřebám studenta
- **Sledování pokroku**: Kontinuální monitorování osvojených konceptů a identifikace mezer ve znalostech
- **Multimodální interakce**: Využití textu, obrázků a audio pro bohatší vzdělávací zážitek
- **Dlouhodobá personalizace**: Uchovávání učebního profilu studenta napříč sezeními

### Výzvy Projektu
- **Komplexnost správy kontextu**: Udržování relevantního kontextu napříč různými předměty a časovými obdobími
- **Personalizace ve velkém měřítku**: Efektivní adaptace na individuální učební styly a tempo
- **Hodnocení porozumění**: Přesné měření skutečného pochopení konceptů, nejen zapamatování
- **Integrace různých předmětů**: Propojování znalostí napříč disciplínami

### Potenciální Dopad
Tento systém může revolucionizovat vzdělávání poskytnutím:
- Dostupného osobního tutora 24/7
- Objektívního sledování pokroku bez lidských předsudků
- Škálovatelného řešení pro vzdělávací instituce
- Podpory různých učebních stylů a potřeb

## Komplexní Příklad s Python Implementací

````python
langchain==0.1.0
openai==1.12.0
gradio==4.15.0
chromadb==0.4.22
pydantic==2.5.3
sqlalchemy==2.0.25
python-dotenv==1.0.0
numpy==1.24.3
pandas==2.0.3
matplotlib==3.7.1
seaborn==0.12.2
````

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    CHROMA_PERSIST_DIRECTORY = "./chroma_db"
    DATABASE_URL = "sqlite:///tutor_memory.db"
    
    # Vzdělávací konfigurace
    SUBJECTS = [
        "Matematika", "Fyzika", "Chemie", "Biologie", 
        "Historie", "Geografie", "Čeština", "Angličtina",
        "Informatika", "Umění"
    ]
    
    DIFFICULTY_LEVELS = ["Začátečník", "Pokročilý začátečník", "Střední", "Pokročilý", "Expert"]
    
    # MCP konfigurace
    MAX_CONTEXT_LENGTH = 4000
    CONCEPT_RETENTION_THRESHOLD = 0.8
    SESSION_TIMEOUT_MINUTES = 30
````

````python
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
from pydantic import BaseModel
from typing import List, Optional, Dict
import json

Base = declarative_base()

class Student(Base):
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    email = Column(String(200), unique=True)
    preferred_language = Column(String(10), default="cs")
    learning_style = Column(String(50))  # vizuální, auditivní, kinestetický
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime, default=datetime.utcnow)

class ConceptProgress(Base):
    __tablename__ = "concept_progress"
    
    id = Column(Integer, primary_key=True)
    student_id = Column(Integer, nullable=False)
    subject = Column(String(50), nullable=False)
    concept_name = Column(String(200), nullable=False)
    mastery_level = Column(Float, default=0.0)  # 0.0 - 1.0
    attempts = Column(Integer, default=0)
    correct_answers = Column(Integer, default=0)
    last_practiced = Column(DateTime, default=datetime.utcnow)
    notes = Column(Text)

class LearningSession(Base):
    __tablename__ = "learning_sessions"
    
    id = Column(Integer, primary_key=True)
    student_id = Column(Integer, nullable=False)
    subject = Column(String(50), nullable=False)
    session_start = Column(DateTime, default=datetime.utcnow)
    session_end = Column(DateTime)
    concepts_covered = Column(Text)  # JSON seznam konceptů
    performance_score = Column(Float)
    feedback = Column(Text)

# Pydantic modely pro API
class ConceptTrackingRequest(BaseModel):
    student_id: int
    subject: str
    concept: str
    correct: bool
    difficulty: str

class LearningGoal(BaseModel):
    subject: str
    target_concepts: List[str]
    target_mastery: float
    deadline: Optional[datetime] = None

class StudentProfile(BaseModel):
    id: int
    name: str
    subjects: List[str]
    learning_style: str
    current_goals: List[LearningGoal]
    recent_progress: Dict[str, float]
````

````python
from typing import Dict, List, Optional
import json
from datetime import datetime, timedelta
from langchain.memory import ConversationSummaryBufferMemory
from langchain.schema import BaseMessage, HumanMessage, AIMessage

class MCPContextManager:
    """Model Context Protocol implementace pro vzdělávacího tutora"""
    
    def __init__(self, max_context_length: int = 4000):
        self.max_context_length = max_context_length
        self.active_contexts: Dict[str, Dict] = {}
        self.concept_tracking: Dict[str, Dict] = {}
        
    def create_session_context(self, student_id: int, subject: str) -> str:
        """Vytvoří nový kontext pro vzdělávací sezení"""
        session_id = f"{student_id}_{subject}_{datetime.now().timestamp()}"
        
        self.active_contexts[session_id] = {
            "student_id": student_id,
            "subject": subject,
            "start_time": datetime.now(),
            "messages": [],
            "concepts_discussed": [],
            "current_difficulty": "Střední",
            "learning_objectives": [],
            "session_summary": ""
        }
        
        return session_id
    
    def add_message_to_context(self, session_id: str, message: BaseMessage, 
                              concepts: List[str] = None):
        """Přidá zprávu do kontextu sezení"""
        if session_id not in self.active_contexts:
            raise ValueError(f"Session {session_id} not found")
        
        context = self.active_contexts[session_id]
        context["messages"].append({
            "timestamp": datetime.now(),
            "type": type(message).__name__,
            "content": message.content,
            "concepts": concepts or []
        })
        
        if concepts:
            context["concepts_discussed"].extend(concepts)
            context["concepts_discussed"] = list(set(context["concepts_discussed"]))
        
        self._manage_context_length(session_id)
    
    def _manage_context_length(self, session_id: str):
        """Spravuje délku kontextu podle MCP protokolu"""
        context = self.active_contexts[session_id]
        messages = context["messages"]
        
        # Spočítá přibližnou délku kontextu
        total_length = sum(len(str(msg["content"])) for msg in messages)
        
        if total_length > self.max_context_length:
            # Zachová poslední zprávy a vytvoří shrnutí starších
            recent_messages = messages[-10:]  # Zachová posledních 10 zpráv
            older_messages = messages[:-10]
            
            # Vytvoří shrnutí starších zpráv
            summary = self._create_message_summary(older_messages)
            context["session_summary"] = summary
            context["messages"] = recent_messages
    
    def _create_message_summary(self, messages: List[Dict]) -> str:
        """Vytvoří shrnutí zpráv pro udržení kontextu"""
        concepts = set()
        key_topics = []
        
        for msg in messages:
            if msg.get("concepts"):
                concepts.update(msg["concepts"])
            
            # Extrahuje klíčová témata z obsahu
            content = msg["content"]
            if len(content) > 50:
                key_topics.append(content[:50] + "...")
        
        summary = f"Diskutované koncepty: {', '.join(concepts)}. "
        summary += f"Klíčová témata: {'; '.join(key_topics[:3])}"
        
        return summary
    
    def get_context_for_llm(self, session_id: str) -> Dict:
        """Vrátí kontext optimalizovaný pro LLM"""
        if session_id not in self.active_contexts:
            return {}
        
        context = self.active_contexts[session_id]
        
        return {
            "session_summary": context.get("session_summary", ""),
            "recent_messages": context["messages"][-5:],  # Posledních 5 zpráv
            "concepts_discussed": context["concepts_discussed"],
            "current_difficulty": context["current_difficulty"],
            "learning_objectives": context["learning_objectives"],
            "subject": context["subject"]
        }
    
    def update_concept_tracking(self, student_id: int, subject: str, 
                              concept: str, performance: float):
        """Aktualizuje sledování konceptů podle MCP"""
        key = f"{student_id}_{subject}_{concept}"
        
        if key not in self.concept_tracking:
            self.concept_tracking[key] = {
                "mastery_level": 0.0,
                "attempts": 0,
                "last_performance": [],
                "trend": "neutral"
            }
        
        tracking = self.concept_tracking[key]
        tracking["attempts"] += 1
        tracking["last_performance"].append(performance)
        
        # Zachová pouze posledních 10 výsledků
        if len(tracking["last_performance"]) > 10:
            tracking["last_performance"] = tracking["last_performance"][-10:]
        
        # Vypočítá novou úroveň zvládnutí
        recent_avg = sum(tracking["last_performance"][-3:]) / min(3, len(tracking["last_performance"]))
        tracking["mastery_level"] = (tracking["mastery_level"] * 0.7 + recent_avg * 0.3)
        
        # Určí trend
        if len(tracking["last_performance"]) >= 3:
            recent = tracking["last_performance"][-3:]
            if recent[-1] > recent[0]:
                tracking["trend"] = "improving"
            elif recent[-1] < recent[0]:
                tracking["trend"] = "declining"
            else:
                tracking["trend"] = "stable"
    
    def get_learning_recommendations(self, student_id: int, subject: str) -> List[str]:
        """Generuje doporučení na základě MCP dat"""
        recommendations = []
        
        # Analyzuje koncepty pro daného studenta a předmět
        student_concepts = {
            k: v for k, v in self.concept_tracking.items()
            if k.startswith(f"{student_id}_{subject}_")
        }
        
        # Najde koncepty s nízkou úrovní zvládnutí
        weak_concepts = [
            k.split("_")[-1] for k, v in student_concepts.items()
            if v["mastery_level"] < 0.6
        ]
        
        if weak_concepts:
            recommendations.append(f"Doporučuji procvičit: {', '.join(weak_concepts[:3])}")
        
        # Najde koncepty se zhoršujícím se trendem
        declining_concepts = [
            k.split("_")[-1] for k, v in student_concepts.items()
            if v["trend"] == "declining"
        ]
        
        if declining_concepts:
            recommendations.append(f"Věnuj pozornost konceptům, kde se zhoršuješ: {', '.join(declining_concepts[:2])}")
        
        return recommendations
````

````python
from langchain.llms import OpenAI
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.schema import HumanMessage, AIMessage
from langchain.callbacks import get_openai_callback
import openai
from typing import List, Dict, Optional
import json
import random

class AIEducationalTutor:
    """AI Vzdělávací tutor s pokročilými schopnostmi"""
    
    def __init__(self, api_key: str):
        self.chat_model = ChatOpenAI(
            api_key=api_key,
            model="gpt-4",
            temperature=0.7,
            max_tokens=1000
        )
        
        self.subject_prompts = self._load_subject_prompts()
        self.concept_database = self._initialize_concept_database()
    
    def _load_subject_prompts(self) -> Dict[str, str]:
        """Načte specializované prompty pro různé předměty"""
        return {
            "Matematika": """Jsi zkušený učitel matematiky. Vysvětluj koncepty krok za krokem, 
            používej konkrétní příklady a ujisti se, že student rozumí před pokračováním na další úroveň.""",
            
            "Fyzika": """Jsi energický učitel fyziky. Propojuj teoretické koncepty s praktickými 
            příklady z každodenního života. Používej analogie a vizualizace.""",
            
            "Historie": """Jsi zapálený historik. Vyprávěj příběhy, které oživí historické události. 
            Pomoz studentovi pochopit příčiny a důsledky historických procesů.""",
            
            "Chemie": """Jsi odborník na chemii. Vysvětluj chemické procesy bezpečně a zajímavě. 
            Zdůrazňuj praktické aplikace a souvislosti s každodenním životem.""",
        }
    
    def _initialize_concept_database(self) -> Dict[str, List[str]]:
        """Inicializuje databázi konceptů pro různé předměty"""
        return {
            "Matematika": [
                "sčítání", "odčítání", "násobení", "dělení", "zlomky", "procenta",
                "algebra", "funkce", "geometrie", "trigonometrie", "kalkulus"
            ],
            "Fyzika": [
                "síla", "pohyb", "energie", "teplo", "světlo", "elektřina", "magnetismus",
                "vlny", "atomy", "radioaktivita"
            ],
            "Chemie": [
                "atomy", "molekuly", "prvky", "sloučeniny", "reakce", "kyseliny",
                "zásady", "organická chemie", "anorganická chemie"
            ],
            "Historie": [
                "starověk", "středověk", "novověk", "20. století", "válka", "revoluce",
                "kultura", "politika", "ekonomie", "společnost"
            ]
        }
    
    async def generate_response(self, student_message: str, context: Dict, 
                              subject: str, difficulty: str) -> Dict:
        """Generuje odpověď tutora na základě kontextu a MCP dat"""
        
        # Připraví prompt na základě předmětu
        system_prompt = self.subject_prompts.get(subject, 
            "Jsi zkušený učitel. Pomáhej studentovi učit se efektivně a s nadšením.")
        
        # Přidá kontext do promptu
        context_info = self._format_context_for_prompt(context)
        
        prompt_template = ChatPromptTemplate.from_messages([
            ("system", f"{system_prompt}\n\nKontext sezení: {context_info}"),
            ("human", "{student_message}")
        ])
        
        try:
            with get_openai_callback() as cb:
                response = await self.chat_model.agenerate([
                    prompt_template.format_messages(student_message=student_message)
                ])
                
                ai_response = response.generations[0][0].text
                
                # Analyzuje odpověď pro extrakci konceptů
                concepts = self._extract_concepts_from_response(ai_response, subject)
                
                return {
                    "response": ai_response,
                    "concepts_covered": concepts,
                    "difficulty_assessment": self._assess_difficulty(student_message),
                    "tokens_used": cb.total_tokens,
                    "cost": cb.total_cost
                }
                
        except Exception as e:
            return {
                "response": f"Omlouvám se, nastala chyba: {str(e)}",
                "concepts_covered": [],
                "difficulty_assessment": difficulty,
                "tokens_used": 0,
                "cost": 0
            }
    
    def _format_context_for_prompt(self, context: Dict) -> str:
        """Formátuje kontext pro použití v promptu"""
        context_parts = []
        
        if context.get("session_summary"):
            context_parts.append(f"Shrnutí sezení: {context['session_summary']}")
        
        if context.get("concepts_discussed"):
            context_parts.append(f"Diskutované koncepty: {', '.join(context['concepts_discussed'])}")
        
        if context.get("current_difficulty"):
            context_parts.append(f"Aktuální úroveň obtížnosti: {context['current_difficulty']}")
        
        return " | ".join(context_parts) if context_parts else "Nové sezení"
    
    def _extract_concepts_from_response(self, response: str, subject: str) -> List[str]:
        """Extrahuje koncepty z odpovědi AI pomocí keyword matching"""
        concepts_found = []
        subject_concepts = self.concept_database.get(subject, [])
        
        response_lower = response.lower()
        
        for concept in subject_concepts:
            if concept.lower() in response_lower:
                concepts_found.append(concept)
        
        return concepts_found
    
    def _assess_difficulty(self, student_message: str) -> str:
        """Odhadne obtížnost na základě studentovy zprávy"""
        message_lower = student_message.lower()
        
        # Jednoduchá heuristika pro odhad obtížnosti
        difficulty_indicators = {
            "easy": ["začátek", "základy", "jednoduché", "pomozte", "nerozumím"],
            "medium": ["příklad", "vysvětlit", "jak", "proč"],
            "hard": ["pokročilé", "složité", "detailně", "analýza", "důkaz"]
        }
        
        for level, indicators in difficulty_indicators.items():
            if any(indicator in message_lower for indicator in indicators):
                if level == "easy":
                    return "Začátečník"
                elif level == "medium":
                    return "Střední"
                else:
                    return "Pokročilý"
        
        return "Střední"  # Výchozí hodnota
    
    def generate_practice_questions(self, subject: str, concepts: List[str], 
                                  difficulty: str, count: int = 3) -> List[Dict]:
        """Generuje cvičné otázky na základě konceptů"""
        questions = []
        
        question_templates = {
            "Matematika": [
                "Vypočítej: {problem}",
                "Vyřeš rovnici: {equation}",
                "Najdi {target} v následujícím příkladu: {context}"
            ],
            "Fyzika": [
                "Vysvětli jev: {phenomenon}",
                "Vypočítej {quantity} při následujících podmínkách: {conditions}",
                "Proč se děje: {situation}"
            ]
        }
        
        templates = question_templates.get(subject, ["Otázka týkající se {concept}"])
        
        for i in range(count):
            concept = random.choice(concepts) if concepts else "obecný koncept"
            template = random.choice(templates)
            
            # Jednoduchá generace otázky (v reálné aplikaci by bylo sofistikovanější)
            question = template.format(
                problem=f"úloha s {concept}",
                equation=f"rovnice zahrnující {concept}",
                target="výsledek",
                context=f"příklad s {concept}",
                phenomenon=concept,
                quantity="hodnotu",
                conditions=f"parametry {concept}",
                situation=f"situace týkající se {concept}",
                concept=concept
            )
            
            questions.append({
                "id": f"q_{i+1}",
                "question": question,
                "concept": concept,
                "difficulty": difficulty,
                "type": "open-ended"
            })
        
        return questions
    
    def evaluate_answer(self, question: Dict, student_answer: str) -> Dict:
        """Vyhodnotí studentovu odpověď"""
        # Jednoduchá implementace - v reálné aplikaci by bylo sofistikovanější
        score = random.uniform(0.6, 1.0)  # Simulace hodnocení
        
        feedback_templates = [
            "Dobrá práce! Tvoje odpověď ukazuje pochopení konceptu.",
            "Správný směr! Zkus se zaměřit více na {concept}.",
            "Výborně! Vidím, že rozumíš principu {concept}.",
            "Téměř správně. Zkus ještě jednou s ohledem na {concept}."
        ]
        
        feedback = random.choice(feedback_templates).format(
            concept=question["concept"]
        )
        
        return {
            "score": score,
            "feedback": feedback,
            "correct": score > 0.7,
            "concept": question["concept"],
            "improvement_areas": [question["concept"]] if score < 0.7 else []
        }
````

````python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base, Student, ConceptProgress, LearningSession
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import json

class LongTermMemoryManager:
    """Správce dlouhodobé paměti pro vzdělávacího tutora"""
    
    def __init__(self, database_url: str):
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        Session = sessionmaker(bind=self.engine)
        self.session = Session()
    
    def create_student(self, name: str, email: str, learning_style: str = "vizuální") -> int:
        """Vytvoří nového studenta"""
        student = Student(
            name=name,
            email=email,
            learning_style=learning_style
        )
        
        self.session.add(student)
        self.session.commit()
        return student.id
    
    def get_student(self, student_id: int) -> Optional[Student]:
        """Získá studenta podle ID"""
        return self.session.query(Student).filter(Student.id == student_id).first()
    
    def update_concept_progress(self, student_id: int, subject: str, 
                              concept_name: str, correct: bool, difficulty: str):
        """Aktualizuje pokrok v konceptu"""
        progress = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.subject == subject,
            ConceptProgress.concept_name == concept_name
        ).first()
        
        if not progress:
            progress = ConceptProgress(
                student_id=student_id,
                subject=subject,
                concept_name=concept_name
            )
            self.session.add(progress)
        
        progress.attempts += 1
        if correct:
            progress.correct_answers += 1
        
        # Vypočítá novou úroveň zvládnutí
        accuracy = progress.correct_answers / progress.attempts
        difficulty_multiplier = self._get_difficulty_multiplier(difficulty)
        
        # Exponenciální váhovaný průměr pro hladší aktualizace
        alpha = 0.3  # Learning rate
        new_contribution = accuracy * difficulty_multiplier
        progress.mastery_level = (1 - alpha) * progress.mastery_level + alpha * new_contribution
        
        progress.last_practiced = datetime.utcnow()
        self.session.commit()
    
    def _get_difficulty_multiplier(self, difficulty: str) -> float:
        """Vrátí multiplikátor na základě obtížnosti"""
        multipliers = {
            "Začátečník": 0.8,
            "Pokročilý začátečník": 0.9,
            "Střední": 1.0,
            "Pokročilý": 1.2,
            "Expert": 1.5
        }
        return multipliers.get(difficulty, 1.0)
    
    def get_student_progress(self, student_id: int, subject: str = None) -> List[Dict]:
        """Získá pokrok studenta"""
        query = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id
        )
        
        if subject:
            query = query.filter(ConceptProgress.subject == subject)
        
        progress_list = query.all()
        
        return [
            {
                "subject": p.subject,
                "concept": p.concept_name,
                "mastery_level": p.mastery_level,
                "attempts": p.attempts,
                "accuracy": p.correct_answers / p.attempts if p.attempts > 0 else 0,
                "last_practiced": p.last_practiced
            }
            for p in progress_list
        ]
    
    def get_learning_analytics(self, student_id: int, days: int = 30) -> Dict:
        """Získá analytické údaje o učení"""
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        
        # Celkový pokrok
        total_progress = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.last_practiced >= cutoff_date
        ).all()
        
        # Sezení
        sessions = self.session.query(LearningSession).filter(
            LearningSession.student_id == student_id,
            LearningSession.session_start >= cutoff_date
        ).all()
        
        # Statistiky podle předmětů
        subject_stats = {}
        for progress in total_progress:
            subject = progress.subject
            if subject not in subject_stats:
                subject_stats[subject] = {
                    "concepts_count": 0,
                    "avg_mastery": 0.0,
                    "total_attempts": 0,
                    "weak_concepts": []
                }
            
            stats = subject_stats[subject]
            stats["concepts_count"] += 1
            stats["avg_mastery"] += progress.mastery_level
            stats["total_attempts"] += progress.attempts
            
            if progress.mastery_level < 0.6:
                stats["weak_concepts"].append(progress.concept_name)
        
        # Průměrné hodnoty
        for subject, stats in subject_stats.items():
            if stats["concepts_count"] > 0:
                stats["avg_mastery"] /= stats["concepts_count"]
        
        return {
            "period_days": days,
            "total_concepts_practiced": len(total_progress),
            "total_sessions": len(sessions),
            "subject_statistics": subject_stats,
            "overall_mastery": sum(p.mastery_level for p in total_progress) / len(total_progress) if total_progress else 0,
            "most_active_subject": max(subject_stats.keys(), key=lambda x: subject_stats[x]["total_attempts"]) if subject_stats else None
        }
    
    def start_learning_session(self, student_id: int, subject: str) -> int:
        """Zahájí nové vzdělávací sezení"""
        session = LearningSession(
            student_id=student_id,
            subject=subject
        )
        
        self.session.add(session)
        self.session.commit()
        return session.id
    
    def end_learning_session(self, session_id: int, concepts_covered: List[str], 
                           performance_score: float, feedback: str):
        """Ukončí vzdělávací sezení"""
        session = self.session.query(LearningSession).filter(
            LearningSession.id == session_id
        ).first()
        
        if session:
            session.session_end = datetime.utcnow()
            session.concepts_covered = json.dumps(concepts_covered)
            session.performance_score = performance_score
            session.feedback = feedback
            self.session.commit()
    
    def get_recommended_concepts(self, student_id: int, subject: str, limit: int = 5) -> List[str]:
        """Doporučí koncepty k procvičení na základě pokroku"""
        # Získá koncepty s nízkou úrovní zvládnutí
        weak_concepts = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.subject == subject,
            ConceptProgress.mastery_level < 0.7
        ).order_by(ConceptProgress.mastery_level.asc()).limit(limit).all()
        
        # Získá koncepty, které nebyly dlouho procvičovány
        old_concepts = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.subject == subject,
            ConceptProgress.last_practiced < datetime.utcnow() - timedelta(days=7)
        ).order_by(ConceptProgress.last_practiced.asc()).limit(limit).all()
        
        recommendations = []
        
        # Priorita: slabé koncepty
        for concept in weak_concepts:
            recommendations.append(concept.concept_name)
        
        # Doplnění starými koncepty
        for concept in old_concepts:
            if concept.concept_name not in recommendations and len(recommendations) < limit:
                recommendations.append(concept.concept_name)
        
        return recommendations[:limit]
    
    def cleanup_old_data(self, days_to_keep: int = 365):
        """Vyčistí stará data pro optimalizaci"""
        cutoff_date = datetime.utcnow() - timedelta(days=days_to_keep)
        
        # Smaže stará sezení
        self.session.query(LearningSession).filter(
            LearningSession.session_start < cutoff_date
        ).delete()
        
        self.session.commit()
    
    def __del__(self):
        """Zavře databázové připojení"""
        if hasattr(self, 'session'):
            self.session.close()
````

````python
import gradio as gr
import asyncio
from typing import List, Tuple, Dict
import json
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from io import BytesIO
import base64

from ai_tutor import AIEducationalTutor
from mcp_manager import MCPContextManager
from memory_manager import LongTermMemoryManager
from config import Config

class TutorGradioInterface:
    """Gradio uživatelské rozhraní pro vzdělávacího tutora"""
    
    def __init__(self):
        self.config = Config()
        self.ai_tutor = AIEducationalTutor(self.config.OPENAI_API_KEY)
        self.mcp_manager = MCPContextManager(self.config.MAX_CONTEXT_LENGTH)
        self.memory_manager = LongTermMemoryManager(self.config.DATABASE_URL)
        
        self.current_session_id = None
        self.current_student_id = None
        
    def create_interface(self):
        """Vytvoří Gradio rozhraní"""
        
        with gr.Blocks(title="AI Vzdělávací Tutor", theme=gr.themes.Soft()) as interface:
            gr.Markdown("# 🎓 AI Vzdělávací Tutor")
            gr.Markdown("*Personalizovaný tutor pro všechny předměty s pokročilým sledováním pokroku*")
            
            with gr.Tab("Učení"):
                self._create_learning_tab()
            
            with gr.Tab("Pokrok"):
                self._create_progress_tab()
            
            with gr.Tab("Cvičení"):
                self._create_practice_tab()
            
            with gr.Tab("Profil"):
                self._create_profile_tab()
        
        return interface
    
    def _create_learning_tab(self):
        """Vytvoří záložku pro učení"""
        with gr.Row():
            with gr.Column(scale=2):
                student_name = gr.Textbox(
                    label="Jméno studenta",
                    placeholder="Zadej své jméno"
                )
                subject_dropdown = gr.Dropdown(
                    choices=self.config.SUBJECTS,
                    label="Předmět",
                    value="Matematika"
                )
                difficulty_dropdown = gr.Dropdown(
                    choices=self.config.DIFFICULTY_LEVELS,
                    label="Úroveň obtížnosti",
                    value="Střední"
                )
                
                start_session_btn = gr.Button("Zahájit sezení", variant="primary")
            
            with gr.Column(scale=1):
                session_info = gr.JSON(label="Informace o sezení", visible=False)
        
        with gr.Row():
            chatbot = gr.Chatbot(label="Konverzace s tutorem", height=400)
        
        with gr.Row():
            msg_input = gr.Textbox(
                label="Tvoje zpráva",
                placeholder="Napiš svoji otázku nebo odpověď...",
                scale=4
            )
            send_btn = gr.Button("Odeslat", scale=1)
        
        with gr.Row():
            concepts_display = gr.Textbox(
                label="Probírané koncepty",
                interactive=False
            )
            recommendations_display = gr.Textbox(
                label="Doporučení",
                interactive=False
            )
        
        # Event handlers
        start_session_btn.click(
            fn=self.start_learning_session,
            inputs=[student_name, subject_dropdown, difficulty_dropdown],
            outputs=[session_info, chatbot, concepts_display, recommendations_display]
        )
        
        send_btn.click(
            fn=self.process_message,
            inputs=[msg_input, chatbot, subject_dropdown, difficulty_dropdown],
            outputs=[chatbot, msg_input, concepts_display, recommendations_display]
        )
        
        msg_input.submit(
            fn=self.process_message,
            inputs=[msg_input, chatbot, subject_dropdown, difficulty_dropdown],
            outputs=[chatbot, msg_input, concepts_display, recommendations_display]
        )
    
    def _create_progress_tab(self):
        """Vytvoří záložku pro sledování pokroku"""
        with gr.Row():
            student_id_input = gr.Number(
                label="ID studenta",
                value=1
            )
            subject_filter = gr.Dropdown(
                choices=["Všechny"] + self.config.SUBJECTS,
                label="Filtr předmětu",
                value="Všechny"
            )
            refresh_btn = gr.Button("Aktualizovat")
        
        with gr.Row():
            progress_chart = gr.Plot(label="Graf pokroku")
        
        with gr.Row():
            progress_table = gr.Dataframe(
                label="Detailní pokrok",
                headers=["Předmět", "Koncept", "Úroveň zvládnutí", "Pokusy", "Přesnost"]
            )
        
        with gr.Row():
            analytics_json = gr.JSON(label="Analytické údaje")
        
        refresh_btn.click(
            fn=self.update_progress_display,
            inputs=[student_id_input, subject_filter],
            outputs=[progress_chart, progress_table, analytics_json]
        )
    
    def _create_practice_tab(self):
        """Vytvoří záložku pro cvičení"""
        with gr.Row():
            with gr.Column():
                practice_subject = gr.Dropdown(
                    choices=self.config.SUBJECTS,
                    label="Předmět pro cvičení",
                    value="Matematika"
                )
                practice_difficulty = gr.Dropdown(
                    choices=self.config.DIFFICULTY_LEVELS,
                    label="Obtížnost",
                    value="Střední"
                )
                question_count = gr.Slider(
                    minimum=1,
                    maximum=10,
                    value=3,
                    step=1,
                    label="Počet otázek"
                )
                generate_questions_btn = gr.Button("Generovat otázky")
        
        with gr.Row():
            questions_display = gr.JSON(label="Cvičné otázky")
        
        with gr.Row():
            answer_input = gr.Textbox(
                label="Tvoje odpověď",
                placeholder="Napiš svoji odpověď na aktuální otázku..."
            )
            submit_answer_btn = gr.Button("Odeslat odpověď")
        
        with gr.Row():
            feedback_display = gr.Textbox(
                label="Zpětná vazba",
                interactive=False
            )
        
        generate_questions_btn.click(
            fn=self.generate_practice_questions,
            inputs=[practice_subject, practice_difficulty, question_count],
            outputs=[questions_display]
        )
        
        submit_answer_btn.click(
            fn=self.evaluate_practice_answer,
            inputs=[answer_input, questions_display],
            outputs=[feedback_display, answer_input]
        )
    
    def _create_profile_tab(self):
        """Vytvoří záložku pro profil studenta"""
        with gr.Row():
            with gr.Column():
                profile_name = gr.Textbox(label="Jméno")
                profile_email = gr.Textbox(label="Email")
                learning_style = gr.Dropdown(
                    choices=["vizuální", "auditivní", "kinestetický"],
                    label="Učební styl",
                    value="vizuální"
                )
                create_profile_btn = gr.Button("Vytvořit profil")
            
            with gr.Column():
                profile_display = gr.JSON(label="Aktuální profil")
        
        create_profile_btn.click(
            fn=self.create_student_profile,
            inputs=[profile_name, profile_email, learning_style],
            outputs=[profile_display]
        )
    
    def start_learning_session(self, student_name: str, subject: str, difficulty: str):
        """Zahájí nové vzdělávací sezení"""
        if not student_name:
            return {}, [["Systém", "Prosím zadej své jméno pro zahájení sezení."]], "", ""
        
        # Najde nebo vytvoří studenta
        # Jednoduchá implementace - v reálné aplikaci by bylo sofistikovanější
        self.current_student_id = 1  # Výchozí ID
        
        # Vytvoří MCP kontext
        self.current_session_id = self.mcp_manager.create_session_context(
            self.current_student_id, subject
        )
        
        # Zahájí sezení v databázi
        session_db_id = self.memory_manager.start_learning_session(
            self.current_student_id, subject
        )
        
        # Úvodní zpráva
        welcome_msg = f"Ahoj {student_name}! Jsem tvůj AI tutor. Dnes budeme studovat {subject} na úrovni {difficulty}. Jak ti mohu pomoci?"
        
        # Získá doporučení
        recommendations = self.memory_manager.get_recommended_concepts(
            self.current_student_id, subject, 3
        )
        
        session_info = {
            "session_id": self.current_session_id,
            "student_id": self.current_student_id,
            "subject": subject,
            "difficulty": difficulty,
            "db_session_id": session_db_id
        }
        
        concepts_text = "Sezení zahájeno"
        recommendations_text = f"Doporučené koncepty: {', '.join(recommendations)}" if recommendations else "Zatím žádná doporučení"
        
        return session_info, [["Tutor", welcome_msg]], concepts_text, recommendations_text
    
    async def process_message(self, message: str, chat_history: List, subject: str, difficulty: str):
        """Zpracuje zprávu od studenta"""
        if not self.current_session_id or not message.strip():
            return chat_history, "", "", ""
        
        # Přidá zprávu do historie
        chat_history.append(["Student", message])
        
        # Získá kontext pro LLM
        context = self.mcp_manager.get_context_for_llm(self.current_session_id)
        
        # Generuje odpověď AI tutora
        response_data = await self.ai_tutor.generate_response(
            message, context, subject, difficulty
        )
        
        ai_response = response_data["response"]
        concepts_covered = response_data["concepts_covered"]
        
        # Přidá odpověď do historie
        chat_history.append(["Tutor", ai_response])
        
        # Aktualizuje MCP kontext
        self.mcp_manager.add_message_to_context(
            self.current_session_id,
            gr.HumanMessage(content=message),
            concepts_covered
        )
        
        self.mcp_manager.add_message_to_context(
            self.current_session_id,
            gr.AIMessage(content=ai_response),
            concepts_covered
        )
        
        # Aktualizuje pokrok v konceptech
        for concept in concepts_covered:
            # Jednoduché hodnocení - v reálné aplikaci by bylo sofistikovanější
            self.memory_manager.update_concept_progress(
                self.current_student_id, subject, concept, True, difficulty
            )
        
        # Získá nová doporučení
        recommendations = self.mcp_manager.get_learning_recommendations(
            self.current_student_id, subject
        )
        
        concepts_text = f"Probírané koncepty: {', '.join(concepts_covered)}" if concepts_covered else "Žádné nové koncepty"
        recommendations_text = "; ".join(recommendations) if recommendations else "Žádná nová doporučení"
        
        return chat_history, "", concepts_text, recommendations_text
    
    def update_progress_display(self, student_id: int, subject_filter: str):
        """Aktualizuje zobrazení pokroku"""
        # Získá data o pokroku
        subject = None if subject_filter == "Všechny" else subject_filter
        progress_data = self.memory_manager.get_student_progress(student_id, subject)
        
        if not progress_data:
            empty_fig = plt.figure(figsize=(10, 6))
            plt.text(0.5, 0.5, 'Zatím žádná data', ha='center', va='center', transform=plt.gca().transAxes)
            plt.title('Pokrok studenta')
            return empty_fig, [], {}
        
        # Vytvoří graf
        df = pd.DataFrame(progress_data)
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # Graf úrovně zvládnutí podle předmětů
        subject_mastery = df.groupby('subject')['mastery_level'].mean()
        ax1.bar(subject_mastery.index, subject_mastery.values)
        ax1.set_title('Průměrná úroveň zvládnutí podle předmětů')
        ax1.set_ylabel('Úroveň zvládnutí')
        ax1.tick_params(axis='x', rotation=45)
        
        # Graf pokroku v čase (simulace)
        ax2.plot(range(len(df)), df['mastery_level'].cumsum() / range(1, len(df) + 1))
        ax2.set_title('Vývoj celkového pokroku')
        ax2.set_xlabel('Pořadí konceptu')
        ax2.set_ylabel('Kumulativní průměr')
        
        plt.tight_layout()
        
        # Připraví tabulku
        table_data = [
            [row['subject'], row['concept'], f"{row['mastery_level']:.2f}", 
             row['attempts'], f"{row['accuracy']:.2f}"]
            for row in progress_data
        ]
        
        # Získá analytické údaje
        analytics = self.memory_manager.get_learning_analytics(student_id)
        
        return fig, table_data, analytics
    
    def generate_practice_questions(self, subject: str, difficulty: str, count: int):
        """Generuje cvičné otázky"""
        # Získá koncepty pro daný předmět
        concepts = self.ai_tutor.concept_database.get(subject, [])
        selected_concepts = concepts[:5]  # Vybere prvních 5 konceptů
        
        questions = self.ai_tutor.generate_practice_questions(
            subject, selected_concepts, difficulty, count
        )
        
        return questions
    
    def evaluate_practice_answer(self, answer: str, questions_data: List):
        """Vyhodnotí odpověď na cvičnou otázku"""
        if not answer.strip() or not questions_data:
            return "Prosím zadej odpověď na otázku.", ""
        
        # Vezme první otázku (jednoduchá implementace)
        question = questions_data[0] if questions_data else None
        
        if not question:
            return "Žádná otázka k vyhodnocení.", ""
        
        evaluation = self.ai_tutor.evaluate_answer(question, answer)
        
        # Aktualizuje pokrok
        if self.current_student_id:
            self.memory_manager.update_concept_progress(
                self.current_student_id,
                question.get("subject", "Obecné"),
                question["concept"],
                evaluation["correct"],
                question["difficulty"]
            )
        
        feedback = f"Skóre: {evaluation['score']:.2f}\n{evaluation['feedback']}"
        
        return feedback, ""
    
    def create_student_profile(self, name: str, email: str, learning_style: str):
        """Vytvoří profil studenta"""
        if not name or not email:
            return {"error": "Jméno a email jsou povinné"}
        
        try:
            student_id = self.memory_manager.create_student(name, email, learning_style)
            
            profile = {
                "id": student_id,
                "name": name,
                "email": email,
                "learning_style": learning_style,
                "created": "úspěšně"
            }
            
            return profile
            
        except Exception as e:
            return {"error": f"Chyba při vytváření profilu: {str(e)}"}

def main():
    """Hlavní funkce pro spuštění aplikace"""
    interface = TutorGradioInterface()
    app = interface.create_interface()
    
    app.launch(
        server_name="0.0.0.0",
        server_port=7860,
        share=False,
        debug=True
    )

if __name__ == "__main__":
    main()
````

````python
import asyncio
import sys
import os
from dotenv import load_dotenv

# Přidá současný adresář do Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from gradio_interface import main

if __name__ == "__main__":
    # Načte proměnné prostředí
    load_dotenv()
    
    # Ověří klíčové konfigurace
    required_vars = ["OPENAI_API_KEY"]
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        print("❌ Chybí následující proměnné prostředí:")
        for var in missing_vars:
            print(f"   - {var}")
        print("\n💡 Vytvoř soubor .env a přidej:")
        print("OPENAI_API_KEY=your_openai_api_key_here")
        sys.exit(1)
    
    print("🎓 Spouštím AI Vzdělávacího Tutora...")
    print("📚 Systém podporuje všechny předměty s pokročilým sledováním pokroku")
    print("🔗 Otevři prohlížeč na http://localhost:7860")
    
    try:
        main()
    except KeyboardInterrupt:
        print("\n👋 Ukončuji aplikaci...")
    except Exception as e:
        print(f"❌ Chyba při spuštění: {e}")
        sys.exit(1)
````

````python
# OpenAI API klíč (povinný)
OPENAI_API_KEY=your_openai_api_key_here

# Volitelné konfigurace
CHROMA_PERSIST_DIRECTORY=./chroma_db
DATABASE_URL=sqlite:///tutor_memory.db
MAX_CONTEXT_LENGTH=4000
````

## Shrnutí Projektu

### Hodnota Projektu
Interaktivní Vzdělávací Tutor představuje pokročilé řešení pro personalizované vzdělávání, které kombinuje nejmodernější AI technologie s důkladným sledováním pokroku studenta. Projekt využívá **Model Context Protocol** pro efektivní správu kontextu napříč vzdělávacími sezeními.

### Klíčové Výhody
- **Personalizace**: Adaptace na individuální učební styl a tempo každého studenta
- **Multimodální podpora**: Využití GPT-4o pro práci s textem, obrázky a audio
- **Dlouhodobá paměť**: Uchovávání pokroku a preferencí napříč sezeními
- **Sledování konceptů**: Detailní monitoring zvládnutí jednotlivých vzdělávacích konceptů
- **Interaktivní rozhraní**: Uživatelsky přívětivé webové rozhraní pomocí Gradio

### Technologické Inovace
Projekt implementuje pokročilé architektonické vzory včetně MCP pro správu kontextu, LangChain pro AI workflow, SQLAlchemy pro perzistenci dat a ChromaDB pro vektorové vyhledávání. Systém je navržen pro škálovatelnost a maintainability s modulární architekturou.

### Praktické Využití
Systém lze nasadit v různých vzdělávacích kontextech - od individuálního domácího studia přes školní výuku až po korporátní training programy. Poskytuje objektivní měření pokroku a personalizované doporučení pro optimalizaci učebního procesu.