<small>Claude Sonnet 4 **(Interaktivn√≠ Vzdƒõl√°vac√≠ Tutor (V≈°echny P≈ôedmƒõty))**</small>
# Interactive Education Tutor (All Subjects)

## Kl√≠ƒçov√© Koncepty

### Model Context Protocol (MCP)
**Model Context Protocol** je standardizovan√Ω protokol pro spr√°vu kontextu v AI aplikac√≠ch. Umo≈æ≈àuje efektivn√≠ sledov√°n√≠ konverzaƒçn√≠ho kontextu, spr√°vu pamƒõti a koordinaci mezi r≈Øzn√Ωmi komponentami AI syst√©mu.

### LangChain
**LangChain** je framework pro v√Ωvoj aplikac√≠ vyu≈æ√≠vaj√≠c√≠ch velk√© jazykov√© modely (LLM). Poskytuje n√°stroje pro ≈ôetƒõzen√≠ operac√≠, spr√°vu prompt≈Ø, integraci s extern√≠mi datov√Ωmi zdroji a vytv√°≈ôen√≠ komplexn√≠ch AI workflows.

### Long-Term Memory
**Dlouhodob√° pamƒõ≈•** v AI syst√©mech umo≈æ≈àuje uchov√°v√°n√≠ informac√≠ nap≈ô√≠ƒç jednotliv√Ωmi sezen√≠mi. V kontextu vzdƒõl√°vac√≠ho tutora zahrnuje sledov√°n√≠ pokroku studenta, nauƒçen√Ωch koncept≈Ø a personalizaƒçn√≠ch preferenc√≠.

### Concept Tracking
**Sledov√°n√≠ koncept≈Ø** je technika monitorov√°n√≠, kter√© vzdƒõl√°vac√≠ koncepty student zvl√°dl, kter√© pot≈ôebuje procviƒçit, a jak se jeho porozumƒõn√≠ vyv√≠j√≠ v ƒçase.

### OpenAI GPT-4o
**GPT-4o** je pokroƒçil√Ω multimod√°ln√≠ jazykov√Ω model od OpenAI, kter√Ω dok√°≈æe zpracov√°vat text, obr√°zky a audio, co≈æ umo≈æ≈àuje bohat≈°√≠ vzdƒõl√°vac√≠ interakce.

### Gradio UI
**Gradio** je Python knihovna pro rychl√© vytv√°≈ôen√≠ webov√Ωch u≈æivatelsk√Ωch rozhran√≠ pro machine learning modely a AI aplikace.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Interaktivn√≠ Vzdƒõl√°vac√≠ Tutor je pokroƒçil√Ω AI syst√©m navr≈æen√Ω pro personalizovan√© vzdƒõl√°v√°n√≠ nap≈ô√≠ƒç v≈°emi p≈ôedmƒõty. Hlavn√≠ c√≠le zahrnuj√≠:

- **Adaptivn√≠ uƒçen√≠**: P≈ôizp≈Øsoben√≠ tempa a stylu v√Ωuky individu√°ln√≠m pot≈ôeb√°m studenta
- **Sledov√°n√≠ pokroku**: Kontinu√°ln√≠ monitorov√°n√≠ osvojen√Ωch koncept≈Ø a identifikace mezer ve znalostech
- **Multimod√°ln√≠ interakce**: Vyu≈æit√≠ textu, obr√°zk≈Ø a audio pro bohat≈°√≠ vzdƒõl√°vac√≠ z√°≈æitek
- **Dlouhodob√° personalizace**: Uchov√°v√°n√≠ uƒçebn√≠ho profilu studenta nap≈ô√≠ƒç sezen√≠mi

### V√Ωzvy Projektu
- **Komplexnost spr√°vy kontextu**: Udr≈æov√°n√≠ relevantn√≠ho kontextu nap≈ô√≠ƒç r≈Øzn√Ωmi p≈ôedmƒõty a ƒçasov√Ωmi obdob√≠mi
- **Personalizace ve velk√©m mƒõ≈ô√≠tku**: Efektivn√≠ adaptace na individu√°ln√≠ uƒçebn√≠ styly a tempo
- **Hodnocen√≠ porozumƒõn√≠**: P≈ôesn√© mƒõ≈ôen√≠ skuteƒçn√©ho pochopen√≠ koncept≈Ø, nejen zapamatov√°n√≠
- **Integrace r≈Øzn√Ωch p≈ôedmƒõt≈Ø**: Propojov√°n√≠ znalost√≠ nap≈ô√≠ƒç discipl√≠nami

### Potenci√°ln√≠ Dopad
Tento syst√©m m≈Ø≈æe revolucionizovat vzdƒõl√°v√°n√≠ poskytnut√≠m:
- Dostupn√©ho osobn√≠ho tutora 24/7
- Objekt√≠vn√≠ho sledov√°n√≠ pokroku bez lidsk√Ωch p≈ôedsudk≈Ø
- ≈†k√°lovateln√©ho ≈ôe≈°en√≠ pro vzdƒõl√°vac√≠ instituce
- Podpory r≈Øzn√Ωch uƒçebn√≠ch styl≈Ø a pot≈ôeb

## Komplexn√≠ P≈ô√≠klad s Python Implementac√≠

````python
langchain==0.1.0
openai==1.12.0
gradio==4.15.0
chromadb==0.4.22
pydantic==2.5.3
sqlalchemy==2.0.25
python-dotenv==1.0.0
numpy==1.24.3
pandas==2.0.3
matplotlib==3.7.1
seaborn==0.12.2
````

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    CHROMA_PERSIST_DIRECTORY = "./chroma_db"
    DATABASE_URL = "sqlite:///tutor_memory.db"
    
    # Vzdƒõl√°vac√≠ konfigurace
    SUBJECTS = [
        "Matematika", "Fyzika", "Chemie", "Biologie", 
        "Historie", "Geografie", "ƒåe≈°tina", "Angliƒçtina",
        "Informatika", "Umƒõn√≠"
    ]
    
    DIFFICULTY_LEVELS = ["Zaƒç√°teƒçn√≠k", "Pokroƒçil√Ω zaƒç√°teƒçn√≠k", "St≈ôedn√≠", "Pokroƒçil√Ω", "Expert"]
    
    # MCP konfigurace
    MAX_CONTEXT_LENGTH = 4000
    CONCEPT_RETENTION_THRESHOLD = 0.8
    SESSION_TIMEOUT_MINUTES = 30
````

````python
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
from pydantic import BaseModel
from typing import List, Optional, Dict
import json

Base = declarative_base()

class Student(Base):
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    email = Column(String(200), unique=True)
    preferred_language = Column(String(10), default="cs")
    learning_style = Column(String(50))  # vizu√°ln√≠, auditivn√≠, kinestetick√Ω
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime, default=datetime.utcnow)

class ConceptProgress(Base):
    __tablename__ = "concept_progress"
    
    id = Column(Integer, primary_key=True)
    student_id = Column(Integer, nullable=False)
    subject = Column(String(50), nullable=False)
    concept_name = Column(String(200), nullable=False)
    mastery_level = Column(Float, default=0.0)  # 0.0 - 1.0
    attempts = Column(Integer, default=0)
    correct_answers = Column(Integer, default=0)
    last_practiced = Column(DateTime, default=datetime.utcnow)
    notes = Column(Text)

class LearningSession(Base):
    __tablename__ = "learning_sessions"
    
    id = Column(Integer, primary_key=True)
    student_id = Column(Integer, nullable=False)
    subject = Column(String(50), nullable=False)
    session_start = Column(DateTime, default=datetime.utcnow)
    session_end = Column(DateTime)
    concepts_covered = Column(Text)  # JSON seznam koncept≈Ø
    performance_score = Column(Float)
    feedback = Column(Text)

# Pydantic modely pro API
class ConceptTrackingRequest(BaseModel):
    student_id: int
    subject: str
    concept: str
    correct: bool
    difficulty: str

class LearningGoal(BaseModel):
    subject: str
    target_concepts: List[str]
    target_mastery: float
    deadline: Optional[datetime] = None

class StudentProfile(BaseModel):
    id: int
    name: str
    subjects: List[str]
    learning_style: str
    current_goals: List[LearningGoal]
    recent_progress: Dict[str, float]
````

````python
from typing import Dict, List, Optional
import json
from datetime import datetime, timedelta
from langchain.memory import ConversationSummaryBufferMemory
from langchain.schema import BaseMessage, HumanMessage, AIMessage

class MCPContextManager:
    """Model Context Protocol implementace pro vzdƒõl√°vac√≠ho tutora"""
    
    def __init__(self, max_context_length: int = 4000):
        self.max_context_length = max_context_length
        self.active_contexts: Dict[str, Dict] = {}
        self.concept_tracking: Dict[str, Dict] = {}
        
    def create_session_context(self, student_id: int, subject: str) -> str:
        """Vytvo≈ô√≠ nov√Ω kontext pro vzdƒõl√°vac√≠ sezen√≠"""
        session_id = f"{student_id}_{subject}_{datetime.now().timestamp()}"
        
        self.active_contexts[session_id] = {
            "student_id": student_id,
            "subject": subject,
            "start_time": datetime.now(),
            "messages": [],
            "concepts_discussed": [],
            "current_difficulty": "St≈ôedn√≠",
            "learning_objectives": [],
            "session_summary": ""
        }
        
        return session_id
    
    def add_message_to_context(self, session_id: str, message: BaseMessage, 
                              concepts: List[str] = None):
        """P≈ôid√° zpr√°vu do kontextu sezen√≠"""
        if session_id not in self.active_contexts:
            raise ValueError(f"Session {session_id} not found")
        
        context = self.active_contexts[session_id]
        context["messages"].append({
            "timestamp": datetime.now(),
            "type": type(message).__name__,
            "content": message.content,
            "concepts": concepts or []
        })
        
        if concepts:
            context["concepts_discussed"].extend(concepts)
            context["concepts_discussed"] = list(set(context["concepts_discussed"]))
        
        self._manage_context_length(session_id)
    
    def _manage_context_length(self, session_id: str):
        """Spravuje d√©lku kontextu podle MCP protokolu"""
        context = self.active_contexts[session_id]
        messages = context["messages"]
        
        # Spoƒç√≠t√° p≈ôibli≈ænou d√©lku kontextu
        total_length = sum(len(str(msg["content"])) for msg in messages)
        
        if total_length > self.max_context_length:
            # Zachov√° posledn√≠ zpr√°vy a vytvo≈ô√≠ shrnut√≠ star≈°√≠ch
            recent_messages = messages[-10:]  # Zachov√° posledn√≠ch 10 zpr√°v
            older_messages = messages[:-10]
            
            # Vytvo≈ô√≠ shrnut√≠ star≈°√≠ch zpr√°v
            summary = self._create_message_summary(older_messages)
            context["session_summary"] = summary
            context["messages"] = recent_messages
    
    def _create_message_summary(self, messages: List[Dict]) -> str:
        """Vytvo≈ô√≠ shrnut√≠ zpr√°v pro udr≈æen√≠ kontextu"""
        concepts = set()
        key_topics = []
        
        for msg in messages:
            if msg.get("concepts"):
                concepts.update(msg["concepts"])
            
            # Extrahuje kl√≠ƒçov√° t√©mata z obsahu
            content = msg["content"]
            if len(content) > 50:
                key_topics.append(content[:50] + "...")
        
        summary = f"Diskutovan√© koncepty: {', '.join(concepts)}. "
        summary += f"Kl√≠ƒçov√° t√©mata: {'; '.join(key_topics[:3])}"
        
        return summary
    
    def get_context_for_llm(self, session_id: str) -> Dict:
        """Vr√°t√≠ kontext optimalizovan√Ω pro LLM"""
        if session_id not in self.active_contexts:
            return {}
        
        context = self.active_contexts[session_id]
        
        return {
            "session_summary": context.get("session_summary", ""),
            "recent_messages": context["messages"][-5:],  # Posledn√≠ch 5 zpr√°v
            "concepts_discussed": context["concepts_discussed"],
            "current_difficulty": context["current_difficulty"],
            "learning_objectives": context["learning_objectives"],
            "subject": context["subject"]
        }
    
    def update_concept_tracking(self, student_id: int, subject: str, 
                              concept: str, performance: float):
        """Aktualizuje sledov√°n√≠ koncept≈Ø podle MCP"""
        key = f"{student_id}_{subject}_{concept}"
        
        if key not in self.concept_tracking:
            self.concept_tracking[key] = {
                "mastery_level": 0.0,
                "attempts": 0,
                "last_performance": [],
                "trend": "neutral"
            }
        
        tracking = self.concept_tracking[key]
        tracking["attempts"] += 1
        tracking["last_performance"].append(performance)
        
        # Zachov√° pouze posledn√≠ch 10 v√Ωsledk≈Ø
        if len(tracking["last_performance"]) > 10:
            tracking["last_performance"] = tracking["last_performance"][-10:]
        
        # Vypoƒç√≠t√° novou √∫rove≈à zvl√°dnut√≠
        recent_avg = sum(tracking["last_performance"][-3:]) / min(3, len(tracking["last_performance"]))
        tracking["mastery_level"] = (tracking["mastery_level"] * 0.7 + recent_avg * 0.3)
        
        # Urƒç√≠ trend
        if len(tracking["last_performance"]) >= 3:
            recent = tracking["last_performance"][-3:]
            if recent[-1] > recent[0]:
                tracking["trend"] = "improving"
            elif recent[-1] < recent[0]:
                tracking["trend"] = "declining"
            else:
                tracking["trend"] = "stable"
    
    def get_learning_recommendations(self, student_id: int, subject: str) -> List[str]:
        """Generuje doporuƒçen√≠ na z√°kladƒõ MCP dat"""
        recommendations = []
        
        # Analyzuje koncepty pro dan√©ho studenta a p≈ôedmƒõt
        student_concepts = {
            k: v for k, v in self.concept_tracking.items()
            if k.startswith(f"{student_id}_{subject}_")
        }
        
        # Najde koncepty s n√≠zkou √∫rovn√≠ zvl√°dnut√≠
        weak_concepts = [
            k.split("_")[-1] for k, v in student_concepts.items()
            if v["mastery_level"] < 0.6
        ]
        
        if weak_concepts:
            recommendations.append(f"Doporuƒçuji procviƒçit: {', '.join(weak_concepts[:3])}")
        
        # Najde koncepty se zhor≈°uj√≠c√≠m se trendem
        declining_concepts = [
            k.split("_")[-1] for k, v in student_concepts.items()
            if v["trend"] == "declining"
        ]
        
        if declining_concepts:
            recommendations.append(f"Vƒõnuj pozornost koncept≈Øm, kde se zhor≈°uje≈°: {', '.join(declining_concepts[:2])}")
        
        return recommendations
````

````python
from langchain.llms import OpenAI
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.schema import HumanMessage, AIMessage
from langchain.callbacks import get_openai_callback
import openai
from typing import List, Dict, Optional
import json
import random

class AIEducationalTutor:
    """AI Vzdƒõl√°vac√≠ tutor s pokroƒçil√Ωmi schopnostmi"""
    
    def __init__(self, api_key: str):
        self.chat_model = ChatOpenAI(
            api_key=api_key,
            model="gpt-4",
            temperature=0.7,
            max_tokens=1000
        )
        
        self.subject_prompts = self._load_subject_prompts()
        self.concept_database = self._initialize_concept_database()
    
    def _load_subject_prompts(self) -> Dict[str, str]:
        """Naƒçte specializovan√© prompty pro r≈Øzn√© p≈ôedmƒõty"""
        return {
            "Matematika": """Jsi zku≈°en√Ω uƒçitel matematiky. Vysvƒõtluj koncepty krok za krokem, 
            pou≈æ√≠vej konkr√©tn√≠ p≈ô√≠klady a ujisti se, ≈æe student rozum√≠ p≈ôed pokraƒçov√°n√≠m na dal≈°√≠ √∫rove≈à.""",
            
            "Fyzika": """Jsi energick√Ω uƒçitel fyziky. Propojuj teoretick√© koncepty s praktick√Ωmi 
            p≈ô√≠klady z ka≈ædodenn√≠ho ≈æivota. Pou≈æ√≠vej analogie a vizualizace.""",
            
            "Historie": """Jsi zap√°len√Ω historik. Vypr√°vƒõj p≈ô√≠bƒõhy, kter√© o≈æiv√≠ historick√© ud√°losti. 
            Pomoz studentovi pochopit p≈ô√≠ƒçiny a d≈Øsledky historick√Ωch proces≈Ø.""",
            
            "Chemie": """Jsi odborn√≠k na chemii. Vysvƒõtluj chemick√© procesy bezpeƒçnƒõ a zaj√≠mavƒõ. 
            Zd≈Øraz≈àuj praktick√© aplikace a souvislosti s ka≈ædodenn√≠m ≈æivotem.""",
        }
    
    def _initialize_concept_database(self) -> Dict[str, List[str]]:
        """Inicializuje datab√°zi koncept≈Ø pro r≈Øzn√© p≈ôedmƒõty"""
        return {
            "Matematika": [
                "sƒç√≠t√°n√≠", "odƒç√≠t√°n√≠", "n√°soben√≠", "dƒõlen√≠", "zlomky", "procenta",
                "algebra", "funkce", "geometrie", "trigonometrie", "kalkulus"
            ],
            "Fyzika": [
                "s√≠la", "pohyb", "energie", "teplo", "svƒõtlo", "elekt≈ôina", "magnetismus",
                "vlny", "atomy", "radioaktivita"
            ],
            "Chemie": [
                "atomy", "molekuly", "prvky", "slouƒçeniny", "reakce", "kyseliny",
                "z√°sady", "organick√° chemie", "anorganick√° chemie"
            ],
            "Historie": [
                "starovƒõk", "st≈ôedovƒõk", "novovƒõk", "20. stolet√≠", "v√°lka", "revoluce",
                "kultura", "politika", "ekonomie", "spoleƒçnost"
            ]
        }
    
    async def generate_response(self, student_message: str, context: Dict, 
                              subject: str, difficulty: str) -> Dict:
        """Generuje odpovƒõƒè tutora na z√°kladƒõ kontextu a MCP dat"""
        
        # P≈ôiprav√≠ prompt na z√°kladƒõ p≈ôedmƒõtu
        system_prompt = self.subject_prompts.get(subject, 
            "Jsi zku≈°en√Ω uƒçitel. Pom√°hej studentovi uƒçit se efektivnƒõ a s nad≈°en√≠m.")
        
        # P≈ôid√° kontext do promptu
        context_info = self._format_context_for_prompt(context)
        
        prompt_template = ChatPromptTemplate.from_messages([
            ("system", f"{system_prompt}\n\nKontext sezen√≠: {context_info}"),
            ("human", "{student_message}")
        ])
        
        try:
            with get_openai_callback() as cb:
                response = await self.chat_model.agenerate([
                    prompt_template.format_messages(student_message=student_message)
                ])
                
                ai_response = response.generations[0][0].text
                
                # Analyzuje odpovƒõƒè pro extrakci koncept≈Ø
                concepts = self._extract_concepts_from_response(ai_response, subject)
                
                return {
                    "response": ai_response,
                    "concepts_covered": concepts,
                    "difficulty_assessment": self._assess_difficulty(student_message),
                    "tokens_used": cb.total_tokens,
                    "cost": cb.total_cost
                }
                
        except Exception as e:
            return {
                "response": f"Omlouv√°m se, nastala chyba: {str(e)}",
                "concepts_covered": [],
                "difficulty_assessment": difficulty,
                "tokens_used": 0,
                "cost": 0
            }
    
    def _format_context_for_prompt(self, context: Dict) -> str:
        """Form√°tuje kontext pro pou≈æit√≠ v promptu"""
        context_parts = []
        
        if context.get("session_summary"):
            context_parts.append(f"Shrnut√≠ sezen√≠: {context['session_summary']}")
        
        if context.get("concepts_discussed"):
            context_parts.append(f"Diskutovan√© koncepty: {', '.join(context['concepts_discussed'])}")
        
        if context.get("current_difficulty"):
            context_parts.append(f"Aktu√°ln√≠ √∫rove≈à obt√≠≈ænosti: {context['current_difficulty']}")
        
        return " | ".join(context_parts) if context_parts else "Nov√© sezen√≠"
    
    def _extract_concepts_from_response(self, response: str, subject: str) -> List[str]:
        """Extrahuje koncepty z odpovƒõdi AI pomoc√≠ keyword matching"""
        concepts_found = []
        subject_concepts = self.concept_database.get(subject, [])
        
        response_lower = response.lower()
        
        for concept in subject_concepts:
            if concept.lower() in response_lower:
                concepts_found.append(concept)
        
        return concepts_found
    
    def _assess_difficulty(self, student_message: str) -> str:
        """Odhadne obt√≠≈ænost na z√°kladƒõ studentovy zpr√°vy"""
        message_lower = student_message.lower()
        
        # Jednoduch√° heuristika pro odhad obt√≠≈ænosti
        difficulty_indicators = {
            "easy": ["zaƒç√°tek", "z√°klady", "jednoduch√©", "pomozte", "nerozum√≠m"],
            "medium": ["p≈ô√≠klad", "vysvƒõtlit", "jak", "proƒç"],
            "hard": ["pokroƒçil√©", "slo≈æit√©", "detailnƒõ", "anal√Ωza", "d≈Økaz"]
        }
        
        for level, indicators in difficulty_indicators.items():
            if any(indicator in message_lower for indicator in indicators):
                if level == "easy":
                    return "Zaƒç√°teƒçn√≠k"
                elif level == "medium":
                    return "St≈ôedn√≠"
                else:
                    return "Pokroƒçil√Ω"
        
        return "St≈ôedn√≠"  # V√Ωchoz√≠ hodnota
    
    def generate_practice_questions(self, subject: str, concepts: List[str], 
                                  difficulty: str, count: int = 3) -> List[Dict]:
        """Generuje cviƒçn√© ot√°zky na z√°kladƒõ koncept≈Ø"""
        questions = []
        
        question_templates = {
            "Matematika": [
                "Vypoƒç√≠tej: {problem}",
                "Vy≈ôe≈° rovnici: {equation}",
                "Najdi {target} v n√°sleduj√≠c√≠m p≈ô√≠kladu: {context}"
            ],
            "Fyzika": [
                "Vysvƒõtli jev: {phenomenon}",
                "Vypoƒç√≠tej {quantity} p≈ôi n√°sleduj√≠c√≠ch podm√≠nk√°ch: {conditions}",
                "Proƒç se dƒõje: {situation}"
            ]
        }
        
        templates = question_templates.get(subject, ["Ot√°zka t√Ωkaj√≠c√≠ se {concept}"])
        
        for i in range(count):
            concept = random.choice(concepts) if concepts else "obecn√Ω koncept"
            template = random.choice(templates)
            
            # Jednoduch√° generace ot√°zky (v re√°ln√© aplikaci by bylo sofistikovanƒõj≈°√≠)
            question = template.format(
                problem=f"√∫loha s {concept}",
                equation=f"rovnice zahrnuj√≠c√≠ {concept}",
                target="v√Ωsledek",
                context=f"p≈ô√≠klad s {concept}",
                phenomenon=concept,
                quantity="hodnotu",
                conditions=f"parametry {concept}",
                situation=f"situace t√Ωkaj√≠c√≠ se {concept}",
                concept=concept
            )
            
            questions.append({
                "id": f"q_{i+1}",
                "question": question,
                "concept": concept,
                "difficulty": difficulty,
                "type": "open-ended"
            })
        
        return questions
    
    def evaluate_answer(self, question: Dict, student_answer: str) -> Dict:
        """Vyhodnot√≠ studentovu odpovƒõƒè"""
        # Jednoduch√° implementace - v re√°ln√© aplikaci by bylo sofistikovanƒõj≈°√≠
        score = random.uniform(0.6, 1.0)  # Simulace hodnocen√≠
        
        feedback_templates = [
            "Dobr√° pr√°ce! Tvoje odpovƒõƒè ukazuje pochopen√≠ konceptu.",
            "Spr√°vn√Ω smƒõr! Zkus se zamƒõ≈ôit v√≠ce na {concept}.",
            "V√Ωbornƒõ! Vid√≠m, ≈æe rozum√≠≈° principu {concept}.",
            "T√©mƒõ≈ô spr√°vnƒõ. Zkus je≈°tƒõ jednou s ohledem na {concept}."
        ]
        
        feedback = random.choice(feedback_templates).format(
            concept=question["concept"]
        )
        
        return {
            "score": score,
            "feedback": feedback,
            "correct": score > 0.7,
            "concept": question["concept"],
            "improvement_areas": [question["concept"]] if score < 0.7 else []
        }
````

````python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base, Student, ConceptProgress, LearningSession
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import json

class LongTermMemoryManager:
    """Spr√°vce dlouhodob√© pamƒõti pro vzdƒõl√°vac√≠ho tutora"""
    
    def __init__(self, database_url: str):
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        Session = sessionmaker(bind=self.engine)
        self.session = Session()
    
    def create_student(self, name: str, email: str, learning_style: str = "vizu√°ln√≠") -> int:
        """Vytvo≈ô√≠ nov√©ho studenta"""
        student = Student(
            name=name,
            email=email,
            learning_style=learning_style
        )
        
        self.session.add(student)
        self.session.commit()
        return student.id
    
    def get_student(self, student_id: int) -> Optional[Student]:
        """Z√≠sk√° studenta podle ID"""
        return self.session.query(Student).filter(Student.id == student_id).first()
    
    def update_concept_progress(self, student_id: int, subject: str, 
                              concept_name: str, correct: bool, difficulty: str):
        """Aktualizuje pokrok v konceptu"""
        progress = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.subject == subject,
            ConceptProgress.concept_name == concept_name
        ).first()
        
        if not progress:
            progress = ConceptProgress(
                student_id=student_id,
                subject=subject,
                concept_name=concept_name
            )
            self.session.add(progress)
        
        progress.attempts += 1
        if correct:
            progress.correct_answers += 1
        
        # Vypoƒç√≠t√° novou √∫rove≈à zvl√°dnut√≠
        accuracy = progress.correct_answers / progress.attempts
        difficulty_multiplier = self._get_difficulty_multiplier(difficulty)
        
        # Exponenci√°ln√≠ v√°hovan√Ω pr≈Ømƒõr pro hlad≈°√≠ aktualizace
        alpha = 0.3  # Learning rate
        new_contribution = accuracy * difficulty_multiplier
        progress.mastery_level = (1 - alpha) * progress.mastery_level + alpha * new_contribution
        
        progress.last_practiced = datetime.utcnow()
        self.session.commit()
    
    def _get_difficulty_multiplier(self, difficulty: str) -> float:
        """Vr√°t√≠ multiplik√°tor na z√°kladƒõ obt√≠≈ænosti"""
        multipliers = {
            "Zaƒç√°teƒçn√≠k": 0.8,
            "Pokroƒçil√Ω zaƒç√°teƒçn√≠k": 0.9,
            "St≈ôedn√≠": 1.0,
            "Pokroƒçil√Ω": 1.2,
            "Expert": 1.5
        }
        return multipliers.get(difficulty, 1.0)
    
    def get_student_progress(self, student_id: int, subject: str = None) -> List[Dict]:
        """Z√≠sk√° pokrok studenta"""
        query = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id
        )
        
        if subject:
            query = query.filter(ConceptProgress.subject == subject)
        
        progress_list = query.all()
        
        return [
            {
                "subject": p.subject,
                "concept": p.concept_name,
                "mastery_level": p.mastery_level,
                "attempts": p.attempts,
                "accuracy": p.correct_answers / p.attempts if p.attempts > 0 else 0,
                "last_practiced": p.last_practiced
            }
            for p in progress_list
        ]
    
    def get_learning_analytics(self, student_id: int, days: int = 30) -> Dict:
        """Z√≠sk√° analytick√© √∫daje o uƒçen√≠"""
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        
        # Celkov√Ω pokrok
        total_progress = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.last_practiced >= cutoff_date
        ).all()
        
        # Sezen√≠
        sessions = self.session.query(LearningSession).filter(
            LearningSession.student_id == student_id,
            LearningSession.session_start >= cutoff_date
        ).all()
        
        # Statistiky podle p≈ôedmƒõt≈Ø
        subject_stats = {}
        for progress in total_progress:
            subject = progress.subject
            if subject not in subject_stats:
                subject_stats[subject] = {
                    "concepts_count": 0,
                    "avg_mastery": 0.0,
                    "total_attempts": 0,
                    "weak_concepts": []
                }
            
            stats = subject_stats[subject]
            stats["concepts_count"] += 1
            stats["avg_mastery"] += progress.mastery_level
            stats["total_attempts"] += progress.attempts
            
            if progress.mastery_level < 0.6:
                stats["weak_concepts"].append(progress.concept_name)
        
        # Pr≈Ømƒõrn√© hodnoty
        for subject, stats in subject_stats.items():
            if stats["concepts_count"] > 0:
                stats["avg_mastery"] /= stats["concepts_count"]
        
        return {
            "period_days": days,
            "total_concepts_practiced": len(total_progress),
            "total_sessions": len(sessions),
            "subject_statistics": subject_stats,
            "overall_mastery": sum(p.mastery_level for p in total_progress) / len(total_progress) if total_progress else 0,
            "most_active_subject": max(subject_stats.keys(), key=lambda x: subject_stats[x]["total_attempts"]) if subject_stats else None
        }
    
    def start_learning_session(self, student_id: int, subject: str) -> int:
        """Zah√°j√≠ nov√© vzdƒõl√°vac√≠ sezen√≠"""
        session = LearningSession(
            student_id=student_id,
            subject=subject
        )
        
        self.session.add(session)
        self.session.commit()
        return session.id
    
    def end_learning_session(self, session_id: int, concepts_covered: List[str], 
                           performance_score: float, feedback: str):
        """Ukonƒç√≠ vzdƒõl√°vac√≠ sezen√≠"""
        session = self.session.query(LearningSession).filter(
            LearningSession.id == session_id
        ).first()
        
        if session:
            session.session_end = datetime.utcnow()
            session.concepts_covered = json.dumps(concepts_covered)
            session.performance_score = performance_score
            session.feedback = feedback
            self.session.commit()
    
    def get_recommended_concepts(self, student_id: int, subject: str, limit: int = 5) -> List[str]:
        """Doporuƒç√≠ koncepty k procviƒçen√≠ na z√°kladƒõ pokroku"""
        # Z√≠sk√° koncepty s n√≠zkou √∫rovn√≠ zvl√°dnut√≠
        weak_concepts = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.subject == subject,
            ConceptProgress.mastery_level < 0.7
        ).order_by(ConceptProgress.mastery_level.asc()).limit(limit).all()
        
        # Z√≠sk√° koncepty, kter√© nebyly dlouho procviƒçov√°ny
        old_concepts = self.session.query(ConceptProgress).filter(
            ConceptProgress.student_id == student_id,
            ConceptProgress.subject == subject,
            ConceptProgress.last_practiced < datetime.utcnow() - timedelta(days=7)
        ).order_by(ConceptProgress.last_practiced.asc()).limit(limit).all()
        
        recommendations = []
        
        # Priorita: slab√© koncepty
        for concept in weak_concepts:
            recommendations.append(concept.concept_name)
        
        # Doplnƒõn√≠ star√Ωmi koncepty
        for concept in old_concepts:
            if concept.concept_name not in recommendations and len(recommendations) < limit:
                recommendations.append(concept.concept_name)
        
        return recommendations[:limit]
    
    def cleanup_old_data(self, days_to_keep: int = 365):
        """Vyƒçist√≠ star√° data pro optimalizaci"""
        cutoff_date = datetime.utcnow() - timedelta(days=days_to_keep)
        
        # Sma≈æe star√° sezen√≠
        self.session.query(LearningSession).filter(
            LearningSession.session_start < cutoff_date
        ).delete()
        
        self.session.commit()
    
    def __del__(self):
        """Zav≈ôe datab√°zov√© p≈ôipojen√≠"""
        if hasattr(self, 'session'):
            self.session.close()
````

````python
import gradio as gr
import asyncio
from typing import List, Tuple, Dict
import json
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from io import BytesIO
import base64

from ai_tutor import AIEducationalTutor
from mcp_manager import MCPContextManager
from memory_manager import LongTermMemoryManager
from config import Config

class TutorGradioInterface:
    """Gradio u≈æivatelsk√© rozhran√≠ pro vzdƒõl√°vac√≠ho tutora"""
    
    def __init__(self):
        self.config = Config()
        self.ai_tutor = AIEducationalTutor(self.config.OPENAI_API_KEY)
        self.mcp_manager = MCPContextManager(self.config.MAX_CONTEXT_LENGTH)
        self.memory_manager = LongTermMemoryManager(self.config.DATABASE_URL)
        
        self.current_session_id = None
        self.current_student_id = None
        
    def create_interface(self):
        """Vytvo≈ô√≠ Gradio rozhran√≠"""
        
        with gr.Blocks(title="AI Vzdƒõl√°vac√≠ Tutor", theme=gr.themes.Soft()) as interface:
            gr.Markdown("# üéì AI Vzdƒõl√°vac√≠ Tutor")
            gr.Markdown("*Personalizovan√Ω tutor pro v≈°echny p≈ôedmƒõty s pokroƒçil√Ωm sledov√°n√≠m pokroku*")
            
            with gr.Tab("Uƒçen√≠"):
                self._create_learning_tab()
            
            with gr.Tab("Pokrok"):
                self._create_progress_tab()
            
            with gr.Tab("Cviƒçen√≠"):
                self._create_practice_tab()
            
            with gr.Tab("Profil"):
                self._create_profile_tab()
        
        return interface
    
    def _create_learning_tab(self):
        """Vytvo≈ô√≠ z√°lo≈æku pro uƒçen√≠"""
        with gr.Row():
            with gr.Column(scale=2):
                student_name = gr.Textbox(
                    label="Jm√©no studenta",
                    placeholder="Zadej sv√© jm√©no"
                )
                subject_dropdown = gr.Dropdown(
                    choices=self.config.SUBJECTS,
                    label="P≈ôedmƒõt",
                    value="Matematika"
                )
                difficulty_dropdown = gr.Dropdown(
                    choices=self.config.DIFFICULTY_LEVELS,
                    label="√örove≈à obt√≠≈ænosti",
                    value="St≈ôedn√≠"
                )
                
                start_session_btn = gr.Button("Zah√°jit sezen√≠", variant="primary")
            
            with gr.Column(scale=1):
                session_info = gr.JSON(label="Informace o sezen√≠", visible=False)
        
        with gr.Row():
            chatbot = gr.Chatbot(label="Konverzace s tutorem", height=400)
        
        with gr.Row():
            msg_input = gr.Textbox(
                label="Tvoje zpr√°va",
                placeholder="Napi≈° svoji ot√°zku nebo odpovƒõƒè...",
                scale=4
            )
            send_btn = gr.Button("Odeslat", scale=1)
        
        with gr.Row():
            concepts_display = gr.Textbox(
                label="Prob√≠ran√© koncepty",
                interactive=False
            )
            recommendations_display = gr.Textbox(
                label="Doporuƒçen√≠",
                interactive=False
            )
        
        # Event handlers
        start_session_btn.click(
            fn=self.start_learning_session,
            inputs=[student_name, subject_dropdown, difficulty_dropdown],
            outputs=[session_info, chatbot, concepts_display, recommendations_display]
        )
        
        send_btn.click(
            fn=self.process_message,
            inputs=[msg_input, chatbot, subject_dropdown, difficulty_dropdown],
            outputs=[chatbot, msg_input, concepts_display, recommendations_display]
        )
        
        msg_input.submit(
            fn=self.process_message,
            inputs=[msg_input, chatbot, subject_dropdown, difficulty_dropdown],
            outputs=[chatbot, msg_input, concepts_display, recommendations_display]
        )
    
    def _create_progress_tab(self):
        """Vytvo≈ô√≠ z√°lo≈æku pro sledov√°n√≠ pokroku"""
        with gr.Row():
            student_id_input = gr.Number(
                label="ID studenta",
                value=1
            )
            subject_filter = gr.Dropdown(
                choices=["V≈°echny"] + self.config.SUBJECTS,
                label="Filtr p≈ôedmƒõtu",
                value="V≈°echny"
            )
            refresh_btn = gr.Button("Aktualizovat")
        
        with gr.Row():
            progress_chart = gr.Plot(label="Graf pokroku")
        
        with gr.Row():
            progress_table = gr.Dataframe(
                label="Detailn√≠ pokrok",
                headers=["P≈ôedmƒõt", "Koncept", "√örove≈à zvl√°dnut√≠", "Pokusy", "P≈ôesnost"]
            )
        
        with gr.Row():
            analytics_json = gr.JSON(label="Analytick√© √∫daje")
        
        refresh_btn.click(
            fn=self.update_progress_display,
            inputs=[student_id_input, subject_filter],
            outputs=[progress_chart, progress_table, analytics_json]
        )
    
    def _create_practice_tab(self):
        """Vytvo≈ô√≠ z√°lo≈æku pro cviƒçen√≠"""
        with gr.Row():
            with gr.Column():
                practice_subject = gr.Dropdown(
                    choices=self.config.SUBJECTS,
                    label="P≈ôedmƒõt pro cviƒçen√≠",
                    value="Matematika"
                )
                practice_difficulty = gr.Dropdown(
                    choices=self.config.DIFFICULTY_LEVELS,
                    label="Obt√≠≈ænost",
                    value="St≈ôedn√≠"
                )
                question_count = gr.Slider(
                    minimum=1,
                    maximum=10,
                    value=3,
                    step=1,
                    label="Poƒçet ot√°zek"
                )
                generate_questions_btn = gr.Button("Generovat ot√°zky")
        
        with gr.Row():
            questions_display = gr.JSON(label="Cviƒçn√© ot√°zky")
        
        with gr.Row():
            answer_input = gr.Textbox(
                label="Tvoje odpovƒõƒè",
                placeholder="Napi≈° svoji odpovƒõƒè na aktu√°ln√≠ ot√°zku..."
            )
            submit_answer_btn = gr.Button("Odeslat odpovƒõƒè")
        
        with gr.Row():
            feedback_display = gr.Textbox(
                label="Zpƒõtn√° vazba",
                interactive=False
            )
        
        generate_questions_btn.click(
            fn=self.generate_practice_questions,
            inputs=[practice_subject, practice_difficulty, question_count],
            outputs=[questions_display]
        )
        
        submit_answer_btn.click(
            fn=self.evaluate_practice_answer,
            inputs=[answer_input, questions_display],
            outputs=[feedback_display, answer_input]
        )
    
    def _create_profile_tab(self):
        """Vytvo≈ô√≠ z√°lo≈æku pro profil studenta"""
        with gr.Row():
            with gr.Column():
                profile_name = gr.Textbox(label="Jm√©no")
                profile_email = gr.Textbox(label="Email")
                learning_style = gr.Dropdown(
                    choices=["vizu√°ln√≠", "auditivn√≠", "kinestetick√Ω"],
                    label="Uƒçebn√≠ styl",
                    value="vizu√°ln√≠"
                )
                create_profile_btn = gr.Button("Vytvo≈ôit profil")
            
            with gr.Column():
                profile_display = gr.JSON(label="Aktu√°ln√≠ profil")
        
        create_profile_btn.click(
            fn=self.create_student_profile,
            inputs=[profile_name, profile_email, learning_style],
            outputs=[profile_display]
        )
    
    def start_learning_session(self, student_name: str, subject: str, difficulty: str):
        """Zah√°j√≠ nov√© vzdƒõl√°vac√≠ sezen√≠"""
        if not student_name:
            return {}, [["Syst√©m", "Pros√≠m zadej sv√© jm√©no pro zah√°jen√≠ sezen√≠."]], "", ""
        
        # Najde nebo vytvo≈ô√≠ studenta
        # Jednoduch√° implementace - v re√°ln√© aplikaci by bylo sofistikovanƒõj≈°√≠
        self.current_student_id = 1  # V√Ωchoz√≠ ID
        
        # Vytvo≈ô√≠ MCP kontext
        self.current_session_id = self.mcp_manager.create_session_context(
            self.current_student_id, subject
        )
        
        # Zah√°j√≠ sezen√≠ v datab√°zi
        session_db_id = self.memory_manager.start_learning_session(
            self.current_student_id, subject
        )
        
        # √övodn√≠ zpr√°va
        welcome_msg = f"Ahoj {student_name}! Jsem tv≈Øj AI tutor. Dnes budeme studovat {subject} na √∫rovni {difficulty}. Jak ti mohu pomoci?"
        
        # Z√≠sk√° doporuƒçen√≠
        recommendations = self.memory_manager.get_recommended_concepts(
            self.current_student_id, subject, 3
        )
        
        session_info = {
            "session_id": self.current_session_id,
            "student_id": self.current_student_id,
            "subject": subject,
            "difficulty": difficulty,
            "db_session_id": session_db_id
        }
        
        concepts_text = "Sezen√≠ zah√°jeno"
        recommendations_text = f"Doporuƒçen√© koncepty: {', '.join(recommendations)}" if recommendations else "Zat√≠m ≈æ√°dn√° doporuƒçen√≠"
        
        return session_info, [["Tutor", welcome_msg]], concepts_text, recommendations_text
    
    async def process_message(self, message: str, chat_history: List, subject: str, difficulty: str):
        """Zpracuje zpr√°vu od studenta"""
        if not self.current_session_id or not message.strip():
            return chat_history, "", "", ""
        
        # P≈ôid√° zpr√°vu do historie
        chat_history.append(["Student", message])
        
        # Z√≠sk√° kontext pro LLM
        context = self.mcp_manager.get_context_for_llm(self.current_session_id)
        
        # Generuje odpovƒõƒè AI tutora
        response_data = await self.ai_tutor.generate_response(
            message, context, subject, difficulty
        )
        
        ai_response = response_data["response"]
        concepts_covered = response_data["concepts_covered"]
        
        # P≈ôid√° odpovƒõƒè do historie
        chat_history.append(["Tutor", ai_response])
        
        # Aktualizuje MCP kontext
        self.mcp_manager.add_message_to_context(
            self.current_session_id,
            gr.HumanMessage(content=message),
            concepts_covered
        )
        
        self.mcp_manager.add_message_to_context(
            self.current_session_id,
            gr.AIMessage(content=ai_response),
            concepts_covered
        )
        
        # Aktualizuje pokrok v konceptech
        for concept in concepts_covered:
            # Jednoduch√© hodnocen√≠ - v re√°ln√© aplikaci by bylo sofistikovanƒõj≈°√≠
            self.memory_manager.update_concept_progress(
                self.current_student_id, subject, concept, True, difficulty
            )
        
        # Z√≠sk√° nov√° doporuƒçen√≠
        recommendations = self.mcp_manager.get_learning_recommendations(
            self.current_student_id, subject
        )
        
        concepts_text = f"Prob√≠ran√© koncepty: {', '.join(concepts_covered)}" if concepts_covered else "≈Ω√°dn√© nov√© koncepty"
        recommendations_text = "; ".join(recommendations) if recommendations else "≈Ω√°dn√° nov√° doporuƒçen√≠"
        
        return chat_history, "", concepts_text, recommendations_text
    
    def update_progress_display(self, student_id: int, subject_filter: str):
        """Aktualizuje zobrazen√≠ pokroku"""
        # Z√≠sk√° data o pokroku
        subject = None if subject_filter == "V≈°echny" else subject_filter
        progress_data = self.memory_manager.get_student_progress(student_id, subject)
        
        if not progress_data:
            empty_fig = plt.figure(figsize=(10, 6))
            plt.text(0.5, 0.5, 'Zat√≠m ≈æ√°dn√° data', ha='center', va='center', transform=plt.gca().transAxes)
            plt.title('Pokrok studenta')
            return empty_fig, [], {}
        
        # Vytvo≈ô√≠ graf
        df = pd.DataFrame(progress_data)
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # Graf √∫rovnƒõ zvl√°dnut√≠ podle p≈ôedmƒõt≈Ø
        subject_mastery = df.groupby('subject')['mastery_level'].mean()
        ax1.bar(subject_mastery.index, subject_mastery.values)
        ax1.set_title('Pr≈Ømƒõrn√° √∫rove≈à zvl√°dnut√≠ podle p≈ôedmƒõt≈Ø')
        ax1.set_ylabel('√örove≈à zvl√°dnut√≠')
        ax1.tick_params(axis='x', rotation=45)
        
        # Graf pokroku v ƒçase (simulace)
        ax2.plot(range(len(df)), df['mastery_level'].cumsum() / range(1, len(df) + 1))
        ax2.set_title('V√Ωvoj celkov√©ho pokroku')
        ax2.set_xlabel('Po≈ôad√≠ konceptu')
        ax2.set_ylabel('Kumulativn√≠ pr≈Ømƒõr')
        
        plt.tight_layout()
        
        # P≈ôiprav√≠ tabulku
        table_data = [
            [row['subject'], row['concept'], f"{row['mastery_level']:.2f}", 
             row['attempts'], f"{row['accuracy']:.2f}"]
            for row in progress_data
        ]
        
        # Z√≠sk√° analytick√© √∫daje
        analytics = self.memory_manager.get_learning_analytics(student_id)
        
        return fig, table_data, analytics
    
    def generate_practice_questions(self, subject: str, difficulty: str, count: int):
        """Generuje cviƒçn√© ot√°zky"""
        # Z√≠sk√° koncepty pro dan√Ω p≈ôedmƒõt
        concepts = self.ai_tutor.concept_database.get(subject, [])
        selected_concepts = concepts[:5]  # Vybere prvn√≠ch 5 koncept≈Ø
        
        questions = self.ai_tutor.generate_practice_questions(
            subject, selected_concepts, difficulty, count
        )
        
        return questions
    
    def evaluate_practice_answer(self, answer: str, questions_data: List):
        """Vyhodnot√≠ odpovƒõƒè na cviƒçnou ot√°zku"""
        if not answer.strip() or not questions_data:
            return "Pros√≠m zadej odpovƒõƒè na ot√°zku.", ""
        
        # Vezme prvn√≠ ot√°zku (jednoduch√° implementace)
        question = questions_data[0] if questions_data else None
        
        if not question:
            return "≈Ω√°dn√° ot√°zka k vyhodnocen√≠.", ""
        
        evaluation = self.ai_tutor.evaluate_answer(question, answer)
        
        # Aktualizuje pokrok
        if self.current_student_id:
            self.memory_manager.update_concept_progress(
                self.current_student_id,
                question.get("subject", "Obecn√©"),
                question["concept"],
                evaluation["correct"],
                question["difficulty"]
            )
        
        feedback = f"Sk√≥re: {evaluation['score']:.2f}\n{evaluation['feedback']}"
        
        return feedback, ""
    
    def create_student_profile(self, name: str, email: str, learning_style: str):
        """Vytvo≈ô√≠ profil studenta"""
        if not name or not email:
            return {"error": "Jm√©no a email jsou povinn√©"}
        
        try:
            student_id = self.memory_manager.create_student(name, email, learning_style)
            
            profile = {
                "id": student_id,
                "name": name,
                "email": email,
                "learning_style": learning_style,
                "created": "√∫spƒõ≈°nƒõ"
            }
            
            return profile
            
        except Exception as e:
            return {"error": f"Chyba p≈ôi vytv√°≈ôen√≠ profilu: {str(e)}"}

def main():
    """Hlavn√≠ funkce pro spu≈°tƒõn√≠ aplikace"""
    interface = TutorGradioInterface()
    app = interface.create_interface()
    
    app.launch(
        server_name="0.0.0.0",
        server_port=7860,
        share=False,
        debug=True
    )

if __name__ == "__main__":
    main()
````

````python
import asyncio
import sys
import os
from dotenv import load_dotenv

# P≈ôid√° souƒçasn√Ω adres√°≈ô do Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from gradio_interface import main

if __name__ == "__main__":
    # Naƒçte promƒõnn√© prost≈ôed√≠
    load_dotenv()
    
    # Ovƒõ≈ô√≠ kl√≠ƒçov√© konfigurace
    required_vars = ["OPENAI_API_KEY"]
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        print("‚ùå Chyb√≠ n√°sleduj√≠c√≠ promƒõnn√© prost≈ôed√≠:")
        for var in missing_vars:
            print(f"   - {var}")
        print("\nüí° Vytvo≈ô soubor .env a p≈ôidej:")
        print("OPENAI_API_KEY=your_openai_api_key_here")
        sys.exit(1)
    
    print("üéì Spou≈°t√≠m AI Vzdƒõl√°vac√≠ho Tutora...")
    print("üìö Syst√©m podporuje v≈°echny p≈ôedmƒõty s pokroƒçil√Ωm sledov√°n√≠m pokroku")
    print("üîó Otev≈ôi prohl√≠≈æeƒç na http://localhost:7860")
    
    try:
        main()
    except KeyboardInterrupt:
        print("\nüëã Ukonƒçuji aplikaci...")
    except Exception as e:
        print(f"‚ùå Chyba p≈ôi spu≈°tƒõn√≠: {e}")
        sys.exit(1)
````

````python
# OpenAI API kl√≠ƒç (povinn√Ω)
OPENAI_API_KEY=your_openai_api_key_here

# Voliteln√© konfigurace
CHROMA_PERSIST_DIRECTORY=./chroma_db
DATABASE_URL=sqlite:///tutor_memory.db
MAX_CONTEXT_LENGTH=4000
````

## Shrnut√≠ Projektu

### Hodnota Projektu
Interaktivn√≠ Vzdƒõl√°vac√≠ Tutor p≈ôedstavuje pokroƒçil√© ≈ôe≈°en√≠ pro personalizovan√© vzdƒõl√°v√°n√≠, kter√© kombinuje nejmodernƒõj≈°√≠ AI technologie s d≈Økladn√Ωm sledov√°n√≠m pokroku studenta. Projekt vyu≈æ√≠v√° **Model Context Protocol** pro efektivn√≠ spr√°vu kontextu nap≈ô√≠ƒç vzdƒõl√°vac√≠mi sezen√≠mi.

### Kl√≠ƒçov√© V√Ωhody
- **Personalizace**: Adaptace na individu√°ln√≠ uƒçebn√≠ styl a tempo ka≈æd√©ho studenta
- **Multimod√°ln√≠ podpora**: Vyu≈æit√≠ GPT-4o pro pr√°ci s textem, obr√°zky a audio
- **Dlouhodob√° pamƒõ≈•**: Uchov√°v√°n√≠ pokroku a preferenc√≠ nap≈ô√≠ƒç sezen√≠mi
- **Sledov√°n√≠ koncept≈Ø**: Detailn√≠ monitoring zvl√°dnut√≠ jednotliv√Ωch vzdƒõl√°vac√≠ch koncept≈Ø
- **Interaktivn√≠ rozhran√≠**: U≈æivatelsky p≈ô√≠vƒõtiv√© webov√© rozhran√≠ pomoc√≠ Gradio

### Technologick√© Inovace
Projekt implementuje pokroƒçil√© architektonick√© vzory vƒçetnƒõ MCP pro spr√°vu kontextu, LangChain pro AI workflow, SQLAlchemy pro perzistenci dat a ChromaDB pro vektorov√© vyhled√°v√°n√≠. Syst√©m je navr≈æen pro ≈°k√°lovatelnost a maintainability s modul√°rn√≠ architekturou.

### Praktick√© Vyu≈æit√≠
Syst√©m lze nasadit v r≈Øzn√Ωch vzdƒõl√°vac√≠ch kontextech - od individu√°ln√≠ho dom√°c√≠ho studia p≈ôes ≈°koln√≠ v√Ωuku a≈æ po korpor√°tn√≠ training programy. Poskytuje objektivn√≠ mƒõ≈ôen√≠ pokroku a personalizovan√© doporuƒçen√≠ pro optimalizaci uƒçebn√≠ho procesu.