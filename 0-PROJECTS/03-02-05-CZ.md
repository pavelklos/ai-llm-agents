<small>Claude Sonnet 4 **(Codebase Q&A Bot s RAG Architekturou)**</small>
# Codebase Q&A Bot

## Klíčové Koncepty

### RAG (Retrieval-Augmented Generation)
Hybridní přístup, který kombinuje vyhledávání relevantních informací z databáze znalostí s generováním odpovědí pomocí LLM. RAG umožňuje AI modelům přistupovat k aktuálním a specifickým informacím bez nutnosti přetrénování.

### OpenAI GPT-4o
Nejnovější multimodální model od OpenAI s vylepšenou rychlostí a efektivitou. Optimalizován pro komplexní úlohy zpracování textu a kódu.

### GitHub API
RESTful API umožňující programový přístup k repozitářům, souborům, commit historii a metadata GitHub projektů.

### Docstring Parsing
Automatické extrahování dokumentace z komentářů a docstringů v kódu. Umožňuje porozumění účelu funkcí, tříd a modulů.

### Embeddings
Vektorové reprezentace textu v multidimenzionálním prostoru, kde sémanticky podobné texty mají blízké pozice. Klíčové pro efektivní vyhledávání podobného obsahu.

### VSCode Extension
Plugin pro Visual Studio Code umožňující integraci AI funkcionalit přímo do vývojového prostředí.

## Komplexní Vysvětlení Projektu

Codebase Q&A Bot představuje pokročilý AI asistent navržený speciálně pro vývojáře a týmy pracující s rozsáhlými kódovými bázemi. Projekt řeší kritický problém moderního softwarového vývoje - rychlé pochopení a navigaci složitých projektů.

### Cíle Projektu
- **Okamžité odpovědi**: Poskytování relevantních odpovědí na technické otázky o kódu
- **Kontextové porozumění**: Chápání vztahů mezi různými částmi kódové báze
- **Dokumentační podpora**: Automatické generování a aktualizace technické dokumentace
- **Onboarding zjednodušení**: Rychlejší zapracování nových členů týmu

### Technické Výzvy
- **Sémantické indexování**: Efektivní reprezentace kódu v embedding prostoru
- **Kontextová relevance**: Nalezení přesně relevantních kódových segmentů
- **Škálovatelnost**: Zpracování velkých kódových bází s tisíci souborů
- **Aktuálnost**: Udržování synchronizace s měnícím se kódem

### Potenciální Dopad
Projekt může výrazně zvýšit produktivitu vývojářských týmů, snížit čas potřebný na porozumění legacy kódu a zlepšit kvalitu dokumentace prostřednictvím automatizovaných insights.

## Komplexní Implementace v Pythonu

````python
openai==1.12.0
langchain==0.1.10
langchain-openai==0.0.8
chromadb==0.4.22
gitpython==3.1.41
requests==2.31.0
python-dotenv==1.0.1
fastapi==0.109.2
uvicorn==0.27.1
pydantic==2.6.1
tiktoken==0.5.2
PyGithub==2.2.0
tree-sitter==0.20.4
tree-sitter-python==0.20.4
````

````python
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime

class CodeFile(BaseModel):
    filepath: str
    content: str
    language: str
    size: int
    last_modified: datetime
    functions: List[Dict[str, Any]] = []
    classes: List[Dict[str, Any]] = []
    imports: List[str] = []

class QueryRequest(BaseModel):
    question: str
    repository: str
    max_results: int = 5
    include_code: bool = True

class QueryResponse(BaseModel):
    answer: str
    relevant_files: List[str]
    confidence_score: float
    sources: List[Dict[str, Any]]
    execution_time: float

class EmbeddingDocument(BaseModel):
    content: str
    metadata: Dict[str, Any]
    embedding: Optional[List[float]] = None
````

````python
import ast
import tree_sitter_python as tspython
from tree_sitter import Language, Parser
from typing import List, Dict, Any
import re

class CodeParser:
    def __init__(self):
        PY_LANGUAGE = Language(tspython.language(), "python")
        self.parser = Parser()
        self.parser.set_language(PY_LANGUAGE)
    
    def parse_python_file(self, content: str, filepath: str) -> Dict[str, Any]:
        """Parsuje Python soubor a extrahuje strukturované informace."""
        try:
            tree = ast.parse(content)
            
            functions = self._extract_functions(tree, content)
            classes = self._extract_classes(tree, content)
            imports = self._extract_imports(tree)
            docstrings = self._extract_docstrings(content)
            
            return {
                "filepath": filepath,
                "functions": functions,
                "classes": classes,
                "imports": imports,
                "docstrings": docstrings,
                "complexity": self._calculate_complexity(tree)
            }
        except SyntaxError as e:
            return {"error": f"Syntax error: {str(e)}", "filepath": filepath}
    
    def _extract_functions(self, tree: ast.AST, content: str) -> List[Dict[str, Any]]:
        """Extrahuje funkce s jejich dokumentací a parametry."""
        functions = []
        lines = content.split('\n')
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                func_info = {
                    "name": node.name,
                    "line_number": node.lineno,
                    "docstring": ast.get_docstring(node),
                    "arguments": [arg.arg for arg in node.args.args],
                    "decorators": [dec.id if isinstance(dec, ast.Name) else str(dec) for dec in node.decorator_list],
                    "is_async": isinstance(node, ast.AsyncFunctionDef),
                    "return_annotation": self._get_annotation(node.returns) if node.returns else None
                }
                
                # Extrakce zdrojového kódu funkce
                if node.lineno <= len(lines):
                    func_lines = []
                    for i in range(node.lineno - 1, min(len(lines), node.end_lineno or len(lines))):
                        func_lines.append(lines[i])
                    func_info["source_code"] = '\n'.join(func_lines)
                
                functions.append(func_info)
        
        return functions
    
    def _extract_classes(self, tree: ast.AST, content: str) -> List[Dict[str, Any]]:
        """Extrahuje třídy s jejich metodami a atributy."""
        classes = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                class_methods = []
                class_attributes = []
                
                for item in node.body:
                    if isinstance(item, ast.FunctionDef):
                        class_methods.append({
                            "name": item.name,
                            "docstring": ast.get_docstring(item),
                            "arguments": [arg.arg for arg in item.args.args],
                            "is_property": any(isinstance(dec, ast.Name) and dec.id == "property" for dec in item.decorator_list)
                        })
                    elif isinstance(item, ast.Assign):
                        for target in item.targets:
                            if isinstance(target, ast.Name):
                                class_attributes.append(target.id)
                
                classes.append({
                    "name": node.name,
                    "line_number": node.lineno,
                    "docstring": ast.get_docstring(node),
                    "base_classes": [base.id if isinstance(base, ast.Name) else str(base) for base in node.bases],
                    "methods": class_methods,
                    "attributes": class_attributes,
                    "decorators": [dec.id if isinstance(dec, ast.Name) else str(dec) for dec in node.decorator_list]
                })
        
        return classes
    
    def _extract_imports(self, tree: ast.AST) -> List[str]:
        """Extrahuje všechny importy."""
        imports = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.append(alias.name)
            elif isinstance(node, ast.ImportFrom):
                module = node.module or ""
                for alias in node.names:
                    imports.append(f"{module}.{alias.name}" if module else alias.name)
        
        return imports
    
    def _extract_docstrings(self, content: str) -> List[Dict[str, Any]]:
        """Extrahuje všechny docstringy z kódu."""
        docstrings = []
        pattern = r'"""(.*?)"""'
        
        for match in re.finditer(pattern, content, re.DOTALL):
            docstring = match.group(1).strip()
            if docstring:
                docstrings.append({
                    "content": docstring,
                    "start_pos": match.start(),
                    "end_pos": match.end()
                })
        
        return docstrings
    
    def _calculate_complexity(self, tree: ast.AST) -> int:
        """Vypočítá cyklomatickou složitost."""
        complexity = 1
        
        for node in ast.walk(tree):
            if isinstance(node, (ast.If, ast.While, ast.For, ast.AsyncFor)):
                complexity += 1
            elif isinstance(node, ast.ExceptHandler):
                complexity += 1
            elif isinstance(node, (ast.And, ast.Or)):
                complexity += 1
        
        return complexity
    
    def _get_annotation(self, annotation) -> str:
        """Získá string reprezentaci type annotation."""
        if isinstance(annotation, ast.Name):
            return annotation.id
        elif isinstance(annotation, ast.Constant):
            return str(annotation.value)
        else:
            return str(annotation)
````

````python
import os
import requests
from github import Github
from typing import List, Dict, Any, Optional
import base64
from datetime import datetime

class GitHubClient:
    def __init__(self, access_token: Optional[str] = None):
        self.access_token = access_token or os.getenv('GITHUB_TOKEN')
        self.github = Github(self.access_token) if self.access_token else None
        self.session = requests.Session()
        if self.access_token:
            self.session.headers.update({'Authorization': f'token {self.access_token}'})
    
    def get_repository_files(self, repo_name: str, file_extensions: List[str] = None) -> List[Dict[str, Any]]:
        """Získá všechny soubory z repozitáře."""
        if file_extensions is None:
            file_extensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.h', '.md', '.rst']
        
        try:
            repo = self.github.get_repo(repo_name)
            files = []
            
            def process_contents(contents, path=""):
                for content in contents:
                    if content.type == "dir":
                        # Rekurzivně zpracuj složky
                        try:
                            sub_contents = repo.get_contents(content.path)
                            process_contents(sub_contents, content.path)
                        except Exception as e:
                            print(f"Chyba při zpracování složky {content.path}: {e}")
                    else:
                        # Zpracuj soubor
                        file_ext = os.path.splitext(content.name)[1]
                        if file_ext in file_extensions:
                            try:
                                file_data = {
                                    "name": content.name,
                                    "path": content.path,
                                    "size": content.size,
                                    "sha": content.sha,
                                    "download_url": content.download_url,
                                    "last_modified": content.last_modified,
                                    "extension": file_ext
                                }
                                files.append(file_data)
                            except Exception as e:
                                print(f"Chyba při zpracování souboru {content.path}: {e}")
            
            contents = repo.get_contents("")
            process_contents(contents)
            
            return files
            
        except Exception as e:
            raise Exception(f"Chyba při získávání souborů z repozitáře {repo_name}: {e}")
    
    def get_file_content(self, repo_name: str, file_path: str) -> str:
        """Získá obsah konkrétního souboru."""
        try:
            repo = self.github.get_repo(repo_name)
            file_content = repo.get_contents(file_path)
            
            if file_content.encoding == 'base64':
                content = base64.b64decode(file_content.content).decode('utf-8')
            else:
                content = file_content.content
            
            return content
            
        except Exception as e:
            raise Exception(f"Chyba při získávání obsahu souboru {file_path}: {e}")
    
    def get_repository_info(self, repo_name: str) -> Dict[str, Any]:
        """Získá základní informace o repozitáři."""
        try:
            repo = self.github.get_repo(repo_name)
            
            return {
                "name": repo.name,
                "full_name": repo.full_name,
                "description": repo.description,
                "language": repo.language,
                "languages": repo.get_languages(),
                "size": repo.size,
                "stars": repo.stargazers_count,
                "forks": repo.forks_count,
                "created_at": repo.created_at,
                "updated_at": repo.updated_at,
                "topics": repo.get_topics(),
                "readme": self._get_readme(repo)
            }
            
        except Exception as e:
            raise Exception(f"Chyba při získávání informací o repozitáři {repo_name}: {e}")
    
    def _get_readme(self, repo) -> Optional[str]:
        """Získá README soubor repozitáře."""
        try:
            readme = repo.get_readme()
            content = base64.b64decode(readme.content).decode('utf-8')
            return content
        except:
            return None
    
    def search_repositories(self, query: str, language: str = None, limit: int = 10) -> List[Dict[str, Any]]:
        """Vyhledá repozitáře podle dotazu."""
        try:
            search_query = query
            if language:
                search_query += f" language:{language}"
            
            repositories = self.github.search_repositories(search_query)
            
            results = []
            for i, repo in enumerate(repositories):
                if i >= limit:
                    break
                
                results.append({
                    "name": repo.name,
                    "full_name": repo.full_name,
                    "description": repo.description,
                    "language": repo.language,
                    "stars": repo.stargazers_count,
                    "url": repo.html_url
                })
            
            return results
            
        except Exception as e:
            raise Exception(f"Chyba při vyhledávání repozitářů: {e}")
````

````python
import chromadb
from chromadb.config import Settings
from openai import OpenAI
from typing import List, Dict, Any, Optional
import numpy as np
from langchain.text_splitter import RecursiveCharacterTextSplitter
import hashlib
import json

class EmbeddingService:
    def __init__(self, openai_api_key: str, chroma_persist_directory: str = "./chroma_db"):
        self.openai_client = OpenAI(api_key=openai_api_key)
        self.chroma_client = chromadb.PersistentClient(path=chroma_persist_directory)
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            length_function=len,
            separators=["\n\n", "\n", " ", ""]
        )
        
    def create_collection(self, collection_name: str) -> chromadb.Collection:
        """Vytvoří nebo získá kolekci v ChromaDB."""
        try:
            collection = self.chroma_client.get_collection(collection_name)
            print(f"Kolekce '{collection_name}' již existuje.")
        except:
            collection = self.chroma_client.create_collection(
                name=collection_name,
                metadata={"hnsw:space": "cosine"}
            )
            print(f"Vytvořena nová kolekce '{collection_name}'.")
        
        return collection
    
    def generate_embeddings(self, texts: List[str], model: str = "text-embedding-3-small") -> List[List[float]]:
        """Generuje embeddingy pro seznam textů."""
        try:
            response = self.openai_client.embeddings.create(
                input=texts,
                model=model
            )
            
            embeddings = [item.embedding for item in response.data]
            return embeddings
            
        except Exception as e:
            raise Exception(f"Chyba při generování embeddingů: {e}")
    
    def process_code_file(self, file_content: str, file_metadata: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Zpracuje kódový soubor na chunky s metadaty."""
        chunks = self.text_splitter.split_text(file_content)
        
        processed_chunks = []
        for i, chunk in enumerate(chunks):
            chunk_metadata = {
                **file_metadata,
                "chunk_index": i,
                "chunk_size": len(chunk),
                "chunk_id": self._generate_chunk_id(file_metadata["filepath"], i)
            }
            
            processed_chunks.append({
                "content": chunk,
                "metadata": chunk_metadata
            })
        
        return processed_chunks
    
    def add_documents_to_collection(self, collection: chromadb.Collection, documents: List[Dict[str, Any]]):
        """Přidá dokumenty do ChromaDB kolekce."""
        if not documents:
            return
        
        # Připrav data pro batch insert
        texts = [doc["content"] for doc in documents]
        metadatas = [doc["metadata"] for doc in documents]
        ids = [doc["metadata"]["chunk_id"] for doc in documents]
        
        # Generuj embeddingy
        embeddings = self.generate_embeddings(texts)
        
        # Přidej do kolekce
        collection.add(
            embeddings=embeddings,
            documents=texts,
            metadatas=metadatas,
            ids=ids
        )
        
        print(f"Přidáno {len(documents)} dokumentů do kolekce.")
    
    def search_similar_documents(self, collection: chromadb.Collection, query: str, 
                                n_results: int = 5, filter_metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """Vyhledá podobné dokumenty podle dotazu."""
        try:
            # Generuj embedding pro dotaz
            query_embedding = self.generate_embeddings([query])[0]
            
            # Vyhledej v kolekci
            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results,
                where=filter_metadata,
                include=["documents", "metadatas", "distances"]
            )
            
            return {
                "documents": results["documents"][0],
                "metadatas": results["metadatas"][0],
                "distances": results["distances"][0],
                "query": query
            }
            
        except Exception as e:
            raise Exception(f"Chyba při vyhledávání podobných dokumentů: {e}")
    
    def _generate_chunk_id(self, filepath: str, chunk_index: int) -> str:
        """Generuje unikátní ID pro chunk."""
        content = f"{filepath}_{chunk_index}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def get_collection_stats(self, collection: chromadb.Collection) -> Dict[str, Any]:
        """Získá statistiky kolekce."""
        try:
            count = collection.count()
            
            # Získej ukázku metadat
            sample = collection.peek(limit=10)
            
            file_types = {}
            languages = {}
            
            for metadata in sample["metadatas"]:
                ext = metadata.get("extension", "unknown")
                lang = metadata.get("language", "unknown")
                
                file_types[ext] = file_types.get(ext, 0) + 1
                languages[lang] = languages.get(lang, 0) + 1
            
            return {
                "total_documents": count,
                "file_types": file_types,
                "languages": languages,
                "sample_metadata": sample["metadatas"][:3] if sample["metadatas"] else []
            }
            
        except Exception as e:
            return {"error": str(e)}
````

````python
from typing import List, Dict, Any, Optional
from openai import OpenAI
import time
from datetime import datetime

class RAGEngine:
    def __init__(self, openai_api_key: str, embedding_service, model: str = "gpt-4"):
        self.openai_client = OpenAI(api_key=openai_api_key)
        self.embedding_service = embedding_service
        self.model = model
        self.conversation_history = []
    
    def generate_answer(self, query: str, context_documents: List[Dict[str, Any]], 
                       repository_info: Dict[str, Any] = None, max_tokens: int = 1500) -> Dict[str, Any]:
        """Generuje odpověď na základě kontextových dokumentů."""
        start_time = time.time()
        
        try:
            # Sestaví kontext z relevantních dokumentů
            context = self._build_context(context_documents, repository_info)
            
            # Vytvoří prompt pro GPT-4
            system_prompt = self._create_system_prompt()
            user_prompt = self._create_user_prompt(query, context)
            
            # Volá OpenAI API
            response = self.openai_client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=max_tokens,
                temperature=0.1,
                top_p=0.9
            )
            
            answer = response.choices[0].message.content
            execution_time = time.time() - start_time
            
            # Spočítá confidence score
            confidence_score = self._calculate_confidence_score(context_documents)
            
            # Připraví seznam zdrojů
            sources = self._prepare_sources(context_documents)
            
            result = {
                "answer": answer,
                "confidence_score": confidence_score,
                "sources": sources,
                "execution_time": execution_time,
                "model_used": self.model,
                "tokens_used": response.usage.total_tokens if response.usage else 0
            }
            
            # Uloží do historie konverzace
            self._add_to_history(query, answer, context_documents)
            
            return result
            
        except Exception as e:
            return {
                "error": f"Chyba při generování odpovědi: {str(e)}",
                "execution_time": time.time() - start_time
            }
    
    def _build_context(self, documents: List[Dict[str, Any]], repository_info: Dict[str, Any] = None) -> str:
        """Sestaví kontext z relevantních dokumentů."""
        context_parts = []
        
        # Přidá informace o repozitáři
        if repository_info:
            context_parts.append(f"REPOZITÁŘ: {repository_info.get('name', 'N/A')}")
            context_parts.append(f"POPIS: {repository_info.get('description', 'N/A')}")
            context_parts.append(f"JAZYK: {repository_info.get('language', 'N/A')}")
            context_parts.append("---")
        
        # Přidá relevantní dokumenty
        for i, doc in enumerate(documents[:5]):  # Omezí na 5 nejrelevantnějších
            metadata = doc.get("metadata", {})
            content = doc.get("content", "")
            
            context_parts.append(f"SOUBOR {i+1}: {metadata.get('filepath', 'unknown')}")
            if metadata.get('language'):
                context_parts.append(f"JAZYK: {metadata.get('language')}")
            
            # Přidá informace o funkcích a třídách, pokud jsou dostupné
            if metadata.get('functions'):
                func_names = [f['name'] for f in metadata['functions'][:3]]
                context_parts.append(f"FUNKCE: {', '.join(func_names)}")
            
            if metadata.get('classes'):
                class_names = [c['name'] for c in metadata['classes'][:3]]
                context_parts.append(f"TŘÍDY: {', '.join(class_names)}")
            
            context_parts.append(f"OBSAH:\n{content}")
            context_parts.append("---")
        
        return "\n".join(context_parts)
    
    def _create_system_prompt(self) -> str:
        """Vytvoří systémový prompt pro AI asistenta."""
        return """Jsi zkušený software engineer a AI asistent specializující se na analýzu kódu a odpovídání na technické otázky.

TVOJE ROLE:
- Analyzuješ kódové báze a poskytl přesné technické odpovědi
- Vysvětluješ komplexní koncepty jasně a srozumitelně
- Identifikuješ problémy v kódu a navrhuješ řešení
- Poskytl kontextové informace o architektuře a design patterns

PRAVIDLA:
- Vždy odpovidáš v češtině
- Buď konkrétní a přesný
- Uveď reference na konkrétní soubory a řádky kódu, pokud jsou relevantní
- Pokud nejsi si jistý, řekni to explicitně
- Při navrhování změn vysvětli důvody
- Používej technické termíny přesně

FORMÁT ODPOVĚDI:
- Začni přímou odpovědí na otázku
- Přidej relevantní technické detaily
- Ukaž konkrétní příklady z poskytnutého kódu
- Navrhni další kroky nebo doporučení, pokud je to relevantní"""

    def _create_user_prompt(self, query: str, context: str) -> str:
        """Vytvoří uživatelský prompt s otázkou a kontextem."""
        return f"""OTÁZKA: {query}

KONTEXT Z KÓDOVÉ BÁZE:
{context}

Odpověz na otázku na základě poskytnutého kontextu z kódové báze. Buď konkrétní a odkázej na relevantní části kódu."""

    def _calculate_confidence_score(self, documents: List[Dict[str, Any]]) -> float:
        """Vypočítá confidence score na základě relevance dokumentů."""
        if not documents:
            return 0.0
        
        # Použije vzdálenosti z similarity search
        distances = [doc.get("distance", 1.0) for doc in documents]
        
        # Konvertuje vzdálenosti na confidence (1 - průměrná vzdálenost)
        avg_distance = sum(distances) / len(distances)
        confidence = max(0.0, min(1.0, 1.0 - avg_distance))
        
        return round(confidence, 3)
    
    def _prepare_sources(self, documents: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Připraví seznam zdrojů pro odpověď."""
        sources = []
        
        for doc in documents[:3]:  # Pouze top 3 zdroje
            metadata = doc.get("metadata", {})
            sources.append({
                "file": metadata.get("filepath", "unknown"),
                "language": metadata.get("language", "unknown"),
                "chunk_index": metadata.get("chunk_index", 0),
                "relevance_score": round(1.0 - doc.get("distance", 1.0), 3)
            })
        
        return sources
    
    def _add_to_history(self, query: str, answer: str, context_documents: List[Dict[str, Any]]):
        """Přidá konverzaci do historie."""
        self.conversation_history.append({
            "timestamp": datetime.now().isoformat(),
            "query": query,
            "answer": answer,
            "num_context_docs": len(context_documents),
            "context_files": [doc.get("metadata", {}).get("filepath", "unknown") 
                            for doc in context_documents[:3]]
        })
        
        # Udržuje pouze posledních 10 konverzací
        if len(self.conversation_history) > 10:
            self.conversation_history = self.conversation_history[-10:]
    
    def get_conversation_history(self) -> List[Dict[str, Any]]:
        """Vrátí historii konverzace."""
        return self.conversation_history
    
    def clear_history(self):
        """Vymaže historii konverzace."""
        self.conversation_history = []
````

````python
import os
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from typing import Optional

from models import QueryRequest, QueryResponse
from github_client import GitHubClient
from code_parser import CodeParser
from embedding_service import EmbeddingService
from rag_engine import RAGEngine

# Načte environment variables
load_dotenv()

app = FastAPI(
    title="Codebase Q&A Bot",
    description="AI bot pro odpovídání na technické otázky z kódových bází",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Globální instance služeb
github_client = None
embedding_service = None
rag_engine = None
code_parser = None

@app.on_event("startup")
async def startup_event():
    """Inicializuje služby při startu aplikace."""
    global github_client, embedding_service, rag_engine, code_parser
    
    # Kontrola environment variables
    openai_api_key = os.getenv("OPENAI_API_KEY")
    github_token = os.getenv("GITHUB_TOKEN")
    
    if not openai_api_key:
        raise ValueError("OPENAI_API_KEY environment variable je vyžadována")
    
    # Inicializace služeb
    github_client = GitHubClient(github_token)
    embedding_service = EmbeddingService(openai_api_key)
    rag_engine = RAGEngine(openai_api_key, embedding_service)
    code_parser = CodeParser()
    
    print("Služby úspěšně inicializovány!")

@app.post("/index_repository", response_model=dict)
async def index_repository(repo_name: str, collection_name: Optional[str] = None):
    """Indexuje repozitář do embedding databáze."""
    try:
        if collection_name is None:
            collection_name = repo_name.replace("/", "_").replace("-", "_")
        
        print(f"Začínám indexování repozitáře: {repo_name}")
        
        # Získá informace o repozitáři
        repo_info = github_client.get_repository_info(repo_name)
        
        # Získá seznam souborů
        files = github_client.get_repository_files(repo_name)
        print(f"Nalezeno {len(files)} souborů")
        
        # Vytvoří kolekci
        collection = embedding_service.create_collection(collection_name)
        
        # Zpracuje soubory
        processed_documents = []
        
        for file_info in files[:50]:  # Omezí na 50 souborů pro demo
            try:
                print(f"Zpracovávám: {file_info['path']}")
                
                # Získá obsah souboru
                content = github_client.get_file_content(repo_name, file_info["path"])
                
                # Parsuje kód
                parsed_info = code_parser.parse_python_file(content, file_info["path"])
                
                # Připraví metadata
                metadata = {
                    **file_info,
                    **parsed_info,
                    "repository": repo_name,
                    "language": repo_info.get("language", "unknown")
                }
                
                # Zpracuje na chunky
                chunks = embedding_service.process_code_file(content, metadata)
                processed_documents.extend(chunks)
                
            except Exception as e:
                print(f"Chyba při zpracování {file_info['path']}: {e}")
                continue
        
        # Přidá dokumenty do kolekce
        if processed_documents:
            embedding_service.add_documents_to_collection(collection, processed_documents)
        
        # Získá statistiky
        stats = embedding_service.get_collection_stats(collection)
        
        return {
            "status": "success",
            "repository": repo_name,
            "collection": collection_name,
            "files_processed": len(files),
            "documents_created": len(processed_documents),
            "statistics": stats
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba při indexování: {str(e)}")

@app.post("/query", response_model=QueryResponse)
async def query_codebase(request: QueryRequest):
    """Odpovídá na otázky o kódové bázi."""
    try:
        collection_name = request.repository.replace("/", "_").replace("-", "_")
        
        # Získá kolekci
        collection = embedding_service.create_collection(collection_name)
        
        # Vyhledá relevantní dokumenty
        search_results = embedding_service.search_similar_documents(
            collection=collection,
            query=request.question,
            n_results=request.max_results
        )
        
        # Připraví dokumenty pro RAG
        context_documents = []
        for i, (doc, metadata, distance) in enumerate(zip(
            search_results["documents"],
            search_results["metadatas"], 
            search_results["distances"]
        )):
            context_documents.append({
                "content": doc,
                "metadata": metadata,
                "distance": distance
            })
        
        # Získá informace o repozitáři
        try:
            repo_info = github_client.get_repository_info(request.repository)
        except:
            repo_info = {"name": request.repository}
        
        # Generuje odpověď
        result = rag_engine.generate_answer(
            query=request.question,
            context_documents=context_documents,
            repository_info=repo_info
        )
        
        if "error" in result:
            raise HTTPException(status_code=500, detail=result["error"])
        
        # Připraví response
        relevant_files = list(set([
            doc["metadata"].get("filepath", "unknown") 
            for doc in context_documents
        ]))
        
        return QueryResponse(
            answer=result["answer"],
            relevant_files=relevant_files,
            confidence_score=result["confidence_score"],
            sources=result["sources"],
            execution_time=result["execution_time"]
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chyba při zpracování dotazu: {str(e)}")

@app.get("/repositories/{repo_name}/info")
async def get_repository_info(repo_name: str):
    """Získá informace o repozitáři."""
    try:
        repo_info = github_client.get_repository_info(repo_name)
        return repo_info
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Repozitář nenalezen: {str(e)}")

@app.get("/collections/{collection_name}/stats")
async def get_collection_stats(collection_name: str):
    """Získá statistiky kolekce."""
    try:
        collection = embedding_service.create_collection(collection_name)
        stats = embedding_service.get_collection_stats(collection)
        return stats
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Kolekce nenalezena: {str(e)}")

@app.get("/conversation/history")
async def get_conversation_history():
    """Získá historii konverzace."""
    return {
        "history": rag_engine.get_conversation_history(),
        "total_conversations": len(rag_engine.conversation_history)
    }

@app.delete("/conversation/history")
async def clear_conversation_history():
    """Vymaže historii konverzace."""
    rag_engine.clear_history()
    return {"status": "Historie konverzace byla vymazána"}

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "services": {
            "github_client": github_client is not None,
            "embedding_service": embedding_service is not None,
            "rag_engine": rag_engine is not None,
            "code_parser": code_parser is not None
        }
    }

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
````

````python
import asyncio
import requests
import json
from dotenv import load_dotenv
import os

# Načte environment variables
load_dotenv()

class CodebaseQAClient:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
    
    def index_repository(self, repo_name: str, collection_name: str = None):
        """Indexuje repozitář."""
        url = f"{self.base_url}/index_repository"
        params = {"repo_name": repo_name}
        if collection_name:
            params["collection_name"] = collection_name
        
        response = requests.post(url, params=params)
        return response.json()
    
    def query_codebase(self, question: str, repository: str, max_results: int = 5):
        """Položí otázku o kódové bázi."""
        url = f"{self.base_url}/query"
        data = {
            "question": question,
            "repository": repository,
            "max_results": max_results,
            "include_code": True
        }
        
        response = requests.post(url, json=data)
        return response.json()
    
    def get_repository_info(self, repo_name: str):
        """Získá informace o repozitáři."""
        url = f"{self.base_url}/repositories/{repo_name}/info"
        response = requests.get(url)
        return response.json()

def demo_usage():
    """Demonstruje použití Codebase Q&A Bot."""
    client = CodebaseQAClient()
    
    # Příklad repozitáře pro testování (můžete změnit)
    repo_name = "microsoft/vscode"  # Veřejný repozitář
    
    print("=== CODEBASE Q&A BOT DEMO ===\n")
    
    # 1. Získání informací o repozitáři
    print("1. Získávám informace o repozitáři...")
    try:
        repo_info = client.get_repository_info(repo_name)
        print(f"Repozitář: {repo_info['name']}")
        print(f"Popis: {repo_info['description']}")
        print(f"Jazyk: {repo_info['language']}")
        print(f"Hvězdy: {repo_info['stars']}")
        print()
    except Exception as e:
        print(f"Chyba: {e}\n")
        return
    
    # 2. Indexování repozitáře
    print("2. Indexuji repozitář (toto může trvat několik minut)...")
    try:
        index_result = client.index_repository(repo_name)
        print(f"Status: {index_result['status']}")
        print(f"Zpracováno souborů: {index_result['files_processed']}")
        print(f"Vytvořeno dokumentů: {index_result['documents_created']}")
        print()
    except Exception as e:
        print(f"Chyba při indexování: {e}\n")
        return
    
    # 3. Pokládání otázek
    questions = [
        "Jak funguje systém extensionů v tomto projektu?",
        "Jaké jsou hlavní třídy a jejich účel?",
        "Jak se implementuje syntax highlighting?",
        "Kde se nachází konfigurace TypeScript kompilátoru?",
        "Jaké design patterns se používají v kódu?"
    ]
    
    print("3. Pokládám otázky o kódové bázi...\n")
    
    for i, question in enumerate(questions, 1):
        print(f"OTÁZKA {i}: {question}")
        print("-" * 60)
        
        try:
            response = client.query_codebase(question, repo_name)
            
            print(f"ODPOVĚĎ:")
            print(response['answer'])
            print(f"\nConfidence Score: {response['confidence_score']}")
            print(f"Čas zpracování: {response['execution_time']:.2f}s")
            print(f"Relevantní soubory: {', '.join(response['relevant_files'][:3])}")
            
            if response['sources']:
                print("\nZDROJE:")
                for source in response['sources'][:2]:
                    print(f"  - {source['file']} (relevance: {source['relevance_score']})")
            
        except Exception as e:
            print(f"Chyba při dotazu: {e}")
        
        print("\n" + "="*80 + "\n")

def create_sample_data():
    """Vytvoří ukázková data pro testování."""
    sample_files = {
        "main.py": '''
"""
Hlavní modul aplikace pro zpracování dat.
"""
import logging
from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class User:
    """Reprezentuje uživatele systému."""
    id: int
    name: str
    email: str
    is_active: bool = True
    
    def validate_email(self) -> bool:
        """Validuje email adresu."""
        return "@" in self.email

class DataProcessor:
    """Zpracovává a transformuje data."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def process_users(self, users: List[User]) -> List[Dict[str, Any]]:
        """Zpracuje seznam uživatelů."""
        result = []
        for user in users:
            if user.is_active and user.validate_email():
                result.append({
                    "id": user.id,
                    "name": user.name,
                    "email": user.email
                })
        return result
    
    def generate_report(self, data: List[Dict[str, Any]]) -> str:
        """Generuje report z dat."""
        return f"Zpracováno {len(data)} záznamů"

def main():
    """Hlavní funkce aplikace."""
    config = {"debug": True, "max_users": 1000}
    processor = DataProcessor(config)
    
    users = [
        User(1, "Jan Novák", "jan@example.com"),
        User(2, "Marie Svoboda", "marie@example.com", False),
        User(3, "Petr Dvořák", "invalid-email")
    ]
    
    processed = processor.process_users(users)
    report = processor.generate_report(processed)
    print(report)

if __name__ == "__main__":
    main()
''',
        
        "utils.py": '''
"""
Pomocné utility funkce.
"""
import json
import datetime
from typing import Union, Optional

def load_config(file_path: str) -> dict:
    """Načte konfiguraci z JSON souboru."""
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def format_timestamp(timestamp: Optional[datetime.datetime] = None) -> str:
    """Formátuje timestamp do čitelného formátu."""
    if timestamp is None:
        timestamp = datetime.datetime.now()
    return timestamp.strftime("%Y-%m-%d %H:%M:%S")

class Logger:
    """Jednoduchý logger pro aplikaci."""
    
    def __init__(self, name: str, level: str = "INFO"):
        self.name = name
        self.level = level
    
    def log(self, message: str, level: str = "INFO"):
        """Loguje zprávu."""
        timestamp = format_timestamp()
        print(f"[{timestamp}] {level} - {self.name}: {message}")
    
    def info(self, message: str):
        """Info log."""
        self.log(message, "INFO")
    
    def error(self, message: str):
        """Error log."""
        self.log(message, "ERROR")
'''
    }
    
    # Uloží ukázková data
    os.makedirs("sample_data", exist_ok=True)
    for filename, content in sample_files.items():
        with open(f"sample_data/{filename}", "w", encoding="utf-8") as f:
            f.write(content)
    
    print("Vytvořena ukázková data v složce 'sample_data/'")

if __name__ == "__main__":
    # Vytvoří ukázková data
    create_sample_data()
    
    # Spustí demo (vyžaduje běžící server)
    try:
        demo_usage()
    except requests.exceptions.ConnectionError:
        print("Server není spuštěn. Spusťte nejprve 'python src/main.py'")
````

````python
# OpenAI API klíč (povinný)
OPENAI_API_KEY=your_openai_api_key_here

# GitHub token (volitelný, ale doporučený pro větší rate limity)
GITHUB_TOKEN=your_github_token_here

# ChromaDB persistence directory
CHROMA_PERSIST_DIRECTORY=./chroma_db

# FastAPI konfigurace
HOST=0.0.0.0
PORT=8000
DEBUG=True
````

## Shrnutí Projektu

Codebase Q&A Bot představuje pokročilé řešení pro automatizovanou analýzu a dotazování kódových bází pomocí RAG architektury. Projekt kombinuje sílu moderních AI modelů s efektivním vektorovým vyhledáváním pro poskytování kontextově relevantních odpovědí na technické otázky.

### Klíčové Výhody

**Technická Excelence**: Využití nejmodernějších technologií včetně OpenAI GPT-4o, ChromaDB embeddings a pokročilého parsování kódu pro maximální přesnost odpovědí.

**Škálovatelnost**: Modulární architektura umožňuje snadné rozšíření na velké kódové báze s tisíci souborů při zachování rychlé odezvy.

**Praktičnost**: RESTful API interface a možnost integrace do VSCode poskytuje seamless developer experience.

**Inteligence**: RAG architektura zajišťuje, že odpovědi jsou založené na aktuálním kódu, nikoli na zastaralých trénovacích datech.

### Budoucí Rozšíření

Projekt má potenciál pro rozšíření o real-time synchronizaci s Git repository, podporu dalších programovacích jazyků, integraci s CI/CD pipelines a pokročilé analytické funkce pro code quality assessment.

Tento AI-powered nástroj transformuje způsob, jakým vývojáři interagují s komplexními kódovými bázemi, a představuje významný krok směrem k inteligentnímu software development ecosystem.