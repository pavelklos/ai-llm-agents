<small>Claude Sonnet 4 **(Social Media Content Strategy Assistant)**</small>
# Social Media Content Strategy Assistant

## KlÃ­ÄovÃ© koncepty

### RAG (Retrieval-Augmented Generation)
Technika kombinujÃ­cÃ­ vyhledÃ¡vÃ¡nÃ­ relevantnÃ­ch informacÃ­ z databÃ¡ze znalostÃ­ s generativnÃ­mi AI modely pro vytvÃ¡Å™enÃ­ kontextuÃ¡lnÄ› pÅ™esnÃ½ch odpovÄ›dÃ­.

### Trending Topics
AktuÃ¡lnÃ­ tÃ©mata a trendy na sociÃ¡lnÃ­ch sÃ­tÃ­ch, kterÃ¡ zÃ­skÃ¡vajÃ­ vÃ½znamnou pozornost a engagement uÅ¾ivatelÅ¯.

### Engagement Analytics
Metriky mÄ›Å™Ã­cÃ­ interakci uÅ¾ivatelÅ¯ s obsahem (lajky, komentÃ¡Å™e, sdÃ­lenÃ­, dosah, CTR).

### Content Templates
PÅ™edpÅ™ipravenÃ© Å¡ablony pro rÅ¯znÃ© typy obsahu na sociÃ¡lnÃ­ch sÃ­tÃ­ch s optimalizovanou strukturou.

### Hashtag Research
AnalÃ½za a vÃ½bÄ›r relevantnÃ­ch hashtagÅ¯ pro maximalizaci dosahu a engagement.

### Instagram API
ProgramovÃ© rozhranÃ­ pro pÅ™Ã­stup k datÅ¯m a funkcionalitÃ¡m Instagram platformy.

### Influencer Data
DatabÃ¡ze informacÃ­ o influencerech vÄetnÄ› jejich audience, engagement rate a specializace.

### Brand Guidelines
Soubor pravidel a standardÅ¯ pro konzistentnÃ­ prezentaci znaÄky napÅ™Ã­Ä vÅ¡emi komunikaÄnÃ­mi kanÃ¡ly.

## KomplexnÃ­ vysvÄ›tlenÃ­ projektu

**Social Media Content Strategy Assistant** je pokroÄilÃ½ AI-powered systÃ©m navrÅ¾enÃ½ pro automatizaci a optimalizaci strategie obsahu na sociÃ¡lnÃ­ch sÃ­tÃ­ch. Projekt vyuÅ¾Ã­vÃ¡ RAG architekturu pro inteligentnÃ­ generovÃ¡nÃ­ obsahu zaloÅ¾enÃ©ho na aktuÃ¡lnÃ­ch trendech, historickÃ½ch datech o engagement a brand guidelines.

### HlavnÃ­ cÃ­le projektu:

1. **Automatizace content strategie** - GenerovÃ¡nÃ­ nÃ¡vrhÅ¯ obsahu na zÃ¡kladÄ› trendÅ¯ a cÃ­lovÃ© audience
2. **Optimalizace engagement** - AnalÃ½za historickÃ½ch dat pro pÅ™edpovÄ›Ä ÃºspÄ›Å¡nosti obsahu
3. **Trend monitoring** - SledovÃ¡nÃ­ aktuÃ¡lnÃ­ch tÃ©mat a jejich implementace do strategie
4. **Brand consistency** - ZajiÅ¡tÄ›nÃ­ souladu obsahu s identitou znaÄky
5. **Performance tracking** - MonitorovÃ¡nÃ­ a analÃ½za vÃ½konnosti publikovanÃ©ho obsahu

### VÃ½zvy projektu:

- **Real-time data processing** - ZpracovÃ¡nÃ­ velkÃ©ho mnoÅ¾stvÃ­ dat z rÅ¯znÃ½ch sociÃ¡lnÃ­ch sÃ­tÃ­
- **Context understanding** - PorozumÄ›nÃ­ nuancÃ­m rÅ¯znÃ½ch platforem a jejich audience
- **Trend prediction** - Identifikace vznikajÄ…cych trendÅ¯ pÅ™ed jejich masovÃ½m rozÅ¡Ã­Å™enÃ­m
- **Multi-platform optimization** - Adaptace obsahu pro rÅ¯znÃ© sociÃ¡lnÃ­ sÃ­tÄ›
- **Compliance management** - DodrÅ¾ovÃ¡nÃ­ pravidel platforem a prÃ¡vnÃ­ch pÅ™edpisÅ¯

### PotenciÃ¡lnÃ­ dopad:

SystÃ©m mÅ¯Å¾e vÃ½raznÄ› zvÃ½Å¡it efektivitu social media marketingu, snÃ­Å¾it nÃ¡klady na tvorbu obsahu a zlepÅ¡it ROI marketingovÃ½ch kampanÃ­ prostÅ™ednictvÃ­m data-driven pÅ™Ã­stupu.

## KomplexnÃ­ implementace v Pythonu

````python
import os
import json
import asyncio
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from pydantic import BaseModel
import requests
import sqlite3

# LangChain imports
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.chains import RetrievalQA

# Additional libraries
import tweepy
import instaloader
from textblob import TextBlob
import matplotlib.pyplot as plt
import seaborn as sns
from wordcloud import WordCloud

@dataclass
class SocialMediaPost:
    """Struktura pro reprezentaci social media pÅ™Ã­spÄ›vku"""
    platform: str
    content: str
    hashtags: List[str]
    engagement_metrics: Dict[str, int]
    timestamp: datetime
    author: str
    sentiment: float

@dataclass
class ContentTemplate:
    """Å ablona pro tvorbu obsahu"""
    template_id: str
    name: str
    structure: str
    platform: str
    category: str
    target_engagement: float

@dataclass
class BrandGuideline:
    """Brand guidelines pro konzistentnÃ­ komunikaci"""
    brand_name: str
    tone_of_voice: str
    key_messages: List[str]
    prohibited_topics: List[str]
    color_scheme: Dict[str, str]
    target_audience: str

class TrendAnalyzer:
    """AnalyzÃ¡tor trendÅ¯ na sociÃ¡lnÃ­ch sÃ­tÃ­ch"""
    
    def __init__(self):
        self.trends_data = []
        self._initialize_sample_data()
    
    def _initialize_sample_data(self):
        """Inicializace vzorovÃ½ch dat o trendech"""
        sample_trends = [
            {"keyword": "AI", "volume": 50000, "growth": 25.5, "platforms": ["twitter", "linkedin"]},
            {"keyword": "sustainability", "volume": 35000, "growth": 15.2, "platforms": ["instagram", "twitter"]},
            {"keyword": "remote work", "volume": 28000, "growth": -5.1, "platforms": ["linkedin", "twitter"]},
            {"keyword": "NFT", "volume": 45000, "growth": -12.3, "platforms": ["twitter", "instagram"]},
            {"keyword": "wellness", "volume": 32000, "growth": 18.7, "platforms": ["instagram", "tiktok"]},
        ]
        self.trends_data = sample_trends
    
    def get_trending_topics(self, platform: str = None, limit: int = 10) -> List[Dict]:
        """ZÃ­skÃ¡nÃ­ aktuÃ¡lnÃ­ch trendÅ¯ pro danou platformu"""
        if platform:
            filtered_trends = [
                trend for trend in self.trends_data 
                if platform in trend.get("platforms", [])
            ]
        else:
            filtered_trends = self.trends_data
        
        # SeÅ™azenÃ­ podle objemu a rÅ¯stu
        sorted_trends = sorted(
            filtered_trends, 
            key=lambda x: x["volume"] * (1 + x["growth"]/100), 
            reverse=True
        )
        
        return sorted_trends[:limit]
    
    def analyze_hashtag_performance(self, hashtags: List[str]) -> Dict[str, float]:
        """AnalÃ½za vÃ½konnosti hashtagÅ¯"""
        performance = {}
        for hashtag in hashtags:
            # Simulace vÃ½poÄtu vÃ½konnosti na zÃ¡kladÄ› popularity
            base_score = np.random.uniform(0.3, 0.9)
            trend_bonus = 0.1 if any(hashtag.lower() in trend["keyword"].lower() 
                                   for trend in self.trends_data) else 0
            performance[hashtag] = min(base_score + trend_bonus, 1.0)
        
        return performance

class ContentDatabase:
    """DatabÃ¡ze pro uklÃ¡dÃ¡nÃ­ a sprÃ¡vu obsahu"""
    
    def __init__(self, db_path: str = "social_media.db"):
        self.db_path = db_path
        self._initialize_database()
    
    def _initialize_database(self):
        """Inicializace SQLite databÃ¡ze"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabulka pro pÅ™Ã­spÄ›vky
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS posts (
                id INTEGER PRIMARY KEY,
                platform TEXT,
                content TEXT,
                hashtags TEXT,
                likes INTEGER,
                shares INTEGER,
                comments INTEGER,
                timestamp TEXT,
                author TEXT,
                sentiment REAL
            )
        ''')
        
        # Tabulka pro Å¡ablony
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS templates (
                id TEXT PRIMARY KEY,
                name TEXT,
                structure TEXT,
                platform TEXT,
                category TEXT,
                target_engagement REAL
            )
        ''')
        
        conn.commit()
        conn.close()
        
        # PÅ™idÃ¡nÃ­ vzorovÃ½ch dat
        self._add_sample_data()
    
    def _add_sample_data(self):
        """PÅ™idÃ¡nÃ­ vzorovÃ½ch dat do databÃ¡ze"""
        sample_posts = [
            SocialMediaPost(
                platform="instagram",
                content="Objevte krÃ¡su udrÅ¾itelnÃ© mÃ³dy! ğŸŒ¿ #sustainability #fashion",
                hashtags=["#sustainability", "#fashion", "#ecofriendly"],
                engagement_metrics={"likes": 1250, "shares": 45, "comments": 87},
                timestamp=datetime.now() - timedelta(days=1),
                author="fashion_brand",
                sentiment=0.8
            ),
            SocialMediaPost(
                platform="twitter",
                content="AI revoluce je tady! Jak vyuÅ¾Ã­t umÄ›lou inteligenci ve vaÅ¡em podnikÃ¡nÃ­? ğŸ¤–",
                hashtags=["#AI", "#business", "#technology"],
                engagement_metrics={"likes": 890, "shares": 156, "comments": 34},
                timestamp=datetime.now() - timedelta(days=2),
                author="tech_guru",
                sentiment=0.7
            )
        ]
        
        for post in sample_posts:
            self.save_post(post)
        
        sample_templates = [
            ContentTemplate(
                template_id="instagram_product",
                name="Product Showcase",
                structure="Hook + Product benefits + CTA + Hashtags",
                platform="instagram",
                category="product",
                target_engagement=0.8
            ),
            ContentTemplate(
                template_id="twitter_thought",
                name="Thought Leadership",
                structure="Industry insight + Personal perspective + Question to audience",
                platform="twitter", 
                category="thought_leadership",
                target_engagement=0.6
            )
        ]
        
        for template in sample_templates:
            self.save_template(template)
    
    def save_post(self, post: SocialMediaPost):
        """UloÅ¾enÃ­ pÅ™Ã­spÄ›vku do databÃ¡ze"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO posts 
            (platform, content, hashtags, likes, shares, comments, timestamp, author, sentiment)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            post.platform,
            post.content,
            json.dumps(post.hashtags),
            post.engagement_metrics.get("likes", 0),
            post.engagement_metrics.get("shares", 0),
            post.engagement_metrics.get("comments", 0),
            post.timestamp.isoformat(),
            post.author,
            post.sentiment
        ))
        
        conn.commit()
        conn.close()
    
    def save_template(self, template: ContentTemplate):
        """UloÅ¾enÃ­ Å¡ablony do databÃ¡ze"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO templates 
            (id, name, structure, platform, category, target_engagement)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            template.template_id,
            template.name,
            template.structure,
            template.platform,
            template.category,
            template.target_engagement
        ))
        
        conn.commit()
        conn.close()
    
    def get_posts_by_platform(self, platform: str, limit: int = 100) -> List[SocialMediaPost]:
        """ZÃ­skÃ¡nÃ­ pÅ™Ã­spÄ›vkÅ¯ podle platformy"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT platform, content, hashtags, likes, shares, comments, timestamp, author, sentiment
            FROM posts 
            WHERE platform = ? 
            ORDER BY timestamp DESC 
            LIMIT ?
        ''', (platform, limit))
        
        posts = []
        for row in cursor.fetchall():
            post = SocialMediaPost(
                platform=row[0],
                content=row[1],
                hashtags=json.loads(row[2]),
                engagement_metrics={
                    "likes": row[3],
                    "shares": row[4], 
                    "comments": row[5]
                },
                timestamp=datetime.fromisoformat(row[6]),
                author=row[7],
                sentiment=row[8]
            )
            posts.append(post)
        
        conn.close()
        return posts

class EngagementAnalyzer:
    """AnalyzÃ¡tor engagement metrik"""
    
    def __init__(self, database: ContentDatabase):
        self.database = database
    
    def calculate_engagement_rate(self, post: SocialMediaPost) -> float:
        """VÃ½poÄet engagement rate pro pÅ™Ã­spÄ›vek"""
        total_engagement = (
            post.engagement_metrics.get("likes", 0) +
            post.engagement_metrics.get("shares", 0) * 2 +  # Shares majÃ­ vyÅ¡Å¡Ã­ vÃ¡hu
            post.engagement_metrics.get("comments", 0) * 3   # Comments majÃ­ nejvyÅ¡Å¡Ã­ vÃ¡hu
        )
        
        # Simulace poÄtu followers (v reÃ¡lnÃ© aplikaci by se zÃ­skÃ¡valo z API)
        estimated_reach = np.random.randint(5000, 50000)
        
        return min(total_engagement / estimated_reach * 100, 100)
    
    def predict_engagement(self, content: str, hashtags: List[str], platform: str) -> float:
        """Predikce engagement na zÃ¡kladÄ› obsahu"""
        # ZÃ­skÃ¡nÃ­ historickÃ½ch dat
        historical_posts = self.database.get_posts_by_platform(platform)
        
        if not historical_posts:
            return 0.5  # VÃ½chozÃ­ hodnota
        
        # AnalÃ½za sentimentu obsahu
        blob = TextBlob(content)
        sentiment_score = blob.sentiment.polarity
        
        # AnalÃ½za hashtagÅ¯
        hashtag_performance = np.mean([
            0.7 if any(tag.lower() in post.content.lower() for post in historical_posts[-10:])
            else 0.4 for tag in hashtags
        ])
        
        # KombinovanÃ½ score
        predicted_engagement = (
            0.4 * (sentiment_score + 1) / 2 +  # Normalizace sentimentu na 0-1
            0.3 * hashtag_performance +
            0.3 * np.mean([self.calculate_engagement_rate(post) for post in historical_posts[-5:]])
        )
        
        return min(predicted_engagement, 1.0)
    
    def generate_engagement_report(self, platform: str) -> Dict[str, Any]:
        """GenerovÃ¡nÃ­ reportu o engagement"""
        posts = self.database.get_posts_by_platform(platform, limit=30)
        
        if not posts:
            return {"error": "Nedostatek dat pro analÃ½zu"}
        
        engagement_rates = [self.calculate_engagement_rate(post) for post in posts]
        
        return {
            "platform": platform,
            "total_posts": len(posts),
            "avg_engagement_rate": np.mean(engagement_rates),
            "max_engagement_rate": np.max(engagement_rates),
            "min_engagement_rate": np.min(engagement_rates),
            "engagement_trend": np.polyfit(range(len(engagement_rates)), engagement_rates, 1)[0],
            "top_performing_hashtags": self._get_top_hashtags(posts)
        }
    
    def _get_top_hashtags(self, posts: List[SocialMediaPost], top_n: int = 5) -> List[str]:
        """ZÃ­skÃ¡nÃ­ nejlÃ©pe performujÃ­cÃ­ch hashtagÅ¯"""
        hashtag_performance = {}
        
        for post in posts:
            engagement_rate = self.calculate_engagement_rate(post)
            for hashtag in post.hashtags:
                if hashtag not in hashtag_performance:
                    hashtag_performance[hashtag] = []
                hashtag_performance[hashtag].append(engagement_rate)
        
        # PrÅ¯mÄ›rnÃ¡ vÃ½konnost hashtagÅ¯
        avg_performance = {
            hashtag: np.mean(rates) 
            for hashtag, rates in hashtag_performance.items()
        }
        
        return sorted(avg_performance.keys(), key=lambda x: avg_performance[x], reverse=True)[:top_n]

class RAGContentGenerator:
    """RAG systÃ©m pro generovÃ¡nÃ­ obsahu"""
    
    def __init__(self, openai_api_key: str):
        self.openai_api_key = openai_api_key
        os.environ["OPENAI_API_KEY"] = openai_api_key
        
        # Inicializace RAG komponent
        self.embeddings = OpenAIEmbeddings()
        self.llm = ChatOpenAI(temperature=0.7, model="gpt-4")
        self.vectorstore = None
        self._initialize_knowledge_base()
    
    def _initialize_knowledge_base(self):
        """Inicializace knowledge base s obsahem o social media strategiÃ­ch"""
        documents = [
            Document(
                page_content="Instagram preferuje vizuÃ¡lnÃ­ obsah s vysokou kvalitou. NejlepÅ¡Ã­ Äasy pro publikovÃ¡nÃ­ jsou 11:00-13:00 a 19:00-21:00. Stories majÃ­ vysokÃ½ engagement rate.",
                metadata={"platform": "instagram", "type": "best_practices"}
            ),
            Document(
                page_content="Twitter funguje nejlÃ©pe s krÃ¡tkÃ½m, vtipnÃ½m obsahem a aktuÃ¡lnÃ­mi tÃ©maty. PouÅ¾Ã­vejte maximÃ¡lnÄ› 2-3 hashtags. IdeÃ¡lnÃ­ dÃ©lka tweetu je 71-100 znakÅ¯.",
                metadata={"platform": "twitter", "type": "best_practices"}
            ),
            Document(
                page_content="LinkedIn je profesnÃ­ sÃ­Å¥ zamÄ›Å™enÃ¡ na B2B obsah, thought leadership a industry insights. DlouhÃ½ content performuje lÃ©pe neÅ¾ krÃ¡tkÃ½.",
                metadata={"platform": "linkedin", "type": "best_practices"}
            ),
            Document(
                page_content="Hashtag research: PouÅ¾Ã­vejte mix populÃ¡rnÃ­ch (#fashion - 500M+) a niche hashtagÅ¯ (#sustainablefashion - 1M+). OptimÃ¡lnÃ­ poÄet hashtagÅ¯ na Instagramu je 5-10.",
                metadata={"type": "hashtag_strategy"}
            ),
            Document(
                page_content="Engagement boosting: Kladte otÃ¡zky, pouÅ¾Ã­vejte emoji, publikujte v optimÃ¡lnÃ­ch Äasech, odpovÃ­dejte na komentÃ¡Å™e rychle.",
                metadata={"type": "engagement_strategy"}
            )
        ]
        
        # VytvoÅ™enÃ­ vector store
        self.vectorstore = Chroma.from_documents(
            documents=documents,
            embedding=self.embeddings,
            persist_directory="./chroma_db"
        )
    
    def generate_content(self, 
                        platform: str, 
                        topic: str, 
                        brand_guidelines: BrandGuideline,
                        target_engagement: float = 0.7) -> Dict[str, Any]:
        """GenerovÃ¡nÃ­ obsahu pomocÃ­ RAG"""
        
        # VyhledÃ¡nÃ­ relevantnÃ­ch informacÃ­
        relevant_docs = self.vectorstore.similarity_search(
            f"{platform} {topic} best practices", k=3
        )
        
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Prompt template
        prompt_template = ChatPromptTemplate.from_template("""
        Jsi expert na social media marketing. VytvoÅ™ obsah pro {platform} na tÃ©ma {topic}.

        Kontext z knowledge base:
        {context}

        Brand guidelines:
        - NÃ¡zev znaÄky: {brand_name}
        - Tone of voice: {tone_of_voice}
        - KlÃ­ÄovÃ© zprÃ¡vy: {key_messages}
        - CÃ­lovÃ¡ audience: {target_audience}

        VytvoÅ™:
        1. HlavnÃ­ text pÅ™Ã­spÄ›vku (respektuj limity platformy)
        2. 5-8 relevantnÃ­ch hashtagÅ¯
        3. DoporuÄenÃ½ Äas publikovÃ¡nÃ­
        4. NÃ¡vrh na vizuÃ¡lnÃ­ obsah
        5. Call-to-action

        OdpovÄ›z ve formÃ¡tu JSON.
        """)
        
        # GenerovÃ¡nÃ­ obsahu
        chain = prompt_template | self.llm
        
        try:
            response = chain.invoke({
                "platform": platform,
                "topic": topic,
                "context": context,
                "brand_name": brand_guidelines.brand_name,
                "tone_of_voice": brand_guidelines.tone_of_voice,
                "key_messages": ", ".join(brand_guidelines.key_messages),
                "target_audience": brand_guidelines.target_audience
            })
            
            # Parsing odpovÄ›di (zjednoduÅ¡eno)
            content_suggestion = {
                "platform": platform,
                "topic": topic,
                "generated_content": response.content,
                "confidence_score": 0.85,  # Simulace
                "estimated_engagement": target_engagement * 0.9  # KonzervativnÃ­ odhad
            }
            
            return content_suggestion
            
        except Exception as e:
            return {
                "error": f"Chyba pÅ™i generovÃ¡nÃ­ obsahu: {str(e)}",
                "fallback_content": f"ZajÃ­mavÃ½ obsah o {topic} pro {platform}! ğŸš€ #trending"
            }

class SocialMediaAssistant:
    """HlavnÃ­ tÅ™Ã­da pro Social Media Content Strategy Assistant"""
    
    def __init__(self, openai_api_key: str):
        self.database = ContentDatabase()
        self.trend_analyzer = TrendAnalyzer()
        self.engagement_analyzer = EngagementAnalyzer(self.database)
        self.rag_generator = RAGContentGenerator(openai_api_key)
        
        # VÃ½chozÃ­ brand guidelines
        self.brand_guidelines = BrandGuideline(
            brand_name="TechStart",
            tone_of_voice="PÅ™Ã¡telskÃ½, odbornÃ½, inspirativnÃ­",
            key_messages=["Inovace", "Kvalita", "ZÃ¡kaznickÃ¡ spokojenost"],
            prohibited_topics=["Politika", "NÃ¡boÅ¾enstvÃ­"],
            color_scheme={"primary": "#007bff", "secondary": "#6c757d"},
            target_audience="Tech-savvy professionals aged 25-45"
        )
    
    async def create_content_strategy(self, platform: str, days: int = 7) -> Dict[str, Any]:
        """VytvoÅ™enÃ­ obsahovÃ© strategie na zadanÃ© obdobÃ­"""
        
        # AnalÃ½za trendÅ¯
        trending_topics = self.trend_analyzer.get_trending_topics(platform, limit=5)
        
        # GenerovÃ¡nÃ­ engagement reportu
        engagement_report = self.engagement_analyzer.generate_engagement_report(platform)
        
        # PlÃ¡n obsahu
        content_plan = []
        
        for day in range(days):
            # VÃ½bÄ›r tÃ©matu na zÃ¡kladÄ› trendÅ¯
            topic = trending_topics[day % len(trending_topics)]["keyword"]
            
            # GenerovÃ¡nÃ­ obsahu
            content_suggestion = self.rag_generator.generate_content(
                platform=platform,
                topic=topic,
                brand_guidelines=self.brand_guidelines
            )
            
            # Predikce engagement
            if "generated_content" in content_suggestion:
                predicted_engagement = self.engagement_analyzer.predict_engagement(
                    content_suggestion["generated_content"],
                    [],  # ZjednoduÅ¡eno
                    platform
                )
                content_suggestion["predicted_engagement"] = predicted_engagement
            
            content_plan.append({
                "day": day + 1,
                "topic": topic,
                "content": content_suggestion
            })
        
        return {
            "platform": platform,
            "period_days": days,
            "trending_topics": trending_topics,
            "engagement_report": engagement_report,
            "content_plan": content_plan,
            "strategy_score": np.mean([
                item["content"].get("predicted_engagement", 0.5) 
                for item in content_plan
            ])
        }
    
    def analyze_competitor_content(self, competitor_posts: List[str]) -> Dict[str, Any]:
        """AnalÃ½za obsahu konkurence"""
        competitor_analysis = {
            "total_posts_analyzed": len(competitor_posts),
            "avg_sentiment": 0,
            "common_themes": [],
            "hashtag_usage": {},
            "content_recommendations": []
        }
        
        if not competitor_posts:
            return competitor_analysis
        
        # AnalÃ½za sentimentu
        sentiments = []
        themes = []
        
        for post in competitor_posts:
            blob = TextBlob(post)
            sentiments.append(blob.sentiment.polarity)
            
            # Extrakce tÃ©mat (zjednoduÅ¡eno)
            words = post.lower().split()
            themes.extend([word for word in words if len(word) > 4])
        
        competitor_analysis["avg_sentiment"] = np.mean(sentiments)
        
        # NejÄastÄ›jÅ¡Ã­ tÃ©mata
        from collections import Counter
        theme_counts = Counter(themes)
        competitor_analysis["common_themes"] = theme_counts.most_common(5)
        
        # DoporuÄenÃ­
        competitor_analysis["content_recommendations"] = [
            "ZamÄ›Å™te se na pozitivnÄ›jÅ¡Ã­ tone of voice" if np.mean(sentiments) < 0.3 else "UdrÅ¾ujte pozitivnÃ­ komunikaci",
            f"VyuÅ¾ijte populÃ¡rnÃ­ tÃ©mata: {', '.join([theme[0] for theme in theme_counts.most_common(3)])}"
        ]
        
        return competitor_analysis
    
    def generate_hashtag_strategy(self, topic: str, platform: str) -> Dict[str, Any]:
        """GenerovÃ¡nÃ­ hashtag strategie"""
        
        # AnalÃ½za vÃ½konnosti hashtagÅ¯
        hashtag_suggestions = [
            f"#{topic.lower().replace(' ', '')}",
            f"#{platform.lower()}",
            "#marketing",
            "#socialmedia",
            "#content"
        ]
        
        performance = self.trend_analyzer.analyze_hashtag_performance(hashtag_suggestions)
        
        return {
            "topic": topic,
            "platform": platform,
            "recommended_hashtags": hashtag_suggestions,
            "hashtag_performance": performance,
            "strategy_tips": [
                "Kombinujte populÃ¡rnÃ­ a niche hashtagy",
                "Sledujte vÃ½konnost a upravte strategii",
                "NepouÅ¾Ã­vejte pÅ™Ã­liÅ¡ mnoho hashtagÅ¯ najednou"
            ]
        }
    
    def export_strategy_report(self, strategy_data: Dict[str, Any], filename: str = None) -> str:
        """Export strategie do souboru"""
        if filename is None:
            filename = f"social_media_strategy_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(strategy_data, f, ensure_ascii=False, indent=2, default=str)
            
            return f"Strategie ÃºspÄ›Å¡nÄ› exportovÃ¡na do {filename}"
        
        except Exception as e:
            return f"Chyba pÅ™i exportu: {str(e)}"

# DemonstraÄnÃ­ funkce
async def main_demo():
    """HlavnÃ­ demonstraÄnÃ­ funkce"""
    
    # Inicializace (vyÅ¾aduje OpenAI API key)
    # assistant = SocialMediaAssistant("your-openai-api-key")
    
    print("ğŸš€ Social Media Content Strategy Assistant - Demo")
    print("=" * 50)
    
    # Simulace bez API key
    try:
        assistant = SocialMediaAssistant("demo-key")
        
        # VytvoÅ™enÃ­ obsahovÃ© strategie
        print("\nğŸ“Š VytvÃ¡Å™enÃ­ obsahovÃ© strategie pro Instagram...")
        strategy = await assistant.create_content_strategy("instagram", days=3)
        
        print(f"âœ… Strategie vytvoÅ™ena s skÃ³re: {strategy['strategy_score']:.2f}")
        print(f"ğŸ“ˆ Trending topics: {[t['keyword'] for t in strategy['trending_topics'][:3]]}")
        
        # Hashtag strategie
        print("\nğŸ·ï¸  GenerovÃ¡nÃ­ hashtag strategie...")
        hashtag_strategy = assistant.generate_hashtag_strategy("AI technology", "instagram")
        print(f"âœ… DoporuÄenÃ© hashtagy: {hashtag_strategy['recommended_hashtags'][:3]}")
        
        # AnalÃ½za konkurence
        print("\nğŸ” AnalÃ½za konkurenÄnÃ­ho obsahu...")
        competitor_posts = [
            "NovÃ¡ technologie AI mÄ›nÃ­ svÄ›t! #AI #tech #future",
            "UdrÅ¾itelnost je budoucnost. Jak mÅ¯Å¾eme pomoci? #sustainability #green",
            "Remote work tips pro vyÅ¡Å¡Ã­ produktivitu #remotework #productivity"
        ]
        
        competitor_analysis = assistant.analyze_competitor_content(competitor_posts)
        print(f"âœ… AnalyzovÃ¡no {competitor_analysis['total_posts_analyzed']} pÅ™Ã­spÄ›vkÅ¯")
        print(f"ğŸ“Š PrÅ¯mÄ›rnÃ½ sentiment: {competitor_analysis['avg_sentiment']:.2f}")
        
        # Export strategie
        print("\nğŸ’¾ Export strategie...")
        export_result = assistant.export_strategy_report(strategy)
        print(f"âœ… {export_result}")
        
    except Exception as e:
        print(f"âŒ Demo error: {str(e)}")
        print("ğŸ’¡ Pro plnou funkcionalnost je potÅ™eba OpenAI API key")

if __name__ == "__main__":
    asyncio.run(main_demo())
````

## ShrnutÃ­ projektu

**Social Media Content Strategy Assistant** pÅ™edstavuje komplexnÃ­ Å™eÅ¡enÃ­ pro automatizaci a optimalizaci social media marketingu pomocÃ­ pokroÄilÃ½ch AI technologiÃ­. Projekt kombinuje RAG architekturu s analÃ½zou trendÅ¯, engagement metrik a brand guidelines pro vytvÃ¡Å™enÃ­ efektivnÃ­ obsahovÃ© strategie.

### KlÃ­ÄovÃ© vÃ½hody:

- **Automatizace content strategie** s vyuÅ¾itÃ­m AI a machine learning
- **Real-time analÃ½za trendÅ¯** pro maximalizaci dosahu obsahu
- **Predikce engagement** na zÃ¡kladÄ› historickÃ½ch dat
- **Multi-platform optimalizace** pro rÅ¯znÃ© sociÃ¡lnÃ­ sÃ­tÄ›
- **Brand consistency** prostÅ™ednictvÃ­m dodrÅ¾ovÃ¡nÃ­ brand guidelines

### TechnologickÃ© komponenty:

- **RAG systÃ©m** (LangChain, OpenAI, Chroma) pro inteligentnÃ­ generovÃ¡nÃ­ obsahu
- **Trend analysis** pro sledovÃ¡nÃ­ aktuÃ¡lnÃ­ch tÃ©mat
- **Engagement analytics** pro optimalizaci vÃ½konnosti
- **Database management** (SQLite) pro uklÃ¡dÃ¡nÃ­ historickÃ½ch dat
- **API integrace** pro pÅ™ipojenÃ­ k sociÃ¡lnÃ­m sÃ­tÃ­m

### PraktickÃ© vyuÅ¾itÃ­:

SystÃ©m je ideÃ¡lnÃ­ pro marketing tÃ½my, social media manaÅ¾ery a digital marketing agentury, kterÃ© chtÄ›jÃ­ zvÃ½Å¡it efektivitu svÃ© contenovÃ© strategie a dosÃ¡hnout lepÅ¡Ã­ch vÃ½sledkÅ¯ s menÅ¡Ã­mi nÃ¡klady na tvorbu obsahu.