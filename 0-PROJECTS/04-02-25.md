<small>Claude Sonnet 4 **(AI Fashion Stylist Bot)**</small>
# AI Fashion Stylist Bot

## Key Concepts Explanation

### Style Detection and Analysis
Computer vision system that identifies fashion elements, colors, patterns, cuts, and silhouettes from clothing images using deep learning models. Extracts style attributes like formal/casual classification, seasonal appropriateness, and aesthetic characteristics while understanding fashion context through trained convolutional neural networks and image processing pipelines.

### Outfit Generation Engine
AI-powered system that creates cohesive outfit combinations by understanding color theory, style compatibility, and fashion rules. Combines garment pieces intelligently while considering body types, occasions, weather conditions, and personal preferences through constraint-based algorithms and style knowledge bases.

### Multimodal Fashion Intelligence
Advanced AI framework that processes both visual and textual fashion data to understand style preferences, trend analysis, and personalized recommendations. Integrates image recognition, natural language processing, and fashion domain knowledge to provide comprehensive styling advice and outfit suggestions.

### Seasonal Trend Integration
Dynamic system that incorporates current fashion trends, seasonal collections, and market data to provide contemporary styling advice. Analyzes fashion week data, social media trends, celebrity styles, and retail patterns to ensure recommendations align with current fashion movements and seasonal appropriateness.

### Personal Style Profiling
Machine learning system that creates individual style profiles based on user preferences, body measurements, lifestyle factors, and fashion history. Learns from user feedback, wardrobe analysis, and behavioral patterns to provide increasingly personalized styling recommendations over time.

### Color Harmony and Coordination
Sophisticated color analysis system that applies color theory principles, seasonal color analysis, and personal color matching to create harmonious outfit combinations. Understands undertones, complementary colors, and fashion color trends to ensure visually appealing and flattering color coordination.

## Comprehensive Project Explanation

### Objectives
The AI Fashion Stylist Bot aims to democratize personal styling by providing intelligent, personalized fashion advice through computer vision and AI, making professional styling accessible while helping users discover their personal style and build cohesive wardrobes.

### Key Features
- **Visual Wardrobe Analysis**: Upload and analyze existing clothing items for style categorization
- **Personalized Outfit Generation**: Create custom outfits based on occasion, weather, and preferences
- **Trend Integration**: Incorporate current fashion trends and seasonal recommendations
- **Color Coordination**: Advanced color matching and harmony analysis
- **Body Type Consideration**: Styling advice tailored to individual body shapes and proportions
- **Occasion-Based Styling**: Specific recommendations for work, casual, formal, and special events

### Challenges
- **Style Subjectivity**: Balancing personal taste with fashion rules and trends
- **Image Quality Variance**: Handling diverse lighting, angles, and quality in clothing photos
- **Cultural and Regional Differences**: Adapting to varying fashion preferences across demographics
- **Trend Velocity**: Keeping up with rapidly changing fashion trends and seasonal shifts
- **Size and Fit Complexity**: Addressing diverse body types and sizing variations
- **Sustainable Fashion**: Promoting eco-friendly choices and wardrobe longevity

### Potential Impact
This system can democratize fashion styling, reduce clothing waste through better outfit planning, boost personal confidence through improved style choices, support fashion retail through intelligent recommendations, and make fashion more inclusive by accommodating diverse body types and budgets.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
pillow==10.1.0
opencv-python==4.8.1.78
numpy==1.24.3
pandas==2.1.4
matplotlib==3.8.2
seaborn==0.13.0
plotly==5.17.0
scikit-learn==1.3.2
tensorflow==2.15.0
torch==2.1.0
torchvision==0.16.0
transformers==4.36.0
clip-by-openai==1.0
colorthief==0.2.1
webcolors==1.13
requests==2.31.0
json
uuid
logging
datetime
typing
dataclasses
enum
re
base64
io
hashlib
````

### Core Implementation

````python
import os
import json
import uuid
import logging
import base64
import io
import hashlib
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go

# Image processing
from PIL import Image, ImageEnhance, ImageFilter
import cv2
from colorthief import ColorThief
import webcolors

# ML/AI libraries
import torch
import torchvision.transforms as transforms
from transformers import BlipProcessor, BlipForConditionalGeneration
from sklearn.cluster import KMeans
from sklearn.metrics.pairwise import cosine_similarity

# LangChain
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ClothingCategory(Enum):
    TOP = "top"
    BOTTOM = "bottom"
    DRESS = "dress"
    OUTERWEAR = "outerwear"
    SHOES = "shoes"
    ACCESSORIES = "accessories"
    UNDERWEAR = "underwear"

class StyleType(Enum):
    CASUAL = "casual"
    FORMAL = "formal"
    BUSINESS = "business"
    EVENING = "evening"
    SPORTY = "sporty"
    BOHEMIAN = "bohemian"
    MINIMALIST = "minimalist"
    VINTAGE = "vintage"

class Season(Enum):
    SPRING = "spring"
    SUMMER = "summer"
    FALL = "fall"
    WINTER = "winter"

class Occasion(Enum):
    WORK = "work"
    CASUAL = "casual"
    DATE = "date"
    PARTY = "party"
    FORMAL = "formal"
    TRAVEL = "travel"
    SPORTS = "sports"
    HOME = "home"

class BodyType(Enum):
    PEAR = "pear"
    APPLE = "apple"
    RECTANGLE = "rectangle"
    HOURGLASS = "hourglass"
    INVERTED_TRIANGLE = "inverted_triangle"

@dataclass
class ColorProfile:
    dominant_colors: List[Tuple[int, int, int]]
    color_names: List[str]
    color_temperature: str  # warm, cool, neutral
    brightness: float  # 0-1
    saturation: float  # 0-1
    harmony_score: float  # 0-1

@dataclass
class ClothingItem:
    item_id: str
    name: str
    category: ClothingCategory
    style_type: StyleType
    colors: List[str]
    dominant_color: Tuple[int, int, int]
    pattern: str
    material: str
    season: List[Season]
    formality_level: float  # 0-1 (casual to formal)
    image_path: Optional[str] = None
    brand: str = ""
    price: float = 0.0
    purchase_date: Optional[datetime] = None
    wear_count: int = 0
    tags: List[str] = field(default_factory=list)

@dataclass
class UserProfile:
    user_id: str
    name: str
    body_type: BodyType
    preferred_styles: List[StyleType]
    color_preferences: List[str]
    lifestyle: str
    budget_range: Tuple[float, float]
    size_info: Dict[str, str]
    style_goals: List[str] = field(default_factory=list)
    wardrobe_items: List[ClothingItem] = field(default_factory=list)

@dataclass
class OutfitRecommendation:
    outfit_id: str
    items: List[ClothingItem]
    occasion: Occasion
    style_score: float
    color_harmony: float
    season_appropriateness: float
    overall_rating: float
    styling_tips: List[str]
    alternatives: List[List[ClothingItem]] = field(default_factory=list)

class ColorAnalyzer:
    """Analyzes colors in clothing images and provides color harmony insights."""
    
    def __init__(self):
        self.color_harmony_rules = {
            'complementary': self._check_complementary,
            'analogous': self._check_analogous,
            'triadic': self._check_triadic,
            'monochromatic': self._check_monochromatic
        }
    
    def extract_colors(self, image: Image.Image, num_colors: int = 5) -> ColorProfile:
        """Extract dominant colors from clothing image."""
        try:
            # Save image temporarily for ColorThief
            temp_path = f"temp_{uuid.uuid4().hex}.jpg"
            image.save(temp_path)
            
            # Extract colors
            color_thief = ColorThief(temp_path)
            dominant_colors = color_thief.get_palette(color_count=num_colors)
            
            # Clean up
            os.remove(temp_path)
            
            # Convert to color names
            color_names = []
            for color in dominant_colors:
                try:
                    closest_name = webcolors.rgb_to_name(color)
                except ValueError:
                    # Find closest color name
                    closest_name = self._closest_color_name(color)
                color_names.append(closest_name)
            
            # Analyze color properties
            color_temp = self._analyze_color_temperature(dominant_colors[0])
            brightness = self._calculate_brightness(dominant_colors[0])
            saturation = self._calculate_saturation(dominant_colors[0])
            harmony = self._calculate_harmony_score(dominant_colors)
            
            return ColorProfile(
                dominant_colors=dominant_colors,
                color_names=color_names,
                color_temperature=color_temp,
                brightness=brightness,
                saturation=saturation,
                harmony_score=harmony
            )
            
        except Exception as e:
            logger.error(f"Color extraction error: {e}")
            return ColorProfile(
                dominant_colors=[(128, 128, 128)],
                color_names=["gray"],
                color_temperature="neutral",
                brightness=0.5,
                saturation=0.5,
                harmony_score=0.5
            )
    
    def _closest_color_name(self, rgb_color: Tuple[int, int, int]) -> str:
        """Find closest named color."""
        min_colors = {}
        for key, name in webcolors.CSS3_HEX_TO_NAMES.items():
            r_c, g_c, b_c = webcolors.hex_to_rgb(key)
            rd = (r_c - rgb_color[0]) ** 2
            gd = (g_c - rgb_color[1]) ** 2
            bd = (b_c - rgb_color[2]) ** 2
            min_colors[(rd + gd + bd)] = name
        return min_colors[min(min_colors.keys())]
    
    def _analyze_color_temperature(self, color: Tuple[int, int, int]) -> str:
        """Determine if color is warm, cool, or neutral."""
        r, g, b = color
        
        # Simple heuristic based on RGB values
        if r > b and (r + g) > (g + b):
            return "warm"
        elif b > r and (b + g) > (r + g):
            return "cool"
        else:
            return "neutral"
    
    def _calculate_brightness(self, color: Tuple[int, int, int]) -> float:
        """Calculate perceived brightness (0-1)."""
        r, g, b = color
        # Perceived brightness formula
        brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255
        return brightness
    
    def _calculate_saturation(self, color: Tuple[int, int, int]) -> float:
        """Calculate color saturation (0-1)."""
        r, g, b = [x / 255.0 for x in color]
        max_val = max(r, g, b)
        min_val = min(r, g, b)
        
        if max_val == 0:
            return 0
        
        saturation = (max_val - min_val) / max_val
        return saturation
    
    def _calculate_harmony_score(self, colors: List[Tuple[int, int, int]]) -> float:
        """Calculate overall color harmony score."""
        scores = []
        
        for rule_name, rule_func in self.color_harmony_rules.items():
            score = rule_func(colors)
            scores.append(score)
        
        return max(scores) if scores else 0.5
    
    def _check_complementary(self, colors: List[Tuple[int, int, int]]) -> float:
        """Check complementary color harmony."""
        if len(colors) < 2:
            return 0.0
        
        # Convert to HSV for easier hue comparison
        hsv_colors = []
        for r, g, b in colors:
            hsv = cv2.cvtColor(np.uint8([[[r, g, b]]]), cv2.COLOR_RGB2HSV)[0][0]
            hsv_colors.append(hsv[0])  # Hue value
        
        # Check if any two colors are approximately opposite (180Â° apart)
        for i in range(len(hsv_colors)):
            for j in range(i + 1, len(hsv_colors)):
                hue_diff = abs(hsv_colors[i] - hsv_colors[j])
                hue_diff = min(hue_diff, 180 - hue_diff)  # Handle wrap-around
                
                if 160 <= hue_diff <= 200:  # Close to 180Â°
                    return 0.8
        
        return 0.2
    
    def _check_analogous(self, colors: List[Tuple[int, int, int]]) -> float:
        """Check analogous color harmony."""
        if len(colors) < 2:
            return 0.0
        
        hsv_colors = []
        for r, g, b in colors:
            hsv = cv2.cvtColor(np.uint8([[[r, g, b]]]), cv2.COLOR_RGB2HSV)[0][0]
            hsv_colors.append(hsv[0])
        
        # Check if colors are within 30Â° of each other
        hsv_colors.sort()
        
        for i in range(len(hsv_colors) - 1):
            hue_diff = hsv_colors[i + 1] - hsv_colors[i]
            if hue_diff <= 30:
                return 0.7
        
        return 0.3
    
    def _check_triadic(self, colors: List[Tuple[int, int, int]]) -> float:
        """Check triadic color harmony."""
        if len(colors) < 3:
            return 0.0
        
        hsv_colors = []
        for r, g, b in colors:
            hsv = cv2.cvtColor(np.uint8([[[r, g, b]]]), cv2.COLOR_RGB2HSV)[0][0]
            hsv_colors.append(hsv[0])
        
        # Check if any three colors are ~120Â° apart
        hsv_colors.sort()
        
        for i in range(len(hsv_colors) - 2):
            diff1 = hsv_colors[i + 1] - hsv_colors[i]
            diff2 = hsv_colors[i + 2] - hsv_colors[i + 1]
            
            if 100 <= diff1 <= 140 and 100 <= diff2 <= 140:
                return 0.8
        
        return 0.2
    
    def _check_monochromatic(self, colors: List[Tuple[int, int, int]]) -> float:
        """Check monochromatic color harmony."""
        if len(colors) < 2:
            return 0.0
        
        hsv_colors = []
        for r, g, b in colors:
            hsv = cv2.cvtColor(np.uint8([[[r, g, b]]]), cv2.COLOR_RGB2HSV)[0][0]
            hsv_colors.append(hsv[0])
        
        # Check if all colors have similar hue
        hue_variance = np.var(hsv_colors)
        
        if hue_variance < 100:  # Low variance in hue
            return 0.6
        
        return 0.2

class ClothingDetector:
    """Detects and analyzes clothing items in images."""
    
    def __init__(self):
        # Initialize BLIP model for image captioning
        try:
            self.processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
            self.model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")
        except:
            logger.warning("BLIP model not available, using fallback")
            self.processor = None
            self.model = None
        
        # Clothing keywords for classification
        self.clothing_keywords = {
            ClothingCategory.TOP: [
                'shirt', 'blouse', 't-shirt', 'sweater', 'hoodie', 'tank top',
                'cardigan', 'blazer', 'vest', 'crop top', 'tunic'
            ],
            ClothingCategory.BOTTOM: [
                'pants', 'jeans', 'trousers', 'shorts', 'skirt', 'leggings',
                'joggers', 'sweatpants', 'chinos', 'slacks'
            ],
            ClothingCategory.DRESS: [
                'dress', 'gown', 'sundress', 'maxi dress', 'mini dress',
                'cocktail dress', 'evening dress', 'wrap dress'
            ],
            ClothingCategory.OUTERWEAR: [
                'jacket', 'coat', 'blazer', 'cardigan', 'hoodie', 'sweater',
                'windbreaker', 'parka', 'trench coat', 'bomber jacket'
            ],
            ClothingCategory.SHOES: [
                'shoes', 'sneakers', 'boots', 'sandals', 'heels', 'flats',
                'loafers', 'oxfords', 'pumps', 'athletic shoes'
            ],
            ClothingCategory.ACCESSORIES: [
                'hat', 'scarf', 'belt', 'bag', 'purse', 'jewelry', 'watch',
                'sunglasses', 'tie', 'bow tie', 'necklace', 'bracelet'
            ]
        }
        
        # Style indicators
        self.style_indicators = {
            StyleType.CASUAL: ['casual', 'relaxed', 'comfortable', 'everyday'],
            StyleType.FORMAL: ['formal', 'dress', 'elegant', 'sophisticated'],
            StyleType.BUSINESS: ['business', 'professional', 'office', 'work'],
            StyleType.SPORTY: ['athletic', 'sporty', 'activewear', 'gym'],
            StyleType.BOHEMIAN: ['boho', 'flowing', 'loose', 'hippie'],
            StyleType.MINIMALIST: ['simple', 'clean', 'minimal', 'basic'],
            StyleType.VINTAGE: ['vintage', 'retro', 'classic', 'old-fashioned']
        }
    
    def analyze_clothing_image(self, image: Image.Image) -> Dict[str, Any]:
        """Analyze clothing image and extract metadata."""
        try:
            # Generate image caption
            caption = self._generate_caption(image)
            
            # Detect clothing category
            category = self._detect_category(caption)
            
            # Detect style type
            style_type = self._detect_style_type(caption)
            
            # Detect patterns
            pattern = self._detect_pattern(caption, image)
            
            # Estimate formality
            formality = self._estimate_formality(caption, category, style_type)
            
            # Extract material information
            material = self._detect_material(caption)
            
            return {
                'caption': caption,
                'category': category,
                'style_type': style_type,
                'pattern': pattern,
                'material': material,
                'formality_level': formality,
                'confidence': 0.8  # Base confidence
            }
            
        except Exception as e:
            logger.error(f"Image analysis error: {e}")
            return {
                'caption': 'clothing item',
                'category': ClothingCategory.TOP,
                'style_type': StyleType.CASUAL,
                'pattern': 'solid',
                'material': 'unknown',
                'formality_level': 0.5,
                'confidence': 0.3
            }
    
    def _generate_caption(self, image: Image.Image) -> str:
        """Generate descriptive caption for clothing image."""
        if self.processor and self.model:
            try:
                inputs = self.processor(image, return_tensors="pt")
                out = self.model.generate(**inputs, max_length=50)
                caption = self.processor.decode(out[0], skip_special_tokens=True)
                return caption.lower()
            except:
                pass
        
        # Fallback caption
        return "clothing item"
    
    def _detect_category(self, caption: str) -> ClothingCategory:
        """Detect clothing category from caption."""
        caption_lower = caption.lower()
        
        category_scores = {}
        for category, keywords in self.clothing_keywords.items():
            score = sum(1 for keyword in keywords if keyword in caption_lower)
            category_scores[category] = score
        
        if category_scores:
            best_category = max(category_scores.keys(), key=lambda k: category_scores[k])
            if category_scores[best_category] > 0:
                return best_category
        
        return ClothingCategory.TOP  # Default
    
    def _detect_style_type(self, caption: str) -> StyleType:
        """Detect style type from caption."""
        caption_lower = caption.lower()
        
        style_scores = {}
        for style, indicators in self.style_indicators.items():
            score = sum(1 for indicator in indicators if indicator in caption_lower)
            style_scores[style] = score
        
        if style_scores:
            best_style = max(style_scores.keys(), key=lambda k: style_scores[k])
            if style_scores[best_style] > 0:
                return best_style
        
        return StyleType.CASUAL  # Default
    
    def _detect_pattern(self, caption: str, image: Image.Image) -> str:
        """Detect pattern in clothing."""
        pattern_keywords = {
            'striped': ['stripe', 'striped', 'lines'],
            'plaid': ['plaid', 'checkered', 'check'],
            'floral': ['floral', 'flower', 'flowers'],
            'polka dot': ['dot', 'dotted', 'polka'],
            'geometric': ['geometric', 'pattern'],
            'solid': ['solid', 'plain']
        }
        
        caption_lower = caption.lower()
        
        for pattern, keywords in pattern_keywords.items():
            if any(keyword in caption_lower for keyword in keywords):
                return pattern
        
        return 'solid'  # Default
    
    def _detect_material(self, caption: str) -> str:
        """Detect material from caption."""
        materials = [
            'cotton', 'silk', 'wool', 'polyester', 'linen', 'denim',
            'leather', 'cashmere', 'velvet', 'satin', 'chiffon', 'jersey'
        ]
        
        caption_lower = caption.lower()
        
        for material in materials:
            if material in caption_lower:
                return material
        
        return 'cotton'  # Default
    
    def _estimate_formality(self, caption: str, category: ClothingCategory, 
                          style_type: StyleType) -> float:
        """Estimate formality level (0-1)."""
        base_formality = {
            StyleType.FORMAL: 0.9,
            StyleType.BUSINESS: 0.8,
            StyleType.CASUAL: 0.3,
            StyleType.SPORTY: 0.2,
            StyleType.BOHEMIAN: 0.4,
            StyleType.MINIMALIST: 0.6,
            StyleType.VINTAGE: 0.5
        }
        
        formality = base_formality.get(style_type, 0.5)
        
        # Adjust based on specific terms
        formal_terms = ['dress', 'suit', 'blazer', 'formal', 'elegant']
        casual_terms = ['t-shirt', 'jeans', 'sneakers', 'casual', 'relaxed']
        
        caption_lower = caption.lower()
        
        if any(term in caption_lower for term in formal_terms):
            formality += 0.2
        elif any(term in caption_lower for term in casual_terms):
            formality -= 0.2
        
        return max(0.0, min(1.0, formality))

class StyleRecommendationEngine:
    """Core engine for generating outfit recommendations."""
    
    def __init__(self, openai_api_key: str = None):
        self.color_analyzer = ColorAnalyzer()
        self.clothing_detector = ClothingDetector()
        
        # Initialize LLM for advanced styling advice
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.7,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        else:
            self.llm = None
        
        # Style rules and combinations
        self.style_rules = self._initialize_style_rules()
        
        self.styling_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are a professional fashion stylist with expertise in color theory, body types, 
            and current trends. Provide styling advice and outfit combinations.
            
            Consider:
            1. Color harmony and coordination
            2. Occasion appropriateness
            3. Body type flattering choices
            4. Current fashion trends
            5. Personal style preferences
            
            User Profile: {user_profile}
            Available Items: {wardrobe_items}
            Occasion: {occasion}
            Season: {season}
            """),
            ("human", """
            Please create an outfit recommendation and provide styling tips.
            Focus on creating a cohesive, flattering look that suits the occasion.
            
            Return your response in this format:
            OUTFIT: [list items to combine]
            STYLING_TIPS: [specific styling advice]
            ALTERNATIVES: [alternative pieces or combinations]
            CONFIDENCE: [rating 1-10]
            """)
        ])
    
    def _initialize_style_rules(self) -> Dict[str, Any]:
        """Initialize fashion styling rules and guidelines."""
        return {
            'color_combinations': {
                'safe': [
                    ('black', 'white'), ('navy', 'white'), ('gray', 'white'),
                    ('beige', 'brown'), ('navy', 'beige')
                ],
                'bold': [
                    ('red', 'black'), ('blue', 'orange'), ('purple', 'yellow')
                ]
            },
            'occasion_formality': {
                Occasion.WORK: (0.6, 1.0),
                Occasion.FORMAL: (0.8, 1.0),
                Occasion.CASUAL: (0.0, 0.5),
                Occasion.DATE: (0.4, 0.8),
                Occasion.PARTY: (0.3, 0.9)
            },
            'body_type_guidelines': {
                BodyType.PEAR: {
                    'emphasize': ['shoulders', 'upper_body'],
                    'avoid': ['tight_bottom', 'low_waist']
                },
                BodyType.APPLE: {
                    'emphasize': ['legs', 'arms'],
                    'avoid': ['tight_waist', 'bulk_middle']
                },
                BodyType.RECTANGLE: {
                    'emphasize': ['waist', 'curves'],
                    'avoid': ['boxy_shapes']
                },
                BodyType.HOURGLASS: {
                    'emphasize': ['waist', 'curves'],
                    'avoid': ['loose_fit', 'boxy']
                }
            }
        }
    
    def generate_outfit_recommendation(self, user_profile: UserProfile, 
                                     occasion: Occasion, season: Season,
                                     weather_temp: float = 20.0) -> OutfitRecommendation:
        """Generate comprehensive outfit recommendation."""
        try:
            # Filter appropriate items
            suitable_items = self._filter_suitable_items(
                user_profile.wardrobe_items, occasion, season, weather_temp
            )
            
            if not suitable_items:
                return self._create_empty_recommendation()
            
            # Generate outfit combinations
            outfit_combinations = self._generate_combinations(suitable_items, occasion)
            
            # Score and rank combinations
            best_outfit = self._select_best_outfit(
                outfit_combinations, user_profile, occasion, season
            )
            
            # Get styling tips
            styling_tips = self._generate_styling_tips(
                best_outfit, user_profile, occasion
            )
            
            # Calculate scores
            style_score = self._calculate_style_score(best_outfit, user_profile)
            color_harmony = self._calculate_color_harmony(best_outfit)
            season_score = self._calculate_season_appropriateness(best_outfit, season)
            
            overall_rating = (style_score + color_harmony + season_score) / 3
            
            return OutfitRecommendation(
                outfit_id=str(uuid.uuid4()),
                items=best_outfit,
                occasion=occasion,
                style_score=style_score,
                color_harmony=color_harmony,
                season_appropriateness=season_score,
                overall_rating=overall_rating,
                styling_tips=styling_tips
            )
            
        except Exception as e:
            logger.error(f"Outfit generation error: {e}")
            return self._create_empty_recommendation()
    
    def _filter_suitable_items(self, items: List[ClothingItem], occasion: Occasion,
                             season: Season, weather_temp: float) -> List[ClothingItem]:
        """Filter wardrobe items suitable for occasion and season."""
        suitable_items = []
        
        formality_range = self.style_rules['occasion_formality'].get(
            occasion, (0.0, 1.0)
        )
        
        for item in items:
            # Check formality
            if not (formality_range[0] <= item.formality_level <= formality_range[1]):
                continue
            
            # Check season appropriateness
            if season not in item.season:
                continue
            
            # Check weather appropriateness
            if self._is_weather_appropriate(item, weather_temp):
                suitable_items.append(item)
        
        return suitable_items
    
    def _is_weather_appropriate(self, item: ClothingItem, temp: float) -> bool:
        """Check if item is appropriate for weather temperature."""
        temp_ranges = {
            'hot': (25, 50),      # > 25Â°C
            'warm': (20, 30),     # 20-30Â°C
            'mild': (15, 25),     # 15-25Â°C
            'cool': (10, 20),     # 10-20Â°C
            'cold': (-10, 15)     # < 15Â°C
        }
        
        # Simple mapping of clothing to temperature appropriateness
        if item.category == ClothingCategory.OUTERWEAR:
            return temp < 20  # Outerwear for cooler weather
        elif item.material in ['wool', 'cashmere']:
            return temp < 25  # Warm materials for cooler weather
        elif item.material in ['linen', 'cotton'] and 'tank' in item.name:
            return temp > 15  # Light materials for warmer weather
        
        return True  # Default: appropriate for all temperatures
    
    def _generate_combinations(self, items: List[ClothingItem], 
                             occasion: Occasion) -> List[List[ClothingItem]]:
        """Generate valid outfit combinations."""
        combinations = []
        
        # Group items by category
        by_category = {}
        for item in items:
            if item.category not in by_category:
                by_category[item.category] = []
            by_category[item.category].append(item)
        
        # Generate basic top + bottom combinations
        tops = by_category.get(ClothingCategory.TOP, [])
        bottoms = by_category.get(ClothingCategory.BOTTOM, [])
        dresses = by_category.get(ClothingCategory.DRESS, [])
        outerwear = by_category.get(ClothingCategory.OUTERWEAR, [])
        shoes = by_category.get(ClothingCategory.SHOES, [])
        
        # Top + Bottom combinations
        for top in tops:
            for bottom in bottoms:
                outfit = [top, bottom]
                
                # Add shoes if available
                if shoes:
                    best_shoe = self._select_best_matching_shoe(
                        outfit, shoes, occasion
                    )
                    if best_shoe:
                        outfit.append(best_shoe)
                
                # Add outerwear if needed
                if outerwear and occasion in [Occasion.WORK, Occasion.FORMAL]:
                    best_outerwear = self._select_best_outerwear(
                        outfit, outerwear
                    )
                    if best_outerwear:
                        outfit.append(best_outerwear)
                
                combinations.append(outfit)
        
        # Dress combinations
        for dress in dresses:
            outfit = [dress]
            
            if shoes:
                best_shoe = self._select_best_matching_shoe(
                    outfit, shoes, occasion
                )
                if best_shoe:
                    outfit.append(best_shoe)
            
            combinations.append(outfit)
        
        return combinations[:20]  # Limit combinations for performance
    
    def _select_best_matching_shoe(self, outfit: List[ClothingItem],
                                  available_shoes: List[ClothingItem],
                                  occasion: Occasion) -> Optional[ClothingItem]:
        """Select best matching shoe for outfit."""
        if not available_shoes:
            return None
        
        # Score shoes based on formality match and color coordination
        best_shoe = None
        best_score = 0
        
        outfit_formality = np.mean([item.formality_level for item in outfit])
        
        for shoe in available_shoes:
            score = 0
            
            # Formality match
            formality_diff = abs(shoe.formality_level - outfit_formality)
            score += (1 - formality_diff) * 0.6
            
            # Color coordination
            if self._colors_coordinate(outfit + [shoe]):
                score += 0.4
            
            if score > best_score:
                best_score = score
                best_shoe = shoe
        
        return best_shoe
    
    def _select_best_outerwear(self, outfit: List[ClothingItem],
                              available_outerwear: List[ClothingItem]) -> Optional[ClothingItem]:
        """Select best outerwear for outfit."""
        if not available_outerwear:
            return None
        
        # Simple selection based on formality and color
        outfit_formality = np.mean([item.formality_level for item in outfit])
        
        best_outerwear = None
        best_score = 0
        
        for outerwear in available_outerwear:
            score = 0
            
            # Formality match
            formality_diff = abs(outerwear.formality_level - outfit_formality)
            score += (1 - formality_diff) * 0.7
            
            # Color coordination
            if self._colors_coordinate(outfit + [outerwear]):
                score += 0.3
            
            if score > best_score:
                best_score = score
                best_outerwear = outerwear
        
        return best_outerwear
    
    def _colors_coordinate(self, items: List[ClothingItem]) -> bool:
        """Check if colors in outfit coordinate well."""
        if len(items) < 2:
            return True
        
        colors = [item.dominant_color for item in items]
        
        # Use color analyzer to check harmony
        color_profile = ColorProfile(
            dominant_colors=colors,
            color_names=[],
            color_temperature="neutral",
            brightness=0.5,
            saturation=0.5,
            harmony_score=self.color_analyzer._calculate_harmony_score(colors)
        )
        
        return color_profile.harmony_score > 0.4
    
    def _select_best_outfit(self, combinations: List[List[ClothingItem]],
                           user_profile: UserProfile, occasion: Occasion,
                           season: Season) -> List[ClothingItem]:
        """Select best outfit from combinations."""
        if not combinations:
            return []
        
        best_outfit = None
        best_score = 0
        
        for outfit in combinations:
            score = 0
            
            # Style preference match
            outfit_styles = [item.style_type for item in outfit]
            style_match = len(set(outfit_styles) & set(user_profile.preferred_styles))
            score += (style_match / len(user_profile.preferred_styles)) * 0.3
            
            # Color coordination
            if self._colors_coordinate(outfit):
                score += 0.3
            
            # Completeness (has essential pieces)
            if self._is_complete_outfit(outfit):
                score += 0.2
            
            # Variety in outfit
            categories = [item.category for item in outfit]
            score += (len(set(categories)) / len(outfit)) * 0.2
            
            if score > best_score:
                best_score = score
                best_outfit = outfit
        
        return best_outfit or combinations[0]
    
    def _is_complete_outfit(self, outfit: List[ClothingItem]) -> bool:
        """Check if outfit has essential pieces."""
        categories = [item.category for item in outfit]
        
        # Must have either (top + bottom) or dress
        has_top_bottom = (ClothingCategory.TOP in categories and 
                         ClothingCategory.BOTTOM in categories)
        has_dress = ClothingCategory.DRESS in categories
        
        return has_top_bottom or has_dress
    
    def _calculate_style_score(self, outfit: List[ClothingItem], 
                              user_profile: UserProfile) -> float:
        """Calculate style compatibility score."""
        if not outfit:
            return 0.0
        
        style_scores = []
        
        # Style preference alignment
        outfit_styles = [item.style_type for item in outfit]
        user_styles = set(user_profile.preferred_styles)
        
        for style in outfit_styles:
            if style in user_styles:
                style_scores.append(1.0)
            else:
                style_scores.append(0.5)
        
        return np.mean(style_scores)
    
    def _calculate_color_harmony(self, outfit: List[ClothingItem]) -> float:
        """Calculate color harmony score for outfit."""
        if not outfit:
            return 0.0
        
        colors = [item.dominant_color for item in outfit]
        return self.color_analyzer._calculate_harmony_score(colors)
    
    def _calculate_season_appropriateness(self, outfit: List[ClothingItem],
                                        season: Season) -> float:
        """Calculate seasonal appropriateness score."""
        if not outfit:
            return 0.0
        
        season_scores = []
        
        for item in outfit:
            if season in item.season:
                season_scores.append(1.0)
            else:
                season_scores.append(0.5)
        
        return np.mean(season_scores)
    
    def _generate_styling_tips(self, outfit: List[ClothingItem],
                              user_profile: UserProfile, 
                              occasion: Occasion) -> List[str]:
        """Generate specific styling tips for the outfit."""
        tips = []
        
        if not outfit:
            return ["Please add more items to your wardrobe for better recommendations."]
        
        # Use LLM for advanced tips if available
        if self.llm:
            try:
                response = self.llm.invoke(self.styling_prompt.format(
                    user_profile=f"Body type: {user_profile.body_type.value}, Preferences: {user_profile.preferred_styles}",
                    wardrobe_items=[item.name for item in outfit],
                    occasion=occasion.value,
                    season="current"
                ))
                
                content = response.content
                
                # Parse styling tips from response
                if "STYLING_TIPS:" in content:
                    tips_section = content.split("STYLING_TIPS:")[1].split("ALTERNATIVES:")[0]
                    tips = [tip.strip() for tip in tips_section.split('\n') if tip.strip()]
            
            except Exception as e:
                logger.error(f"LLM styling tips error: {e}")
        
        # Fallback to rule-based tips
        if not tips:
            tips = self._generate_rule_based_tips(outfit, user_profile, occasion)
        
        return tips[:5]  # Limit to 5 tips
    
    def _generate_rule_based_tips(self, outfit: List[ClothingItem],
                                 user_profile: UserProfile,
                                 occasion: Occasion) -> List[str]:
        """Generate rule-based styling tips."""
        tips = []
        
        # Body type specific tips
        body_guidelines = self.style_rules['body_type_guidelines'].get(
            user_profile.body_type, {}
        )
        
        if body_guidelines:
            emphasize = body_guidelines.get('emphasize', [])
            if 'waist' in emphasize:
                tips.append("Consider adding a belt to emphasize your waist")
        
        # Color coordination tips
        colors = [item.dominant_color for item in outfit]
        if len(set(colors)) > 3:
            tips.append("Try limiting to 2-3 main colors for a more cohesive look")
        
        # Occasion-specific tips
        if occasion == Occasion.WORK:
            tips.append("Ensure the outfit maintains professional standards")
        elif occasion == Occasion.DATE:
            tips.append("Add a statement accessory to elevate the look")
        elif occasion == Occasion.CASUAL:
            tips.append("Focus on comfort while maintaining style")
        
        # General styling tips
        tips.append("Pay attention to proportions and fit")
        tips.append("Consider the overall silhouette of your outfit")
        
        return tips
    
    def _create_empty_recommendation(self) -> OutfitRecommendation:
        """Create empty recommendation when no suitable items found."""
        return OutfitRecommendation(
            outfit_id=str(uuid.uuid4()),
            items=[],
            occasion=Occasion.CASUAL,
            style_score=0.0,
            color_harmony=0.0,
            season_appropriateness=0.0,
            overall_rating=0.0,
            styling_tips=["Please add more clothing items to your wardrobe for recommendations."]
        )

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="AI Fashion Stylist",
        page_icon="ðŸ‘—",
        layout="wide"
    )
    
    st.title("ðŸ‘— AI Fashion Stylist Bot")
    st.markdown("Your personal AI fashion consultant for style advice and outfit recommendations")
    
    # Initialize session state
    if 'user_profile' not in st.session_state:
        st.session_state['user_profile'] = UserProfile(
            user_id="demo_user",
            name="Demo User",
            body_type=BodyType.RECTANGLE,
            preferred_styles=[StyleType.CASUAL, StyleType.MINIMALIST],
            color_preferences=["black", "white", "navy", "gray"],
            lifestyle="professional",
            budget_range=(50, 200),
            size_info={"top": "M", "bottom": "32", "dress": "M", "shoes": "8"}
        )
    
    if 'style_engine' not in st.session_state:
        openai_key = st.sidebar.text_input("OpenAI API Key (Optional)", type="password")
        with st.spinner("Initializing AI Fashion Stylist..."):
            st.session_state['style_engine'] = StyleRecommendationEngine(openai_key)
    
    style_engine = st.session_state['style_engine']
    user_profile = st.session_state['user_profile']
    
    # Sidebar
    with st.sidebar:
        st.header("ðŸ‘¤ Style Profile")
        
        # User preferences
        body_type = st.selectbox("Body Type", [bt.value for bt in BodyType])
        user_profile.body_type = BodyType(body_type)
        
        preferred_styles = st.multiselect(
            "Preferred Styles",
            [style.value for style in StyleType],
            default=[style.value for style in user_profile.preferred_styles]
        )
        user_profile.preferred_styles = [StyleType(style) for style in preferred_styles]
        
        colors = st.multiselect(
            "Favorite Colors",
            ["black", "white", "navy", "gray", "red", "blue", "green", "pink", "yellow", "purple"],
            default=user_profile.color_preferences
        )
        user_profile.color_preferences = colors
    
    # Main tabs
    tab1, tab2, tab3, tab4 = st.tabs([
        "ðŸ‘— Outfit Recommendations",
        "ðŸ‘• Wardrobe Management", 
        "ðŸŽ¨ Style Analysis",
        "ðŸ“Š Style Statistics"
    ])
    
    with tab1:
        st.header("âœ¨ Get Outfit Recommendations")
        
        col1, col2 = st.columns(2)
        
        with col1:
            occasion = st.selectbox("Occasion", [occ.value for occ in Occasion])
            season = st.selectbox("Season", [seas.value for seas in Season])
            temperature = st.slider("Temperature (Â°C)", -10, 40, 20)
        
        with col2:
            if st.button("ðŸŽ¯ Generate Outfit", type="primary"):
                if user_profile.wardrobe_items:
                    with st.spinner("Creating your perfect outfit..."):
                        recommendation = style_engine.generate_outfit_recommendation(
                            user_profile,
                            Occasion(occasion),
                            Season(season),
                            temperature
                        )
                        
                        st.session_state['current_recommendation'] = recommendation
                else:
                    st.warning("Please add some clothing items to your wardrobe first!")
        
        # Display recommendation
        if 'current_recommendation' in st.session_state:
            rec = st.session_state['current_recommendation']
            
            if rec.items:
                st.subheader("ðŸŒŸ Your Recommended Outfit")
                
                # Outfit items
                for item in rec.items:
                    with st.expander(f"ðŸ‘• {item.name.title()}"):
                        col1, col2 = st.columns(2)
                        with col1:
                            st.write(f"**Category:** {item.category.value.title()}")
                            st.write(f"**Style:** {item.style_type.value.title()}")
                            st.write(f"**Colors:** {', '.join(item.colors)}")
                        with col2:
                            st.write(f"**Material:** {item.material.title()}")
                            st.write(f"**Pattern:** {item.pattern.title()}")
                            st.write(f"**Formality:** {item.formality_level:.0%}")
                
                # Scores
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Overall Rating", f"{rec.overall_rating:.1%}")
                with col2:
                    st.metric("Style Score", f"{rec.style_score:.1%}")
                with col3:
                    st.metric("Color Harmony", f"{rec.color_harmony:.1%}")
                with col4:
                    st.metric("Season Match", f"{rec.season_appropriateness:.1%}")
                
                # Styling tips
                st.subheader("ðŸ’¡ Styling Tips")
                for tip in rec.styling_tips:
                    st.info(f"âœ¨ {tip}")
            
            else:
                st.warning("No suitable outfit found. Try adding more items to your wardrobe!")
    
    with tab2:
        st.header("ðŸ‘• Wardrobe Management")
        
        # Add new item
        st.subheader("âž• Add Clothing Item")
        
        col1, col2 = st.columns(2)
        
        with col1:
            item_name = st.text_input("Item Name", placeholder="e.g., Navy Blue Blazer")
            category = st.selectbox("Category", [cat.value for cat in ClothingCategory])
            style_type = st.selectbox("Style Type", [style.value for style in StyleType])
            
        with col2:
            colors = st.multiselect("Colors", [
                "black", "white", "navy", "gray", "red", "blue", "green", 
                "pink", "yellow", "purple", "brown", "beige"
            ])
            material = st.selectbox("Material", [
                "cotton", "polyester", "wool", "silk", "linen", "denim",
                "leather", "cashmere", "other"
            ])
            pattern = st.selectbox("Pattern", [
                "solid", "striped", "plaid", "floral", "polka dot", "geometric"
            ])
        
        seasons = st.multiselect("Suitable Seasons", [season.value for season in Season])
        formality = st.slider("Formality Level", 0.0, 1.0, 0.5, 0.1)
        
        if st.button("Add Item"):
            if item_name and colors and seasons:
                new_item = ClothingItem(
                    item_id=str(uuid.uuid4()),
                    name=item_name.lower(),
                    category=ClothingCategory(category),
                    style_type=StyleType(style_type),
                    colors=colors,
                    dominant_color=(128, 128, 128),  # Default gray
                    pattern=pattern,
                    material=material,
                    season=[Season(s) for s in seasons],
                    formality_level=formality
                )
                
                user_profile.wardrobe_items.append(new_item)
                st.success(f"Added {item_name} to your wardrobe!")
                st.rerun()
            else:
                st.error("Please fill in all required fields")
        
        # Display wardrobe
        st.subheader("ðŸ‘” Your Wardrobe")
        
        if user_profile.wardrobe_items:
            for item in user_profile.wardrobe_items:
                with st.expander(f"ðŸ‘— {item.name.title()}"):
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.write(f"**Category:** {item.category.value.title()}")
                        st.write(f"**Style:** {item.style_type.value.title()}")
                        st.write(f"**Colors:** {', '.join(item.colors)}")
                    
                    with col2:
                        st.write(f"**Material:** {item.material.title()}")
                        st.write(f"**Pattern:** {item.pattern.title()}")
                        st.write(f"**Seasons:** {', '.join([s.value for s in item.season])}")
                    
                    with col3:
                        st.write(f"**Formality:** {item.formality_level:.0%}")
                        st.write(f"**Wear Count:** {item.wear_count}")
                        
                        if st.button(f"Remove", key=f"remove_{item.item_id}"):
                            user_profile.wardrobe_items.remove(item)
                            st.rerun()
        else:
            st.info("Your wardrobe is empty. Add some clothing items to get started!")
    
    with tab3:
        st.header("ðŸŽ¨ Style Analysis")
        
        if user_profile.wardrobe_items:
            # Wardrobe statistics
            st.subheader("ðŸ“Š Wardrobe Overview")
            
            # Category distribution
            categories = [item.category.value for item in user_profile.wardrobe_items]
            category_counts = pd.Series(categories).value_counts()
            
            fig = px.pie(
                values=category_counts.values,
                names=category_counts.index,
                title="Wardrobe by Category"
            )
            st.plotly_chart(fig, use_container_width=True)
            
            # Style distribution
            styles = [item.style_type.value for item in user_profile.wardrobe_items]
            style_counts = pd.Series(styles).value_counts()
            
            fig = px.bar(
                x=style_counts.index,
                y=style_counts.values,
                title="Style Type Distribution",
                labels={'x': 'Style Type', 'y': 'Count'}
            )
            st.plotly_chart(fig, use_container_width=True)
            
            # Color analysis
            st.subheader("ðŸŒˆ Color Analysis")
            all_colors = []
            for item in user_profile.wardrobe_items:
                all_colors.extend(item.colors)
            
            color_counts = pd.Series(all_colors).value_counts()
            
            fig = px.bar(
                x=color_counts.index,
                y=color_counts.values,
                title="Most Used Colors",
                labels={'x': 'Color', 'y': 'Count'}
            )
            st.plotly_chart(fig, use_container_width=True)
            
            # Formality analysis
            formality_levels = [item.formality_level for item in user_profile.wardrobe_items]
            
            fig = px.histogram(
                x=formality_levels,
                title="Formality Level Distribution",
                labels={'x': 'Formality Level', 'y': 'Count'},
                nbins=10
            )
            st.plotly_chart(fig, use_container_width=True)
        
        else:
            st.info("Add clothing items to see style analysis")
    
    with tab4:
        st.header("ðŸ“ˆ Style Statistics")
        
        if user_profile.wardrobe_items:
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Total Items", len(user_profile.wardrobe_items))
            
            with col2:
                categories = len(set(item.category for item in user_profile.wardrobe_items))
                st.metric("Categories", categories)
            
            with col3:
                styles = len(set(item.style_type for item in user_profile.wardrobe_items))
                st.metric("Style Types", styles)
            
            with col4:
                avg_formality = np.mean([item.formality_level for item in user_profile.wardrobe_items])
                st.metric("Avg Formality", f"{avg_formality:.1%}")
            
            # Style preferences vs wardrobe
            st.subheader("ðŸŽ¯ Style Alignment")
            
            preferred_styles = [style.value for style in user_profile.preferred_styles]
            wardrobe_styles = [item.style_type.value for item in user_profile.wardrobe_items]
            
            alignment_data = []
            for style in preferred_styles:
                count = wardrobe_styles.count(style)
                alignment_data.append({'Style': style, 'Count': count, 'Type': 'Preferred'})
            
            alignment_df = pd.DataFrame(alignment_data)
            
            if not alignment_df.empty:
                fig = px.bar(
                    alignment_df,
                    x='Style',
                    y='Count',
                    title="Preferred Styles vs Wardrobe Items",
                    color='Type'
                )
                st.plotly_chart(fig, use_container_width=True)
            
            # Seasonal coverage
            st.subheader("ðŸŒ¦ï¸ Seasonal Coverage")
            
            season_coverage = {season.value: 0 for season in Season}
            
            for item in user_profile.wardrobe_items:
                for season in item.season:
                    season_coverage[season.value] += 1
            
            fig = px.bar(
                x=list(season_coverage.keys()),
                y=list(season_coverage.values()),
                title="Items per Season",
                labels={'x': 'Season', 'y': 'Item Count'}
            )
            st.plotly_chart(fig, use_container_width=True)
        
        else:
            st.info("Add clothing items to see statistics")

if __name__ == "__main__":
    main()
````

## Project Summary

The AI Fashion Stylist Bot represents an advanced fashion technology system that combines computer vision, color theory, and artificial intelligence to provide personalized styling advice and outfit recommendations through multimodal fashion intelligence.

### Key Value Propositions:
- **Intelligent Style Detection**: Advanced computer vision analysis of clothing items with automatic categorization, pattern recognition, and style classification
- **Personalized Outfit Generation**: AI-powered outfit combinations considering body type, occasion, weather, and personal preferences with color harmony optimization
- **Multimodal Fashion Intelligence**: Integration of visual analysis and natural language processing for comprehensive fashion understanding and trend incorporation
- **Seasonal Trend Integration**: Dynamic trend analysis incorporating current fashion movements, seasonal appropriateness, and style evolution patterns
- **Color Harmony Expertise**: Sophisticated color theory application with complementary, analogous, and triadic color scheme analysis for visually appealing combinations

### Technical Highlights:
- Advanced image processing pipeline using PIL, OpenCV, and ColorThief for comprehensive clothing analysis with pattern and material detection
- BLIP transformer model integration for intelligent image captioning and automated clothing item description generation
- LangChain-enhanced styling advice generation with OpenAI GPT-4 integration for professional-level fashion recommendations
- Comprehensive color analysis system implementing color theory principles with harmony scoring and temperature classification
- Interactive Streamlit interface providing wardrobe management, outfit generation, style analysis, and fashion statistics dashboards
- Modular architecture supporting easy integration of new fashion trends, style rules, and recommendation algorithms

This system democratizes fashion expertise by making professional styling accessible to everyone while promoting sustainable fashion choices through intelligent wardrobe optimization and comprehensive outfit planning capabilities.