<small>Claude Sonnet 4 **(Multi-Agent Game Master for RPG - AI-Enhanced MCP Integration)**</small>
# Multi-Agent Game Master (RPG)

## Key Concepts Explanation

### Model Context Protocol (MCP)
Advanced context management framework for RPG games that maintains comprehensive world state, character memories, quest progressions, and narrative continuity across game sessions, enabling persistent storytelling and dynamic narrative adaptation based on player actions and choices.

### CrewAI Multi-Agent Orchestration
Sophisticated agent coordination system that manages specialized RPG agents including Dungeon Master, Character Manager, World Builder, Quest Designer, and Combat Resolver, each with distinct roles and expertise working collaboratively to create immersive gaming experiences.

### LangGraph RPG Workflow Management
Graph-based workflow orchestration that manages complex RPG mechanics including turn-based combat, dialogue trees, skill checks, inventory management, and story progression through interconnected nodes representing game states and decision points.

### Character Memory System
Persistent memory architecture that tracks individual character backstories, personality traits, relationships, skill development, inventory states, and personal quest lines, enabling consistent character behavior and meaningful character progression over time.

### Dynamic World Context
Evolving world state management that tracks locations, NPCs, factions, political situations, economic conditions, and environmental changes, creating a living world that responds to player actions and maintains internal consistency across storylines.

### Function Calling & JSON Tools
Intelligent tool integration system that handles game mechanics through structured function calls including dice rolling, stat calculations, inventory management, spell casting, and rule enforcement while maintaining game balance and narrative flow.

## Comprehensive Project Explanation

The Multi-Agent Game Master revolutionizes text-based role-playing games by providing AI-enhanced game mastering capabilities that maintain persistent world states, develop compelling narratives, and manage complex game mechanics through coordinated AI agents. This system enables immersive RPG experiences with dynamic storytelling, consistent character development, and adaptive gameplay that responds intelligently to player choices.

### Objectives
- **Intelligent Game Mastering**: Provide comprehensive AI-driven game master capabilities that create engaging narratives, manage game mechanics, and adapt storylines dynamically based on player actions and preferences
- **Persistent World Management**: Maintain detailed world states including geography, politics, economics, and social structures that evolve organically based on player interactions and time progression
- **Character Development Excellence**: Enable deep character progression with persistent memories, skill development, relationship tracking, and meaningful backstory integration that influences gameplay and narrative direction
- **Multi-Agent Coordination**: Orchestrate specialized AI agents for different game aspects including storytelling, combat resolution, world building, and character management to create cohesive and immersive experiences
- **Dynamic Narrative Generation**: Generate adaptive storylines with branching narratives, consequential choices, and emergent plot developments that maintain narrative coherence while responding to player agency

### Challenges
- **Narrative Consistency**: Maintaining coherent storylines and character motivations across extended game sessions while allowing for player agency and emergent narrative developments
- **Complex Rule Management**: Implementing comprehensive RPG rule systems including combat mechanics, skill checks, magic systems, and character progression while maintaining game balance and fairness
- **Agent Coordination**: Ensuring seamless collaboration between specialized agents while preventing conflicts and maintaining consistent world state and character information
- **Memory Scalability**: Managing large amounts of persistent data including character histories, world states, and narrative progressions without performance degradation
- **Player Experience Balance**: Balancing challenge levels, narrative pacing, and player agency while maintaining engagement and preventing frustration or boredom

### Potential Impact
This platform could revolutionize digital role-playing experiences by providing accessible, high-quality game mastering for players without requiring human DMs, enabling solo play experiences, and supporting game masters with intelligent assistance tools that enhance creativity while reducing administrative overhead.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import logging
import os
import uuid
import random
from typing import Dict, List, Optional, Any, Union, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import numpy as np

# CrewAI and multi-agent
from crewai import Agent, Task, Crew, Process
from crewai.tools import BaseTool, tool

# LangGraph
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolExecutor

# LangChain
from langchain.chat_models import ChatOpenAI
from langchain.schema import BaseMessage, HumanMessage, AIMessage, SystemMessage
from langchain.memory import ConversationBufferWindowMemory
from langchain.prompts import PromptTemplate, ChatPromptTemplate
from langchain.tools import BaseTool

# Database
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, DateTime, Text, JSON, Integer, Boolean, Float

# Vector store for world knowledge
from langchain.vectorstores import Chroma
from langchain.embeddings import OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document

# Web framework
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

# Utilities
import aiofiles
from pydantic import BaseModel
import warnings
warnings.filterwarnings('ignore')

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database Models
Base = declarative_base()

class GameSession(Base):
    __tablename__ = "game_sessions"
    
    id = Column(String, primary_key=True)
    campaign_name = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_played = Column(DateTime, default=datetime.utcnow)
    session_count = Column(Integer, default=0)
    world_state = Column(JSON)
    active_players = Column(JSON)
    current_scene = Column(String)
    game_metadata = Column(JSON)

class Character(Base):
    __tablename__ = "characters"
    
    id = Column(String, primary_key=True)
    session_id = Column(String, nullable=False)
    name = Column(String, nullable=False)
    character_class = Column(String)
    level = Column(Integer, default=1)
    stats = Column(JSON)  # STR, DEX, CON, INT, WIS, CHA
    skills = Column(JSON)
    inventory = Column(JSON)
    backstory = Column(Text)
    personality = Column(JSON)
    relationships = Column(JSON)
    quest_log = Column(JSON)
    current_hp = Column(Integer)
    max_hp = Column(Integer)
    experience = Column(Integer, default=0)
    location = Column(String)
    character_memory = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

class WorldLocation(Base):
    __tablename__ = "world_locations"
    
    id = Column(String, primary_key=True)
    session_id = Column(String, nullable=False)
    name = Column(String, nullable=False)
    description = Column(Text)
    location_type = Column(String)  # city, dungeon, wilderness, etc.
    connections = Column(JSON)  # Connected locations
    npcs = Column(JSON)
    items = Column(JSON)
    events = Column(JSON)
    political_state = Column(JSON)
    economic_state = Column(JSON)
    environment = Column(JSON)
    secrets = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

class GameEvent(Base):
    __tablename__ = "game_events"
    
    id = Column(String, primary_key=True)
    session_id = Column(String, nullable=False)
    event_type = Column(String)  # combat, dialogue, skill_check, story
    description = Column(Text)
    participants = Column(JSON)
    outcomes = Column(JSON)
    world_changes = Column(JSON)
    character_changes = Column(JSON)
    timestamp = Column(DateTime, default=datetime.utcnow)
    scene_context = Column(JSON)

class Quest(Base):
    __tablename__ = "quests"
    
    id = Column(String, primary_key=True)
    session_id = Column(String, nullable=False)
    title = Column(String, nullable=False)
    description = Column(Text)
    quest_giver = Column(String)
    quest_type = Column(String)  # main, side, personal
    status = Column(String, default="active")  # active, completed, failed
    objectives = Column(JSON)
    rewards = Column(JSON)
    prerequisites = Column(JSON)
    time_limit = Column(DateTime)
    character_assignments = Column(JSON)
    progress_tracking = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

# Enums and Data Classes
class DiceType(Enum):
    D4 = 4
    D6 = 6
    D8 = 8
    D10 = 10
    D12 = 12
    D20 = 20
    D100 = 100

class ActionType(Enum):
    COMBAT = "combat"
    SKILL_CHECK = "skill_check"
    DIALOGUE = "dialogue"
    EXPLORATION = "exploration"
    REST = "rest"
    INVENTORY = "inventory"

@dataclass
class GameState:
    session_id: str
    current_scene: str
    active_characters: List[str]
    world_context: Dict[str, Any]
    turn_order: List[str]
    pending_actions: List[Dict[str, Any]]
    narrative_context: str
    last_event: Dict[str, Any]

@dataclass
class CharacterStats:
    strength: int = 10
    dexterity: int = 10
    constitution: int = 10
    intelligence: int = 10
    wisdom: int = 10
    charisma: int = 10

@dataclass
class ActionResult:
    success: bool
    result_description: str
    dice_rolls: List[Dict[str, Any]]
    world_changes: Dict[str, Any]
    character_changes: Dict[str, Any]
    narrative_impact: str

class DiceRoller:
    """Handles all dice rolling mechanics"""
    
    @staticmethod
    def roll_dice(dice_type: DiceType, count: int = 1, modifier: int = 0) -> Dict[str, Any]:
        """Roll dice with modifier"""
        rolls = [random.randint(1, dice_type.value) for _ in range(count)]
        total = sum(rolls) + modifier
        
        return {
            "dice_type": f"{count}d{dice_type.value}",
            "rolls": rolls,
            "modifier": modifier,
            "total": total,
            "individual_results": rolls
        }
    
    @staticmethod
    def roll_d20_check(modifier: int = 0, difficulty: int = 15) -> Dict[str, Any]:
        """Standard D20 check against difficulty"""
        roll_result = DiceRoller.roll_dice(DiceType.D20, 1, modifier)
        success = roll_result["total"] >= difficulty
        
        return {
            **roll_result,
            "difficulty": difficulty,
            "success": success,
            "margin": roll_result["total"] - difficulty
        }
    
    @staticmethod
    def roll_initiative() -> int:
        """Roll initiative (D20 + DEX modifier)"""
        return DiceRoller.roll_dice(DiceType.D20, 1)["total"]

class CharacterManager:
    """Manages character data and operations"""
    
    def __init__(self, session_factory):
        self.session_factory = session_factory
    
    async def create_character(self, session_id: str, character_data: Dict[str, Any]) -> str:
        """Create a new character"""
        try:
            character_id = str(uuid.uuid4())
            
            # Generate base stats if not provided
            if "stats" not in character_data:
                character_data["stats"] = self._generate_stats()
            
            # Calculate HP
            constitution_mod = self._get_ability_modifier(character_data["stats"]["constitution"])
            max_hp = 10 + constitution_mod  # Base HP calculation
            
            async with self.session_factory() as session:
                character = Character(
                    id=character_id,
                    session_id=session_id,
                    name=character_data["name"],
                    character_class=character_data.get("character_class", "Fighter"),
                    stats=character_data["stats"],
                    skills=character_data.get("skills", {}),
                    inventory=character_data.get("inventory", {"items": [], "gold": 100}),
                    backstory=character_data.get("backstory", ""),
                    personality=character_data.get("personality", {}),
                    relationships=character_data.get("relationships", {}),
                    quest_log=character_data.get("quest_log", []),
                    current_hp=max_hp,
                    max_hp=max_hp,
                    location=character_data.get("location", "starting_town"),
                    character_memory={"events": [], "npcs_met": [], "places_visited": []}
                )
                session.add(character)
                await session.commit()
            
            return character_id
            
        except Exception as e:
            logger.error(f"Character creation failed: {e}")
            raise
    
    def _generate_stats(self) -> Dict[str, int]:
        """Generate random character stats"""
        stats = {}
        for stat in ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"]:
            # Roll 4d6, drop lowest
            rolls = [random.randint(1, 6) for _ in range(4)]
            rolls.sort()
            stats[stat] = sum(rolls[-3:])  # Sum of highest 3
        return stats
    
    def _get_ability_modifier(self, score: int) -> int:
        """Calculate ability modifier from score"""
        return (score - 10) // 2
    
    async def get_character(self, character_id: str) -> Optional[Dict[str, Any]]:
        """Get character data"""
        try:
            async with self.session_factory() as session:
                result = await session.execute(
                    "SELECT * FROM characters WHERE id = ?", (character_id,)
                )
                row = result.fetchone()
                
                if row:
                    return dict(row._mapping)
                return None
                
        except Exception as e:
            logger.error(f"Character retrieval failed: {e}")
            return None
    
    async def update_character_memory(self, character_id: str, event: Dict[str, Any]):
        """Update character memory with new event"""
        try:
            async with self.session_factory() as session:
                character = await self.get_character(character_id)
                if character:
                    memory = character.get("character_memory", {"events": []})
                    memory["events"].append({
                        "timestamp": datetime.utcnow().isoformat(),
                        "event": event
                    })
                    
                    # Keep only last 100 events
                    memory["events"] = memory["events"][-100:]
                    
                    await session.execute(
                        "UPDATE characters SET character_memory = ? WHERE id = ?",
                        (json.dumps(memory), character_id)
                    )
                    await session.commit()
                    
        except Exception as e:
            logger.error(f"Character memory update failed: {e}")

class WorldBuilder:
    """Manages world state and locations"""
    
    def __init__(self, session_factory, vector_store):
        self.session_factory = session_factory
        self.vector_store = vector_store
    
    async def create_location(self, session_id: str, location_data: Dict[str, Any]) -> str:
        """Create a new world location"""
        try:
            location_id = str(uuid.uuid4())
            
            async with self.session_factory() as session:
                location = WorldLocation(
                    id=location_id,
                    session_id=session_id,
                    name=location_data["name"],
                    description=location_data.get("description", ""),
                    location_type=location_data.get("location_type", "generic"),
                    connections=location_data.get("connections", []),
                    npcs=location_data.get("npcs", []),
                    items=location_data.get("items", []),
                    events=location_data.get("events", []),
                    political_state=location_data.get("political_state", {}),
                    economic_state=location_data.get("economic_state", {}),
                    environment=location_data.get("environment", {}),
                    secrets=location_data.get("secrets", [])
                )
                session.add(location)
                await session.commit()
            
            # Add to vector store for semantic search
            doc = Document(
                page_content=f"{location_data['name']}: {location_data.get('description', '')}",
                metadata={"location_id": location_id, "type": "location"}
            )
            self.vector_store.add_documents([doc])
            
            return location_id
            
        except Exception as e:
            logger.error(f"Location creation failed: {e}")
            raise
    
    async def get_world_state(self, session_id: str) -> Dict[str, Any]:
        """Get comprehensive world state"""
        try:
            async with self.session_factory() as session:
                # Get all locations
                locations_result = await session.execute(
                    "SELECT * FROM world_locations WHERE session_id = ?", (session_id,)
                )
                locations = [dict(row._mapping) for row in locations_result.fetchall()]
                
                # Get active quests
                quests_result = await session.execute(
                    "SELECT * FROM quests WHERE session_id = ? AND status = 'active'", (session_id,)
                )
                quests = [dict(row._mapping) for row in quests_result.fetchall()]
                
                # Get recent events
                events_result = await session.execute(
                    """SELECT * FROM game_events WHERE session_id = ? 
                       ORDER BY timestamp DESC LIMIT 20""", (session_id,)
                )
                recent_events = [dict(row._mapping) for row in events_result.fetchall()]
                
                return {
                    "locations": locations,
                    "active_quests": quests,
                    "recent_events": recent_events,
                    "world_time": datetime.utcnow().isoformat()
                }
                
        except Exception as e:
            logger.error(f"World state retrieval failed: {e}")
            return {}
    
    async def update_location_state(self, location_id: str, updates: Dict[str, Any]):
        """Update location state"""
        try:
            async with self.session_factory() as session:
                update_fields = []
                values = []
                
                for field, value in updates.items():
                    if field in ["npcs", "items", "events", "political_state", "economic_state"]:
                        update_fields.append(f"{field} = ?")
                        values.append(json.dumps(value))
                
                if update_fields:
                    values.append(location_id)
                    query = f"UPDATE world_locations SET {', '.join(update_fields)} WHERE id = ?"
                    await session.execute(query, tuple(values))
                    await session.commit()
                    
        except Exception as e:
            logger.error(f"Location update failed: {e}")

class RPGTools:
    """Collection of RPG-specific tools"""
    
    def __init__(self, character_manager: CharacterManager, world_builder: WorldBuilder):
        self.character_manager = character_manager
        self.world_builder = world_builder
        self.dice_roller = DiceRoller()
    
    def create_tools(self) -> List[BaseTool]:
        """Create RPG tools for agents"""
        
        @tool
        def roll_dice(dice_notation: str, modifier: int = 0) -> str:
            """Roll dice using standard notation (e.g., '2d6', '1d20')"""
            try:
                # Parse dice notation
                if 'd' not in dice_notation.lower():
                    return "Invalid dice notation. Use format like '2d6' or '1d20'"
                
                parts = dice_notation.lower().split('d')
                count = int(parts[0]) if parts[0] else 1
                sides = int(parts[1])
                
                # Map to DiceType
                dice_map = {4: DiceType.D4, 6: DiceType.D6, 8: DiceType.D8, 
                           10: DiceType.D10, 12: DiceType.D12, 20: DiceType.D20, 100: DiceType.D100}
                
                if sides not in dice_map:
                    return f"Unsupported dice type: d{sides}"
                
                result = self.dice_roller.roll_dice(dice_map[sides], count, modifier)
                return f"Rolled {dice_notation}: {result['rolls']} + {modifier} = {result['total']}"
                
            except Exception as e:
                return f"Dice roll failed: {e}"
        
        @tool
        def skill_check(character_id: str, skill: str, difficulty: int = 15) -> str:
            """Perform a skill check for a character"""
            try:
                # This would get character stats and calculate skill modifier
                # Simplified version
                modifier = random.randint(-2, 5)  # Simulate skill modifier
                result = self.dice_roller.roll_d20_check(modifier, difficulty)
                
                success_text = "Success!" if result["success"] else "Failure!"
                return f"{skill} check: Rolled {result['rolls'][0]} + {modifier} = {result['total']} vs DC {difficulty}. {success_text}"
                
            except Exception as e:
                return f"Skill check failed: {e}"
        
        @tool
        def combat_attack(attacker_id: str, target_id: str, weapon: str = "sword") -> str:
            """Perform a combat attack"""
            try:
                # Simplified combat mechanics
                attack_roll = self.dice_roller.roll_d20_check(5, 15)  # +5 attack bonus vs AC 15
                
                if attack_roll["success"]:
                    damage_roll = self.dice_roller.roll_dice(DiceType.D8, 1, 3)  # 1d8+3 damage
                    return f"Attack hits! Damage: {damage_roll['total']}"
                else:
                    return f"Attack misses! Rolled {attack_roll['total']} vs AC 15"
                    
            except Exception as e:
                return f"Combat attack failed: {e}"
        
        @tool
        def search_world_knowledge(query: str) -> str:
            """Search world knowledge for information"""
            try:
                # Use vector store to search for relevant world information
                results = self.world_builder.vector_store.similarity_search(query, k=3)
                
                if results:
                    return "\n".join([doc.page_content for doc in results])
                else:
                    return "No relevant information found in the world knowledge."
                    
            except Exception as e:
                return f"World knowledge search failed: {e}"
        
        @tool
        def manage_inventory(character_id: str, action: str, item: str, quantity: int = 1) -> str:
            """Manage character inventory (add, remove, use items)"""
            try:
                if action == "add":
                    return f"Added {quantity} {item}(s) to inventory"
                elif action == "remove":
                    return f"Removed {quantity} {item}(s) from inventory"
                elif action == "use":
                    return f"Used {item}"
                else:
                    return "Invalid inventory action. Use 'add', 'remove', or 'use'"
                    
            except Exception as e:
                return f"Inventory management failed: {e}"
        
        return [roll_dice, skill_check, combat_attack, search_world_knowledge, manage_inventory]

class GameMasterAgent:
    """Main game master agent using CrewAI"""
    
    def __init__(self, character_manager: CharacterManager, world_builder: WorldBuilder, 
                 rpg_tools: RPGTools):
        self.character_manager = character_manager
        self.world_builder = world_builder
        self.rpg_tools = rpg_tools
        self.llm = ChatOpenAI(model_name="gpt-4o", temperature=0.7)
        
        # Create specialized agents
        self.agents = self._create_agents()
        self.tools = rpg_tools.create_tools()
    
    def _create_agents(self) -> Dict[str, Agent]:
        """Create specialized RPG agents"""
        
        # Dungeon Master Agent
        dm_agent = Agent(
            role="Dungeon Master",
            goal="Create engaging narrative experiences and manage overall game flow",
            backstory="""You are an experienced Dungeon Master with decades of experience 
            running tabletop RPG campaigns. You excel at weaving compelling narratives, 
            creating memorable NPCs, and adapting to player choices while maintaining 
            story coherence.""",
            verbose=True,
            allow_delegation=True,
            tools=self.tools,
            llm=self.llm
        )
        
        # Combat Manager Agent
        combat_agent = Agent(
            role="Combat Manager",
            goal="Handle all combat encounters fairly and dynamically",
            backstory="""You are a tactical combat expert who ensures fair and exciting 
            combat encounters. You understand RPG mechanics deeply and can create 
            challenging but balanced fights that showcase each character's abilities.""",
            verbose=True,
            allow_delegation=False,
            tools=self.tools,
            llm=self.llm
        )
        
        # World Keeper Agent
        world_agent = Agent(
            role="World Keeper",
            goal="Maintain world consistency and manage environmental storytelling",
            backstory="""You are the keeper of world lore and consistency. You track 
            all world state changes, manage political and economic systems, and ensure 
            that the world feels alive and reactive to player actions.""",
            verbose=True,
            allow_delegation=False,
            tools=self.tools,
            llm=self.llm
        )
        
        # Character Developer Agent
        character_agent = Agent(
            role="Character Developer",
            goal="Track character growth and personal storylines",
            backstory="""You specialize in character development and personal narratives. 
            You track each character's growth, relationships, and personal quests, 
            ensuring that every character has meaningful moments and development.""",
            verbose=True,
            allow_delegation=False,
            tools=self.tools,
            llm=self.llm
        )
        
        return {
            "dm": dm_agent,
            "combat": combat_agent,
            "world": world_agent,
            "character": character_agent
        }
    
    async def process_player_action(self, session_id: str, character_id: str, 
                                  action: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Process a player action using the appropriate agents"""
        try:
            # Determine action type
            action_type = self._classify_action(action)
            
            # Get current game state
            world_state = await self.world_builder.get_world_state(session_id)
            character_data = await self.character_manager.get_character(character_id)
            
            # Create context for agents
            game_context = {
                "session_id": session_id,
                "character_id": character_id,
                "character_data": character_data,
                "world_state": world_state,
                "action": action,
                "action_type": action_type,
                "additional_context": context
            }
            
            # Route to appropriate agent workflow
            if action_type == ActionType.COMBAT:
                result = await self._handle_combat_action(game_context)
            elif action_type == ActionType.DIALOGUE:
                result = await self._handle_dialogue_action(game_context)
            elif action_type == ActionType.EXPLORATION:
                result = await self._handle_exploration_action(game_context)
            elif action_type == ActionType.SKILL_CHECK:
                result = await self._handle_skill_check_action(game_context)
            else:
                result = await self._handle_general_action(game_context)
            
            # Update character memory
            await self.character_manager.update_character_memory(character_id, {
                "action": action,
                "result": result,
                "context": context
            })
            
            return result
            
        except Exception as e:
            logger.error(f"Action processing failed: {e}")
            return {
                "success": False,
                "message": "An error occurred while processing your action.",
                "error": str(e)
            }
    
    def _classify_action(self, action: str) -> ActionType:
        """Classify the type of action being taken"""
        action_lower = action.lower()
        
        # Combat keywords
        if any(word in action_lower for word in ["attack", "fight", "combat", "hit", "strike"]):
            return ActionType.COMBAT
        
        # Dialogue keywords
        if any(word in action_lower for word in ["talk", "speak", "ask", "tell", "say"]):
            return ActionType.DIALOGUE
        
        # Exploration keywords
        if any(word in action_lower for word in ["go", "move", "explore", "search", "look"]):
            return ActionType.EXPLORATION
        
        # Skill check keywords
        if any(word in action_lower for word in ["check", "roll", "attempt", "try"]):
            return ActionType.SKILL_CHECK
        
        return ActionType.EXPLORATION  # Default
    
    async def _handle_combat_action(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Handle combat actions using combat agent"""
        try:
            # Create combat task
            combat_task = Task(
                description=f"""
                Handle combat action: {context['action']}
                
                Character: {context['character_data']['name']}
                Current HP: {context['character_data']['current_hp']}/{context['character_data']['max_hp']}
                Stats: {context['character_data']['stats']}
                
                World Context: {context['world_state']}
                
                Determine the outcome of this combat action, including:
                1. Attack rolls and damage calculations
                2. Enemy responses
                3. HP changes
                4. Tactical situation updates
                5. Narrative description of the action
                """,
                agent=self.agents["combat"],
                expected_output="Combat result with dice rolls, damage, and narrative description"
            )
            
            # Execute task
            crew = Crew(
                agents=[self.agents["combat"]],
                tasks=[combat_task],
                process=Process.sequential
            )
            
            result = crew.kickoff()
            
            return {
                "success": True,
                "action_type": "combat",
                "result": result,
                "message": "Combat action resolved",
                "dice_rolls": [],  # Would be populated by actual dice rolls
                "hp_changes": {}   # Would track HP changes
            }
            
        except Exception as e:
            logger.error(f"Combat action failed: {e}")
            return {"success": False, "message": f"Combat action failed: {e}"}
    
    async def _handle_dialogue_action(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Handle dialogue actions using DM agent"""
        try:
            dialogue_task = Task(
                description=f"""
                Handle dialogue action: {context['action']}
                
                Character: {context['character_data']['name']}
                Charisma: {context['character_data']['stats']['charisma']}
                Personality: {context['character_data']['personality']}
                
                World Context: {context['world_state']}
                
                Create engaging dialogue responses that:
                1. Stay in character for NPCs
                2. Advance the story appropriately
                3. Provide meaningful choices
                4. Reflect character relationships
                5. Include any necessary skill checks
                """,
                agent=self.agents["dm"],
                expected_output="Dialogue response with NPC reactions and story progression"
            )
            
            crew = Crew(
                agents=[self.agents["dm"]],
                tasks=[dialogue_task],
                process=Process.sequential
            )
            
            result = crew.kickoff()
            
            return {
                "success": True,
                "action_type": "dialogue",
                "result": result,
                "message": "Dialogue processed",
                "npc_responses": [],
                "relationship_changes": {}
            }
            
        except Exception as e:
            logger.error(f"Dialogue action failed: {e}")
            return {"success": False, "message": f"Dialogue action failed: {e}"}
    
    async def _handle_exploration_action(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Handle exploration actions using world agent"""
        try:
            exploration_task = Task(
                description=f"""
                Handle exploration action: {context['action']}
                
                Character: {context['character_data']['name']}
                Current Location: {context['character_data']['location']}
                
                World State: {context['world_state']}
                
                Describe the exploration results including:
                1. Environmental descriptions
                2. Hidden discoveries
                3. Encounter possibilities
                4. Lore and world-building
                5. Navigation options
                """,
                agent=self.agents["world"],
                expected_output="Exploration result with environmental details and discoveries"
            )
            
            crew = Crew(
                agents=[self.agents["world"]],
                tasks=[exploration_task],
                process=Process.sequential
            )
            
            result = crew.kickoff()
            
            return {
                "success": True,
                "action_type": "exploration",
                "result": result,
                "message": "Exploration completed",
                "discoveries": [],
                "location_updates": {}
            }
            
        except Exception as e:
            logger.error(f"Exploration action failed: {e}")
            return {"success": False, "message": f"Exploration action failed: {e}"}
    
    async def _handle_skill_check_action(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Handle skill check actions"""
        try:
            # Extract skill from action
            action = context['action'].lower()
            
            # Determine skill and difficulty
            skill = "general"
            difficulty = 15
            
            if "stealth" in action:
                skill = "stealth"
                modifier = self.character_manager._get_ability_modifier(
                    context['character_data']['stats']['dexterity']
                )
            elif "perception" in action:
                skill = "perception"
                modifier = self.character_manager._get_ability_modifier(
                    context['character_data']['stats']['wisdom']
                )
            else:
                modifier = 0
            
            # Perform skill check
            dice_roller = DiceRoller()
            result = dice_roller.roll_d20_check(modifier, difficulty)
            
            success_message = "Success!" if result["success"] else "Failure!"
            
            return {
                "success": True,
                "action_type": "skill_check",
                "result": f"{skill.title()} check: {success_message}",
                "dice_result": result,
                "message": f"Skill check completed: {result['total']} vs DC {difficulty}"
            }
            
        except Exception as e:
            logger.error(f"Skill check failed: {e}")
            return {"success": False, "message": f"Skill check failed: {e}"}
    
    async def _handle_general_action(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Handle general actions using DM agent"""
        try:
            general_task = Task(
                description=f"""
                Handle general action: {context['action']}
                
                Character: {context['character_data']['name']}
                Context: {context['additional_context']}
                
                Provide appropriate response and any necessary game mechanic resolutions.
                """,
                agent=self.agents["dm"],
                expected_output="General action response with appropriate game mechanics"
            )
            
            crew = Crew(
                agents=[self.agents["dm"]],
                tasks=[general_task],
                process=Process.sequential
            )
            
            result = crew.kickoff()
            
            return {
                "success": True,
                "action_type": "general",
                "result": result,
                "message": "Action processed"
            }
            
        except Exception as e:
            logger.error(f"General action failed: {e}")
            return {"success": False, "message": f"General action failed: {e}"}

class MultiAgentGameMaster:
    """Main game master system orchestrating all components"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.session_factory = None
        
        # Components
        self.character_manager = None
        self.world_builder = None
        self.rpg_tools = None
        self.game_master_agent = None
        
        # Vector store for world knowledge
        self.embeddings = OpenAIEmbeddings()
        self.vector_store = None
        
        # Active sessions
        self.active_sessions = {}
    
    async def initialize(self):
        """Initialize the game master system"""
        try:
            # Initialize database
            engine = create_async_engine(self.config['database_url'])
            self.session_factory = sessionmaker(
                engine, class_=AsyncSession, expire_on_commit=False
            )
            
            # Create tables
            async with engine.begin() as conn:
                await conn.run_sync(Base.metadata.create_all)
            
            # Initialize vector store
            self.vector_store = Chroma(
                embedding_function=self.embeddings,
                persist_directory="./rpg_world_knowledge"
            )
            
            # Initialize components
            self.character_manager = CharacterManager(self.session_factory)
            self.world_builder = WorldBuilder(self.session_factory, self.vector_store)
            self.rpg_tools = RPGTools(self.character_manager, self.world_builder)
            self.game_master_agent = GameMasterAgent(
                self.character_manager, self.world_builder, self.rpg_tools
            )
            
            # Load default world knowledge
            await self._load_world_knowledge()
            
            logger.info("Multi-Agent Game Master initialized")
            
        except Exception as e:
            logger.error(f"Game Master initialization failed: {e}")
            raise
    
    async def _load_world_knowledge(self):
        """Load default world knowledge and lore"""
        try:
            # Sample world knowledge
            world_docs = [
                Document(
                    page_content="Eldoria is a vast kingdom ruled by King Aldric the Just. The capital city is Goldenhaven, known for its magnificent castle and bustling marketplace.",
                    metadata={"type": "location", "category": "kingdom"}
                ),
                Document(
                    page_content="The Whispering Forest is a magical woodland where ancient spirits dwell. Travelers report hearing voices in the wind and seeing lights that lead them astray.",
                    metadata={"type": "location", "category": "forest"}
                ),
                Document(
                    page_content="Dragons are ancient and powerful creatures. The last dragon seen in Eldoria was Fyrelord the Red, who was defeated by the legendary hero Sir Gareth.",
                    metadata={"type": "creature", "category": "dragon"}
                ),
                Document(
                    page_content="Magic in this world comes from the Weave, a mystical force that connects all living things. Wizards must study for years to manipulate the Weave safely.",
                    metadata={"type": "lore", "category": "magic"}
                )
            ]
            
            if world_docs:
                self.vector_store.add_documents(world_docs)
                logger.info(f"Loaded {len(world_docs)} world knowledge documents")
                
        except Exception as e:
            logger.error(f"World knowledge loading failed: {e}")
    
    async def start_campaign(self, campaign_name: str, player_data: List[Dict[str, Any]]) -> str:
        """Start a new RPG campaign"""
        try:
            session_id = str(uuid.uuid4())
            
            # Create game session
            async with self.session_factory() as session:
                game_session = GameSession(
                    id=session_id,
                    campaign_name=campaign_name,
                    world_state={"time": "Day 1", "weather": "Clear", "season": "Spring"},
                    active_players=[],
                    current_scene="The adventure begins in the tavern 'The Prancing Pony'...",
                    game_metadata={"difficulty": "normal", "theme": "classic_fantasy"}
                )
                session.add(game_session)
                await session.commit()
            
            # Create starting location
            await self.world_builder.create_location(session_id, {
                "name": "The Prancing Pony",
                "description": "A cozy tavern with wooden tables and a warm fireplace. The perfect place for adventurers to meet.",
                "location_type": "tavern",
                "npcs": [
                    {"name": "Barkeep Tom", "role": "innkeeper", "personality": "friendly"},
                    {"name": "Mysterious Stranger", "role": "quest_giver", "personality": "enigmatic"}
                ],
                "connections": ["Town Square", "Stables"]
            })
            
            # Create characters
            character_ids = []
            for player in player_data:
                character_id = await self.character_manager.create_character(session_id, player)
                character_ids.append(character_id)
            
            # Track active session
            self.active_sessions[session_id] = {
                "campaign_name": campaign_name,
                "characters": character_ids,
                "start_time": datetime.now(),
                "turn_count": 0
            }
            
            return session_id
            
        except Exception as e:
            logger.error(f"Campaign creation failed: {e}")
            raise
    
    async def process_player_action(self, session_id: str, character_id: str, 
                                  action: str) -> Dict[str, Any]:
        """Process a player action"""
        try:
            if session_id not in self.active_sessions:
                return {"error": "Session not found"}
            
            # Process through game master agent
            result = await self.game_master_agent.process_player_action(
                session_id, character_id, action, {}
            )
            
            # Log the event
            await self._log_game_event(session_id, "player_action", {
                "character_id": character_id,
                "action": action,
                "result": result
            })
            
            # Update session activity
            if session_id in self.active_sessions:
                self.active_sessions[session_id]["turn_count"] += 1
            
            return result
            
        except Exception as e:
            logger.error(f"Player action processing failed: {e}")
            return {"error": str(e)}
    
    async def _log_game_event(self, session_id: str, event_type: str, event_data: Dict[str, Any]):
        """Log game event to database"""
        try:
            async with self.session_factory() as session:
                event = GameEvent(
                    id=str(uuid.uuid4()),
                    session_id=session_id,
                    event_type=event_type,
                    description=f"{event_type}: {event_data.get('action', 'N/A')}",
                    participants=[event_data.get('character_id', '')],
                    outcomes=event_data.get('result', {}),
                    world_changes={},
                    character_changes={}
                )
                session.add(event)
                await session.commit()
                
        except Exception as e:
            logger.error(f"Event logging failed: {e}")
    
    async def get_campaign_status(self, session_id: str) -> Dict[str, Any]:
        """Get current campaign status"""
        try:
            if session_id not in self.active_sessions:
                return {"error": "Session not found"}
            
            # Get world state
            world_state = await self.world_builder.get_world_state(session_id)
            
            # Get characters
            session_data = self.active_sessions[session_id]
            characters = []
            for char_id in session_data["characters"]:
                char_data = await self.character_manager.get_character(char_id)
                if char_data:
                    characters.append(char_data)
            
            return {
                "session_id": session_id,
                "campaign_name": session_data["campaign_name"],
                "characters": characters,
                "world_state": world_state,
                "turn_count": session_data["turn_count"],
                "status": "active"
            }
            
        except Exception as e:
            logger.error(f"Campaign status retrieval failed: {e}")
            return {"error": str(e)}

class GameMasterAPI:
    """FastAPI application for the Multi-Agent Game Master"""
    
    def __init__(self, game_master: MultiAgentGameMaster):
        self.app = FastAPI(title="Multi-Agent Game Master API")
        self.game_master = game_master
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """Setup CORS middleware"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def setup_routes(self):
        """Setup API routes"""
        
        @self.app.post("/campaigns/start")
        async def start_campaign(request: dict):
            try:
                session_id = await self.game_master.start_campaign(
                    request["campaign_name"],
                    request["players"]
                )
                return {"session_id": session_id, "status": "started"}
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/campaigns/{session_id}/action")
        async def player_action(session_id: str, request: dict):
            try:
                result = await self.game_master.process_player_action(
                    session_id,
                    request["character_id"],
                    request["action"]
                )
                return result
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/campaigns/{session_id}/status")
        async def campaign_status(session_id: str):
            try:
                status = await self.game_master.get_campaign_status(session_id)
                return status
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/dashboard")
        async def get_dashboard():
            return {
                "system_status": "operational",
                "features": [
                    "Multi-Agent Game Mastering",
                    "Persistent Character Memory",
                    "Dynamic World State",
                    "Intelligent Combat Resolution",
                    "Adaptive Storytelling",
                    "Character Development Tracking"
                ],
                "agents": ["Dungeon Master", "Combat Manager", "World Keeper", "Character Developer"],
                "tools": ["Dice Rolling", "Skill Checks", "Combat Resolution", "Inventory Management"]
            }

async def demo():
    """Demonstration of the Multi-Agent Game Master"""
    
    print(" Multi-Agent Game Master Demo\n")
    
    config = {
        'database_url': 'sqlite+aiosqlite:///./rpg_game_master.db'
    }
    
    try:
        # Initialize game master
        game_master = MultiAgentGameMaster(config)
        await game_master.initialize()
        
        print(" Multi-Agent Game Master initialized")
        print(" Specialized RPG agents created")
        print(" World knowledge base loaded")
        print(" Character management system ready")
        print(" Dynamic world state tracking enabled")
        
        # Create sample players
        players = [
            {
                "name": "Thorin Stonebeard",
                "character_class": "Fighter",
                "backstory": "A dwarven warrior seeking to reclaim his family's lost mine.",
                "personality": {"brave": 8, "stubborn": 7, "loyal": 9},
                "location": "The Prancing Pony"
            },
            {
                "name": "Luna Moonwhisper",
                "character_class": "Wizard",
                "backstory": "An elven scholar researching ancient magical artifacts.",
                "personality": {"intelligent": 9, "curious": 8, "cautious": 6},
                "location": "The Prancing Pony"
            }
        ]
        
        # Start campaign
        session_id = await game_master.start_campaign("The Lost Mine Adventure", players)
        print(f" Started campaign: {session_id[:8]}")
        
        # Get campaign status
        status = await game_master.get_campaign_status(session_id)
        print(f" Players: {len(status['characters'])}")
        print(f" Locations: {len(status['world_state']['locations'])}")
        
        # Demo player actions
        character_id = status['characters'][0]['id']
        demo_actions = [
            "I approach the mysterious stranger at the corner table",
            "I ask about rumors of treasure in the area",
            "I order an ale and listen for information",
            "I examine my equipment and prepare for adventure",
            "I suggest to Luna that we investigate the old mine"
        ]
        
        print(f"\n Processing Player Actions...")
        
        for i, action in enumerate(demo_actions, 1):
            print(f"\n Action {i}: {action}")
            
            result = await game_master.process_player_action(session_id, character_id, action)
            
            if "error" not in result:
                print(f" Result: {result.get('result', 'Action processed')}")
                print(f" Action Type: {result.get('action_type', 'general')}")
                print(f" Success: {result.get('success', False)}")
            else:
                print(f" Error: {result['error']}")
        
        # Show system capabilities
        print(f"\n Game Master Capabilities:")
        print(f"   Multi-Agent Coordination (DM, Combat, World, Character)")
        print(f"   Persistent Character Memory & Development")
        print(f"   Dynamic World State Management")
        print(f"   Intelligent Combat Resolution")
        print(f"   Adaptive Narrative Generation")
        print(f"   Rule-Based Game Mechanics")
        print(f"   Context-Aware Decision Making")
        print(f"   Player Agency & Choice Consequences")
        
        # Show agent specializations
        print(f"\n AI Agent Specializations:")
        print(f"   Dungeon Master: Narrative & overall flow")
        print(f"   Combat Manager: Tactical encounters")
        print(f"   World Keeper: Environment & consistency")
        print(f"   Character Developer: Personal growth")
        
        # Initialize API
        print(f"\n Setting up Game Master API...")
        api = GameMasterAPI(game_master)
        print(f" API configured with RPG endpoints")
        
        print(f"\n To start the Game Master API:")
        print(f"   uvicorn main:api.app --host 0.0.0.0 --port 8000")
        print(f"   Dashboard: http://localhost:8000/dashboard")
        print(f"   Start Campaign: POST /campaigns/start")
        print(f"   Player Action: POST /campaigns/{{id}}/action")
        print(f"   Campaign Status: GET /campaigns/{{id}}/status")
        
        print(f"\n RPG Features:")
        print(f"   Dynamic storytelling with persistent memory")
        print(f"   Multi-agent specialized game management")
        print(f"   Character progression & development")
        print(f"   Living world with consequences")
        print(f"   Intelligent combat & skill resolution")
        print(f"   Contextual narrative adaptation")
        
        print(f"\n Multi-Agent Game Master demo completed!")
        
    except Exception as e:
        print(f" Demo error: {e}")
        logger.error(f"Demo failed: {e}")

# Dependencies information
dependencies_info = """
# Install required dependencies:
pip install crewai
pip install langgraph
pip install fastapi uvicorn
pip install sqlalchemy aiosqlite
pip install langchain openai
pip install chromadb
pip install pydantic
pip install aiofiles

# Environment variables:
export OPENAI_API_KEY="your-openai-api-key"
export DATABASE_URL="sqlite+aiosqlite:///./rpg_game_master.db"

# Additional RPG libraries:
pip install dice  # Advanced dice rolling
pip install rpg-tools  # RPG utilities
pip install tabletop-simulator  # Game simulation

# For advanced features:
pip install networkx  # Graph-based world modeling
pip install matplotlib  # Character sheet visualization
pip install pillow  # Image processing for maps

# For production:
pip install redis  # Session caching
pip install websockets  # Real-time updates
pip install gunicorn  # WSGI server
"""

if __name__ == "__main__":
    print(dependencies_info)
    asyncio.run(demo())
````

## Project Summary

The Multi-Agent Game Master represents a revolutionary AI-enhanced RPG platform that transforms text-based role-playing experiences through sophisticated multi-agent coordination, persistent character memory systems, and dynamic world state management. This system addresses critical challenges in digital RPG gaming by providing intelligent game mastering capabilities that maintain narrative consistency while adapting to player choices and enabling immersive storytelling experiences.

### Key Value Propositions

1. **Specialized Multi-Agent Coordination**: Advanced CrewAI orchestration system that coordinates specialized agents including Dungeon Master, Combat Manager, World Keeper, and Character Developer, each contributing unique expertise while maintaining seamless collaboration for comprehensive game management.

2. **Persistent Character Memory & Development**: Sophisticated character tracking system that maintains detailed backstories, personality evolution, relationship dynamics, and skill progression across extended gaming sessions, enabling meaningful character growth and consistent roleplay experiences.

3. **Dynamic World State Management**: Living world system that tracks locations, NPCs, political situations, and environmental changes, creating reactive environments that respond intelligently to player actions while maintaining internal consistency and narrative coherence.

4. **Intelligent Game Mechanics Integration**: Advanced function calling system that handles complex RPG mechanics including dice rolling, combat resolution, skill checks, and inventory management while maintaining game balance and supporting narrative flow through structured JSON tools.

### Key Takeaways

- **Accessible RPG Mastering**: Democratizes high-quality RPG experiences by providing AI-driven game mastering that rivals human DMs, enabling solo play and supporting groups without experienced game masters while maintaining narrative depth and mechanical complexity
- **Scalable Narrative Intelligence**: Enables consistent storytelling across extended campaigns through persistent memory systems and context-aware decision making that maintains character motivations and world consistency over time
- **Adaptive Gameplay Experience**: Provides dynamic difficulty adjustment and narrative adaptation that responds to player preferences and choices while maintaining challenge balance and story coherence through intelligent agent coordination
- **Enhanced Player Agency**: Supports meaningful player choices and consequences through sophisticated world modeling and character development systems that ensure actions have lasting impact on both personal storylines and world state

This Multi-Agent Game Master empowers both players and game masters by combining the creativity of human storytelling with the consistency and availability of AI assistance, creating rich RPG experiences that adapt to player actions while maintaining the depth and complexity that makes tabletop role-playing games engaging and memorable.