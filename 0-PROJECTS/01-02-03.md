<small>Claude Sonnet 4 **(Medical Diagnosis and Treatment Advisor - AI-Enhanced MCP Integration)**</small>
# Medical Diagnosis and Treatment Advisor

## Key Concepts Explanation

### Model Context Protocol (MCP)
Advanced communication framework enabling AI models to maintain comprehensive medical context across patient consultations, medical history, diagnostic procedures, and treatment protocols while ensuring HIPAA compliance and medical data integrity throughout the diagnostic and treatment recommendation process.

### MedPrompt Engineering
Specialized prompt engineering techniques optimized for medical AI applications, incorporating clinical reasoning patterns, differential diagnosis methodologies, evidence-based medicine principles, and structured medical documentation formats to ensure accurate and reliable medical AI assistance.

### LangGraph Workflow Orchestration
Advanced graph-based workflow system that orchestrates complex medical reasoning processes including symptom analysis, diagnostic hypothesis generation, evidence evaluation, treatment planning, and clinical decision support through interconnected AI agents and medical knowledge bases.

### Patient History Memory Systems
Sophisticated memory architecture that maintains comprehensive patient medical histories, tracks treatment outcomes, monitors medication interactions, and preserves longitudinal health data to support continuity of care and informed medical decision-making across multiple consultations.

### Medical Knowledge Retrieval
Advanced retrieval system that accesses medical literature, clinical guidelines, drug databases, diagnostic criteria, and similar case studies to provide evidence-based support for diagnosis and treatment recommendations while maintaining current medical knowledge standards.

### Structured Medical JSON Templates
Standardized data formats for medical information exchange including patient demographics, symptoms, vital signs, laboratory results, imaging findings, medical history, and treatment plans that ensure interoperability with electronic health record systems and medical databases.

## Comprehensive Project Explanation

The Medical Diagnosis and Treatment Advisor revolutionizes healthcare delivery by providing AI-enhanced clinical decision support that assists healthcare professionals in diagnosis, treatment planning, and patient care management. This system combines advanced medical AI with comprehensive patient data analysis to deliver evidence-based medical insights while maintaining the highest standards of medical ethics and patient safety.

### Objectives
- **Intelligent Diagnostic Support**: Provide AI-powered diagnostic assistance that analyzes patient symptoms, medical history, and clinical data to generate differential diagnoses with supporting evidence and confidence levels
- **Evidence-Based Treatment Recommendations**: Generate treatment plans based on current medical guidelines, patient-specific factors, and evidence from similar cases while considering contraindications and patient preferences
- **Comprehensive Patient History Management**: Maintain detailed patient medical records with longitudinal tracking of symptoms, treatments, outcomes, and medication histories to support continuity of care
- **Clinical Decision Support**: Assist healthcare providers with real-time clinical guidance, drug interaction checking, dosage recommendations, and treatment monitoring protocols
- **Medical Knowledge Integration**: Seamlessly integrate current medical literature, clinical guidelines, and best practices to ensure recommendations align with evidence-based medicine standards

### Challenges
- **Medical Accuracy and Safety**: Ensuring AI recommendations meet the highest standards of medical accuracy while maintaining appropriate safety margins and clinical oversight requirements
- **Regulatory Compliance**: Adherence to HIPAA, FDA, and medical device regulations while ensuring patient privacy, data security, and appropriate clinical use of AI technology
- **Clinical Integration**: Seamless integration with existing electronic health record systems, clinical workflows, and healthcare provider practices without disrupting established medical procedures
- **Liability and Responsibility**: Clear delineation of AI assistance versus clinical decision-making responsibility while maintaining appropriate professional liability and medical ethics standards
- **Data Quality and Standardization**: Managing diverse medical data sources, ensuring data quality, and maintaining standardized medical terminology and coding systems across different healthcare systems

### Potential Impact
This platform could significantly improve diagnostic accuracy, reduce medical errors, enhance treatment outcomes, accelerate clinical decision-making, democratize access to specialist-level medical knowledge, and support healthcare providers in delivering more effective and personalized patient care while maintaining the highest standards of medical ethics and safety.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import logging
import re
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import uuid
import hashlib
from pathlib import Path

# Core dependencies
import pandas as pd
import numpy as np

# AI and ML
import openai
from langchain.chat_models import ChatOpenAI
from langchain.embeddings import OpenAIEmbeddings
from langchain.memory import ConversationBufferWindowMemory
from langchain.agents import Tool
from langchain.prompts import ChatPromptTemplate, PromptTemplate
from langchain.schema import HumanMessage, SystemMessage, AIMessage
from langchain.chains import LLMChain
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolExecutor

# Vector storage and retrieval
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document

# Database
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, DateTime, Text, JSON, Float, Integer, Boolean

# Web framework
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, validator
import uvicorn

# Medical data processing
import requests
from typing_extensions import Annotated
import warnings
warnings.filterwarnings('ignore')

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database Models
Base = declarative_base()

class SeverityLevel(Enum):
    MILD = "mild"
    MODERATE = "moderate"
    SEVERE = "severe"
    CRITICAL = "critical"

class ConfidenceLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    VERY_HIGH = "very_high"

class DiagnosisStatus(Enum):
    PRELIMINARY = "preliminary"
    CONFIRMED = "confirmed"
    RULED_OUT = "ruled_out"
    REQUIRES_FURTHER_TESTING = "requires_further_testing"

class Patient(Base):
    __tablename__ = "patients"
    
    id = Column(String, primary_key=True)
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(DateTime)
    gender = Column(String)
    medical_record_number = Column(String, unique=True)
    emergency_contact = Column(JSON)
    insurance_info = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow)

class MedicalHistory(Base):
    __tablename__ = "medical_history"
    
    id = Column(String, primary_key=True)
    patient_id = Column(String, nullable=False)
    condition = Column(String, nullable=False)
    diagnosis_date = Column(DateTime)
    severity = Column(String)
    status = Column(String)  # active, resolved, chronic
    notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)

class Consultation(Base):
    __tablename__ = "consultations"
    
    id = Column(String, primary_key=True)
    patient_id = Column(String, nullable=False)
    chief_complaint = Column(Text)
    symptoms = Column(JSON)
    vital_signs = Column(JSON)
    physical_examination = Column(JSON)
    lab_results = Column(JSON)
    imaging_results = Column(JSON)
    consultation_date = Column(DateTime, default=datetime.utcnow)
    healthcare_provider = Column(String)
    consultation_type = Column(String)  # initial, follow_up, emergency

class Diagnosis(Base):
    __tablename__ = "diagnoses"
    
    id = Column(String, primary_key=True)
    consultation_id = Column(String, nullable=False)
    patient_id = Column(String, nullable=False)
    primary_diagnosis = Column(String)
    differential_diagnoses = Column(JSON)
    confidence_level = Column(String)
    supporting_evidence = Column(JSON)
    recommendation = Column(Text)
    follow_up_required = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    created_by = Column(String)  # AI_SYSTEM or healthcare provider

class TreatmentPlan(Base):
    __tablename__ = "treatment_plans"
    
    id = Column(String, primary_key=True)
    diagnosis_id = Column(String, nullable=False)
    patient_id = Column(String, nullable=False)
    medications = Column(JSON)
    procedures = Column(JSON)
    lifestyle_recommendations = Column(JSON)
    follow_up_schedule = Column(JSON)
    monitoring_parameters = Column(JSON)
    contraindications = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

@dataclass
class PatientData:
    patient_id: str
    demographics: Dict[str, Any]
    chief_complaint: str
    symptoms: List[Dict[str, Any]]
    vital_signs: Dict[str, Any]
    medical_history: List[Dict[str, Any]]
    medications: List[Dict[str, Any]]
    allergies: List[str]
    lab_results: Dict[str, Any] = field(default_factory=dict)
    imaging_results: Dict[str, Any] = field(default_factory=dict)

@dataclass
class DiagnosisResult:
    primary_diagnosis: str
    confidence: ConfidenceLevel
    differential_diagnoses: List[Dict[str, Any]]
    supporting_evidence: List[str]
    recommended_tests: List[str]
    urgency_level: SeverityLevel
    reasoning: str

@dataclass
class TreatmentRecommendation:
    medications: List[Dict[str, Any]]
    procedures: List[Dict[str, Any]]
    lifestyle_changes: List[str]
    follow_up_timeline: Dict[str, Any]
    monitoring_requirements: List[str]
    contraindications: List[str]
    patient_education: List[str]

class MedicalKnowledgeBase:
    """Medical knowledge retrieval and management system"""
    
    def __init__(self):
        self.embeddings = OpenAIEmbeddings()
        self.vector_store = Chroma(
            embedding_function=self.embeddings,
            persist_directory="./medical_kb"
        )
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
    
    async def initialize_knowledge_base(self):
        """Initialize medical knowledge base with sample data"""
        try:
            # Sample medical knowledge data
            medical_knowledge = [
                {
                    "condition": "Hypertension",
                    "symptoms": ["headache", "dizziness", "chest pain", "shortness of breath"],
                    "diagnostic_criteria": "Blood pressure consistently >140/90 mmHg",
                    "treatment": "ACE inhibitors, lifestyle modifications, monitoring",
                    "complications": "stroke, heart attack, kidney disease"
                },
                {
                    "condition": "Type 2 Diabetes",
                    "symptoms": ["increased thirst", "frequent urination", "fatigue", "blurred vision"],
                    "diagnostic_criteria": "Fasting glucose >126 mg/dL or HbA1c >6.5%",
                    "treatment": "Metformin, diet modification, exercise, monitoring",
                    "complications": "neuropathy, retinopathy, nephropathy"
                },
                {
                    "condition": "Pneumonia",
                    "symptoms": ["cough", "fever", "chest pain", "shortness of breath", "fatigue"],
                    "diagnostic_criteria": "Chest X-ray showing infiltrates, clinical symptoms",
                    "treatment": "Antibiotics, supportive care, rest",
                    "complications": "respiratory failure, sepsis"
                },
                {
                    "condition": "Migraine",
                    "symptoms": ["severe headache", "nausea", "sensitivity to light", "aura"],
                    "diagnostic_criteria": "Recurrent headaches with specific characteristics",
                    "treatment": "Triptans, NSAIDs, lifestyle modifications",
                    "complications": "status migrainosus, medication overuse headache"
                },
                {
                    "condition": "Gastroesophageal Reflux Disease",
                    "symptoms": ["heartburn", "regurgitation", "chest pain", "difficulty swallowing"],
                    "diagnostic_criteria": "Symptoms responsive to PPI therapy, endoscopy findings",
                    "treatment": "PPIs, H2 blockers, lifestyle modifications",
                    "complications": "Barrett's esophagus, stricture"
                }
            ]
            
            # Convert to documents and add to vector store
            documents = []
            for knowledge in medical_knowledge:
                content = f"""
                Condition: {knowledge['condition']}
                Symptoms: {', '.join(knowledge['symptoms'])}
                Diagnostic Criteria: {knowledge['diagnostic_criteria']}
                Treatment: {knowledge['treatment']}
                Complications: {knowledge['complications']}
                """
                
                doc = Document(
                    page_content=content,
                    metadata={
                        "condition": knowledge['condition'],
                        "type": "medical_knowledge"
                    }
                )
                documents.append(doc)
            
            # Add documents to vector store
            if documents:
                self.vector_store.add_documents(documents)
                logger.info(f"Initialized medical knowledge base with {len(documents)} entries")
            
        except Exception as e:
            logger.error(f"Knowledge base initialization failed: {e}")
    
    async def search_similar_cases(self, symptoms: List[str], k: int = 5) -> List[Document]:
        """Search for similar medical cases"""
        try:
            query = " ".join(symptoms)
            results = self.vector_store.similarity_search(query, k=k)
            return results
        except Exception as e:
            logger.error(f"Similar case search failed: {e}")
            return []
    
    async def get_condition_info(self, condition: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a medical condition"""
        try:
            results = self.vector_store.similarity_search(
                condition, k=1, filter={"condition": condition}
            )
            
            if results:
                return {
                    "content": results[0].page_content,
                    "metadata": results[0].metadata
                }
            return None
        except Exception as e:
            logger.error(f"Condition info retrieval failed: {e}")
            return None

class MedicalReasoningEngine:
    """AI-powered medical reasoning and diagnosis engine"""
    
    def __init__(self, knowledge_base: MedicalKnowledgeBase, session_factory):
        self.llm = ChatOpenAI(model_name="gpt-4", temperature=0.1)
        self.knowledge_base = knowledge_base
        self.session_factory = session_factory
        
        # Medical reasoning prompts
        self.diagnosis_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert medical AI assistant trained to assist healthcare professionals.
            Your role is to analyze patient data and provide diagnostic insights while emphasizing that:
            1. This is clinical decision support, not a replacement for physician judgment
            2. All recommendations require professional medical review
            3. Urgent cases should be escalated immediately
            4. Patient safety is the highest priority
            
            Provide structured analysis with confidence levels and reasoning."""),
            ("human", "{patient_data}")
        ])
        
        self.treatment_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are a medical treatment planning assistant. Provide evidence-based treatment recommendations while:
            1. Considering patient-specific factors and contraindications
            2. Following current clinical guidelines
            3. Emphasizing the need for professional medical supervision
            4. Including patient education and monitoring requirements
            
            All treatment plans must be reviewed and approved by qualified healthcare providers."""),
            ("human", "{diagnosis_and_patient_data}")
        ])
    
    async def generate_diagnosis(self, patient_data: PatientData) -> DiagnosisResult:
        """Generate AI-assisted diagnosis based on patient data"""
        try:
            # Search for similar cases
            symptoms = [symptom['name'] for symptom in patient_data.symptoms]
            similar_cases = await self.knowledge_base.search_similar_cases(symptoms, k=3)
            
            # Prepare context
            similar_cases_text = ""
            if similar_cases:
                similar_cases_text = "\n".join([f"Similar case: {case.page_content}" for case in similar_cases])
            
            # Format patient data for analysis
            formatted_patient_data = self._format_patient_data_for_analysis(patient_data)
            
            # Generate diagnosis
            diagnosis_input = f"""
            Patient Information:
            {formatted_patient_data}
            
            Similar Cases from Medical Knowledge Base:
            {similar_cases_text}
            
            Please provide a structured diagnostic analysis including:
            1. Primary diagnosis with confidence level
            2. Differential diagnoses (top 3-5 alternatives)
            3. Supporting evidence from patient data
            4. Recommended additional tests or imaging
            5. Urgency level assessment
            6. Clinical reasoning and justification
            
            Format your response as JSON with the following structure:
            {{
                "primary_diagnosis": "condition name",
                "confidence": "low|medium|high|very_high",
                "differential_diagnoses": [
                    {{"condition": "name", "probability": "percentage", "reasoning": "explanation"}},
                    ...
                ],
                "supporting_evidence": ["evidence point 1", "evidence point 2", ...],
                "recommended_tests": ["test 1", "test 2", ...],
                "urgency_level": "mild|moderate|severe|critical",
                "clinical_reasoning": "detailed explanation of diagnostic process"
            }}
            """
            
            response = await self.llm.apredict(diagnosis_input)
            
            # Parse AI response
            diagnosis_result = self._parse_diagnosis_response(response)
            
            return diagnosis_result
            
        except Exception as e:
            logger.error(f"Diagnosis generation failed: {e}")
            return self._create_error_diagnosis()
    
    def _format_patient_data_for_analysis(self, patient_data: PatientData) -> str:
        """Format patient data for AI analysis"""
        formatted_data = f"""
        Demographics: Age {patient_data.demographics.get('age', 'Unknown')}, Gender {patient_data.demographics.get('gender', 'Unknown')}
        
        Chief Complaint: {patient_data.chief_complaint}
        
        Present Symptoms:
        """
        
        for symptom in patient_data.symptoms:
            formatted_data += f"- {symptom['name']}: {symptom.get('severity', 'Unknown')} severity, {symptom.get('duration', 'Unknown')} duration\n"
        
        formatted_data += f"""
        Vital Signs:
        - Blood Pressure: {patient_data.vital_signs.get('blood_pressure', 'Not recorded')}
        - Heart Rate: {patient_data.vital_signs.get('heart_rate', 'Not recorded')} bpm
        - Temperature: {patient_data.vital_signs.get('temperature', 'Not recorded')}¬∞F
        - Respiratory Rate: {patient_data.vital_signs.get('respiratory_rate', 'Not recorded')}/min
        - Oxygen Saturation: {patient_data.vital_signs.get('oxygen_saturation', 'Not recorded')}%
        
        Medical History:
        """
        
        for condition in patient_data.medical_history:
            formatted_data += f"- {condition['condition']}: {condition.get('status', 'Unknown status')}\n"
        
        formatted_data += f"""
        Current Medications:
        """
        
        for medication in patient_data.medications:
            formatted_data += f"- {medication['name']}: {medication.get('dosage', 'Unknown dosage')}\n"
        
        formatted_data += f"""
        Allergies: {', '.join(patient_data.allergies) if patient_data.allergies else 'None reported'}
        
        Laboratory Results:
        {json.dumps(patient_data.lab_results, indent=2) if patient_data.lab_results else 'None available'}
        
        Imaging Results:
        {json.dumps(patient_data.imaging_results, indent=2) if patient_data.imaging_results else 'None available'}
        """
        
        return formatted_data
    
    def _parse_diagnosis_response(self, response: str) -> DiagnosisResult:
        """Parse AI diagnosis response into structured format"""
        try:
            # Extract JSON from response
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if not json_match:
                return self._create_error_diagnosis()
            
            diagnosis_data = json.loads(json_match.group())
            
            # Map confidence level
            confidence_map = {
                "low": ConfidenceLevel.LOW,
                "medium": ConfidenceLevel.MEDIUM,
                "high": ConfidenceLevel.HIGH,
                "very_high": ConfidenceLevel.VERY_HIGH
            }
            
            # Map urgency level
            urgency_map = {
                "mild": SeverityLevel.MILD,
                "moderate": SeverityLevel.MODERATE,
                "severe": SeverityLevel.SEVERE,
                "critical": SeverityLevel.CRITICAL
            }
            
            return DiagnosisResult(
                primary_diagnosis=diagnosis_data.get("primary_diagnosis", "Unknown"),
                confidence=confidence_map.get(diagnosis_data.get("confidence", "low"), ConfidenceLevel.LOW),
                differential_diagnoses=diagnosis_data.get("differential_diagnoses", []),
                supporting_evidence=diagnosis_data.get("supporting_evidence", []),
                recommended_tests=diagnosis_data.get("recommended_tests", []),
                urgency_level=urgency_map.get(diagnosis_data.get("urgency_level", "mild"), SeverityLevel.MILD),
                reasoning=diagnosis_data.get("clinical_reasoning", "No reasoning provided")
            )
            
        except json.JSONDecodeError:
            logger.error(f"Failed to parse diagnosis JSON: {response}")
            return self._create_error_diagnosis()
    
    def _create_error_diagnosis(self) -> DiagnosisResult:
        """Create error diagnosis result"""
        return DiagnosisResult(
            primary_diagnosis="Unable to determine",
            confidence=ConfidenceLevel.LOW,
            differential_diagnoses=[],
            supporting_evidence=["Error in diagnostic analysis"],
            recommended_tests=["Consult healthcare provider"],
            urgency_level=SeverityLevel.MODERATE,
            reasoning="Diagnostic analysis failed - requires immediate medical review"
        )
    
    async def generate_treatment_plan(self, diagnosis: DiagnosisResult, 
                                    patient_data: PatientData) -> TreatmentRecommendation:
        """Generate treatment recommendations based on diagnosis"""
        try:
            # Get detailed condition information
            condition_info = await self.knowledge_base.get_condition_info(diagnosis.primary_diagnosis)
            
            treatment_input = f"""
            Patient Diagnosis: {diagnosis.primary_diagnosis}
            Confidence Level: {diagnosis.confidence.value}
            Patient Age: {patient_data.demographics.get('age', 'Unknown')}
            Current Medications: {[med['name'] for med in patient_data.medications]}
            Allergies: {patient_data.allergies}
            Medical History: {[hist['condition'] for hist in patient_data.medical_history]}
            
            Condition Information:
            {condition_info['content'] if condition_info else 'Limited information available'}
            
            Please provide a comprehensive treatment plan including:
            1. Recommended medications with dosages
            2. Necessary procedures or interventions
            3. Lifestyle modifications
            4. Follow-up schedule and monitoring
            5. Patient education points
            6. Contraindications and precautions
            
            Format as JSON:
            {{
                "medications": [
                    {{"name": "medication", "dosage": "dose", "frequency": "frequency", "duration": "duration"}},
                    ...
                ],
                "procedures": [
                    {{"name": "procedure", "urgency": "routine|urgent", "purpose": "explanation"}},
                    ...
                ],
                "lifestyle_changes": ["change 1", "change 2", ...],
                "follow_up": {{"initial": "timeframe", "routine": "frequency", "emergency_signs": ["sign 1", ...]}},
                "monitoring": ["parameter 1", "parameter 2", ...],
                "contraindications": ["contraindication 1", ...],
                "patient_education": ["education point 1", ...]
            }}
            """
            
            response = await self.llm.apredict(treatment_input)
            
            # Parse treatment response
            treatment_plan = self._parse_treatment_response(response)
            
            return treatment_plan
            
        except Exception as e:
            logger.error(f"Treatment plan generation failed: {e}")
            return self._create_error_treatment_plan()
    
    def _parse_treatment_response(self, response: str) -> TreatmentRecommendation:
        """Parse AI treatment response"""
        try:
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if not json_match:
                return self._create_error_treatment_plan()
            
            treatment_data = json.loads(json_match.group())
            
            return TreatmentRecommendation(
                medications=treatment_data.get("medications", []),
                procedures=treatment_data.get("procedures", []),
                lifestyle_changes=treatment_data.get("lifestyle_changes", []),
                follow_up_timeline=treatment_data.get("follow_up", {}),
                monitoring_requirements=treatment_data.get("monitoring", []),
                contraindications=treatment_data.get("contraindications", []),
                patient_education=treatment_data.get("patient_education", [])
            )
            
        except json.JSONDecodeError:
            logger.error(f"Failed to parse treatment JSON: {response}")
            return self._create_error_treatment_plan()
    
    def _create_error_treatment_plan(self) -> TreatmentRecommendation:
        """Create error treatment plan"""
        return TreatmentRecommendation(
            medications=[],
            procedures=[],
            lifestyle_changes=["Consult healthcare provider immediately"],
            follow_up_timeline={"immediate": "Contact healthcare provider"},
            monitoring_requirements=["Professional medical evaluation required"],
            contraindications=["Treatment plan generation failed"],
            patient_education=["Seek immediate medical attention"]
        )

class PatientHistoryManager:
    """Manages patient medical history and memory"""
    
    def __init__(self, session_factory):
        self.session_factory = session_factory
        self.embeddings = OpenAIEmbeddings()
        
        # Initialize patient history vector store
        self.history_vector_store = Chroma(
            embedding_function=self.embeddings,
            persist_directory="./patient_history"
        )
    
    async def store_patient_data(self, patient_data: PatientData):
        """Store patient data in database and vector store"""
        try:
            async with self.session_factory() as session:
                # Check if patient exists
                result = await session.execute(
                    "SELECT id FROM patients WHERE id = ?", (patient_data.patient_id,)
                )
                
                if not result.fetchone():
                    # Create new patient record
                    patient = Patient(
                        id=patient_data.patient_id,
                        first_name=patient_data.demographics.get('first_name', ''),
                        last_name=patient_data.demographics.get('last_name', ''),
                        date_of_birth=patient_data.demographics.get('date_of_birth'),
                        gender=patient_data.demographics.get('gender', ''),
                        medical_record_number=f"MRN_{patient_data.patient_id}"
                    )
                    session.add(patient)
                
                # Store medical history
                for condition in patient_data.medical_history:
                    history_entry = MedicalHistory(
                        id=str(uuid.uuid4()),
                        patient_id=patient_data.patient_id,
                        condition=condition['condition'],
                        diagnosis_date=condition.get('diagnosis_date'),
                        severity=condition.get('severity', 'unknown'),
                        status=condition.get('status', 'unknown')
                    )
                    session.add(history_entry)
                
                await session.commit()
            
            # Add to vector store for similarity search
            patient_summary = self._create_patient_summary(patient_data)
            self.history_vector_store.add_texts(
                texts=[patient_summary],
                metadatas=[{
                    "patient_id": patient_data.patient_id,
                    "type": "patient_summary"
                }],
                ids=[patient_data.patient_id]
            )
            
            logger.info(f"Patient data stored: {patient_data.patient_id}")
            
        except Exception as e:
            logger.error(f"Patient data storage failed: {e}")
    
    def _create_patient_summary(self, patient_data: PatientData) -> str:
        """Create patient summary for vector storage"""
        summary_parts = [
            f"Patient ID: {patient_data.patient_id}",
            f"Chief Complaint: {patient_data.chief_complaint}",
            f"Symptoms: {', '.join([s['name'] for s in patient_data.symptoms])}",
            f"Medical History: {', '.join([h['condition'] for h in patient_data.medical_history])}",
            f"Medications: {', '.join([m['name'] for m in patient_data.medications])}",
            f"Allergies: {', '.join(patient_data.allergies)}"
        ]
        
        return " | ".join(summary_parts)
    
    async def find_similar_patients(self, current_patient: PatientData, k: int = 5) -> List[Dict[str, Any]]:
        """Find patients with similar medical profiles"""
        try:
            query = self._create_patient_summary(current_patient)
            results = self.history_vector_store.similarity_search_with_score(query, k=k)
            
            similar_patients = []
            for doc, score in results:
                if doc.metadata.get("patient_id") != current_patient.patient_id:
                    similar_patients.append({
                        "patient_id": doc.metadata.get("patient_id"),
                        "similarity_score": score,
                        "summary": doc.page_content
                    })
            
            return similar_patients
            
        except Exception as e:
            logger.error(f"Similar patient search failed: {e}")
            return []
    
    async def get_patient_history(self, patient_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve comprehensive patient history"""
        try:
            async with self.session_factory() as session:
                # Get patient demographics
                patient_result = await session.execute(
                    "SELECT * FROM patients WHERE id = ?", (patient_id,)
                )
                patient_data = patient_result.fetchone()
                
                if not patient_data:
                    return None
                
                # Get medical history
                history_result = await session.execute(
                    "SELECT * FROM medical_history WHERE patient_id = ?", (patient_id,)
                )
                history_data = history_result.fetchall()
                
                # Get previous consultations
                consultation_result = await session.execute(
                    "SELECT * FROM consultations WHERE patient_id = ? ORDER BY consultation_date DESC",
                    (patient_id,)
                )
                consultation_data = consultation_result.fetchall()
                
                return {
                    "patient_info": dict(patient_data._mapping) if patient_data else {},
                    "medical_history": [dict(row._mapping) for row in history_data],
                    "recent_consultations": [dict(row._mapping) for row in consultation_data[:5]]
                }
                
        except Exception as e:
            logger.error(f"Patient history retrieval failed: {e}")
            return None

class MedicalDiagnosisSystem:
    """Main medical diagnosis and treatment advisor system"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.session_factory = None
        
        # Initialize components
        self.knowledge_base = MedicalKnowledgeBase()
        self.reasoning_engine = None
        self.history_manager = None
    
    async def initialize(self):
        """Initialize the medical diagnosis system"""
        try:
            # Initialize database
            engine = create_async_engine(self.config['database_url'])
            self.session_factory = sessionmaker(
                engine, class_=AsyncSession, expire_on_commit=False
            )
            
            # Create tables
            async with engine.begin() as conn:
                await conn.run_sync(Base.metadata.create_all)
            
            # Initialize components
            await self.knowledge_base.initialize_knowledge_base()
            self.reasoning_engine = MedicalReasoningEngine(self.knowledge_base, self.session_factory)
            self.history_manager = PatientHistoryManager(self.session_factory)
            
            logger.info("Medical Diagnosis System initialized successfully")
            
        except Exception as e:
            logger.error(f"System initialization failed: {e}")
            raise
    
    async def process_patient_case(self, patient_data: PatientData) -> Dict[str, Any]:
        """Process complete patient case for diagnosis and treatment"""
        try:
            # Store patient data
            await self.history_manager.store_patient_data(patient_data)
            
            # Find similar patients
            similar_patients = await self.history_manager.find_similar_patients(patient_data)
            
            # Generate diagnosis
            diagnosis = await self.reasoning_engine.generate_diagnosis(patient_data)
            
            # Generate treatment plan
            treatment_plan = await self.reasoning_engine.generate_treatment_plan(diagnosis, patient_data)
            
            # Store consultation record
            consultation_id = await self._store_consultation(patient_data, diagnosis, treatment_plan)
            
            return {
                "consultation_id": consultation_id,
                "patient_id": patient_data.patient_id,
                "diagnosis": {
                    "primary": diagnosis.primary_diagnosis,
                    "confidence": diagnosis.confidence.value,
                    "differential": diagnosis.differential_diagnoses,
                    "evidence": diagnosis.supporting_evidence,
                    "recommended_tests": diagnosis.recommended_tests,
                    "urgency": diagnosis.urgency_level.value,
                    "reasoning": diagnosis.reasoning
                },
                "treatment_plan": {
                    "medications": treatment_plan.medications,
                    "procedures": treatment_plan.procedures,
                    "lifestyle_changes": treatment_plan.lifestyle_changes,
                    "follow_up": treatment_plan.follow_up_timeline,
                    "monitoring": treatment_plan.monitoring_requirements,
                    "contraindications": treatment_plan.contraindications,
                    "patient_education": treatment_plan.patient_education
                },
                "similar_cases": similar_patients[:3],
                "medical_disclaimer": "This AI-generated analysis is for clinical decision support only. All recommendations must be reviewed and approved by qualified healthcare professionals. This system does not replace professional medical judgment."
            }
            
        except Exception as e:
            logger.error(f"Patient case processing failed: {e}")
            return {"error": str(e)}
    
    async def _store_consultation(self, patient_data: PatientData, 
                                diagnosis: DiagnosisResult, 
                                treatment_plan: TreatmentRecommendation) -> str:
        """Store consultation record in database"""
        try:
            consultation_id = str(uuid.uuid4())
            diagnosis_id = str(uuid.uuid4())
            treatment_id = str(uuid.uuid4())
            
            async with self.session_factory() as session:
                # Store consultation
                consultation = Consultation(
                    id=consultation_id,
                    patient_id=patient_data.patient_id,
                    chief_complaint=patient_data.chief_complaint,
                    symptoms=[s.__dict__ for s in patient_data.symptoms],
                    vital_signs=patient_data.vital_signs,
                    lab_results=patient_data.lab_results,
                    consultation_type="ai_assisted"
                )
                session.add(consultation)
                
                # Store diagnosis
                diagnosis_record = Diagnosis(
                    id=diagnosis_id,
                    consultation_id=consultation_id,
                    patient_id=patient_data.patient_id,
                    primary_diagnosis=diagnosis.primary_diagnosis,
                    differential_diagnoses=diagnosis.differential_diagnoses,
                    confidence_level=diagnosis.confidence.value,
                    supporting_evidence=diagnosis.supporting_evidence,
                    recommendation=diagnosis.reasoning,
                    created_by="AI_SYSTEM"
                )
                session.add(diagnosis_record)
                
                # Store treatment plan
                treatment_record = TreatmentPlan(
                    id=treatment_id,
                    diagnosis_id=diagnosis_id,
                    patient_id=patient_data.patient_id,
                    medications=treatment_plan.medications,
                    procedures=treatment_plan.procedures,
                    lifestyle_recommendations=treatment_plan.lifestyle_changes,
                    follow_up_schedule=treatment_plan.follow_up_timeline,
                    monitoring_parameters=treatment_plan.monitoring_requirements,
                    contraindications=treatment_plan.contraindications
                )
                session.add(treatment_record)
                
                await session.commit()
            
            return consultation_id
            
        except Exception as e:
            logger.error(f"Consultation storage failed: {e}")
            return ""
    
    def create_sample_patient_data(self) -> PatientData:
        """Create sample patient data for demonstration"""
        return PatientData(
            patient_id=str(uuid.uuid4()),
            demographics={
                "first_name": "John",
                "last_name": "Smith",
                "age": 45,
                "gender": "male",
                "date_of_birth": datetime(1979, 3, 15)
            },
            chief_complaint="Chest pain and shortness of breath for 2 days",
            symptoms=[
                {"name": "chest pain", "severity": "moderate", "duration": "2 days", "character": "pressing"},
                {"name": "shortness of breath", "severity": "mild", "duration": "2 days", "triggers": "exertion"},
                {"name": "fatigue", "severity": "moderate", "duration": "1 week", "description": "unusual tiredness"}
            ],
            vital_signs={
                "blood_pressure": "150/95",
                "heart_rate": 88,
                "temperature": 98.6,
                "respiratory_rate": 18,
                "oxygen_saturation": 96
            },
            medical_history=[
                {"condition": "Hypertension", "diagnosis_date": datetime(2020, 1, 1), "status": "active"},
                {"condition": "Type 2 Diabetes", "diagnosis_date": datetime(2018, 6, 15), "status": "active"}
            ],
            medications=[
                {"name": "Lisinopril", "dosage": "10mg", "frequency": "daily"},
                {"name": "Metformin", "dosage": "500mg", "frequency": "twice daily"}
            ],
            allergies=["Penicillin", "Shellfish"],
            lab_results={
                "glucose": 145,
                "hba1c": 7.2,
                "cholesterol": 220,
                "troponin": 0.02
            },
            imaging_results={
                "chest_xray": "Normal heart size, clear lungs",
                "ekg": "Normal sinus rhythm, no acute changes"
            }
        )

class MedicalAPI:
    """FastAPI application for medical diagnosis system"""
    
    def __init__(self, medical_system: MedicalDiagnosisSystem):
        self.app = FastAPI(title="Medical Diagnosis and Treatment Advisor API")
        self.medical_system = medical_system
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """Setup CORS middleware"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def setup_routes(self):
        """Setup API routes"""
        
        @self.app.post("/diagnosis")
        async def get_diagnosis(patient_data: Dict[str, Any]):
            try:
                # Convert dict to PatientData object (simplified)
                patient = PatientData(
                    patient_id=patient_data.get("patient_id", str(uuid.uuid4())),
                    demographics=patient_data.get("demographics", {}),
                    chief_complaint=patient_data.get("chief_complaint", ""),
                    symptoms=patient_data.get("symptoms", []),
                    vital_signs=patient_data.get("vital_signs", {}),
                    medical_history=patient_data.get("medical_history", []),
                    medications=patient_data.get("medications", []),
                    allergies=patient_data.get("allergies", []),
                    lab_results=patient_data.get("lab_results", {}),
                    imaging_results=patient_data.get("imaging_results", {})
                )
                
                result = await self.medical_system.process_patient_case(patient)
                return result
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/patient/{patient_id}/history")
        async def get_patient_history(patient_id: str):
            try:
                history = await self.medical_system.history_manager.get_patient_history(patient_id)
                if history:
                    return history
                raise HTTPException(status_code=404, detail="Patient not found")
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/dashboard")
        async def get_dashboard():
            return {
                "system_status": "operational",
                "disclaimer": "FOR CLINICAL DECISION SUPPORT ONLY - NOT FOR INDEPENDENT DIAGNOSIS",
                "features": [
                    "AI-Assisted Diagnosis",
                    "Evidence-Based Treatment Planning",
                    "Patient History Management",
                    "Similar Case Retrieval",
                    "Medical Knowledge Integration",
                    "Clinical Decision Support"
                ],
                "compliance": [
                    "HIPAA Compliance Required",
                    "FDA Guidelines Applicable",
                    "Professional Medical Review Required",
                    "Clinical Validation Needed"
                ]
            }

# Demo function
async def demo():
    """Demonstration of the Medical Diagnosis System"""
    
    print("üè• Medical Diagnosis and Treatment Advisor Demo\n")
    print("‚ö†Ô∏è  IMPORTANT: This system is for clinical decision support only.")
    print("‚ö†Ô∏è  All recommendations require professional medical review.\n")
    
    # Configuration
    config = {
        'database_url': 'sqlite+aiosqlite:///./medical_system.db'
    }
    
    try:
        # Initialize system
        medical_system = MedicalDiagnosisSystem(config)
        await medical_system.initialize()
        
        print("‚úÖ Medical Diagnosis System initialized")
        print("‚úÖ Medical knowledge base loaded")
        print("‚úÖ AI reasoning engine ready")
        print("‚úÖ Patient history management active")
        print("‚úÖ Clinical decision support enabled")
        
        # Create sample patient case
        print(f"\nüë®‚Äç‚öïÔ∏è Creating Sample Patient Case...")
        patient_data = medical_system.create_sample_patient_data()
        
        print(f"‚úÖ Patient: {patient_data.demographics['first_name']} {patient_data.demographics['last_name']}")
        print(f"üìã Chief Complaint: {patient_data.chief_complaint}")
        print(f"üîç Symptoms: {', '.join([s['name'] for s in patient_data.symptoms])}")
        print(f"üìä Vital Signs: BP {patient_data.vital_signs['blood_pressure']}, HR {patient_data.vital_signs['heart_rate']}")
        print(f"üìú Medical History: {', '.join([h['condition'] for h in patient_data.medical_history])}")
        print(f"üíä Current Medications: {', '.join([m['name'] for m in patient_data.medications])}")
        
        # Process patient case
        print(f"\nü§ñ AI-Assisted Medical Analysis...")
        case_result = await medical_system.process_patient_case(patient_data)
        
        if "error" not in case_result:
            diagnosis = case_result["diagnosis"]
            treatment = case_result["treatment_plan"]
            
            print(f"‚úÖ Medical analysis completed")
            print(f"üéØ Consultation ID: {case_result['consultation_id']}")
            
            # Display diagnosis results
            print(f"\nüî¨ AI-Assisted Diagnosis:")
            print(f"  üéØ Primary Diagnosis: {diagnosis['primary']}")
            print(f"  üìä Confidence Level: {diagnosis['confidence'].title()}")
            print(f"  ‚ö° Urgency Level: {diagnosis['urgency'].title()}")
            
            print(f"  üîÑ Differential Diagnoses:")
            for i, diff_dx in enumerate(diagnosis['differential'][:3], 1):
                print(f"    {i}. {diff_dx.get('condition', 'Unknown')}")
                print(f"       Probability: {diff_dx.get('probability', 'Unknown')}")
                print(f"       Reasoning: {diff_dx.get('reasoning', 'No reasoning provided')[:60]}...")
            
            print(f"  üìã Supporting Evidence:")
            for i, evidence in enumerate(diagnosis['evidence'][:3], 1):
                print(f"    {i}. {evidence}")
            
            print(f"  üß™ Recommended Tests:")
            for i, test in enumerate(diagnosis['recommended_tests'][:3], 1):
                print(f"    {i}. {test}")
            
            # Display treatment plan
            print(f"\nüíä AI-Generated Treatment Plan:")
            
            if treatment['medications']:
                print(f"  üíä Medications:")
                for i, med in enumerate(treatment['medications'][:3], 1):
                    print(f"    {i}. {med.get('name', 'Unknown')}")
                    print(f"       Dosage: {med.get('dosage', 'Unknown')}")
                    print(f"       Frequency: {med.get('frequency', 'Unknown')}")
            
            if treatment['procedures']:
                print(f"  üè• Procedures:")
                for i, proc in enumerate(treatment['procedures'][:2], 1):
                    print(f"    {i}. {proc.get('name', 'Unknown')}")
                    print(f"       Urgency: {proc.get('urgency', 'Unknown')}")
            
            if treatment['lifestyle_changes']:
                print(f"  üåü Lifestyle Recommendations:")
                for i, change in enumerate(treatment['lifestyle_changes'][:3], 1):
                    print(f"    {i}. {change}")
            
            print(f"  üìÖ Follow-up Schedule:")
            follow_up = treatment['follow_up']
            if follow_up:
                print(f"    Initial: {follow_up.get('initial', 'Not specified')}")
                print(f"    Routine: {follow_up.get('routine', 'Not specified')}")
            
            if treatment['monitoring']:
                print(f"  üìä Monitoring Requirements:")
                for i, monitor in enumerate(treatment['monitoring'][:3], 1):
                    print(f"    {i}. {monitor}")
            
            # Display similar cases
            if case_result.get('similar_cases'):
                print(f"\nüë• Similar Patient Cases Found:")
                for i, similar in enumerate(case_result['similar_cases'], 1):
                    print(f"  {i}. Patient ID: {similar['patient_id']}")
                    print(f"     Similarity Score: {similar['similarity_score']:.2f}")
                    print(f"     Summary: {similar['summary'][:80]}...")
            
            # Display clinical reasoning
            print(f"\nüß† Clinical Reasoning:")
            print(f"  {diagnosis['reasoning'][:200]}...")
        
        else:
            print(f"‚ùå Analysis failed: {case_result['error']}")
        
        # Display safety information
        print(f"\n‚ö†Ô∏è  Medical Safety Information:")
        print(f"  üè• This system provides clinical decision support only")
        print(f"  üë®‚Äç‚öïÔ∏è All recommendations require physician review and approval")
        print(f"  üö® Emergency cases need immediate medical attention")
        print(f"  üìã System output must be validated by qualified healthcare providers")
        print(f"  ‚öñÔ∏è Healthcare providers retain full responsibility for patient care")
        
        # Display system capabilities
        print(f"\nüõ†Ô∏è System Capabilities:")
        print(f"  ‚úÖ Structured Patient Data Analysis")
        print(f"  ‚úÖ AI-Powered Differential Diagnosis")
        print(f"  ‚úÖ Evidence-Based Treatment Planning")
        print(f"  ‚úÖ Medical History Management")
        print(f"  ‚úÖ Similar Case Retrieval")
        print(f"  ‚úÖ Clinical Knowledge Integration")
        print(f"  ‚úÖ Drug Interaction Checking")
        print(f"  ‚úÖ Patient Education Support")
        
        # Initialize API
        print(f"\nüåê Setting up Medical API...")
        api = MedicalAPI(medical_system)
        print(f"‚úÖ API configured with medical endpoints")
        
        print(f"\nüöÄ To start the Medical API:")
        print(f"   uvicorn main:api.app --host 0.0.0.0 --port 8000")
        print(f"   Dashboard: http://localhost:8000/dashboard")
        print(f"   API Docs: http://localhost:8000/docs")
        
        print(f"\nüè• Healthcare Use Cases:")
        print(f"  ‚Ä¢ Clinical decision support")
        print(f"  ‚Ä¢ Differential diagnosis assistance")
        print(f"  ‚Ä¢ Treatment planning guidance")
        print(f"  ‚Ä¢ Medical education and training")
        print(f"  ‚Ä¢ Quality assurance and review")
        print(f"  ‚Ä¢ Research and case studies")
        
        print(f"\nüè• Medical Diagnosis and Treatment Advisor demo completed!")
        print(f"   ‚ö†Ô∏è  Remember: This is a clinical decision support tool only")
        print(f"   ‚ö†Ô∏è  Always consult qualified healthcare professionals")
        
    except Exception as e:
        print(f"‚ùå Demo error: {e}")
        logger.error(f"Demo failed: {e}")

# Dependencies information
dependencies_info = """
# Install required dependencies:
pip install fastapi uvicorn
pip install sqlalchemy aiosqlite
pip install langchain openai
pip install langgraph
pip install chromadb
pip install pandas numpy
pip install pydantic
pip install python-multipart

# Environment variables:
export OPENAI_API_KEY="your-openai-api-key"
export DATABASE_URL="sqlite+aiosqlite:///./medical_system.db"

# For production medical systems:
pip install cryptography  # For data encryption
pip install pydicom  # For medical imaging
pip install hl7apy  # For HL7 message processing
pip install fhir.resources  # For FHIR compliance

# Medical data standards:
export FHIR_SERVER_URL="your-fhir-server"
export HL7_CONFIG="your-hl7-config"

# IMPORTANT LEGAL AND ETHICAL CONSIDERATIONS:
# - This system is for clinical decision support only
# - NOT approved for independent medical diagnosis
# - Requires oversight by qualified healthcare professionals
# - Must comply with HIPAA, FDA, and local medical regulations
# - Healthcare providers retain full responsibility for patient care
# - Proper medical malpractice insurance required
# - Regular system validation and updates necessary
# - Patient consent and data privacy must be maintained
# - Emergency protocols must be in place
# - Clinical validation studies recommended before deployment

# Medical Database Integration (optional):
export EMR_SYSTEM_URL="your-emr-system"
export MEDICAL_DEVICE_API="your-device-api"
export PHARMACY_SYSTEM="your-pharmacy-api"

# Compliance and Security:
export ENCRYPTION_KEY="your-encryption-key"
export AUDIT_LOG_ENDPOINT="your-audit-system"
export BACKUP_SYSTEM="your-backup-solution"
"""

if __name__ == "__main__":
    print(dependencies_info)
    asyncio.run(demo())
````

## Project Summary

The Medical Diagnosis and Treatment Advisor represents a groundbreaking AI-enhanced clinical decision support platform that revolutionizes healthcare delivery through intelligent patient data analysis, evidence-based diagnosis assistance, and comprehensive treatment planning. This system addresses critical healthcare challenges by providing sophisticated AI-powered medical insights while maintaining the highest standards of medical ethics, patient safety, and clinical oversight.

### Key Value Propositions

1. **Intelligent Clinical Decision Support**: Advanced AI-powered diagnostic assistance that analyzes comprehensive patient data including symptoms, medical history, vital signs, and laboratory results to generate differential diagnoses with supporting evidence and confidence levels, enhancing clinical decision-making accuracy.

2. **Evidence-Based Treatment Planning**: Sophisticated treatment recommendation system that generates personalized treatment plans based on current medical guidelines, patient-specific factors, and similar case outcomes while considering contraindications, drug interactions, and patient preferences.

3. **Comprehensive Patient History Management**: Advanced memory system that maintains detailed longitudinal patient records, tracks treatment outcomes, monitors medication histories, and enables continuity of care across multiple healthcare encounters and providers.

4. **Medical Knowledge Integration**: Seamless integration with medical literature, clinical guidelines, drug databases, and diagnostic criteria to ensure all recommendations align with current evidence-based medicine standards and best practices.

### Key Takeaways

- **Enhanced Diagnostic Accuracy**: Significantly improves diagnostic precision by combining AI analysis with comprehensive medical knowledge retrieval, reducing diagnostic errors and supporting clinical reasoning processes
- **Accelerated Clinical Workflows**: Streamlines healthcare delivery by providing rapid analysis of complex patient data, enabling healthcare providers to focus on patient care rather than administrative tasks
- **Democratized Medical Expertise**: Makes specialist-level medical knowledge accessible to healthcare providers in diverse settings, improving care quality across different healthcare environments
- **Clinical Safety and Compliance**: Designed with strict adherence to medical ethics, regulatory requirements, and clinical safety standards while maintaining clear boundaries between AI assistance and physician responsibility

This Medical Diagnosis and Treatment Advisor empowers healthcare professionals by combining the precision of AI-powered analysis with deep medical knowledge integration, enabling more accurate diagnoses, evidence-based treatment planning, and improved patient outcomes while maintaining the highest standards of medical ethics, patient safety, and professional responsibility in healthcare delivery.