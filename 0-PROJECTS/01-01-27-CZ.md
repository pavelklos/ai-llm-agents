<small>Claude Sonnet 4 **(Music Composition Assistant - MCP Projekt)**</small>
# Music Composition Assistant

## Kl√≠ƒçov√© Koncepty Vysvƒõtlen√≠

### Model Context Protocol (MCP)
**MCP** je protokol pro komunikaci mezi AI agenty a n√°stroji/zdroji dat. Umo≈æ≈àuje AI model≈Øm p≈ô√≠stup k extern√≠m funkc√≠m, datab√°z√≠m a slu≈æb√°m strukturovan√Ωm zp≈Øsobem.

### Audio Anal√Ωza
Proces extrakce hudebn√≠ch prvk≈Ø ze zvukov√Ωch soubor≈Ø vƒçetnƒõ tempa, t√≥niny, spektr√°ln√≠ch charakteristik a rytmick√Ωch vzor≈Ø.

### Melodie Generov√°n√≠
Algoritmick√© vytv√°≈ôen√≠ melodick√Ωch sekvenc√≠ na z√°kladƒõ hudebn√≠ch pravidel, styl≈Ø a vstupn√≠ch parametr≈Ø.

### Akordov√© Progrese
Sekvence akord≈Ø tvo≈ô√≠c√≠ harmonickou strukturu skladby, n√°sleduj√≠c√≠ hudebn√≠ teorii a ≈æ√°nrov√© konvence.

### ≈Ω√°nrov√° Klasifikace
ML technika pro automatick√© rozpozn√°n√≠ hudebn√≠ho ≈æ√°nru na z√°kladƒõ audio charakteristik.

### Spotify/Apple Music APIs
Rozhran√≠ umo≈æ≈àuj√≠c√≠ p≈ô√≠stup k metadat≈Øm hudby, audio funkc√≠m a doporuƒçovac√≠m syst√©m≈Øm.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Music Composition Assistant je inteligentn√≠ syst√©m vyu≈æ√≠vaj√≠c√≠ MCP pro tvorbu hudby. Kombinuje AI agenty s hudebn√≠mi n√°stroji pro anal√Ωzu, generov√°n√≠ a kompozici hudby r≈Øzn√Ωch ≈æ√°nr≈Ø.

### Hlavn√≠ V√Ωzvy
- **Hudebn√≠ Teorie**: Implementace komplexn√≠ch hudebn√≠ch pravidel
- **Audio Zpracov√°n√≠**: Real-time anal√Ωza a synt√©za zvuku
- **API Integrace**: Spolehliv√© propojen√≠ s hudebn√≠mi slu≈æbami
- **Kreativita vs. Struktura**: Vyv√°≈æen√≠ algoritmick√© logiky s umƒõleckou svobodou

### Potenci√°ln√≠ Dopad
Demokratizace hudebn√≠ tvorby, umo≈ænƒõn√≠ hudebn√≠k≈Øm v≈°ech √∫rovn√≠ vytv√°≈ôet profesion√°ln√≠ kompozice s AI asistenc√≠.

## Komplexn√≠ Implementace v Pythonu

````python
import asyncio
import json
import logging
import numpy as np
import librosa
import requests
from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple
from abc import ABC, abstractmethod
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import music21
from mcp import ClientSession, StdioServerParameters
from pydantic import BaseModel
import torch
import torch.nn as nn
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
import pickle
import os

# Nastaven√≠ logov√°n√≠
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Hudebn√≠ datov√© struktury
@dataclass
class MusicalNote:
    pitch: str
    duration: float
    velocity: int = 80

@dataclass
class Chord:
    root: str
    quality: str  # major, minor, dim, aug
    notes: List[str]

@dataclass
class MusicalPhrase:
    notes: List[MusicalNote]
    tempo: int
    time_signature: str

# MCP Konfigurace
class MCPConfig(BaseModel):
    server_command: List[str]
    env: Optional[Dict[str, str]] = None

# Audio Analyzer
class AudioAnalyzer:
    def __init__(self):
        self.sample_rate = 22050
        
    def extract_features(self, audio_path: str) -> Dict:
        """Extrakce audio funkc√≠ ze souboru"""
        try:
            y, sr = librosa.load(audio_path, sr=self.sample_rate)
            
            # Z√°kladn√≠ funkce
            tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
            chroma = librosa.feature.chroma_stft(y=y, sr=sr)
            mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)
            spectral_centroid = librosa.feature.spectral_centroid(y=y, sr=sr)
            zero_crossing_rate = librosa.feature.zero_crossing_rate(y)
            
            features = {
                'tempo': float(tempo),
                'chroma_mean': np.mean(chroma, axis=1).tolist(),
                'mfcc_mean': np.mean(mfcc, axis=1).tolist(),
                'spectral_centroid_mean': float(np.mean(spectral_centroid)),
                'zcr_mean': float(np.mean(zero_crossing_rate)),
                'duration': len(y) / sr
            }
            
            logger.info(f"Audio funkce extrahov√°ny: tempo={tempo:.2f}")
            return features
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi extrakci audio funkc√≠: {e}")
            return {}

# Gener√°tor Melodi√≠
class MelodyGenerator:
    def __init__(self):
        self.scales = {
            'major': [0, 2, 4, 5, 7, 9, 11],
            'minor': [0, 2, 3, 5, 7, 8, 10],
            'pentatonic': [0, 2, 4, 7, 9],
            'blues': [0, 3, 5, 6, 7, 10]
        }
        
    def generate_melody(self, scale: str, key: str, length: int, 
                       style: str = 'balanced') -> List[MusicalNote]:
        """Generov√°n√≠ melodie podle zadan√Ωch parametr≈Ø"""
        try:
            if scale not in self.scales:
                scale = 'major'
                
            scale_degrees = self.scales[scale]
            base_octave = 4
            
            melody = []
            
            for i in range(length):
                # V√Ωbƒõr stupnƒõ stupnice
                if style == 'ascending':
                    degree = scale_degrees[i % len(scale_degrees)]
                elif style == 'descending':
                    degree = scale_degrees[-(i % len(scale_degrees)) - 1]
                else:  # balanced
                    degree = np.random.choice(scale_degrees)
                
                # Konverze na MIDI ƒç√≠slo
                key_offset = self._key_to_midi_offset(key)
                midi_note = 60 + key_offset + degree  # C4 = 60
                
                # Konverze na notaci
                pitch = self._midi_to_note_name(midi_note)
                
                # N√°hodn√° d√©lka noty
                durations = [0.25, 0.5, 1.0, 2.0]
                duration = np.random.choice(durations)
                
                note = MusicalNote(pitch=pitch, duration=duration)
                melody.append(note)
            
            logger.info(f"Melodie vygenerov√°na: {length} not ve stupnici {scale}")
            return melody
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ melodie: {e}")
            return []
    
    def _key_to_midi_offset(self, key: str) -> int:
        """Konverze t√≥niny na MIDI offset"""
        key_offsets = {
            'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
            'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
            'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
        }
        return key_offsets.get(key, 0)
    
    def _midi_to_note_name(self, midi_num: int) -> str:
        """Konverze MIDI ƒç√≠sla na n√°zev noty"""
        notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 
                'F#', 'G', 'G#', 'A', 'A#', 'B']
        octave = midi_num // 12 - 1
        note = notes[midi_num % 12]
        return f"{note}{octave}"

# Gener√°tor Akordov√Ωch Progres√≠
class ChordProgressionGenerator:
    def __init__(self):
        self.progressions = {
            'pop': ['I', 'V', 'vi', 'IV'],
            'jazz': ['ii', 'V', 'I', 'vi'],
            'blues': ['I', 'I', 'I', 'I', 'IV', 'IV', 'I', 'I', 'V', 'IV', 'I', 'V'],
            'rock': ['I', 'bVII', 'IV', 'I']
        }
        
    def generate_progression(self, key: str, style: str, length: int) -> List[Chord]:
        """Generov√°n√≠ akordov√© progrese"""
        try:
            if style not in self.progressions:
                style = 'pop'
                
            pattern = self.progressions[style]
            progression = []
            
            for i in range(length):
                roman_numeral = pattern[i % len(pattern)]
                chord = self._roman_to_chord(roman_numeral, key)
                progression.append(chord)
            
            logger.info(f"Akordov√° progrese vygenerov√°na: {length} akord≈Ø ve stylu {style}")
            return progression
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ progrese: {e}")
            return []
    
    def _roman_to_chord(self, roman: str, key: str) -> Chord:
        """Konverze ≈ô√≠msk√©ho ƒç√≠sla na akord"""
        # Zjednodu≈°en√° implementace
        major_scale = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
        key_index = major_scale.index(key) if key in major_scale else 0
        
        # Mapov√°n√≠ ≈ô√≠msk√Ωch ƒç√≠slic
        roman_map = {
            'I': (0, 'major'), 'ii': (1, 'minor'), 'iii': (2, 'minor'),
            'IV': (3, 'major'), 'V': (4, 'major'), 'vi': (5, 'minor'),
            'vii¬∞': (6, 'dim'), 'bVII': (6, 'major')
        }
        
        if roman in roman_map:
            degree, quality = roman_map[roman]
            root_index = (key_index + degree) % 7
            root = major_scale[root_index]
            
            # Generov√°n√≠ not akordu
            if quality == 'major':
                notes = [root, major_scale[(root_index + 2) % 7], 
                        major_scale[(root_index + 4) % 7]]
            elif quality == 'minor':
                notes = [root, major_scale[(root_index + 2) % 7], 
                        major_scale[(root_index + 4) % 7]]
            else:
                notes = [root]
            
            return Chord(root=root, quality=quality, notes=notes)
        
        return Chord(root=key, quality='major', notes=[key])

# ≈Ω√°nrov√Ω Klasifik√°tor
class GenreClassifier:
    def __init__(self):
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.scaler = StandardScaler()
        self.genres = ['rock', 'pop', 'jazz', 'classical', 'electronic', 'blues']
        self.is_trained = False
    
    def train_model(self):
        """Tr√©nov√°n√≠ modelu na syntetick√Ωch datech"""
        try:
            # Generov√°n√≠ syntetick√Ωch tr√©novac√≠ch dat
            X, y = self._generate_training_data()
            
            # Normalizace dat
            X_scaled = self.scaler.fit_transform(X)
            
            # Tr√©nov√°n√≠ modelu
            self.model.fit(X_scaled, y)
            self.is_trained = True
            
            logger.info("Model ≈æ√°nrov√© klasifikace natr√©nov√°n")
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi tr√©nov√°n√≠ modelu: {e}")
    
    def classify_genre(self, features: Dict) -> Tuple[str, float]:
        """Klasifikace ≈æ√°nru na z√°kladƒõ audio funkc√≠"""
        try:
            if not self.is_trained:
                self.train_model()
            
            # P≈ô√≠prava funkc√≠ pro predikci
            feature_vector = self._extract_feature_vector(features)
            feature_scaled = self.scaler.transform([feature_vector])
            
            # Predikce
            prediction = self.model.predict(feature_scaled)[0]
            probabilities = self.model.predict_proba(feature_scaled)[0]
            confidence = max(probabilities)
            
            genre = self.genres[prediction]
            
            logger.info(f"≈Ω√°nr klasifikov√°n: {genre} (spolehlivost: {confidence:.2f})")
            return genre, confidence
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi klasifikaci ≈æ√°nru: {e}")
            return 'unknown', 0.0
    
    def _generate_training_data(self):
        """Generov√°n√≠ syntetick√Ωch tr√©novac√≠ch dat"""
        samples_per_genre = 50
        n_features = 20
        
        X = []
        y = []
        
        for genre_idx, genre in enumerate(self.genres):
            for _ in range(samples_per_genre):
                # Generov√°n√≠ charakteristick√Ωch funkc√≠ pro ka≈æd√Ω ≈æ√°nr
                if genre == 'electronic':
                    features = np.random.normal(0.7, 0.2, n_features)
                elif genre == 'classical':
                    features = np.random.normal(0.3, 0.15, n_features)
                elif genre == 'rock':
                    features = np.random.normal(0.8, 0.25, n_features)
                else:
                    features = np.random.normal(0.5, 0.2, n_features)
                
                X.append(features)
                y.append(genre_idx)
        
        return np.array(X), np.array(y)
    
    def _extract_feature_vector(self, features: Dict) -> List[float]:
        """Extrakce vektoru funkc√≠ ze slovn√≠ku"""
        vector = []
        vector.append(features.get('tempo', 120) / 200.0)  # Normalizace tempa
        vector.append(features.get('spectral_centroid_mean', 1000) / 5000.0)
        vector.append(features.get('zcr_mean', 0.1))
        
        # P≈ôid√°n√≠ MFCC funkc√≠
        mfcc = features.get('mfcc_mean', [0] * 13)
        vector.extend(mfcc[:13])
        
        # P≈ôid√°n√≠ chroma funkc√≠
        chroma = features.get('chroma_mean', [0] * 12)
        vector.extend(chroma[:4])  # Pouze prvn√≠ 4 pro konzistenci
        
        return vector

# Spotify API Client
class SpotifyClient:
    def __init__(self, client_id: str, client_secret: str):
        try:
            credentials = SpotifyClientCredentials(
                client_id=client_id,
                client_secret=client_secret
            )
            self.sp = spotipy.Spotify(client_credentials_manager=credentials)
            logger.info("Spotify klient inicializov√°n")
        except Exception as e:
            logger.error(f"Chyba p≈ôi inicializaci Spotify klienta: {e}")
            self.sp = None
    
    def search_tracks(self, query: str, genre: str = None, limit: int = 10) -> List[Dict]:
        """Vyhled√°n√≠ skladeb na Spotify"""
        try:
            if not self.sp:
                return []
            
            search_query = query
            if genre:
                search_query += f" genre:{genre}"
            
            results = self.sp.search(q=search_query, type='track', limit=limit)
            
            tracks = []
            for track in results['tracks']['items']:
                track_info = {
                    'name': track['name'],
                    'artist': track['artists'][0]['name'],
                    'id': track['id'],
                    'popularity': track['popularity'],
                    'preview_url': track['preview_url']
                }
                tracks.append(track_info)
            
            logger.info(f"Nalezeno {len(tracks)} skladeb pro dotaz: {query}")
            return tracks
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi vyhled√°v√°n√≠ na Spotify: {e}")
            return []
    
    def get_audio_features(self, track_id: str) -> Dict:
        """Z√≠sk√°n√≠ audio funkc√≠ skladby"""
        try:
            if not self.sp:
                return {}
            
            features = self.sp.audio_features(track_id)[0]
            if features:
                return {
                    'danceability': features['danceability'],
                    'energy': features['energy'],
                    'valence': features['valence'],
                    'tempo': features['tempo'],
                    'key': features['key'],
                    'mode': features['mode']
                }
            return {}
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ audio funkc√≠: {e}")
            return {}

# MCP Music Agent
class MCPMusicAgent:
    def __init__(self, config: MCPConfig):
        self.config = config
        self.session = None
        self.audio_analyzer = AudioAnalyzer()
        self.melody_generator = MelodyGenerator()
        self.chord_generator = ChordProgressionGenerator()
        self.genre_classifier = GenreClassifier()
        self.spotify_client = None
        
    async def initialize(self):
        """Inicializace MCP agenta"""
        try:
            server_params = StdioServerParameters(
                command=self.config.server_command,
                env=self.config.env
            )
            self.session = await ClientSession.create(server_params)
            logger.info("MCP agent inicializov√°n")
        except Exception as e:
            logger.error(f"Chyba p≈ôi inicializaci MCP agenta: {e}")
    
    async def analyze_track(self, audio_path: str) -> Dict:
        """Anal√Ωza hudebn√≠ skladby"""
        try:
            features = self.audio_analyzer.extract_features(audio_path)
            if features:
                genre, confidence = self.genre_classifier.classify_genre(features)
                features['predicted_genre'] = genre
                features['genre_confidence'] = confidence
                
                logger.info(f"Skladba analyzov√°na: ≈æ√°nr {genre}")
            return features
        except Exception as e:
            logger.error(f"Chyba p≈ôi anal√Ωze skladby: {e}")
            return {}
    
    async def compose_music(self, style: str, key: str, length: int) -> Dict:
        """Kompozice hudby"""
        try:
            # Generov√°n√≠ melodie
            melody = self.melody_generator.generate_melody(
                scale='major' if style in ['pop', 'rock'] else 'minor',
                key=key,
                length=length
            )
            
            # Generov√°n√≠ akordov√© progrese
            chords = self.chord_generator.generate_progression(
                key=key,
                style=style,
                length=length // 4
            )
            
            composition = {
                'melody': [{'pitch': n.pitch, 'duration': n.duration} for n in melody],
                'chords': [{'root': c.root, 'quality': c.quality, 'notes': c.notes} for c in chords],
                'style': style,
                'key': key,
                'tempo': 120
            }
            
            logger.info(f"Kompozice vytvo≈ôena: {style} v t√≥ninƒõ {key}")
            return composition
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi kompozici: {e}")
            return {}
    
    def set_spotify_credentials(self, client_id: str, client_secret: str):
        """Nastaven√≠ Spotify p≈ôihla≈°ovac√≠ch √∫daj≈Ø"""
        self.spotify_client = SpotifyClient(client_id, client_secret)
    
    async def search_similar_tracks(self, composition: Dict) -> List[Dict]:
        """Vyhled√°n√≠ podobn√Ωch skladeb"""
        try:
            if not self.spotify_client:
                logger.warning("Spotify klient nen√≠ inicializov√°n")
                return []
            
            style = composition.get('style', 'pop')
            key = composition.get('key', 'C')
            
            query = f"key:{key}"
            tracks = self.spotify_client.search_tracks(query, genre=style)
            
            return tracks
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi vyhled√°v√°n√≠ podobn√Ωch skladeb: {e}")
            return []

# Hlavn√≠ Aplikace
class MusicCompositionApp:
    def __init__(self):
        self.mcp_config = MCPConfig(
            server_command=["python", "-m", "music_mcp_server"],
            env={"MUSIC_DATA_PATH": "./music_data"}
        )
        self.agent = MCPMusicAgent(self.mcp_config)
        
    async def run_composition_workflow(self):
        """Spu≈°tƒõn√≠ hlavn√≠ho workflow kompozice"""
        try:
            await self.agent.initialize()
            
            # Uk√°zkov√Ω workflow
            print("üéµ Music Composition Assistant")
            print("=" * 40)
            
            # 1. Kompozice nov√© hudby
            print("1. Vytv√°≈ôen√≠ nov√© kompozice...")
            composition = await self.agent.compose_music(
                style='pop',
                key='C',
                length=16
            )
            
            if composition:
                print(f"‚úÖ Kompozice vytvo≈ôena:")
                print(f"   Styl: {composition['style']}")
                print(f"   T√≥nina: {composition['key']}")
                print(f"   Poƒçet not: {len(composition['melody'])}")
                print(f"   Poƒçet akord≈Ø: {len(composition['chords'])}")
            
            # 2. Anal√Ωza existuj√≠c√≠ skladby (simulace)
            print("\n2. Anal√Ωza existuj√≠c√≠ skladby...")
            # V re√°ln√© aplikaci by zde byl cesta k audio souboru
            sample_features = {
                'tempo': 128.0,
                'spectral_centroid_mean': 2500.0,
                'zcr_mean': 0.05,
                'mfcc_mean': [0.1] * 13,
                'chroma_mean': [0.2] * 12
            }
            
            genre, confidence = self.agent.genre_classifier.classify_genre(sample_features)
            print(f"‚úÖ ≈Ω√°nr identifikov√°n: {genre} (spolehlivost: {confidence:.2f})")
            
            # 3. Vyhled√°n√≠ podobn√Ωch skladeb (vy≈æaduje Spotify credentials)
            print("\n3. Vyhled√°v√°n√≠ podobn√Ωch skladeb...")
            print("‚ÑπÔ∏è  Pro tuto funkci jsou pot≈ôeba Spotify API credentials")
            
            print("\nüéâ Workflow dokonƒçen!")
            
        except Exception as e:
            logger.error(f"Chyba ve workflow: {e}")

# Spu≈°tƒõn√≠ aplikace
async def main():
    """Hlavn√≠ funkce aplikace"""
    app = MusicCompositionApp()
    await app.run_composition_workflow()

if __name__ == "__main__":
    # Instalace z√°vislost√≠
    print("üì¶ Kontrola z√°vislost√≠...")
    required_packages = [
        "librosa", "spotipy", "music21", "torch", 
        "scikit-learn", "numpy", "pydantic"
    ]
    
    print("üí° Pro plnou funkcionalnost nainstalujte:")
    for package in required_packages:
        print(f"   pip install {package}")
    
    print("\nüöÄ Spou≈°tƒõn√≠ Music Composition Assistant...")
    asyncio.run(main())
````

## Shrnut√≠ Projektu

### Hodnota Projektu
Music Composition Assistant p≈ôedstavuje pokroƒçil√Ω AI syst√©m pro hudebn√≠ tvorbu kombinuj√≠c√≠:

- **MCP Integraci** pro modul√°rn√≠ architekturu
- **Audio Anal√Ωzu** pro porozumƒõn√≠ hudebn√≠m struktur√°m  
- **Generativn√≠ AI** pro tvorbu melodi√≠ a akord≈Ø
- **ML Klasifikaci** ≈æ√°nr≈Ø pro stylovou konzistenci
- **API Integrace** s hudebn√≠mi platformami

### Kl√≠ƒçov√© V√Ωhody
- Demokratizace hudebn√≠ tvorby
- Podpora vzdƒõl√°v√°n√≠ v hudebn√≠ teorii
- N√°stroj pro profesion√°ln√≠ hudebn√≠ky
- Scalabiln√≠ architektura s MCP
- Real-time anal√Ωza a generov√°n√≠

### Technick√© Inovace
Projekt vyu≈æ√≠v√° modern√≠ Python ekosyst√©m s knihovnami pro audio zpracov√°n√≠ (librosa), hudebn√≠ teorii (music21), machine learning (scikit-learn) a API integraci (spotipy). MCP protokol zaji≈°≈•uje modul√°rnost a roz≈°i≈ôitelnost syst√©mu.

Tento komprehenzivn√≠ n√°stroj umo≈æ≈àuje jak zaƒç√°teƒçn√≠k≈Øm, tak pokroƒçil√Ωm hudebn√≠k≈Øm vyu≈æ√≠t s√≠lu AI pro kreativn√≠ hudebn√≠ tvorbu.