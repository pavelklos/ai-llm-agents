<small>Claude Sonnet 4 **(Customer Service Chatbot Agent)**</small>
# Customer Service Chatbot Agent

## Key Concepts Explanation

### Retrieval-Augmented Generation (RAG)
Advanced AI system that combines large language models with external knowledge retrieval to provide accurate, contextually relevant responses by searching through company documentation, FAQs, policies, and product information in real-time.

### Multi-turn Conversation Management
Sophisticated dialogue system that maintains conversation context across multiple exchanges, tracks user intent progression, handles topic switches, and preserves conversation state for coherent, natural customer interactions.

### Tool Integration and Function Calling
Extensible framework that enables the chatbot to interact with external systems including CRM databases, order management systems, payment processors, and third-party APIs to perform actions beyond conversation.

### Intent Recognition and Classification
Natural language understanding system that identifies customer intents, extracts entities, and classifies conversation types to route requests appropriately and trigger relevant automated workflows.

### Escalation Management
Intelligent system that recognizes when conversations require human intervention, seamlessly transfers context to human agents, and maintains continuity throughout the customer service journey.

## Comprehensive Project Explanation

### Objectives
The Customer Service Chatbot Agent provides automated customer support through intelligent conversation management, knowledge retrieval, and system integration to deliver efficient, accurate, and personalized customer service experiences.

### Key Features
- **Intelligent Knowledge Retrieval**: RAG-powered responses from company knowledge base
- **Context-Aware Conversations**: Multi-turn dialogue with memory and state management
- **System Integration**: Real-time access to orders, accounts, and business systems
- **Automated Actions**: Ticket creation, order updates, and workflow triggers
- **Seamless Escalation**: Smart handoff to human agents with full context

### Challenges
- **Knowledge Accuracy**: Ensuring retrieved information is current and relevant
- **Context Preservation**: Maintaining conversation flow across complex interactions
- **System Integration**: Connecting to multiple backend systems securely
- **Response Quality**: Balancing automation with human-like interaction quality

### Potential Impact
This system can reduce support costs by 60-80%, improve response times to seconds, provide 24/7 availability, increase customer satisfaction through consistent service quality, and free human agents for complex issues.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
langchain-community==0.0.10
chromadb==0.4.15
sentence-transformers==2.2.2
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
requests==2.31.0
pydantic==2.5.0
python-dotenv==1.0.0
uuid
datetime
logging
typing
dataclasses
enum
json
re
````

### Core Implementation

````python
import pandas as pd
import numpy as np
import json
import re
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import uuid
import requests

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go

# LangChain components
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.memory import ConversationBufferWindowMemory
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.tools import BaseTool
from langchain.agents import AgentExecutor, create_openai_functions_agent

# Vector database
import chromadb
from sentence_transformers import SentenceTransformer

# Pydantic for structured data
from pydantic import BaseModel, Field

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CustomerIntent(Enum):
    PRODUCT_INQUIRY = "product_inquiry"
    ORDER_STATUS = "order_status"
    RETURN_REQUEST = "return_request"
    BILLING_ISSUE = "billing_issue"
    TECHNICAL_SUPPORT = "technical_support"
    ACCOUNT_MANAGEMENT = "account_management"
    COMPLAINT = "complaint"
    GENERAL_INQUIRY = "general_inquiry"

class ConversationStatus(Enum):
    ACTIVE = "active"
    RESOLVED = "resolved"
    ESCALATED = "escalated"
    PENDING = "pending"

class Priority(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

@dataclass
class Customer:
    customer_id: str
    email: str
    name: str
    phone: Optional[str] = None
    tier: str = "standard"  # standard, premium, enterprise
    join_date: datetime = field(default_factory=datetime.now)
    total_orders: int = 0
    total_spent: float = 0.0

@dataclass
class Order:
    order_id: str
    customer_id: str
    status: str
    items: List[Dict[str, Any]]
    total_amount: float
    order_date: datetime
    shipping_address: str
    tracking_number: Optional[str] = None

@dataclass
class Ticket:
    ticket_id: str
    customer_id: str
    subject: str
    description: str
    intent: CustomerIntent
    priority: Priority
    status: ConversationStatus
    created_at: datetime
    updated_at: datetime
    assigned_agent: Optional[str] = None
    conversation_history: List[Dict[str, str]] = field(default_factory=list)

@dataclass
class KnowledgeDocument:
    doc_id: str
    title: str
    content: str
    category: str
    tags: List[str]
    last_updated: datetime
    relevance_score: float = 0.0

class KnowledgeBase:
    """RAG-powered knowledge retrieval system."""
    
    def __init__(self):
        # Initialize ChromaDB
        self.chroma_client = chromadb.Client()
        
        try:
            self.collection = self.chroma_client.create_collection(
                name="knowledge_base",
                metadata={"description": "Customer service knowledge base"}
            )
        except:
            self.collection = self.chroma_client.get_collection("knowledge_base")
        
        # Sentence transformer for embeddings
        self.embedding_model = SentenceTransformer('all-MiniLM-L6-v2')
        
        # Initialize with sample knowledge
        self._initialize_knowledge_base()
    
    def _initialize_knowledge_base(self):
        """Initialize knowledge base with sample data."""
        sample_docs = [
            KnowledgeDocument(
                doc_id="kb_001",
                title="Return Policy",
                content="Our return policy allows returns within 30 days of purchase. Items must be unused and in original packaging. Refunds are processed within 5-7 business days.",
                category="policy",
                tags=["returns", "refunds", "policy"],
                last_updated=datetime.now()
            ),
            KnowledgeDocument(
                doc_id="kb_002",
                title="Shipping Information",
                content="We offer free shipping on orders over $50. Standard shipping takes 3-5 business days. Express shipping takes 1-2 business days for an additional fee.",
                category="shipping",
                tags=["shipping", "delivery", "timeline"],
                last_updated=datetime.now()
            ),
            KnowledgeDocument(
                doc_id="kb_003",
                title="Order Tracking",
                content="You can track your order using the tracking number provided in your confirmation email. Orders typically ship within 24 hours of placement.",
                category="orders",
                tags=["tracking", "orders", "status"],
                last_updated=datetime.now()
            ),
            KnowledgeDocument(
                doc_id="kb_004",
                title="Payment Methods",
                content="We accept all major credit cards, PayPal, Apple Pay, and Google Pay. Payment is processed securely at checkout.",
                category="billing",
                tags=["payment", "billing", "security"],
                last_updated=datetime.now()
            ),
            KnowledgeDocument(
                doc_id="kb_005",
                title="Account Management",
                content="You can update your account information, view order history, and manage preferences in your account dashboard. Password changes require email verification.",
                category="account",
                tags=["account", "profile", "password"],
                last_updated=datetime.now()
            ),
            KnowledgeDocument(
                doc_id="kb_006",
                title="Product Warranty",
                content="All products come with a 1-year manufacturer warranty. Electronics have an additional 90-day satisfaction guarantee. Warranty claims require proof of purchase.",
                category="warranty",
                tags=["warranty", "guarantee", "products"],
                last_updated=datetime.now()
            )
        ]
        
        # Add documents to vector database
        for doc in sample_docs:
            self.add_document(doc)
    
    def add_document(self, document: KnowledgeDocument) -> bool:
        """Add document to knowledge base."""
        try:
            # Generate embedding
            embedding = self.embedding_model.encode(document.content).tolist()
            
            # Add to ChromaDB
            self.collection.add(
                documents=[document.content],
                embeddings=[embedding],
                metadatas=[{
                    "doc_id": document.doc_id,
                    "title": document.title,
                    "category": document.category,
                    "tags": json.dumps(document.tags),
                    "last_updated": document.last_updated.isoformat()
                }],
                ids=[document.doc_id]
            )
            
            logger.info(f"Added document {document.doc_id} to knowledge base")
            return True
        
        except Exception as e:
            logger.error(f"Error adding document: {e}")
            return False
    
    def search_knowledge(self, query: str, limit: int = 3) -> List[KnowledgeDocument]:
        """Search knowledge base using semantic similarity."""
        try:
            # Generate query embedding
            query_embedding = self.embedding_model.encode(query).tolist()
            
            # Search ChromaDB
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=limit
            )
            
            documents = []
            if results['documents']:
                for i, content in enumerate(results['documents'][0]):
                    metadata = results['metadatas'][0][i]
                    
                    doc = KnowledgeDocument(
                        doc_id=metadata['doc_id'],
                        title=metadata['title'],
                        content=content,
                        category=metadata['category'],
                        tags=json.loads(metadata['tags']),
                        last_updated=datetime.fromisoformat(metadata['last_updated']),
                        relevance_score=1 - results['distances'][0][i] if 'distances' in results else 0.9
                    )
                    documents.append(doc)
            
            return documents
        
        except Exception as e:
            logger.error(f"Error searching knowledge base: {e}")
            return []

class CRMSystem:
    """Mock CRM system for customer and order management."""
    
    def __init__(self):
        self.customers = {}
        self.orders = {}
        self.tickets = {}
        
        # Initialize with sample data
        self._initialize_sample_data()
    
    def _initialize_sample_data(self):
        """Initialize with sample customer and order data."""
        # Sample customers
        customers = [
            Customer("cust_001", "john.doe@email.com", "John Doe", "+1234567890", "premium", datetime.now() - timedelta(days=365), 15, 2500.0),
            Customer("cust_002", "jane.smith@email.com", "Jane Smith", "+1987654321", "standard", datetime.now() - timedelta(days=180), 8, 800.0),
            Customer("cust_003", "bob.wilson@email.com", "Bob Wilson", "+1555000111", "enterprise", datetime.now() - timedelta(days=730), 45, 12000.0)
        ]
        
        for customer in customers:
            self.customers[customer.customer_id] = customer
        
        # Sample orders
        orders = [
            Order("ord_001", "cust_001", "delivered", [{"item": "Laptop", "quantity": 1, "price": 999.99}], 999.99, datetime.now() - timedelta(days=5), "123 Main St", "TRK123456"),
            Order("ord_002", "cust_002", "shipped", [{"item": "Phone Case", "quantity": 2, "price": 25.99}], 51.98, datetime.now() - timedelta(days=2), "456 Oak Ave", "TRK789012"),
            Order("ord_003", "cust_003", "processing", [{"item": "Monitor", "quantity": 3, "price": 299.99}], 899.97, datetime.now() - timedelta(days=1), "789 Pine Rd", None)
        ]
        
        for order in orders:
            self.orders[order.order_id] = order
    
    def get_customer_by_email(self, email: str) -> Optional[Customer]:
        """Get customer by email address."""
        for customer in self.customers.values():
            if customer.email.lower() == email.lower():
                return customer
        return None
    
    def get_customer_orders(self, customer_id: str) -> List[Order]:
        """Get all orders for a customer."""
        return [order for order in self.orders.values() if order.customer_id == customer_id]
    
    def get_order_by_id(self, order_id: str) -> Optional[Order]:
        """Get order by ID."""
        return self.orders.get(order_id)
    
    def update_order_status(self, order_id: str, new_status: str) -> bool:
        """Update order status."""
        if order_id in self.orders:
            self.orders[order_id].status = new_status
            logger.info(f"Updated order {order_id} status to {new_status}")
            return True
        return False
    
    def create_ticket(self, ticket: Ticket) -> bool:
        """Create a support ticket."""
        try:
            self.tickets[ticket.ticket_id] = ticket
            logger.info(f"Created ticket {ticket.ticket_id}")
            return True
        except Exception as e:
            logger.error(f"Error creating ticket: {e}")
            return False

# LangChain Tools for system integration
class OrderLookupTool(BaseTool):
    """Tool for looking up order information."""
    
    name = "order_lookup"
    description = "Look up order information by order ID or customer email"
    
    def __init__(self, crm_system: CRMSystem):
        super().__init__()
        self.crm = crm_system
    
    def _run(self, query: str) -> str:
        """Execute the order lookup."""
        try:
            # Check if query looks like an order ID
            if query.startswith(('ord_', 'ORDER', '#')):
                order_id = query.replace('#', '').upper()
                if not order_id.startswith('ord_'):
                    order_id = f"ord_{order_id}"
                
                order = self.crm.get_order_by_id(order_id)
                if order:
                    return f"Order {order.order_id}: Status - {order.status}, Total - ${order.total_amount}, Items - {order.items}, Tracking - {order.tracking_number or 'Not available'}"
                else:
                    return f"Order {order_id} not found."
            
            # Check if query looks like an email
            elif "@" in query:
                customer = self.crm.get_customer_by_email(query)
                if customer:
                    orders = self.crm.get_customer_orders(customer.customer_id)
                    if orders:
                        recent_order = max(orders, key=lambda x: x.order_date)
                        return f"Most recent order for {customer.name}: Order {recent_order.order_id}, Status - {recent_order.status}, Total - ${recent_order.total_amount}"
                    else:
                        return f"No orders found for {customer.name}"
                else:
                    return f"Customer with email {query} not found."
            
            else:
                return "Please provide a valid order ID (starting with 'ord_' or '#') or customer email address."
        
        except Exception as e:
            logger.error(f"Error in order lookup: {e}")
            return f"Error looking up order information: {str(e)}"

class CustomerLookupTool(BaseTool):
    """Tool for looking up customer information."""
    
    name = "customer_lookup"
    description = "Look up customer information by email address"
    
    def __init__(self, crm_system: CRMSystem):
        super().__init__()
        self.crm = crm_system
    
    def _run(self, email: str) -> str:
        """Execute the customer lookup."""
        try:
            customer = self.crm.get_customer_by_email(email)
            if customer:
                return f"Customer: {customer.name}, Tier: {customer.tier}, Total Orders: {customer.total_orders}, Total Spent: ${customer.total_spent}, Member since: {customer.join_date.strftime('%Y-%m-%d')}"
            else:
                return f"Customer with email {email} not found."
        
        except Exception as e:
            logger.error(f"Error in customer lookup: {e}")
            return f"Error looking up customer information: {str(e)}"

class TicketCreationTool(BaseTool):
    """Tool for creating support tickets."""
    
    name = "create_ticket"
    description = "Create a support ticket for customer issues"
    
    def __init__(self, crm_system: CRMSystem):
        super().__init__()
        self.crm = crm_system
    
    def _run(self, ticket_info: str) -> str:
        """Create a support ticket."""
        try:
            # Parse ticket information (simplified)
            lines = ticket_info.split('\n')
            customer_id = None
            subject = "Customer Support Request"
            description = ticket_info
            
            # Try to extract structured information
            for line in lines:
                if line.startswith('Customer:'):
                    email = line.split(':', 1)[1].strip()
                    customer = self.crm.get_customer_by_email(email)
                    if customer:
                        customer_id = customer.customer_id
                elif line.startswith('Subject:'):
                    subject = line.split(':', 1)[1].strip()
                elif line.startswith('Description:'):
                    description = line.split(':', 1)[1].strip()
            
            # Create ticket
            ticket = Ticket(
                ticket_id=f"ticket_{uuid.uuid4().hex[:8]}",
                customer_id=customer_id or "unknown",
                subject=subject,
                description=description,
                intent=CustomerIntent.GENERAL_INQUIRY,
                priority=Priority.MEDIUM,
                status=ConversationStatus.ACTIVE,
                created_at=datetime.now(),
                updated_at=datetime.now()
            )
            
            if self.crm.create_ticket(ticket):
                return f"Support ticket {ticket.ticket_id} created successfully. Reference this number for future inquiries."
            else:
                return "Failed to create support ticket. Please try again."
        
        except Exception as e:
            logger.error(f"Error creating ticket: {e}")
            return f"Error creating support ticket: {str(e)}"

class IntentClassifier:
    """Classify customer intents from messages."""
    
    def __init__(self):
        # Intent keywords mapping
        self.intent_keywords = {
            CustomerIntent.ORDER_STATUS: [
                "order", "status", "tracking", "shipped", "delivery", "when will", "where is"
            ],
            CustomerIntent.RETURN_REQUEST: [
                "return", "refund", "exchange", "send back", "money back", "defective"
            ],
            CustomerIntent.BILLING_ISSUE: [
                "billing", "charge", "payment", "invoice", "credit card", "receipt"
            ],
            CustomerIntent.TECHNICAL_SUPPORT: [
                "not working", "broken", "error", "bug", "technical", "help with", "how to"
            ],
            CustomerIntent.PRODUCT_INQUIRY: [
                "product", "item", "specification", "feature", "availability", "price"
            ],
            CustomerIntent.ACCOUNT_MANAGEMENT: [
                "account", "password", "profile", "update", "change", "login"
            ],
            CustomerIntent.COMPLAINT: [
                "complaint", "disappointed", "unhappy", "terrible", "awful", "worst"
            ]
        }
    
    def classify_intent(self, message: str) -> CustomerIntent:
        """Classify the intent of a customer message."""
        message_lower = message.lower()
        
        intent_scores = {}
        
        for intent, keywords in self.intent_keywords.items():
            score = sum(1 for keyword in keywords if keyword in message_lower)
            intent_scores[intent] = score
        
        # Return intent with highest score, default to general inquiry
        if max(intent_scores.values()) > 0:
            return max(intent_scores.items(), key=lambda x: x[1])[0]
        else:
            return CustomerIntent.GENERAL_INQUIRY

class ConversationManager:
    """Manage multi-turn conversations with context."""
    
    def __init__(self):
        self.conversations = {}
        self.memory_window = 10  # Remember last 10 exchanges
    
    def get_conversation(self, conversation_id: str) -> List[BaseMessage]:
        """Get conversation history."""
        return self.conversations.get(conversation_id, [])
    
    def add_message(self, conversation_id: str, message: BaseMessage) -> None:
        """Add message to conversation."""
        if conversation_id not in self.conversations:
            self.conversations[conversation_id] = []
        
        self.conversations[conversation_id].append(message)
        
        # Trim conversation to window size
        if len(self.conversations[conversation_id]) > self.memory_window * 2:
            self.conversations[conversation_id] = self.conversations[conversation_id][-self.memory_window * 2:]
    
    def get_conversation_context(self, conversation_id: str) -> str:
        """Get conversation context as string."""
        messages = self.get_conversation(conversation_id)
        
        context_lines = []
        for msg in messages[-6:]:  # Last 6 messages for context
            if isinstance(msg, HumanMessage):
                context_lines.append(f"Customer: {msg.content}")
            elif isinstance(msg, AIMessage):
                context_lines.append(f"Agent: {msg.content}")
        
        return "\n".join(context_lines)

class CustomerServiceAgent:
    """Main customer service chatbot agent."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.knowledge_base = KnowledgeBase()
        self.crm_system = CRMSystem()
        self.intent_classifier = IntentClassifier()
        self.conversation_manager = ConversationManager()
        
        # Initialize LLM
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.3,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        # Initialize tools
        self.tools = [
            OrderLookupTool(self.crm_system),
            CustomerLookupTool(self.crm_system),
            TicketCreationTool(self.crm_system)
        ]
        
        # Initialize agent
        self.agent = None
        if self.llm:
            self._initialize_agent()
    
    def _initialize_agent(self):
        """Initialize the LangChain agent."""
        # Create prompt template
        system_prompt = """You are a helpful customer service representative. 
        You have access to tools to look up orders, customers, and create support tickets.
        
        Guidelines:
        1. Be polite, professional, and empathetic
        2. Use the available tools to get accurate information
        3. If you can't help with something, escalate to a human agent
        4. Always try to resolve the customer's issue
        5. Provide clear, actionable information
        
        Available tools:
        - order_lookup: Look up order information by order ID or email
        - customer_lookup: Look up customer information by email
        - create_ticket: Create support tickets for complex issues
        
        Context from knowledge base will be provided for relevant queries.
        """
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            MessagesPlaceholder(variable_name="chat_history"),
            ("human", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad")
        ])
        
        # Create agent
        try:
            self.agent = create_openai_functions_agent(
                llm=self.llm,
                tools=self.tools,
                prompt=prompt
            )
            
            self.agent_executor = AgentExecutor(
                agent=self.agent,
                tools=self.tools,
                verbose=True,
                max_iterations=3,
                handle_parsing_errors=True
            )
        except Exception as e:
            logger.error(f"Error initializing agent: {e}")
    
    def process_message(self, conversation_id: str, message: str, 
                       customer_email: Optional[str] = None) -> Dict[str, Any]:
        """Process customer message and generate response."""
        try:
            # Classify intent
            intent = self.intent_classifier.classify_intent(message)
            
            # Get conversation history
            chat_history = self.conversation_manager.get_conversation(conversation_id)
            
            # Search knowledge base for relevant information
            knowledge_docs = self.knowledge_base.search_knowledge(message)
            knowledge_context = "\n".join([f"- {doc.title}: {doc.content}" for doc in knowledge_docs[:2]])
            
            # Prepare input for agent
            agent_input = message
            if knowledge_context:
                agent_input += f"\n\nRelevant Knowledge Base Information:\n{knowledge_context}"
            
            # Generate response
            if self.agent_executor:
                response = self.agent_executor.invoke({
                    "input": agent_input,
                    "chat_history": chat_history
                })
                
                agent_response = response.get("output", "I'm sorry, I'm having trouble processing your request right now.")
            else:
                agent_response = self._generate_fallback_response(message, intent, knowledge_docs)
            
            # Update conversation history
            self.conversation_manager.add_message(conversation_id, HumanMessage(content=message))
            self.conversation_manager.add_message(conversation_id, AIMessage(content=agent_response))
            
            # Determine if escalation is needed
            needs_escalation = self._should_escalate(message, intent, agent_response)
            
            return {
                "response": agent_response,
                "intent": intent.value,
                "knowledge_used": [doc.title for doc in knowledge_docs],
                "needs_escalation": needs_escalation,
                "conversation_id": conversation_id,
                "timestamp": datetime.now().isoformat()
            }
        
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            return {
                "response": "I apologize, but I'm experiencing technical difficulties. Please try again or contact our support team directly.",
                "error": str(e)
            }
    
    def _generate_fallback_response(self, message: str, intent: CustomerIntent, 
                                  knowledge_docs: List[KnowledgeDocument]) -> str:
        """Generate fallback response when LLM is not available."""
        # Use knowledge base information
        if knowledge_docs:
            doc = knowledge_docs[0]
            return f"Based on our {doc.category} information: {doc.content}\n\nIs there anything specific about this that I can help clarify?"
        
        # Intent-based responses
        if intent == CustomerIntent.ORDER_STATUS:
            return "I'd be happy to help you check your order status. Could you please provide your order number or the email address associated with your order?"
        
        elif intent == CustomerIntent.RETURN_REQUEST:
            return "I can help you with returns. Our return policy allows returns within 30 days of purchase. Would you like me to start a return process for you?"
        
        elif intent == CustomerIntent.BILLING_ISSUE:
            return "I understand you have a billing concern. Could you please provide more details about the specific issue you're experiencing?"
        
        elif intent == CustomerIntent.TECHNICAL_SUPPORT:
            return "I'm here to help with technical issues. Could you please describe the problem you're experiencing in more detail?"
        
        else:
            return "Thank you for contacting us. I'm here to help! Could you please provide more details about how I can assist you today?"
    
    def _should_escalate(self, message: str, intent: CustomerIntent, response: str) -> bool:
        """Determine if conversation should be escalated to human agent."""
        escalation_triggers = [
            "speak to manager",
            "human agent",
            "this is ridiculous",
            "terrible service",
            "legal action",
            "lawyer",
            "sue",
            "compensation"
        ]
        
        message_lower = message.lower()
        
        # Check for escalation keywords
        if any(trigger in message_lower for trigger in escalation_triggers):
            return True
        
        # Check for complaint intent with negative sentiment
        if intent == CustomerIntent.COMPLAINT:
            return True
        
        # Check if agent couldn't provide helpful response
        if "I'm sorry" in response and "can't" in response:
            return True
        
        return False
    
    def get_analytics(self, days: int = 7) -> Dict[str, Any]:
        """Get customer service analytics."""
        try:
            # Mock analytics based on CRM data
            total_tickets = len(self.crm_system.tickets)
            total_customers = len(self.crm_system.customers)
            total_orders = len(self.crm_system.orders)
            
            # Calculate resolution metrics
            resolved_tickets = sum(1 for ticket in self.crm_system.tickets.values() 
                                 if ticket.status == ConversationStatus.RESOLVED)
            
            resolution_rate = (resolved_tickets / total_tickets * 100) if total_tickets > 0 else 0
            
            # Intent distribution
            intent_counts = {}
            for ticket in self.crm_system.tickets.values():
                intent = ticket.intent.value
                intent_counts[intent] = intent_counts.get(intent, 0) + 1
            
            return {
                "total_conversations": len(self.conversation_manager.conversations),
                "total_tickets": total_tickets,
                "resolution_rate": resolution_rate,
                "avg_response_time": "< 1 minute",  # Since it's automated
                "customer_satisfaction": 4.2,  # Mock score
                "intent_distribution": intent_counts,
                "knowledge_base_size": self.knowledge_base.collection.count(),
                "escalation_rate": 15.0  # Mock percentage
            }
        
        except Exception as e:
            logger.error(f"Error generating analytics: {e}")
            return {"error": str(e)}

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Customer Service Chatbot Agent",
        page_icon="ðŸ¤–",
        layout="wide"
    )
    
    st.title("ðŸ¤– Customer Service Chatbot Agent")
    st.markdown("**Intelligent customer support with RAG, multi-turn conversations, and tool integration**")
    
    # Initialize session state
    if 'agent' not in st.session_state:
        st.session_state['agent'] = None
    if 'conversation_id' not in st.session_state:
        st.session_state['conversation_id'] = str(uuid.uuid4())
    if 'chat_history' not in st.session_state:
        st.session_state['chat_history'] = []
    if 'customer_email' not in st.session_state:
        st.session_state['customer_email'] = None
    
    # Sidebar configuration
    with st.sidebar:
        st.header("ðŸ”§ Configuration")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Agent") or st.session_state['agent'] is None:
            with st.spinner("Initializing Customer Service Agent..."):
                st.session_state['agent'] = CustomerServiceAgent(openai_key)
                st.success("Agent initialized!")
        
        st.header("ðŸ‘¤ Customer Context")
        
        customer_email = st.text_input("Customer Email (Optional)", 
                                     placeholder="customer@example.com")
        
        if customer_email:
            st.session_state['customer_email'] = customer_email
            
            # Show customer info if found
            if st.session_state['agent']:
                customer = st.session_state['agent'].crm_system.get_customer_by_email(customer_email)
                if customer:
                    st.success(f"Customer: {customer.name}")
                    st.write(f"Tier: {customer.tier}")
                    st.write(f"Orders: {customer.total_orders}")
        
        st.header("ðŸ”„ Session")
        
        if st.button("New Conversation"):
            st.session_state['conversation_id'] = str(uuid.uuid4())
            st.session_state['chat_history'] = []
            st.rerun()
        
        st.write(f"**Conversation ID:** {st.session_state['conversation_id'][:8]}...")
    
    if not st.session_state['agent']:
        st.info("ðŸ‘ˆ Please initialize the agent")
        return
    
    agent = st.session_state['agent']
    
    # Main interface tabs
    tab1, tab2, tab3, tab4 = st.tabs(["ðŸ’¬ Chat Interface", "ðŸ“š Knowledge Base", "ðŸ“Š Analytics", "ðŸ”§ Admin Tools"])
    
    with tab1:
        st.header("ðŸ’¬ Customer Service Chat")
        
        # Display chat history
        for message in st.session_state['chat_history']:
            with st.chat_message(message['role']):
                st.write(message['content'])
                
                # Show metadata for assistant messages
                if message['role'] == 'assistant' and 'metadata' in message:
                    with st.expander("Message Details"):
                        metadata = message['metadata']
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            st.write(f"**Intent:** {metadata.get('intent', 'N/A')}")
                        with col2:
                            if metadata.get('needs_escalation', False):
                                st.error("**Escalation:** Required")
                            else:
                                st.success("**Escalation:** Not needed")
                        with col3:
                            knowledge_used = metadata.get('knowledge_used', [])
                            if knowledge_used:
                                st.write(f"**Knowledge:** {', '.join(knowledge_used)}")
        
        # Chat input
        if prompt := st.chat_input("Type your message here..."):
            # Add user message to history
            st.session_state['chat_history'].append({
                'role': 'user',
                'content': prompt,
                'timestamp': datetime.now()
            })
            
            # Display user message
            with st.chat_message("user"):
                st.write(prompt)
            
            # Generate response
            with st.chat_message("assistant"):
                with st.spinner("Processing..."):
                    response_data = agent.process_message(
                        st.session_state['conversation_id'],
                        prompt,
                        st.session_state['customer_email']
                    )
                    
                    if 'error' not in response_data:
                        response = response_data['response']
                        st.write(response)
                        
                        # Add to history
                        st.session_state['chat_history'].append({
                            'role': 'assistant',
                            'content': response,
                            'timestamp': datetime.now(),
                            'metadata': response_data
                        })
                        
                        # Show escalation warning if needed
                        if response_data.get('needs_escalation', False):
                            st.warning("ðŸš¨ This conversation may need human agent escalation")
                    else:
                        st.error(f"Error: {response_data['error']}")
    
    with tab2:
        st.header("ðŸ“š Knowledge Base Management")
        
        # Knowledge base stats
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Documents", agent.knowledge_base.collection.count())
        with col2:
            st.metric("Categories", 6)  # Mock number
        with col3:
            st.metric("Last Updated", "Today")
        
        # Search knowledge base
        st.subheader("ðŸ” Search Knowledge Base")
        
        search_query = st.text_input("Search for information...")
        
        if search_query:
            with st.spinner("Searching..."):
                results = agent.knowledge_base.search_knowledge(search_query, limit=5)
                
                if results:
                    for doc in results:
                        with st.expander(f"{doc.title} (Relevance: {doc.relevance_score:.2f})"):
                            st.write(f"**Category:** {doc.category}")
                            st.write(f"**Content:** {doc.content}")
                            st.write(f"**Tags:** {', '.join(doc.tags)}")
                            st.write(f"**Last Updated:** {doc.last_updated.strftime('%Y-%m-%d')}")
                else:
                    st.info("No relevant documents found")
        
        # Add new document
        st.subheader("âž• Add New Document")
        
        with st.form("add_document"):
            title = st.text_input("Document Title")
            content = st.text_area("Content")
            category = st.selectbox("Category", ["policy", "shipping", "orders", "billing", "account", "warranty", "other"])
            tags = st.text_input("Tags (comma-separated)")
            
            if st.form_submit_button("Add Document"):
                if title and content:
                    doc = KnowledgeDocument(
                        doc_id=f"kb_{uuid.uuid4().hex[:8]}",
                        title=title,
                        content=content,
                        category=category,
                        tags=[tag.strip() for tag in tags.split(',') if tag.strip()],
                        last_updated=datetime.now()
                    )
                    
                    if agent.knowledge_base.add_document(doc):
                        st.success("Document added successfully!")
                        st.rerun()
                    else:
                        st.error("Failed to add document")
                else:
                    st.error("Please fill in title and content")
    
    with tab3:
        st.header("ðŸ“Š Customer Service Analytics")
        
        if st.button("Refresh Analytics"):
            analytics = agent.get_analytics()
            st.session_state['analytics'] = analytics
        
        if 'analytics' in st.session_state:
            analytics = st.session_state['analytics']
            
            if 'error' not in analytics:
                # Key metrics
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Total Conversations", analytics.get('total_conversations', 0))
                with col2:
                    st.metric("Resolution Rate", f"{analytics.get('resolution_rate', 0):.1f}%")
                with col3:
                    st.metric("Avg Response Time", analytics.get('avg_response_time', 'N/A'))
                with col4:
                    st.metric("Customer Satisfaction", f"{analytics.get('customer_satisfaction', 0):.1f}/5.0")
                
                # Intent distribution
                if analytics.get('intent_distribution'):
                    st.subheader("ðŸ“ˆ Intent Distribution")
                    
                    intent_data = analytics['intent_distribution']
                    
                    fig = px.pie(
                        values=list(intent_data.values()),
                        names=[intent.replace('_', ' ').title() for intent in intent_data.keys()],
                        title="Customer Intent Distribution"
                    )
                    st.plotly_chart(fig, use_container_width=True)
                
                # Performance metrics
                st.subheader("âš¡ Performance Metrics")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.metric("Knowledge Base Size", analytics.get('knowledge_base_size', 0))
                    st.metric("Total Tickets", analytics.get('total_tickets', 0))
                
                with col2:
                    escalation_rate = analytics.get('escalation_rate', 0)
                    st.metric("Escalation Rate", f"{escalation_rate:.1f}%")
                    
                    if escalation_rate > 20:
                        st.warning("High escalation rate - consider improving knowledge base")
                    else:
                        st.success("Escalation rate within normal range")
            else:
                st.error(f"Analytics error: {analytics['error']}")
    
    with tab4:
        st.header("ðŸ”§ Admin Tools")
        
        # CRM Data Management
        st.subheader("ðŸ‘¥ Customer Management")
        
        # Display customers
        customers_df = pd.DataFrame([
            {
                'Customer ID': customer.customer_id,
                'Name': customer.name,
                'Email': customer.email,
                'Tier': customer.tier,
                'Orders': customer.total_orders,
                'Total Spent': f"${customer.total_spent:.2f}"
            }
            for customer in agent.crm_system.customers.values()
        ])
        
        st.dataframe(customers_df, use_container_width=True)
        
        # Display orders
        st.subheader("ðŸ“¦ Order Management")
        
        orders_df = pd.DataFrame([
            {
                'Order ID': order.order_id,
                'Customer ID': order.customer_id,
                'Status': order.status,
                'Total': f"${order.total_amount:.2f}",
                'Date': order.order_date.strftime('%Y-%m-%d'),
                'Tracking': order.tracking_number or 'N/A'
            }
            for order in agent.crm_system.orders.values()
        ])
        
        st.dataframe(orders_df, use_container_width=True)
        
        # Order status update
        st.subheader("ðŸ”„ Update Order Status")
        
        col1, col2 = st.columns(2)
        
        with col1:
            order_id = st.selectbox("Select Order", list(agent.crm_system.orders.keys()))
        
        with col2:
            new_status = st.selectbox("New Status", ["processing", "shipped", "delivered", "cancelled"])
        
        if st.button("Update Status"):
            if agent.crm_system.update_order_status(order_id, new_status):
                st.success(f"Order {order_id} status updated to {new_status}")
                st.rerun()
            else:
                st.error("Failed to update order status")
        
        # Support tickets
        st.subheader("ðŸŽ« Support Tickets")
        
        if agent.crm_system.tickets:
            tickets_df = pd.DataFrame([
                {
                    'Ticket ID': ticket.ticket_id,
                    'Customer ID': ticket.customer_id,
                    'Subject': ticket.subject,
                    'Priority': ticket.priority.value,
                    'Status': ticket.status.value,
                    'Created': ticket.created_at.strftime('%Y-%m-%d %H:%M')
                }
                for ticket in agent.crm_system.tickets.values()
            ])
            
            st.dataframe(tickets_df, use_container_width=True)
        else:
            st.info("No support tickets found")

if __name__ == "__main__":
    main()
````

## Project Summary

The Customer Service Chatbot Agent delivers intelligent automated customer support through advanced RAG technology, multi-turn conversation management, and seamless system integration to provide efficient, accurate, and personalized customer service experiences while reducing operational costs and improving response times.

### Key Value Propositions:
- **RAG-Powered Accuracy**: Retrieval-augmented generation ensures responses are based on current, accurate company information
- **Multi-Turn Context**: Advanced conversation management maintains context across complex customer interactions
- **System Integration**: Real-time access to CRM, order management, and business systems for comprehensive support
- **Intelligent Escalation**: Smart detection of complex issues requiring human agent intervention with seamless handoff

### Technical Architecture:
The system leverages LangChain for conversational AI and tool integration, ChromaDB for vector-based knowledge retrieval, structured tool calling for system interactions, and comprehensive conversation state management, creating a scalable customer service platform that combines the efficiency of automation with the intelligence needed for complex customer support scenarios.