<small>Claude Sonnet 4 **(Kryptomƒõnov√° a Blockchain Intelligence s RAG)**</small>
# Cryptocurrency and Blockchain Intelligence

## Kl√≠ƒçov√© koncepty

### Retrieval-Augmented Generation (RAG)
Hybridn√≠ p≈ô√≠stup kombinuj√≠c√≠ vyhled√°v√°n√≠ relevantn√≠ch informac√≠ z datab√°ze znalost√≠ s generativn√≠mi jazykov√Ωmi modely pro vytv√°≈ôen√≠ kontextovƒõ p≈ôesn√Ωch odpovƒõd√≠.

### Tr≈æn√≠ anal√Ωza
Systematick√© hodnocen√≠ kryptomƒõnov√Ωch trh≈Ø zahrnuj√≠c√≠ cenov√© trendy, objemy obchodov√°n√≠, volatilitu a korelace mezi r≈Øzn√Ωmi aktivy.

### White Papers
Technick√© dokumenty popisuj√≠c√≠ blockchain projekty, jejich technologii, tokenomiku a implementaƒçn√≠ pl√°ny.

### Obchodn√≠ vzory
Identifikace a anal√Ωza opakuj√≠c√≠ch se vzor≈Ø v obchodn√≠ch datech pro predikci budouc√≠ch cenov√Ωch pohyb≈Ø.

### DeFi protokoly
Decentralizovan√© finanƒçn√≠ aplikace poskytuj√≠c√≠ slu≈æby jako lending, swapping a yield farming bez tradiƒçn√≠ch zprost≈ôedkovatel≈Ø.

### CoinGecko API
RESTful API poskytuj√≠c√≠ real-time a historick√° data o kryptomƒõn√°ch, tr≈æn√≠ch kapech a obchodn√≠ch statistik√°ch.

### Anal√Ωza smart kontrakt≈Ø
Hodnocen√≠ bezpeƒçnosti, funkƒçnosti a ekonomick√Ωch aspekt≈Ø smart kontrakt≈Ø v blockchain ekosyst√©mu.

### Hodnocen√≠ rizik
Kvantifikace a kvalifikace rizik spojen√Ωch s kryptomƒõnov√Ωmi investicemi a DeFi protokoly.

## Komplexn√≠ popis projektu

Tento projekt vyv√≠j√≠ sofistikovan√Ω AI syst√©m pro anal√Ωzu kryptomƒõnov√©ho a blockchain ekosyst√©mu s vyu≈æit√≠m RAG architektury. Syst√©m integruje multiple datov√© zdroje vƒçetnƒõ real-time tr≈æn√≠ch dat, white papers, smart kontrakt≈Ø a DeFi protokol≈Ø pro poskytov√°n√≠ inteligentn√≠ch investiƒçn√≠ch insights a rizikov√Ωch hodnocen√≠.

### C√≠le projektu:
- **Automatizovan√° anal√Ωza**: Real-time monitoring a anal√Ωza tis√≠c≈Ø kryptomƒõnov√Ωch projekt≈Ø
- **Rizikov√© hodnocen√≠**: Komplexn√≠ hodnocen√≠ investiƒçn√≠ch rizik zalo≈æen√© na technick√Ωch a fundament√°ln√≠ch anal√Ωz√°ch
- **Tr≈æn√≠ intelligence**: Identifikace tr≈æn√≠ch trend≈Ø a trading p≈ô√≠le≈æitost√≠
- **DeFi monitoring**: Sledov√°n√≠ v√Ωkonnosti a bezpeƒçnosti DeFi protokol≈Ø

### Technick√© v√Ωzvy:
- Integrace heterogenn√≠ch datov√Ωch zdroj≈Ø v real-time
- Anal√Ωza nestrukturovan√Ωch dat (white papers, social media)
- Zpracov√°n√≠ vysokofrekvenƒçn√≠ch tr≈æn√≠ch dat
- Zaji≈°tƒõn√≠ ≈°k√°lovatelnosti pro tis√≠ce token≈Ø

### Potenci√°ln√≠ dopad:
- Demokratizace p≈ô√≠stupu k profesion√°ln√≠ krypto anal√Ωze
- Sn√≠≈æen√≠ investiƒçn√≠ch rizik prost≈ôednictv√≠m better informed decisions
- Zlep≈°en√≠ transparentnosti DeFi ekosyst√©mu

## Komplexn√≠ implementace v Pythonu

````python
import asyncio
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

import pandas as pd
import numpy as np
import requests
import aiohttp
from web3 import Web3
import yfinance as yf

from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.document_loaders import PyPDFLoader, WebBaseLoader
from langchain.schema import Document
from langchain.llms import OpenAI
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate

import chromadb
from chromadb.config import Settings
import openai
from pydantic import BaseModel
import json
import time
from concurrent.futures import ThreadPoolExecutor
import ta

# Konfigurace logov√°n√≠
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class CryptoAsset:
    symbol: str
    name: str
    current_price: float
    market_cap: float
    volume_24h: float
    price_change_24h: float
    risk_score: float
    sentiment_score: float

@dataclass
class DeFiProtocol:
    name: str
    tvl: float
    apy: float
    risk_assessment: str
    smart_contract_address: str
    audit_status: str

class CoinGeckoAPI:
    """CoinGecko API client pro z√≠sk√°v√°n√≠ krypto dat"""
    
    def __init__(self):
        self.base_url = "https://api.coingecko.com/api/v3"
        self.session = requests.Session()
        
    def get_market_data(self, vs_currency: str = "usd", limit: int = 100) -> List[Dict]:
        """Z√≠sk√°n√≠ tr≈æn√≠ch dat top kryptomƒõn"""
        try:
            endpoint = f"{self.base_url}/coins/markets"
            params = {
                "vs_currency": vs_currency,
                "order": "market_cap_desc",
                "per_page": limit,
                "page": 1,
                "sparkline": False,
                "price_change_percentage": "1h,24h,7d"
            }
            
            response = self.session.get(endpoint, params=params)
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ tr≈æn√≠ch dat: {e}")
            return []
    
    def get_coin_history(self, coin_id: str, days: int = 30) -> Dict:
        """Z√≠sk√°n√≠ historick√Ωch dat pro konkr√©tn√≠ coin"""
        try:
            endpoint = f"{self.base_url}/coins/{coin_id}/market_chart"
            params = {
                "vs_currency": "usd",
                "days": days,
                "interval": "daily"
            }
            
            response = self.session.get(endpoint, params=params)
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ historick√Ωch dat: {e}")
            return {}

class SmartContractAnalyzer:
    """Analyz√°tor smart kontrakt≈Ø"""
    
    def __init__(self, web3_provider_url: str):
        self.w3 = Web3(Web3.HTTPProvider(web3_provider_url))
        
    def analyze_contract(self, contract_address: str) -> Dict[str, Any]:
        """Anal√Ωza smart kontraktu"""
        try:
            # Kontrola validity adresy
            if not self.w3.isAddress(contract_address):
                return {"error": "Neplatn√° adresa kontraktu"}
            
            # Z√≠sk√°n√≠ k√≥du kontraktu
            contract_code = self.w3.eth.get_code(contract_address)
            
            # Z√°kladn√≠ metriky
            analysis = {
                "address": contract_address,
                "has_code": len(contract_code) > 0,
                "code_size": len(contract_code),
                "creation_block": self._get_creation_block(contract_address),
                "transaction_count": self._get_transaction_count(contract_address),
                "risk_indicators": self._assess_risk_indicators(contract_address)
            }
            
            return analysis
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi anal√Ωze kontraktu: {e}")
            return {"error": str(e)}
    
    def _get_creation_block(self, address: str) -> Optional[int]:
        """Z√≠sk√°n√≠ bloku vytvo≈ôen√≠ kontraktu"""
        try:
            # Simplified - v re√°ln√© implementaci by bylo t≈ôeba prohledat bloky
            return None
        except:
            return None
    
    def _get_transaction_count(self, address: str) -> int:
        """Z√≠sk√°n√≠ poƒçtu transakc√≠ kontraktu"""
        try:
            return self.w3.eth.get_transaction_count(address)
        except:
            return 0
    
    def _assess_risk_indicators(self, address: str) -> List[str]:
        """Hodnocen√≠ rizikov√Ωch indik√°tor≈Ø"""
        indicators = []
        
        try:
            # Kontrola bakance
            balance = self.w3.eth.get_balance(address)
            if balance > self.w3.toWei(1000, 'ether'):
                indicators.append("high_balance")
            
            # Dal≈°√≠ kontroly by byly implementov√°ny zde
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi hodnocen√≠ rizik: {e}")
        
        return indicators

class TechnicalAnalyzer:
    """Technick√° anal√Ωza kryptomƒõn"""
    
    @staticmethod
    def calculate_indicators(df: pd.DataFrame) -> pd.DataFrame:
        """V√Ωpoƒçet technick√Ωch indik√°tor≈Ø"""
        try:
            # RSI
            df['rsi'] = ta.momentum.RSIIndicator(df['close']).rsi()
            
            # MACD
            macd = ta.trend.MACD(df['close'])
            df['macd'] = macd.macd()
            df['macd_signal'] = macd.macd_signal()
            
            # Bollinger Bands
            bollinger = ta.volatility.BollingerBands(df['close'])
            df['bb_upper'] = bollinger.bollinger_hband()
            df['bb_lower'] = bollinger.bollinger_lband()
            df['bb_middle'] = bollinger.bollinger_mavg()
            
            # Moving Averages
            df['sma_20'] = ta.trend.SMAIndicator(df['close'], window=20).sma_indicator()
            df['ema_12'] = ta.trend.EMAIndicator(df['close'], window=12).ema_indicator()
            
            return df
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi v√Ωpoƒçtu indik√°tor≈Ø: {e}")
            return df
    
    @staticmethod
    def generate_signals(df: pd.DataFrame) -> List[str]:
        """Generov√°n√≠ obchodn√≠ch sign√°l≈Ø"""
        signals = []
        
        try:
            latest = df.iloc[-1]
            
            # RSI sign√°ly
            if latest['rsi'] < 30:
                signals.append("RSI_OVERSOLD")
            elif latest['rsi'] > 70:
                signals.append("RSI_OVERBOUGHT")
            
            # MACD sign√°ly
            if latest['macd'] > latest['macd_signal']:
                signals.append("MACD_BULLISH")
            else:
                signals.append("MACD_BEARISH")
            
            # Bollinger Bands sign√°ly
            if latest['close'] < latest['bb_lower']:
                signals.append("BB_OVERSOLD")
            elif latest['close'] > latest['bb_upper']:
                signals.append("BB_OVERBOUGHT")
                
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ sign√°l≈Ø: {e}")
        
        return signals

class CryptoRAGSystem:
    """Hlavn√≠ RAG syst√©m pro krypto intelligence"""
    
    def __init__(self, openai_api_key: str, web3_provider_url: str = None):
        self.openai_api_key = openai_api_key
        openai.api_key = openai_api_key
        
        # Inicializace komponent
        self.coingecko = CoinGeckoAPI()
        self.contract_analyzer = SmartContractAnalyzer(web3_provider_url) if web3_provider_url else None
        self.technical_analyzer = TechnicalAnalyzer()
        
        # RAG komponenty
        self.embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        
        # Vector store
        self.vectorstore = None
        self._setup_vectorstore()
        
        # LLM
        self.llm = OpenAI(
            openai_api_key=openai_api_key,
            temperature=0.1,
            max_tokens=1000
        )
        
    def _setup_vectorstore(self):
        """Nastaven√≠ vector store"""
        try:
            client = chromadb.Client(Settings(persist_directory="./chroma_db"))
            self.vectorstore = Chroma(
                client=client,
                embedding_function=self.embeddings,
                collection_name="crypto_knowledge"
            )
        except Exception as e:
            logger.error(f"Chyba p≈ôi nastaven√≠ vectorstore: {e}")
    
    def ingest_market_data(self, limit: int = 100):
        """Ingestov√°n√≠ tr≈æn√≠ch dat do RAG syst√©mu"""
        try:
            market_data = self.coingecko.get_market_data(limit=limit)
            
            documents = []
            for coin in market_data:
                content = f"""
                Kryptomƒõna: {coin['name']} ({coin['symbol']})
                Aktu√°ln√≠ cena: ${coin['current_price']}
                Tr≈æn√≠ kapitalizace: ${coin['market_cap']}
                24h objem: ${coin['total_volume']}
                24h zmƒõna: {coin['price_change_percentage_24h']}%
                Rank: {coin['market_cap_rank']}
                """
                
                doc = Document(
                    page_content=content,
                    metadata={
                        "type": "market_data",
                        "symbol": coin['symbol'],
                        "timestamp": datetime.now().isoformat()
                    }
                )
                documents.append(doc)
            
            if documents and self.vectorstore:
                texts = self.text_splitter.split_documents(documents)
                self.vectorstore.add_documents(texts)
                logger.info(f"Ulo≈æeno {len(texts)} dokument≈Ø tr≈æn√≠ch dat")
                
        except Exception as e:
            logger.error(f"Chyba p≈ôi ingestov√°n√≠ dat: {e}")
    
    def analyze_crypto_asset(self, symbol: str) -> Dict[str, Any]:
        """Komplexn√≠ anal√Ωza kryptomƒõny"""
        try:
            # Z√≠sk√°n√≠ z√°kladn√≠ch dat
            market_data = self.coingecko.get_market_data()
            asset_data = next((coin for coin in market_data if coin['symbol'].lower() == symbol.lower()), None)
            
            if not asset_data:
                return {"error": f"Kryptomƒõna {symbol} nebyla nalezena"}
            
            # Technick√° anal√Ωza
            historical_data = self.coingecko.get_coin_history(asset_data['id'])
            signals = []
            
            if historical_data.get('prices'):
                # P≈ôevod na DataFrame
                df = pd.DataFrame(historical_data['prices'], columns=['timestamp', 'close'])
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                df = df.set_index('timestamp')
                
                # V√Ωpoƒçet indik√°tor≈Ø a sign√°l≈Ø
                df = self.technical_analyzer.calculate_indicators(df)
                signals = self.technical_analyzer.generate_signals(df)
            
            # Hodnocen√≠ rizik
            risk_score = self._calculate_risk_score(asset_data, signals)
            
            # RAG dotaz pro kontextovou anal√Ωzu
            context_analysis = self._get_contextual_analysis(symbol)
            
            analysis = {
                "symbol": symbol,
                "name": asset_data['name'],
                "current_price": asset_data['current_price'],
                "market_cap": asset_data['market_cap'],
                "price_change_24h": asset_data['price_change_percentage_24h'],
                "volume_24h": asset_data['total_volume'],
                "risk_score": risk_score,
                "risk_level": self._get_risk_level(risk_score),
                "technical_signals": signals,
                "context_analysis": context_analysis,
                "timestamp": datetime.now().isoformat()
            }
            
            return analysis
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi anal√Ωze {symbol}: {e}")
            return {"error": str(e)}
    
    def _calculate_risk_score(self, asset_data: Dict, signals: List[str]) -> float:
        """V√Ωpoƒçet rizikov√©ho sk√≥re"""
        try:
            score = 0.5  # Z√°kladn√≠ sk√≥re
            
            # Volatilita
            if abs(asset_data.get('price_change_percentage_24h', 0)) > 10:
                score += 0.2
            
            # Tr≈æn√≠ kapitalizace (men≈°√≠ = rizikovƒõj≈°√≠)
            if asset_data.get('market_cap', 0) < 1e9:  # < 1B USD
                score += 0.2
            
            # Technick√© sign√°ly
            bearish_signals = [s for s in signals if 'BEARISH' in s or 'OVERBOUGHT' in s]
            if bearish_signals:
                score += 0.1 * len(bearish_signals)
            
            return min(1.0, max(0.0, score))
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi v√Ωpoƒçtu rizika: {e}")
            return 0.5
    
    def _get_risk_level(self, risk_score: float) -> str:
        """P≈ôevod rizikov√©ho sk√≥re na √∫rove≈à"""
        if risk_score < 0.3:
            return RiskLevel.LOW.value
        elif risk_score < 0.6:
            return RiskLevel.MEDIUM.value
        elif risk_score < 0.8:
            return RiskLevel.HIGH.value
        else:
            return RiskLevel.CRITICAL.value
    
    def _get_contextual_analysis(self, symbol: str) -> str:
        """Z√≠sk√°n√≠ kontextov√© anal√Ωzy pomoc√≠ RAG"""
        try:
            if not self.vectorstore:
                return "Kontextov√° anal√Ωza nen√≠ dostupn√°"
            
            # Vytvo≈ôen√≠ QA ≈ôetƒõzce
            qa_chain = RetrievalQA.from_chain_type(
                llm=self.llm,
                chain_type="stuff",
                retriever=self.vectorstore.as_retriever(search_kwargs={"k": 3}),
                return_source_documents=False
            )
            
            query = f"Poskytni anal√Ωzu kryptomƒõny {symbol} vƒçetnƒõ tr≈æn√≠ch trend≈Ø a rizik"
            result = qa_chain.run(query)
            
            return result
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi kontextov√© anal√Ωze: {e}")
            return "Chyba p≈ôi kontextov√© anal√Ωze"
    
    def generate_portfolio_recommendation(self, symbols: List[str], risk_tolerance: str = "medium") -> Dict[str, Any]:
        """Generov√°n√≠ doporuƒçen√≠ portfolia"""
        try:
            analyses = []
            for symbol in symbols:
                analysis = self.analyze_crypto_asset(symbol)
                if 'error' not in analysis:
                    analyses.append(analysis)
            
            if not analyses:
                return {"error": "≈Ω√°dn√© platn√© anal√Ωzy"}
            
            # Filtrace podle rizikov√© tolerance
            filtered_assets = self._filter_by_risk_tolerance(analyses, risk_tolerance)
            
            # Generov√°n√≠ doporuƒçen√≠ pomoc√≠ LLM
            recommendation = self._generate_llm_recommendation(filtered_assets, risk_tolerance)
            
            return {
                "recommendation": recommendation,
                "analyzed_assets": len(analyses),
                "recommended_assets": len(filtered_assets),
                "risk_tolerance": risk_tolerance,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ doporuƒçen√≠: {e}")
            return {"error": str(e)}
    
    def _filter_by_risk_tolerance(self, analyses: List[Dict], risk_tolerance: str) -> List[Dict]:
        """Filtrace aktiv podle rizikov√© tolerance"""
        risk_thresholds = {
            "low": 0.4,
            "medium": 0.7,
            "high": 1.0
        }
        
        threshold = risk_thresholds.get(risk_tolerance, 0.7)
        return [a for a in analyses if a['risk_score'] <= threshold]
    
    def _generate_llm_recommendation(self, assets: List[Dict], risk_tolerance: str) -> str:
        """Generov√°n√≠ doporuƒçen√≠ pomoc√≠ LLM"""
        try:
            asset_summary = "\n".join([
                f"- {a['name']} ({a['symbol']}): Risk {a['risk_level']}, Price ${a['current_price']}"
                for a in assets
            ])
            
            prompt = f"""
            Jako odborn√≠k na kryptomƒõny vytvo≈ôte doporuƒçen√≠ portfolia na z√°kladƒõ n√°sleduj√≠c√≠ch aktiv:
            
            {asset_summary}
            
            Rizikov√° tolerance: {risk_tolerance}
            
            Poskytnƒõte:
            1. Doporuƒçen√© alokace (%)
            2. Investiƒçn√≠ strategii
            3. Rizikov√© upozornƒõn√≠
            """
            
            response = openai.Completion.create(
                engine="text-davinci-003",
                prompt=prompt,
                max_tokens=500,
                temperature=0.1
            )
            
            return response.choices[0].text.strip()
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ LLM doporuƒçen√≠: {e}")
            return "Chyba p≈ôi generov√°n√≠ doporuƒçen√≠"

class CryptoIntelligenceAPI:
    """REST API wrapper pro crypto intelligence syst√©m"""
    
    def __init__(self, rag_system: CryptoRAGSystem):
        self.rag_system = rag_system
    
    async def get_market_overview(self) -> Dict[str, Any]:
        """Z√≠sk√°n√≠ p≈ôehledu trhu"""
        try:
            market_data = self.rag_system.coingecko.get_market_data(limit=10)
            
            total_market_cap = sum(coin['market_cap'] for coin in market_data if coin['market_cap'])
            avg_change_24h = np.mean([coin['price_change_percentage_24h'] for coin in market_data if coin['price_change_percentage_24h']])
            
            overview = {
                "total_coins": len(market_data),
                "total_market_cap": total_market_cap,
                "average_24h_change": avg_change_24h,
                "top_gainers": sorted(market_data, key=lambda x: x['price_change_percentage_24h'] or 0, reverse=True)[:3],
                "top_losers": sorted(market_data, key=lambda x: x['price_change_percentage_24h'] or 0)[:3],
                "timestamp": datetime.now().isoformat()
            }
            
            return overview
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ p≈ôehledu: {e}")
            return {"error": str(e)}

# Hlavn√≠ aplikace
async def main():
    """Hlavn√≠ funkce demonstruj√≠c√≠ pou≈æit√≠ syst√©mu"""
    
    # Konfigurace (v re√°ln√© aplikaci by bylo v config souboru)
    OPENAI_API_KEY = "your-openai-api-key"
    WEB3_PROVIDER_URL = "https://mainnet.infura.io/v3/your-project-id"
    
    try:
        # Inicializace syst√©mu
        print("üöÄ Inicializace Crypto Intelligence syst√©mu...")
        rag_system = CryptoRAGSystem(
            openai_api_key=OPENAI_API_KEY,
            web3_provider_url=WEB3_PROVIDER_URL
        )
        
        # Ingestov√°n√≠ tr≈æn√≠ch dat
        print("üìä Ingestov√°n√≠ tr≈æn√≠ch dat...")
        rag_system.ingest_market_data(limit=50)
        
        # Anal√Ωza konkr√©tn√≠ch kryptomƒõn
        print("\nüîç Anal√Ωza kryptomƒõn...")
        symbols = ["BTC", "ETH", "ADA", "DOT"]
        
        for symbol in symbols:
            print(f"\n--- Anal√Ωza {symbol} ---")
            analysis = rag_system.analyze_crypto_asset(symbol)
            
            if 'error' not in analysis:
                print(f"N√°zev: {analysis['name']}")
                print(f"Cena: ${analysis['current_price']:,.2f}")
                print(f"24h zmƒõna: {analysis['price_change_24h']:.2f}%")
                print(f"Rizikov√© sk√≥re: {analysis['risk_score']:.2f} ({analysis['risk_level']})")
                print(f"Technick√© sign√°ly: {', '.join(analysis['technical_signals'])}")
            else:
                print(f"Chyba: {analysis['error']}")
        
        # Generov√°n√≠ portfolia
        print("\nüíº Generov√°n√≠ doporuƒçen√≠ portfolia...")
        portfolio_rec = rag_system.generate_portfolio_recommendation(
            symbols=symbols,
            risk_tolerance="medium"
        )
        
        if 'error' not in portfolio_rec:
            print(f"Analyzov√°no: {portfolio_rec['analyzed_assets']} aktiv")
            print(f"Doporuƒçeno: {portfolio_rec['recommended_assets']} aktiv")
            print(f"Doporuƒçen√≠:\n{portfolio_rec['recommendation']}")
        
        # P≈ôehled trhu
        print("\nüìà P≈ôehled trhu...")
        api = CryptoIntelligenceAPI(rag_system)
        market_overview = await api.get_market_overview()
        
        if 'error' not in market_overview:
            print(f"Celkov√° tr≈æn√≠ kapitalizace: ${market_overview['total_market_cap']:,.0f}")
            print(f"Pr≈Ømƒõrn√° 24h zmƒõna: {market_overview['average_24h_change']:.2f}%")
            print("Top r≈Østy:", [f"{coin['symbol']}: +{coin['price_change_percentage_24h']:.1f}%" 
                                for coin in market_overview['top_gainers']])
        
        print("\n‚úÖ Anal√Ωza dokonƒçena!")
        
    except Exception as e:
        logger.error(f"Chyba v hlavn√≠ aplikaci: {e}")
        print(f"‚ùå Chyba: {e}")

if __name__ == "__main__":
    # Spu≈°tƒõn√≠ aplikace
    asyncio.run(main())
````

````python
# Core dependencies
langchain==0.0.350
openai==1.3.7
chromadb==0.4.18
pandas==2.1.4
numpy==1.24.3
requests==2.31.0
aiohttp==3.9.1

# Crypto specific
web3==6.12.0
yfinance==0.2.18
ccxt==4.1.64

# Technical analysis
ta==0.10.2

# Vector database
faiss-cpu==1.7.4
sentence-transformers==2.2.2

# Data processing
python-dotenv==1.0.0
pydantic==2.5.0

# Web framework (pro API)
fastapi==0.104.1
uvicorn==0.24.0

# Monitoring
prometheus-client==0.19.0

# Development
pytest==7.4.3
pytest-asyncio==0.21.1
black==23.11.0
flake8==6.1.0
````

````python
import os
from typing import Dict, Any
from dataclasses import dataclass

@dataclass
class CryptoConfig:
    """Konfigurace pro crypto intelligence syst√©m"""
    
    # API kl√≠ƒçe
    openai_api_key: str = os.getenv("OPENAI_API_KEY", "")
    web3_provider_url: str = os.getenv("WEB3_PROVIDER_URL", "")
    coingecko_api_key: str = os.getenv("COINGECKO_API_KEY", "")
    
    # Database
    chroma_persist_directory: str = "./chroma_db"
    
    # RAG parametry
    chunk_size: int = 1000
    chunk_overlap: int = 200
    max_tokens: int = 1000
    temperature: float = 0.1
    
    # Anal√Ωza parametr≈Ø
    default_analysis_limit: int = 100
    risk_thresholds: Dict[str, float] = None
    
    def __post_init__(self):
        if self.risk_thresholds is None:
            self.risk_thresholds = {
                "low": 0.4,
                "medium": 0.7,
                "high": 1.0
            }
    
    @classmethod
    def from_env(cls) -> 'CryptoConfig':
        """Vytvo≈ôen√≠ konfigurace z environment variables"""
        return cls()
    
    def validate(self) -> bool:
        """Validace konfigurace"""
        required_fields = ["openai_api_key"]
        
        for field in required_fields:
            if not getattr(self, field):
                raise ValueError(f"Chyb√≠ povinn√© pole: {field}")
        
        return True

# Glob√°ln√≠ konfigurace
config = CryptoConfig.from_env()
````

## Shrnut√≠ projektu

Tento projekt p≈ôedstavuje pokroƒçil√Ω AI syst√©m pro anal√Ωzu kryptomƒõnov√©ho a blockchain ekosyst√©mu vyu≈æ√≠vaj√≠c√≠ RAG architekturu. Syst√©m kombinuje real-time tr≈æn√≠ data, technickou anal√Ωzu, hodnocen√≠ smart kontrakt≈Ø a kontextov√© AI anal√Ωzy pro poskytov√°n√≠ komplexn√≠ch investiƒçn√≠ch insights.

### Kl√≠ƒçov√© vlastnosti:
- **Real-time monitoring**: Kontinu√°ln√≠ sledov√°n√≠ tis√≠c≈Ø kryptomƒõn
- **Multidimenzion√°ln√≠ anal√Ωza**: Kombinace technick√©, fundament√°ln√≠ a sentiment anal√Ωzy
- **Rizikov√© hodnocen√≠**: Automatizovan√© hodnocen√≠ investiƒçn√≠ch rizik
- **Portfolio optimalizace**: AI-≈ô√≠zen√© doporuƒçen√≠ portfolia
- **≈†k√°lovatelnost**: Modul√°rn√≠ architektura podporuj√≠c√≠ r≈Øst

### Technologick√° hodnota:
- Implementace state-of-the-art RAG architektury
- Integrace heterogenn√≠ch datov√Ωch zdroj≈Ø
- Vyu≈æit√≠ modern√≠ch AI framework≈Ø (LangChain, OpenAI)
- Asynchronn√≠ zpracov√°n√≠ pro vysokou v√Ωkonnost

### Obchodn√≠ dopad:
- Demokratizace p≈ô√≠stupu k profesion√°ln√≠ krypto anal√Ωze
- Sn√≠≈æen√≠ investiƒçn√≠ch rizik
- Zlep≈°en√≠ transparentnosti DeFi ekosyst√©mu
- Podpora informovan√©ho rozhodov√°n√≠ v krypto investic√≠ch

Syst√©m p≈ôedstavuje v√Ωznamn√Ω krok smƒõrem k inteligentn√≠mu a bezpeƒçnƒõj≈°√≠mu kryptomƒõnov√©mu ekosyst√©mu.