<small>Claude Sonnet 4 **(Event Planning and Venue Management with RAG)**</small>
# Event Planning and Venue Management

## Key Concepts Explanation

### Retrieval-Augmented Generation (RAG)
A technique that combines information retrieval with generative AI to provide intelligent event planning insights by first retrieving relevant data from vendor directories, venue databases, and planning resources, then using an LLM to generate comprehensive event strategies and management solutions.

### Vendor Directories
Comprehensive databases of event service providers including caterers, photographers, entertainers, decorators, and technical service providers, with detailed information about their services, pricing, availability, and past performance ratings.

### Budget Planning
Strategic financial management for events involving cost estimation, resource allocation, expense tracking, and optimization to ensure events meet objectives while staying within financial constraints and maximizing return on investment.

### Guest Lists
Organized databases of event attendees including contact information, dietary restrictions, accessibility needs, RSVP status, and preference profiles that enable personalized event experiences and efficient communication management.

### Venue Specifications
Detailed technical and logistical information about event venues including capacity, layout, equipment availability, accessibility features, catering facilities, parking, and operational constraints that impact event planning decisions.

### Timeline Management
Coordinated scheduling of all event activities including pre-event preparation, vendor coordination, setup, execution, and post-event activities, ensuring smooth operations and timely delivery of all event components.

### Catering Menus
Comprehensive food and beverage service options including menu items, dietary accommodations, pricing structures, service styles, and logistical requirements that must be coordinated with venue capabilities and guest preferences.

## Comprehensive Project Explanation

The Event Planning and Venue Management platform is an AI-powered system that revolutionizes how events are planned, coordinated, and executed. By leveraging RAG technology, this platform combines extensive databases of venues, vendors, and resources with intelligent analysis to provide comprehensive event planning solutions that optimize logistics, budget, and attendee experience.

### Objectives
- **Intelligent Planning**: Automate complex event planning decisions through AI-powered analysis of venue capabilities, vendor options, and guest requirements
- **Resource Optimization**: Maximize efficiency in vendor selection, budget allocation, and timeline coordination to reduce costs and improve outcomes
- **Enhanced Experience**: Create personalized event experiences through intelligent matching of venues, services, and activities to event objectives and attendee preferences
- **Risk Management**: Identify and mitigate potential issues through predictive analysis of venue limitations, vendor reliability, and logistical challenges
- **Streamlined Operations**: Integrate all aspects of event management into a cohesive platform that reduces coordination overhead and improves communication

### Challenges
- **Complex Coordination**: Managing multiple vendors, venues, timelines, and requirements simultaneously while maintaining quality and budget constraints
- **Dynamic Availability**: Handling real-time changes in vendor availability, venue bookings, and guest responses that can impact entire event plans
- **Preference Matching**: Balancing diverse stakeholder requirements, budget constraints, and venue limitations to find optimal solutions
- **Scalability Issues**: Adapting planning approaches for events ranging from intimate gatherings to large-scale conferences and festivals
- **Quality Assurance**: Ensuring vendor reliability and service quality while managing costs and maintaining professional standards

### Potential Impact
- **Industry Efficiency**: Transforming event planning from a manual, relationship-dependent process to an intelligent, data-driven practice
- **Cost Optimization**: Reducing event costs through better vendor selection, resource allocation, and waste reduction strategies
- **Experience Enhancement**: Improving attendee satisfaction through more thoughtful venue selection, catering choices, and activity coordination
- **Professional Development**: Enabling event planners to focus on creative and strategic aspects while automating routine coordination tasks
- **Market Accessibility**: Making professional-quality event planning tools available to smaller organizations and individual planners

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
langchain==0.1.0
openai==1.3.0
chromadb==0.4.18
pandas==2.1.4
numpy==1.24.3
requests==2.31.0
python-dotenv==1.0.0
pydantic==2.5.0
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
alembic==1.13.0
schedule==1.2.0
geopy==2.4.0
folium==0.15.0
plotly==5.17.0
streamlit==1.28.1
jinja2==3.1.2
email-validator==2.1.0
python-multipart==0.0.6
celery==5.3.4
redis==5.0.1
google-calendar==1.4.0
smtplib2==0.2.1
twilio==8.11.0
stripe==7.8.0
datetime==5.3
uuid==1.30
````

### Core Implementation

````python
# main.py
import os
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta, date
from typing import List, Dict, Optional, Tuple, Union
from dataclasses import dataclass, asdict, field
from pydantic import BaseModel, EmailStr
import asyncio
import logging
from pathlib import Path
from enum import Enum
import uuid

from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import Document
import chromadb
import openai
from dotenv import load_dotenv

from geopy.geocoders import Nominatim
from geopy.distance import geodesic
import folium
import plotly.graph_objects as go
import plotly.express as px

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EventType(Enum):
    WEDDING = "wedding"
    CORPORATE = "corporate"
    CONFERENCE = "conference"
    BIRTHDAY = "birthday"
    FUNDRAISER = "fundraiser"
    WORKSHOP = "workshop"
    NETWORKING = "networking"
    CELEBRATION = "celebration"

class VenueType(Enum):
    BANQUET_HALL = "banquet_hall"
    HOTEL = "hotel"
    RESTAURANT = "restaurant"
    OUTDOOR = "outdoor"
    CONFERENCE_CENTER = "conference_center"
    PRIVATE_ESTATE = "private_estate"
    CULTURAL_CENTER = "cultural_center"
    CHURCH = "church"

class ServiceCategory(Enum):
    CATERING = "catering"
    PHOTOGRAPHY = "photography"
    MUSIC = "music"
    DECORATION = "decoration"
    TRANSPORTATION = "transportation"
    SECURITY = "security"
    TECHNICAL = "technical"
    ENTERTAINMENT = "entertainment"

@dataclass
class Venue:
    venue_id: str
    name: str
    venue_type: VenueType
    address: str
    city: str
    state: str
    zip_code: str
    coordinates: Tuple[float, float]
    capacity_seated: int
    capacity_standing: int
    indoor_space: int  # sq ft
    outdoor_space: int  # sq ft
    parking_spaces: int
    accessibility_features: List[str]
    amenities: List[str]
    restrictions: List[str]
    base_rental_cost: float
    additional_fees: Dict[str, float]
    available_dates: List[str]
    contact_info: Dict[str, str]
    rating: float
    reviews_count: int
    photos: List[str]
    floor_plan: Optional[str]

@dataclass
class Vendor:
    vendor_id: str
    name: str
    category: ServiceCategory
    description: str
    services_offered: List[str]
    service_area: List[str]  # cities/regions served
    pricing_structure: Dict[str, Union[float, str]]
    min_order: Optional[float]
    max_capacity: Optional[int]
    specialties: List[str]
    dietary_accommodations: List[str]
    equipment_provided: List[str]
    setup_time_required: int  # minutes
    contact_info: Dict[str, str]
    availability: Dict[str, List[str]]  # date: time_slots
    rating: float
    reviews_count: int
    certifications: List[str]
    insurance_verified: bool
    portfolio: List[str]

@dataclass
class Guest:
    guest_id: str
    first_name: str
    last_name: str
    email: str
    phone: Optional[str]
    dietary_restrictions: List[str]
    accessibility_needs: List[str]
    plus_one: bool
    rsvp_status: str  # pending, confirmed, declined
    table_assignment: Optional[str]
    special_notes: Optional[str]
    contact_preference: str  # email, phone, both
    vip_status: bool

@dataclass
class EventBudget:
    total_budget: float
    venue_budget: float = 0
    catering_budget: float = 0
    decoration_budget: float = 0
    entertainment_budget: float = 0
    photography_budget: float = 0
    transportation_budget: float = 0
    miscellaneous_budget: float = 0
    contingency_percentage: float = 0.10
    actual_expenses: Dict[str, float] = field(default_factory=dict)
    
    def get_remaining_budget(self) -> float:
        total_spent = sum(self.actual_expenses.values())
        return self.total_budget - total_spent
    
    def get_contingency_amount(self) -> float:
        return self.total_budget * self.contingency_percentage

@dataclass
class MenuItem:
    item_id: str
    name: str
    category: str  # appetizer, main, dessert, beverage
    description: str
    price_per_person: float
    dietary_tags: List[str]  # vegetarian, vegan, gluten-free, etc.
    allergens: List[str]
    preparation_time: int  # minutes
    ingredients: List[str]
    presentation_style: str

@dataclass
class CateringPackage:
    package_id: str
    vendor_id: str
    name: str
    description: str
    service_style: str  # buffet, plated, family-style, cocktail
    menu_items: List[MenuItem]
    price_per_person: float
    minimum_guests: int
    maximum_guests: int
    setup_requirements: List[str]
    staff_included: int
    additional_services: List[str]
    dietary_accommodations: List[str]

@dataclass
class TimelineItem:
    item_id: str
    title: str
    description: str
    start_time: datetime
    end_time: datetime
    responsible_party: str
    location: str
    dependencies: List[str]  # item_ids that must complete first
    resources_needed: List[str]
    status: str  # pending, in_progress, completed, delayed
    notes: Optional[str]

@dataclass
class Event:
    event_id: str
    title: str
    event_type: EventType
    date: date
    start_time: datetime
    end_time: datetime
    expected_guests: int
    venue: Optional[Venue]
    budget: EventBudget
    guest_list: List[Guest]
    selected_vendors: Dict[ServiceCategory, Vendor]
    catering_package: Optional[CateringPackage]
    timeline: List[TimelineItem]
    special_requirements: List[str]
    theme: Optional[str]
    dress_code: Optional[str]
    status: str  # planning, confirmed, in_progress, completed, cancelled
    created_date: datetime
    organizer_contact: Dict[str, str]

class EventDataCollector:
    """Collects and manages event planning data"""
    
    def __init__(self):
        self.geocoder = Nominatim(user_agent="event_planner")
        self.sample_data = self._generate_sample_data()
    
    def _generate_sample_data(self):
        """Generate comprehensive sample event planning data"""
        
        # Sample venues
        venues = [
            Venue(
                venue_id="venue_001",
                name="Grand Ballroom Hotel",
                venue_type=VenueType.HOTEL,
                address="123 Luxury Ave",
                city="Downtown",
                state="CA",
                zip_code="90210",
                coordinates=(34.0522, -118.2437),
                capacity_seated=200,
                capacity_standing=300,
                indoor_space=3000,
                outdoor_space=1000,
                parking_spaces=150,
                accessibility_features=["wheelchair_accessible", "elevator", "accessible_restrooms"],
                amenities=["full_kitchen", "av_equipment", "dance_floor", "bridal_suite", "valet_parking"],
                restrictions=["no_smoking", "no_outside_alcohol", "music_curfew_11pm"],
                base_rental_cost=5000.0,
                additional_fees={"cleaning": 500.0, "security": 800.0, "overtime": 200.0},
                available_dates=["2024-06-15", "2024-06-22", "2024-07-10"],
                contact_info={"phone": "(555) 123-4567", "email": "events@grandballroom.com"},
                rating=4.5,
                reviews_count=127,
                photos=["ballroom1.jpg", "ballroom2.jpg"],
                floor_plan="ballroom_layout.pdf"
            ),
            Venue(
                venue_id="venue_002",
                name="Sunset Garden Estate",
                venue_type=VenueType.OUTDOOR,
                address="456 Garden Lane",
                city="Hillside",
                state="CA",
                zip_code="90211",
                coordinates=(34.0823, -118.4015),
                capacity_seated=150,
                capacity_standing=250,
                indoor_space=1500,
                outdoor_space=5000,
                parking_spaces=100,
                accessibility_features=["paved_pathways", "accessible_restrooms"],
                amenities=["garden_setting", "gazebo", "outdoor_kitchen", "fire_pit", "string_lights"],
                restrictions=["weather_dependent", "no_loud_music_after_10pm", "no_pets"],
                base_rental_cost=3500.0,
                additional_fees={"tent_rental": 1200.0, "generator": 300.0, "cleanup": 400.0},
                available_dates=["2024-06-20", "2024-07-15", "2024-08-05"],
                contact_info={"phone": "(555) 234-5678", "email": "info@sunsetgarden.com"},
                rating=4.8,
                reviews_count=89,
                photos=["garden1.jpg", "garden2.jpg"],
                floor_plan="garden_map.pdf"
            ),
            Venue(
                venue_id="venue_003",
                name="Modern Conference Center",
                venue_type=VenueType.CONFERENCE_CENTER,
                address="789 Business Blvd",
                city="Corporate City",
                state="CA",
                zip_code="90212",
                coordinates=(34.0522, -118.2437),
                capacity_seated=400,
                capacity_standing=500,
                indoor_space=8000,
                outdoor_space=0,
                parking_spaces=300,
                accessibility_features=["full_ada_compliance", "multiple_elevators", "assisted_listening"],
                amenities=["state_of_art_av", "high_speed_wifi", "breakout_rooms", "business_center", "catering_kitchen"],
                restrictions=["corporate_events_only", "no_alcohol_without_permit"],
                base_rental_cost=4500.0,
                additional_fees={"av_technician": 1000.0, "setup_crew": 600.0},
                available_dates=["2024-06-12", "2024-06-25", "2024-07-08"],
                contact_info={"phone": "(555) 345-6789", "email": "bookings@moderncenter.com"},
                rating=4.3,
                reviews_count=203,
                photos=["conference1.jpg", "conference2.jpg"],
                floor_plan="conference_layout.pdf"
            )
        ]
        
        # Sample vendors
        vendors = [
            Vendor(
                vendor_id="vendor_001",
                name="Gourmet Catering Co.",
                category=ServiceCategory.CATERING,
                description="Full-service catering with farm-to-table cuisine",
                services_offered=["plated_dinner", "buffet", "cocktail_reception", "brunch"],
                service_area=["Downtown", "Hillside", "Corporate City"],
                pricing_structure={"plated_dinner": 85.0, "buffet": 65.0, "cocktail": 45.0},
                min_order=50.0,
                max_capacity=500,
                specialties=["farm_to_table", "wine_pairing", "custom_menus"],
                dietary_accommodations=["vegetarian", "vegan", "gluten_free", "kosher"],
                equipment_provided=["chafing_dishes", "serving_utensils", "linens"],
                setup_time_required=120,
                contact_info={"phone": "(555) 456-7890", "email": "events@gourmetcatering.com"},
                availability={"2024-06-15": ["morning", "afternoon"], "2024-06-22": ["evening"]},
                rating=4.7,
                reviews_count=156,
                certifications=["food_safety", "alcohol_service"],
                insurance_verified=True,
                portfolio=["wedding1.jpg", "corporate1.jpg"]
            ),
            Vendor(
                vendor_id="vendor_002",
                name="Elegant Photography Studio",
                category=ServiceCategory.PHOTOGRAPHY,
                description="Professional event photography and videography",
                services_offered=["event_photography", "videography", "photo_booth", "drone_photography"],
                service_area=["Greater Los Angeles Area"],
                pricing_structure={"6_hour_package": 2500.0, "8_hour_package": 3200.0, "videography_add_on": 1500.0},
                min_order=None,
                max_capacity=None,
                specialties=["wedding_photography", "corporate_events", "artistic_portraits"],
                dietary_accommodations=[],
                equipment_provided=["professional_cameras", "lighting", "editing_software"],
                setup_time_required=60,
                contact_info={"phone": "(555) 567-8901", "email": "bookings@elegantphoto.com"},
                availability={"2024-06-15": ["all_day"], "2024-07-10": ["morning", "afternoon"]},
                rating=4.9,
                reviews_count=234,
                certifications=["professional_photographers_association"],
                insurance_verified=True,
                portfolio=["portfolio1.jpg", "portfolio2.jpg"]
            ),
            Vendor(
                vendor_id="vendor_003",
                name="Harmony DJ Services",
                category=ServiceCategory.MUSIC,
                description="Professional DJ and live music entertainment",
                services_offered=["dj_service", "live_band", "sound_system", "lighting"],
                service_area=["Los Angeles County"],
                pricing_structure={"dj_4_hours": 800.0, "dj_6_hours": 1200.0, "live_band": 2500.0},
                min_order=None,
                max_capacity=1000,
                specialties=["wedding_music", "corporate_events", "dance_parties"],
                dietary_accommodations=[],
                equipment_provided=["sound_system", "microphones", "music_library", "lighting"],
                setup_time_required=90,
                contact_info={"phone": "(555) 678-9012", "email": "info@harmonydj.com"},
                availability={"2024-06-20": ["evening"], "2024-07-15": ["all_day"]},
                rating=4.6,
                reviews_count=178,
                certifications=["audio_engineering"],
                insurance_verified=True,
                portfolio=["event1.mp4", "event2.mp4"]
            ),
            Vendor(
                vendor_id="vendor_004",
                name="Bloom & Petal Decorators",
                category=ServiceCategory.DECORATION,
                description="Creative floral and event decoration services",
                services_offered=["floral_arrangements", "centerpieces", "ceremony_decor", "lighting_design"],
                service_area=["Southern California"],
                pricing_structure={"bridal_package": 3500.0, "corporate_package": 2000.0, "centerpiece": 150.0},
                min_order=500.0,
                max_capacity=None,
                specialties=["wedding_flowers", "seasonal_arrangements", "luxury_events"],
                dietary_accommodations=[],
                equipment_provided=["vases", "candles", "linens", "decorative_elements"],
                setup_time_required=180,
                contact_info={"phone": "(555) 789-0123", "email": "design@bloompetal.com"},
                availability={"2024-06-22": ["morning"], "2024-08-05": ["all_day"]},
                rating=4.8,
                reviews_count=92,
                certifications=["floral_design", "event_planning"],
                insurance_verified=True,
                portfolio=["wedding_decor1.jpg", "corporate_decor1.jpg"]
            )
        ]
        
        # Sample menu items and catering packages
        menu_items = [
            MenuItem(
                item_id="menu_001",
                name="Grilled Salmon with Lemon Herb Butter",
                category="main",
                description="Fresh Atlantic salmon grilled to perfection with house-made lemon herb butter",
                price_per_person=32.0,
                dietary_tags=["gluten_free", "dairy_free_option"],
                allergens=["fish"],
                preparation_time=25,
                ingredients=["salmon", "lemon", "herbs", "butter", "olive_oil"],
                presentation_style="plated"
            ),
            MenuItem(
                item_id="menu_002",
                name="Vegetarian Quinoa Stuffed Bell Peppers",
                category="main",
                description="Colorful bell peppers stuffed with quinoa, vegetables, and herbs",
                price_per_person=28.0,
                dietary_tags=["vegetarian", "vegan", "gluten_free"],
                allergens=[],
                preparation_time=35,
                ingredients=["bell_peppers", "quinoa", "vegetables", "herbs", "olive_oil"],
                presentation_style="plated"
            ),
            MenuItem(
                item_id="menu_003",
                name="Artisanal Cheese and Charcuterie Board",
                category="appetizer",
                description="Selection of local cheeses, cured meats, fruits, and artisan crackers",
                price_per_person=18.0,
                dietary_tags=["vegetarian_option"],
                allergens=["dairy", "gluten"],
                preparation_time=15,
                ingredients=["cheeses", "cured_meats", "fruits", "crackers", "nuts"],
                presentation_style="buffet"
            )
        ]
        
        catering_packages = [
            CateringPackage(
                package_id="package_001",
                vendor_id="vendor_001",
                name="Elegant Dinner Package",
                description="Three-course plated dinner with wine service",
                service_style="plated",
                menu_items=menu_items,
                price_per_person=85.0,
                minimum_guests=50,
                maximum_guests=200,
                setup_requirements=["full_kitchen", "serving_area", "dining_tables"],
                staff_included=6,
                additional_services=["wine_service", "table_setup", "cleanup"],
                dietary_accommodations=["vegetarian", "vegan", "gluten_free"]
            )
        ]
        
        # Sample guests
        guests = [
            Guest(
                guest_id="guest_001",
                first_name="John",
                last_name="Smith",
                email="john.smith@email.com",
                phone="(555) 111-2222",
                dietary_restrictions=["vegetarian"],
                accessibility_needs=[],
                plus_one=True,
                rsvp_status="confirmed",
                table_assignment="Table 1",
                special_notes="Prefers window seating",
                contact_preference="email",
                vip_status=False
            ),
            Guest(
                guest_id="guest_002",
                first_name="Sarah",
                last_name="Johnson",
                email="sarah.j@email.com",
                phone="(555) 333-4444",
                dietary_restrictions=["gluten_free"],
                accessibility_needs=["wheelchair_accessible"],
                plus_one=False,
                rsvp_status="confirmed",
                table_assignment="Table 2",
                special_notes="Requires wheelchair access",
                contact_preference="phone",
                vip_status=True
            )
        ]
        
        return {
            'venues': venues,
            'vendors': vendors,
            'menu_items': menu_items,
            'catering_packages': catering_packages,
            'guests': guests
        }
    
    async def search_venues(self, 
                          event_type: EventType, 
                          capacity: int, 
                          date: str, 
                          location: str = None,
                          max_budget: float = None) -> List[Venue]:
        """Search for suitable venues based on criteria"""
        
        suitable_venues = []
        
        for venue in self.sample_data['venues']:
            # Check capacity
            if venue.capacity_seated >= capacity or venue.capacity_standing >= capacity:
                # Check date availability
                if date in venue.available_dates:
                    # Check budget if specified
                    if max_budget is None or venue.base_rental_cost <= max_budget:
                        # Basic location matching (simplified)
                        if location is None or location.lower() in venue.city.lower():
                            suitable_venues.append(venue)
        
        # Sort by rating
        suitable_venues.sort(key=lambda x: x.rating, reverse=True)
        return suitable_venues
    
    async def search_vendors(self, 
                           category: ServiceCategory, 
                           date: str, 
                           location: str = None,
                           max_budget: float = None) -> List[Vendor]:
        """Search for vendors by category and criteria"""
        
        suitable_vendors = []
        
        for vendor in self.sample_data['vendors']:
            if vendor.category == category:
                # Check location (simplified)
                if location is None or any(loc.lower() in location.lower() for loc in vendor.service_area):
                    # Check availability
                    if date in vendor.availability:
                        # Basic budget check (simplified)
                        suitable_vendors.append(vendor)
        
        # Sort by rating
        suitable_vendors.sort(key=lambda x: x.rating, reverse=True)
        return suitable_vendors
    
    async def get_catering_options(self, 
                                 guest_count: int, 
                                 dietary_requirements: List[str] = None) -> List[CateringPackage]:
        """Get suitable catering packages"""
        
        suitable_packages = []
        
        for package in self.sample_data['catering_packages']:
            # Check capacity
            if package.minimum_guests <= guest_count <= package.maximum_guests:
                # Check dietary accommodations
                if dietary_requirements:
                    if all(req in package.dietary_accommodations for req in dietary_requirements):
                        suitable_packages.append(package)
                else:
                    suitable_packages.append(package)
        
        return suitable_packages

class EventPlannerRAG:
    """RAG system for intelligent event planning and venue management"""
    
    def __init__(self):
        # Initialize OpenAI
        openai.api_key = os.getenv("OPENAI_API_KEY")
        
        # Initialize components
        self.embeddings = OpenAIEmbeddings()
        self.llm = ChatOpenAI(model="gpt-4", temperature=0.3)
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        
        # Initialize vector store
        self.client = chromadb.PersistentClient(path="./event_planning_db")
        self.vectorstore = Chroma(
            client=self.client,
            collection_name="event_knowledge",
            embedding_function=self.embeddings
        )
        
        self.data_collector = EventDataCollector()
    
    async def initialize_knowledge_base(self):
        """Initialize the knowledge base with event planning data"""
        logger.info("Initializing event planning knowledge base...")
        
        documents = []
        
        # Add venue information
        for venue in self.data_collector.sample_data['venues']:
            doc_content = f"""
            Venue: {venue.name}
            Type: {venue.venue_type.value}
            Location: {venue.address}, {venue.city}, {venue.state}
            Capacity: {venue.capacity_seated} seated, {venue.capacity_standing} standing
            Space: {venue.indoor_space} sq ft indoor, {venue.outdoor_space} sq ft outdoor
            Parking: {venue.parking_spaces} spaces
            Accessibility: {', '.join(venue.accessibility_features)}
            Amenities: {', '.join(venue.amenities)}
            Restrictions: {', '.join(venue.restrictions)}
            Base Cost: ${venue.base_rental_cost:,.2f}
            Additional Fees: {', '.join([f'{k}: ${v}' for k, v in venue.additional_fees.items()])}
            Rating: {venue.rating}/5 ({venue.reviews_count} reviews)
            Available Dates: {', '.join(venue.available_dates)}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "venue",
                    "venue_id": venue.venue_id,
                    "name": venue.name,
                    "venue_type": venue.venue_type.value,
                    "city": venue.city,
                    "capacity_seated": venue.capacity_seated,
                    "base_cost": venue.base_rental_cost,
                    "rating": venue.rating
                }
            ))
        
        # Add vendor information
        for vendor in self.data_collector.sample_data['vendors']:
            doc_content = f"""
            Vendor: {vendor.name}
            Category: {vendor.category.value}
            Description: {vendor.description}
            Services: {', '.join(vendor.services_offered)}
            Service Area: {', '.join(vendor.service_area)}
            Pricing: {', '.join([f'{k}: ${v}' if isinstance(v, (int, float)) else f'{k}: {v}' for k, v in vendor.pricing_structure.items()])}
            Minimum Order: {f'${vendor.min_order}' if vendor.min_order else 'None'}
            Maximum Capacity: {vendor.max_capacity if vendor.max_capacity else 'Unlimited'}
            Specialties: {', '.join(vendor.specialties)}
            Equipment Provided: {', '.join(vendor.equipment_provided)}
            Setup Time: {vendor.setup_time_required} minutes
            Rating: {vendor.rating}/5 ({vendor.reviews_count} reviews)
            Certifications: {', '.join(vendor.certifications)}
            Insurance: {'Verified' if vendor.insurance_verified else 'Not Verified'}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "vendor",
                    "vendor_id": vendor.vendor_id,
                    "name": vendor.name,
                    "category": vendor.category.value,
                    "rating": vendor.rating,
                    "service_area": vendor.service_area
                }
            ))
        
        # Add catering information
        for package in self.data_collector.sample_data['catering_packages']:
            doc_content = f"""
            Catering Package: {package.name}
            Vendor: {package.vendor_id}
            Description: {package.description}
            Service Style: {package.service_style}
            Price per Person: ${package.price_per_person}
            Guest Range: {package.minimum_guests}-{package.maximum_guests} guests
            Staff Included: {package.staff_included}
            Setup Requirements: {', '.join(package.setup_requirements)}
            Additional Services: {', '.join(package.additional_services)}
            Dietary Accommodations: {', '.join(package.dietary_accommodations)}
            Menu Items: {len(package.menu_items)} items available
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "catering_package",
                    "package_id": package.package_id,
                    "vendor_id": package.vendor_id,
                    "name": package.name,
                    "price_per_person": package.price_per_person,
                    "min_guests": package.minimum_guests,
                    "max_guests": package.maximum_guests
                }
            ))
        
        # Add general event planning knowledge
        event_planning_concepts = [
            {
                "title": "Event Timeline Management",
                "content": "Effective event timeline management involves creating detailed schedules for all pre-event, event-day, and post-event activities. Key considerations include vendor setup times, guest arrival patterns, activity durations, and buffer time for unexpected delays."
            },
            {
                "title": "Budget Allocation Best Practices",
                "content": "Event budget allocation typically follows the 40-20-20-10-10 rule: 40% for venue and catering, 20% for photography/videography, 20% for flowers and decorations, 10% for music/entertainment, and 10% contingency fund."
            },
            {
                "title": "Vendor Coordination Strategies",
                "content": "Successful vendor coordination requires clear communication protocols, detailed contracts, regular check-ins, and contingency planning. Establish primary contacts, create shared timelines, and conduct pre-event meetings."
            },
            {
                "title": "Guest Experience Optimization",
                "content": "Optimize guest experience through personalized communication, accessibility considerations, dietary accommodations, clear signage, comfortable seating arrangements, and engaging activities that match the event's purpose."
            },
            {
                "title": "Risk Management in Event Planning",
                "content": "Event risk management includes weather contingencies, vendor backup plans, insurance coverage, health and safety protocols, crowd control measures, and emergency response procedures."
            }
        ]
        
        for concept in event_planning_concepts:
            documents.append(Document(
                page_content=f"Title: {concept['title']}\nContent: {concept['content']}",
                metadata={
                    "type": "planning_concept",
                    "title": concept['title']
                }
            ))
        
        # Add documents to vector store
        if documents:
            self.vectorstore.add_documents(documents)
        
        logger.info(f"Added {len(documents)} documents to knowledge base")
    
    def retrieve_relevant_information(self, query: str, k: int = 8) -> List[Document]:
        """Retrieve relevant event planning information"""
        return self.vectorstore.similarity_search(query, k=k)
    
    async def recommend_venues(self, 
                             event_requirements: Dict[str, any]) -> Dict[str, any]:
        """Recommend suitable venues based on event requirements"""
        
        event_type = EventType(event_requirements.get('event_type', 'celebration'))
        capacity = event_requirements.get('capacity', 100)
        date = event_requirements.get('date', '2024-06-15')
        location = event_requirements.get('location', '')
        budget = event_requirements.get('venue_budget')
        
        # Search for suitable venues
        venues = await self.data_collector.search_venues(
            event_type=event_type,
            capacity=capacity,
            date=date,
            location=location,
            max_budget=budget
        )
        
        if not venues:
            return {"error": "No suitable venues found for the specified criteria"}
        
        # Get relevant context
        query = f"venue recommendation {event_type.value} {capacity} guests {location}"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Create venue summaries
        venue_summaries = []
        for venue in venues[:3]:  # Top 3 venues
            venue_summaries.append(f"""
            {venue.name} ({venue.venue_type.value}):
            - Capacity: {venue.capacity_seated} seated, {venue.capacity_standing} standing
            - Location: {venue.city}, {venue.state}
            - Cost: ${venue.base_rental_cost:,} + fees
            - Rating: {venue.rating}/5
            - Amenities: {', '.join(venue.amenities[:5])}
            - Available: {date in venue.available_dates}
            """)
        
        # Generate recommendations
        prompt = ChatPromptTemplate.from_template("""
        Recommend the best venues for this event based on the requirements and available options:
        
        Event Requirements:
        - Type: {event_type}
        - Expected Guests: {capacity}
        - Date: {date}
        - Location Preference: {location}
        - Budget: {budget}
        
        Available Venues:
        {venue_summaries}
        
        Additional Context: {context}
        
        Provide detailed recommendations including:
        1. Top venue choice with detailed rationale
        2. Alternative venues with pros/cons comparison
        3. Cost analysis and budget considerations
        4. Logistical advantages and potential challenges
        5. Suitability for the specific event type
        6. Guest experience considerations
        7. Booking recommendations and next steps
        
        Make recommendations actionable and specific to the event requirements.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "event_type": event_type.value,
            "capacity": capacity,
            "date": date,
            "location": location or "No preference",
            "budget": f"${budget:,}" if budget else "Not specified",
            "venue_summaries": "\n".join(venue_summaries),
            "context": context
        })
        
        return {
            "event_requirements": event_requirements,
            "venue_recommendations": response.content,
            "available_venues": [asdict(venue) for venue in venues],
            "recommendation_date": datetime.now().isoformat()
        }
    
    async def create_vendor_recommendations(self, 
                                         event_requirements: Dict[str, any]) -> Dict[str, any]:
        """Create comprehensive vendor recommendations"""
        
        date = event_requirements.get('date', '2024-06-15')
        location = event_requirements.get('location', '')
        budget_breakdown = event_requirements.get('budget_breakdown', {})
        
        vendor_recommendations = {}
        
        # Key vendor categories for most events
        key_categories = [ServiceCategory.CATERING, ServiceCategory.PHOTOGRAPHY, 
                         ServiceCategory.MUSIC, ServiceCategory.DECORATION]
        
        for category in key_categories:
            vendors = await self.data_collector.search_vendors(
                category=category,
                date=date,
                location=location,
                max_budget=budget_breakdown.get(category.value)
            )
            
            if vendors:
                vendor_recommendations[category.value] = vendors[:2]  # Top 2 in each category
        
        # Generate comprehensive recommendations
        vendor_summaries = []
        for category, vendors in vendor_recommendations.items():
            for vendor in vendors:
                vendor_summaries.append(f"""
                {vendor.name} ({category}):
                - Rating: {vendor.rating}/5 ({vendor.reviews_count} reviews)
                - Services: {', '.join(vendor.services_offered[:3])}
                - Specialties: {', '.join(vendor.specialties[:2])}
                - Pricing: {list(vendor.pricing_structure.items())[0] if vendor.pricing_structure else 'Contact for pricing'}
                - Setup Time: {vendor.setup_time_required} minutes
                """)
        
        # Get relevant context
        query = f"vendor selection event planning coordination recommendations"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        prompt = ChatPromptTemplate.from_template("""
        Create comprehensive vendor recommendations for this event:
        
        Event Date: {date}
        Location: {location}
        Budget Considerations: {budget_info}
        
        Available Vendors:
        {vendor_summaries}
        
        Planning Context: {context}
        
        Provide detailed vendor recommendations including:
        1. Primary vendor selections with rationale
        2. Alternative options and backup plans
        3. Vendor coordination timeline and logistics
        4. Budget optimization strategies
        5. Quality assurance and vetting considerations
        6. Contract negotiation tips
        7. Vendor coordination best practices
        8. Risk mitigation for vendor dependencies
        
        Focus on practical, actionable advice for successful vendor management.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "date": date,
            "location": location or "Not specified",
            "budget_info": str(budget_breakdown) if budget_breakdown else "Not specified",
            "vendor_summaries": "\n".join(vendor_summaries),
            "context": context
        })
        
        return {
            "vendor_recommendations": response.content,
            "available_vendors_by_category": {k: [asdict(v) for v in vendors] 
                                           for k, vendors in vendor_recommendations.items()},
            "recommendation_date": datetime.now().isoformat()
        }
    
    async def create_event_timeline(self, event_details: Dict[str, any]) -> Dict[str, any]:
        """Create detailed event timeline"""
        
        event_date = datetime.strptime(event_details.get('date', '2024-06-15'), '%Y-%m-%d')
        event_start = event_details.get('start_time', '18:00')
        event_end = event_details.get('end_time', '23:00')
        event_type = event_details.get('event_type', 'celebration')
        guest_count = event_details.get('guest_count', 100)
        
        # Get relevant timeline context
        query = f"event timeline {event_type} planning schedule coordination"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        prompt = ChatPromptTemplate.from_template("""
        Create a comprehensive event timeline for this event:
        
        Event Details:
        - Type: {event_type}
        - Date: {event_date}
        - Start Time: {event_start}
        - End Time: {event_end}
        - Guest Count: {guest_count}
        
        Timeline Planning Context: {context}
        
        Create a detailed timeline including:
        1. Pre-event planning milestones (8-12 weeks before)
        2. Vendor coordination schedule (4-6 weeks before)
        3. Final preparations timeline (1-2 weeks before)
        4. Event day detailed schedule (hour by hour)
        5. Setup and breakdown timeline
        6. Key coordination points and dependencies
        7. Buffer time and contingency planning
        8. Post-event follow-up tasks
        
        Format as a practical, actionable timeline that can guide event execution.
        Include specific timeframes, responsible parties, and critical dependencies.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "event_type": event_type,
            "event_date": event_date.strftime('%Y-%m-%d'),
            "event_start": event_start,
            "event_end": event_end,
            "guest_count": guest_count,
            "context": context
        })
        
        return {
            "event_details": event_details,
            "comprehensive_timeline": response.content,
            "created_date": datetime.now().isoformat()
        }
    
    async def optimize_event_budget(self, 
                                  budget_requirements: Dict[str, any]) -> Dict[str, any]:
        """Optimize event budget allocation"""
        
        total_budget = budget_requirements.get('total_budget', 10000)
        guest_count = budget_requirements.get('guest_count', 100)
        priorities = budget_requirements.get('priorities', [])
        event_type = budget_requirements.get('event_type', 'celebration')
        
        # Get relevant budget context
        query = f"event budget planning allocation {event_type} cost optimization"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        prompt = ChatPromptTemplate.from_template("""
        Create an optimized budget allocation plan for this event:
        
        Budget Parameters:
        - Total Budget: ${total_budget:,}
        - Guest Count: {guest_count}
        - Event Type: {event_type}
        - Priorities: {priorities}
        - Per Person Budget: ${per_person:.2f}
        
        Budget Planning Context: {context}
        
        Provide comprehensive budget optimization including:
        1. Recommended budget allocation by category (percentages and amounts)
        2. Cost-saving strategies without compromising quality
        3. Priority-based spending recommendations
        4. Contingency planning (10-15% buffer)
        5. Negotiation strategies with vendors
        6. Alternative options for different budget scenarios
        7. Hidden costs to anticipate
        8. Budget tracking and management tips
        
        Make recommendations specific to the event type and guest count.
        Include practical tips for maximizing value within the budget constraints.
        """)
        
        per_person_budget = total_budget / guest_count if guest_count > 0 else total_budget
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "total_budget": total_budget,
            "guest_count": guest_count,
            "event_type": event_type,
            "priorities": ', '.join(priorities) if priorities else 'Not specified',
            "per_person": per_person_budget,
            "context": context
        })
        
        return {
            "budget_requirements": budget_requirements,
            "budget_optimization": response.content,
            "per_person_budget": per_person_budget,
            "optimization_date": datetime.now().isoformat()
        }

class EventPlanningAssistant:
    """Main assistant orchestrating event planning and venue management"""
    
    def __init__(self):
        self.rag_system = EventPlannerRAG()
        self.initialized = False
    
    async def initialize(self):
        """Initialize the event planning assistant"""
        if not self.initialized:
            await self.rag_system.initialize_knowledge_base()
            self.initialized = True
            logger.info("Event Planning Assistant initialized successfully")
    
    async def plan_event(self, event_requirements: Dict[str, any]) -> Dict[str, any]:
        """Comprehensive event planning service"""
        
        if not self.initialized:
            await self.initialize()
        
        # Get venue recommendations
        venue_recommendations = await self.rag_system.recommend_venues(event_requirements)
        
        # Get vendor recommendations
        vendor_recommendations = await self.rag_system.create_vendor_recommendations(event_requirements)
        
        # Create timeline
        timeline = await self.rag_system.create_event_timeline(event_requirements)
        
        # Optimize budget
        if 'total_budget' in event_requirements:
            budget_optimization = await self.rag_system.optimize_event_budget(event_requirements)
        else:
            budget_optimization = {"note": "Budget optimization skipped - no budget provided"}
        
        return {
            "event_requirements": event_requirements,
            "venue_recommendations": venue_recommendations,
            "vendor_recommendations": vendor_recommendations,
            "event_timeline": timeline,
            "budget_optimization": budget_optimization,
            "planning_completed": datetime.now().isoformat()
        }
    
    async def find_venues(self, search_criteria: Dict[str, any]) -> Dict[str, any]:
        """Find and recommend venues"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.recommend_venues(search_criteria)
    
    async def get_vendor_recommendations(self, vendor_requirements: Dict[str, any]) -> Dict[str, any]:
        """Get vendor recommendations"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.create_vendor_recommendations(vendor_requirements)
    
    async def create_timeline(self, timeline_requirements: Dict[str, any]) -> Dict[str, any]:
        """Create event timeline"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.create_event_timeline(timeline_requirements)
    
    async def optimize_budget(self, budget_parameters: Dict[str, any]) -> Dict[str, any]:
        """Optimize event budget"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.optimize_event_budget(budget_parameters)

# Example usage and testing
async def main():
    """Main function demonstrating the Event Planning Assistant"""
    
    print("🎉 Initializing Event Planning and Venue Management Assistant...")
    assistant = EventPlanningAssistant()
    
    try:
        # Initialize the system
        await assistant.initialize()
        print("✅ Event Planning Assistant initialized successfully")
        
        # Plan a wedding event
        print("\n💒 Planning a wedding event...")
        wedding_requirements = {
            'event_type': 'wedding',
            'capacity': 150,
            'date': '2024-06-22',
            'location': 'Los Angeles',
            'total_budget': 25000,
            'priorities': ['photography', 'catering', 'venue'],
            'start_time': '17:00',
            'end_time': '23:00',
            'guest_count': 150
        }
        
        wedding_plan = await assistant.plan_event(wedding_requirements)
        
        print("✅ Wedding Planning Complete:")
        print(f"Budget optimization preview: {wedding_plan['budget_optimization']['budget_optimization'][:200]}...")
        
        # Find venues for corporate event
        print("\n🏢 Finding venues for corporate conference...")
        corporate_search = {
            'event_type': 'conference',
            'capacity': 300,
            'date': '2024-07-10',
            'location': 'Corporate City',
            'venue_budget': 5000
        }
        
        venue_results = await assistant.find_venues(corporate_search)
        
        print("✅ Venue Search Complete:")
        if 'available_venues' in venue_results:
            print(f"Found {len(venue_results['available_venues'])} suitable venues")
            print(f"Recommendations preview: {venue_results['venue_recommendations'][:200]}...")
        
        # Get vendor recommendations
        print("\n🎭 Getting vendor recommendations...")
        vendor_requirements = {
            'date': '2024-06-20',
            'location': 'Hillside',
            'budget_breakdown': {
                'catering': 8000,
                'photography': 3000,
                'music': 1500,
                'decoration': 2500
            }
        }
        
        vendor_results = await assistant.get_vendor_recommendations(vendor_requirements)
        
        print("✅ Vendor Recommendations Complete:")
        print(f"Recommendations preview: {vendor_results['vendor_recommendations'][:200]}...")
        
        # Create event timeline
        print("\n📅 Creating event timeline...")
        timeline_requirements = {
            'event_type': 'birthday',
            'date': '2024-08-05',
            'start_time': '19:00',
            'end_time': '22:00',
            'guest_count': 75
        }
        
        timeline_results = await assistant.create_timeline(timeline_requirements)
        
        print("✅ Timeline Created:")
        print(f"Timeline preview: {timeline_results['comprehensive_timeline'][:200]}...")
        
        # Optimize budget
        print("\n💰 Optimizing event budget...")
        budget_parameters = {
            'total_budget': 15000,
            'guest_count': 100,
            'event_type': 'corporate',
            'priorities': ['venue', 'catering', 'av_equipment']
        }
        
        budget_results = await assistant.optimize_budget(budget_parameters)
        
        print("✅ Budget Optimization Complete:")
        print(f"Optimization preview: {budget_results['budget_optimization'][:200]}...")
        
        print("\n🎉 Event Planning and Venue Management demonstration completed successfully!")
        
    except Exception as e:
        logger.error(f"Error in main execution: {str(e)}")
        print(f"❌ Error: {str(e)}")

if __name__ == "__main__":
    # Set up environment variables
    os.environ.setdefault("OPENAI_API_KEY", "your-openai-api-key-here")
    
    # Run the main function
    asyncio.run(main())
````

## Project Summary

The **Event Planning and Venue Management** platform represents a transformative approach to event coordination, combining RAG technology with comprehensive vendor databases and intelligent planning algorithms to democratize access to professional-grade event planning capabilities. This system revolutionizes how events are conceived, planned, and executed by providing AI-powered insights that optimize every aspect of the planning process.

### Key Value Propositions

**Intelligent Resource Matching**: Leverages AI to analyze venue capabilities, vendor services, and event requirements to provide optimal matches that balance budget constraints, quality expectations, and logistical feasibility, dramatically improving planning efficiency.

**Comprehensive Coordination**: Integrates all aspects of event planning including venue selection, vendor coordination, timeline management, and budget optimization into a cohesive platform that reduces complexity and improves outcomes.

**Personalized Planning**: Adapts recommendations based on event type, guest preferences, cultural considerations, and specific requirements to create unique, memorable experiences that exceed expectations.

**Risk Mitigation**: Identifies potential issues early in the planning process and provides contingency strategies, backup options, and risk management protocols to ensure successful event execution.

### Technical Excellence

The implementation showcases advanced event management engineering with **LangChain** for RAG orchestration, **ChromaDB** for vendor and venue knowledge storage, **GeoPy** for location-based matching, and **Plotly** for venue visualization. The architecture supports multi-criteria optimization, real-time availability checking, and scalable vendor management.

### Impact and Applications

This platform serves event planners, venue managers, corporate event coordinators, wedding planners, and individuals organizing personal celebrations. Applications include vendor marketplace optimization, venue utilization analytics, automated timeline generation, and intelligent budget allocation.

The project demonstrates how AI can transform event planning from a manual, experience-dependent craft to an intelligent, data-driven service that combines human creativity with systematic optimization. Through comprehensive automation and intelligent analysis, this system makes professional-quality event planning accessible to everyone while improving outcomes and reducing stress for both planners and clients.