<small>Claude Sonnet 4 **(Virtual Reality Training Simulation Coordinator)**</small>
# Virtual Reality Training Simulation Coordinator

## Kl√≠ƒçov√© koncepty

### Multi-Agent Systems (Syst√©my v√≠ce agent≈Ø)
Architektura zahrnuj√≠c√≠ v√≠ce autonomn√≠ch agent≈Ø, kte≈ô√≠ spolupracuj√≠ na dosa≈æen√≠ spoleƒçn√Ωch c√≠l≈Ø. V kontextu VR tr√©ninku ka≈æd√Ω agent ≈ô√≠d√≠ specifick√Ω aspekt v√Ωcviku - generov√°n√≠ sc√©n√°≈ô≈Ø, hodnocen√≠ v√Ωkonu, anal√Ωzu mezer a optimalizaci cest.

### Scenario Generation (Generov√°n√≠ sc√©n√°≈ô≈Ø)
Automatizovan√Ω proces vytv√°≈ôen√≠ realistick√Ωch tr√©ningov√Ωch sc√©n√°≈ô≈Ø na z√°kladƒõ c√≠l≈Ø v√Ωuky, √∫rovnƒõ obt√≠≈ænosti a specifick√Ωch dovednost√≠. Vyu≈æ√≠v√° AI pro dynamick√© p≈ôizp≈Øsoben√≠ obsahu.

### Performance Assessment (Hodnocen√≠ v√Ωkonu)
Syst√©m pro mƒõ≈ôen√≠ a anal√Ωzu v√Ωkonnosti u≈æivatel≈Ø bƒõhem VR tr√©ninku. Zahrnuje metriky jako rychlost, p≈ôesnost, rozhodov√°n√≠ a adaptabilitu.

### Skill Gap Analysis (Anal√Ωza mezer v dovednostech)
Identifikace rozd√≠l≈Ø mezi aktu√°ln√≠ √∫rovn√≠ dovednost√≠ a po≈æadovan√Ωmi kompetencemi. Poskytuje z√°klad pro personalizovan√© v√Ωukov√© cesty.

### Training Path Optimization (Optimalizace v√Ωukov√Ωch cest)
Adaptivn√≠ proces, kter√Ω upravuje posloupnost a obt√≠≈ænost tr√©ningov√Ωch modul≈Ø na z√°kladƒõ individu√°ln√≠ho pokroku a v√Ωukov√Ωch c√≠l≈Ø.

### Certification Management (Spr√°va certifikac√≠)
Syst√©m pro sledov√°n√≠ pokroku, vyhodnocov√°n√≠ kompetenc√≠ a vyd√°v√°n√≠ certifik√°t≈Ø po √∫spƒõ≈°n√©m dokonƒçen√≠ tr√©ningov√Ωch program≈Ø.

## Komplexn√≠ vysvƒõtlen√≠ projektu

Virtual Reality Training Simulation Coordinator p≈ôedstavuje pokroƒçil√Ω syst√©m pro ≈ô√≠zen√≠ a koordinaci VR v√Ωcvikov√Ωch program≈Ø. Projekt vyu≈æ√≠v√° architekturu v√≠ce agent≈Ø pro automatizaci cel√©ho v√Ωcvikov√©ho procesu - od generov√°n√≠ sc√©n√°≈ô≈Ø a≈æ po vyd√°v√°n√≠ certifik√°t≈Ø.

### C√≠le projektu
- Automatizace tvorby personalizovan√Ωch VR tr√©ningov√Ωch sc√©n√°≈ô≈Ø
- Kontinu√°ln√≠ hodnocen√≠ a adaptace v√Ωcvikov√Ωch program≈Ø
- Optimalizace uƒçebn√≠ch cest pro maxim√°ln√≠ efektivitu
- Objektivn√≠ mƒõ≈ôen√≠ pokroku a vyd√°v√°n√≠ certifik√°t≈Ø

### V√Ωzvy
- Koordinace mezi r≈Øzn√Ωmi agenty v re√°ln√©m ƒçase
- Personalizace obsahu pro r≈Øzn√© √∫rovnƒõ dovednost√≠
- Udr≈æen√≠ konzistence hodnocen√≠ nap≈ô√≠ƒç r≈Øzn√Ωmi sc√©n√°≈ôi
- ≈†k√°lovatelnost pro tis√≠ce souƒçasn√Ωch u≈æivatel≈Ø

### Potenci√°ln√≠ dopad
Syst√©m umo≈æ≈àuje efektivn√≠ a n√°kladovƒõ optim√°ln√≠ v√Ωcvik v oblastech jako zdravotnictv√≠, pr≈Ømysl, bezpeƒçnost a vzdƒõl√°v√°n√≠, s mo≈ænost√≠ ≈°k√°lov√°n√≠ na glob√°ln√≠ √∫rove≈à.

## Komplexn√≠ p≈ô√≠klad s implementac√≠ v Pythonu

### Instalace z√°vislost√≠

````python
# Vytvo≈ôte requirements.txt
autogen==0.2.11
langchain==0.1.4
openai==1.10.0
chromadb==0.4.22
fastapi==0.109.0
uvicorn==0.27.0
pydantic==2.5.3
numpy==1.24.3
pandas==2.0.3
scikit-learn==1.3.0
asyncio-mqtt==0.16.1
````

### Hlavn√≠ implementace

````python
import asyncio
import json
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from enum import Enum
import uuid

import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import chromadb
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SkillLevel(Enum):
    BEGINNER = "zaƒç√°teƒçn√≠k"
    INTERMEDIATE = "pokroƒçil√Ω"
    ADVANCED = "expert"

class ScenarioType(Enum):
    SAFETY = "bezpeƒçnost"
    TECHNICAL = "technick√©"
    COMMUNICATION = "komunikace"
    EMERGENCY = "nouzov√©"

@dataclass
class TrainingUser:
    user_id: str
    name: str
    current_skills: Dict[str, float]  # skill_name -> level (0-1)
    target_skills: Dict[str, float]
    completed_scenarios: List[str]
    performance_history: List[Dict]
    certification_level: str

@dataclass
class TrainingScenario:
    scenario_id: str
    name: str
    description: str
    type: ScenarioType
    difficulty: float  # 0-1
    required_skills: Dict[str, float]
    duration_minutes: int
    learning_objectives: List[str]

@dataclass
class PerformanceMetrics:
    user_id: str
    scenario_id: str
    completion_time: float
    accuracy_score: float
    decision_quality: float
    stress_level: float
    timestamp: datetime

class VRTrainingDatabase:
    """Spr√°va dat pro VR tr√©ning s ChromaDB"""
    
    def __init__(self):
        self.client = chromadb.Client()
        self.scenarios_collection = self.client.create_collection("scenarios")
        self.users_collection = self.client.create_collection("users")
        self.performance_collection = self.client.create_collection("performance")
        
    def store_scenario(self, scenario: TrainingScenario):
        """Ulo≈æen√≠ sc√©n√°≈ôe do datab√°ze"""
        self.scenarios_collection.add(
            documents=[scenario.description],
            metadatas=[asdict(scenario)],
            ids=[scenario.scenario_id]
        )
        
    def store_user(self, user: TrainingUser):
        """Ulo≈æen√≠ u≈æivatele do datab√°ze"""
        self.users_collection.add(
            documents=[f"{user.name} - {user.certification_level}"],
            metadatas=[asdict(user)],
            ids=[user.user_id]
        )
        
    def store_performance(self, metrics: PerformanceMetrics):
        """Ulo≈æen√≠ v√Ωkonov√Ωch metrik"""
        self.performance_collection.add(
            documents=[f"Performance {metrics.user_id} - {metrics.scenario_id}"],
            metadatas=[asdict(metrics)],
            ids=[f"{metrics.user_id}_{metrics.scenario_id}_{metrics.timestamp.isoformat()}"]
        )

class ScenarioGeneratorAgent:
    """Agent pro generov√°n√≠ VR tr√©ningov√Ωch sc√©n√°≈ô≈Ø"""
    
    def __init__(self, llm_chain: LLMChain, database: VRTrainingDatabase):
        self.llm_chain = llm_chain
        self.database = database
        
    async def generate_scenario(self, user: TrainingUser, scenario_type: ScenarioType) -> TrainingScenario:
        """Generov√°n√≠ personalizovan√©ho sc√©n√°≈ôe"""
        try:
            # Anal√Ωza aktu√°ln√≠ch dovednost√≠ u≈æivatele
            skill_gaps = self._analyze_skill_gaps(user)
            
            # Prompt pro generov√°n√≠ sc√©n√°≈ôe
            prompt_vars = {
                "scenario_type": scenario_type.value,
                "skill_gaps": json.dumps(skill_gaps, ensure_ascii=False),
                "user_level": user.certification_level,
                "completed_scenarios": len(user.completed_scenarios)
            }
            
            response = await self.llm_chain.arun(**prompt_vars)
            scenario_data = json.loads(response)
            
            scenario = TrainingScenario(
                scenario_id=str(uuid.uuid4()),
                name=scenario_data["name"],
                description=scenario_data["description"],
                type=scenario_type,
                difficulty=scenario_data["difficulty"],
                required_skills=scenario_data["required_skills"],
                duration_minutes=scenario_data["duration"],
                learning_objectives=scenario_data["objectives"]
            )
            
            self.database.store_scenario(scenario)
            logger.info(f"Generov√°n sc√©n√°≈ô {scenario.name} pro u≈æivatele {user.name}")
            
            return scenario
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ sc√©n√°≈ôe: {e}")
            raise
    
    def _analyze_skill_gaps(self, user: TrainingUser) -> Dict[str, float]:
        """Anal√Ωza mezer v dovednostech"""
        gaps = {}
        for skill, target in user.target_skills.items():
            current = user.current_skills.get(skill, 0)
            gap = max(0, target - current)
            gaps[skill] = gap
        return gaps

class PerformanceAssessmentAgent:
    """Agent pro hodnocen√≠ v√Ωkonu v VR tr√©ninku"""
    
    def __init__(self, database: VRTrainingDatabase):
        self.database = database
        
    async def assess_performance(self, user_id: str, scenario_id: str, 
                               vr_data: Dict[str, Any]) -> PerformanceMetrics:
        """Hodnocen√≠ v√Ωkonu na z√°kladƒõ VR dat"""
        try:
            # Simulace v√Ωpoƒçtu metrik z VR dat
            completion_time = vr_data.get("completion_time", 0)
            actions_taken = vr_data.get("actions", [])
            errors_made = vr_data.get("errors", 0)
            
            # V√Ωpoƒçet sk√≥re p≈ôesnosti
            accuracy_score = max(0, 1 - (errors_made / max(len(actions_taken), 1)))
            
            # Hodnocen√≠ kvality rozhodov√°n√≠
            decision_quality = self._evaluate_decision_quality(actions_taken)
            
            # Odhad √∫rovnƒõ stresu na z√°kladƒõ chov√°n√≠
            stress_level = self._estimate_stress_level(vr_data)
            
            metrics = PerformanceMetrics(
                user_id=user_id,
                scenario_id=scenario_id,
                completion_time=completion_time,
                accuracy_score=accuracy_score,
                decision_quality=decision_quality,
                stress_level=stress_level,
                timestamp=datetime.now()
            )
            
            self.database.store_performance(metrics)
            logger.info(f"Hodnocen v√Ωkon u≈æivatele {user_id} ve sc√©n√°≈ôi {scenario_id}")
            
            return metrics
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi hodnocen√≠ v√Ωkonu: {e}")
            raise
    
    def _evaluate_decision_quality(self, actions: List[Dict]) -> float:
        """Hodnocen√≠ kvality rozhodov√°n√≠"""
        if not actions:
            return 0.5
        
        # Simulace hodnocen√≠ na z√°kladƒõ rychlosti a spr√°vnosti akc√≠
        correct_actions = sum(1 for action in actions if action.get("correct", False))
        return min(1.0, correct_actions / len(actions))
    
    def _estimate_stress_level(self, vr_data: Dict) -> float:
        """Odhad √∫rovnƒõ stresu na z√°kladƒõ VR metrik"""
        # Simulace na z√°kladƒõ r≈Øzn√Ωch faktor≈Ø
        hesitation_time = vr_data.get("hesitation_time", 0)
        movement_erratic = vr_data.get("movement_variability", 0)
        
        stress_indicators = [hesitation_time / 10, movement_erratic]
        return min(1.0, np.mean(stress_indicators))

class SkillGapAnalysisAgent:
    """Agent pro anal√Ωzu mezer v dovednostech"""
    
    def __init__(self, database: VRTrainingDatabase):
        self.database = database
        self.scaler = StandardScaler()
        
    async def analyze_skill_gaps(self, user: TrainingUser) -> Dict[str, Any]:
        """Komprehenzivn√≠ anal√Ωza mezer v dovednostech"""
        try:
            # Z√≠sk√°n√≠ v√Ωkonov√Ωch dat u≈æivatele
            performance_data = self._get_user_performance_data(user.user_id)
            
            # Anal√Ωza trend≈Ø
            trends = self._analyze_performance_trends(performance_data)
            
            # Identifikace prioritn√≠ch oblast√≠
            priority_skills = self._identify_priority_skills(user, trends)
            
            # Predikce ƒçasu pot≈ôebn√©ho pro zlep≈°en√≠
            improvement_timeline = self._predict_improvement_timeline(user, priority_skills)
            
            analysis = {
                "user_id": user.user_id,
                "skill_gaps": self._calculate_skill_gaps(user),
                "performance_trends": trends,
                "priority_skills": priority_skills,
                "improvement_timeline": improvement_timeline,
                "recommendations": self._generate_recommendations(user, priority_skills)
            }
            
            logger.info(f"Provedena anal√Ωza mezer pro u≈æivatele {user.name}")
            return analysis
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi anal√Ωze mezer: {e}")
            raise
    
    def _get_user_performance_data(self, user_id: str) -> List[PerformanceMetrics]:
        """Z√≠sk√°n√≠ v√Ωkonov√Ωch dat u≈æivatele"""
        # Simulace naƒçten√≠ dat z datab√°ze
        return []
    
    def _analyze_performance_trends(self, performance_data: List[PerformanceMetrics]) -> Dict:
        """Anal√Ωza trend≈Ø ve v√Ωkonu"""
        if not performance_data:
            return {"trend": "insufficient_data"}
        
        # Simulace anal√Ωzy trend≈Ø
        return {
            "trend": "improving",
            "improvement_rate": 0.15,
            "consistency": 0.8
        }
    
    def _calculate_skill_gaps(self, user: TrainingUser) -> Dict[str, float]:
        """V√Ωpoƒçet mezer v dovednostech"""
        gaps = {}
        for skill, target in user.target_skills.items():
            current = user.current_skills.get(skill, 0)
            gap = max(0, target - current)
            gaps[skill] = gap
        return gaps
    
    def _identify_priority_skills(self, user: TrainingUser, trends: Dict) -> List[str]:
        """Identifikace prioritn√≠ch dovednost√≠"""
        skill_gaps = self._calculate_skill_gaps(user)
        # Se≈ôazen√≠ podle velikosti mezery
        priority_skills = sorted(skill_gaps.keys(), key=lambda x: skill_gaps[x], reverse=True)
        return priority_skills[:3]  # Top 3 priority skills
    
    def _predict_improvement_timeline(self, user: TrainingUser, priority_skills: List[str]) -> Dict:
        """Predikce ƒçasov√© osy zlep≈°en√≠"""
        timeline = {}
        for skill in priority_skills:
            gap = user.target_skills.get(skill, 0) - user.current_skills.get(skill, 0)
            # Simulace predikce na z√°kladƒõ historick√©ho pokroku
            estimated_weeks = max(4, int(gap * 20))  # Z√°kladn√≠ odhad
            timeline[skill] = estimated_weeks
        return timeline
    
    def _generate_recommendations(self, user: TrainingUser, priority_skills: List[str]) -> List[str]:
        """Generov√°n√≠ doporuƒçen√≠ pro zlep≈°en√≠"""
        recommendations = []
        for skill in priority_skills:
            recommendations.append(f"Zamƒõ≈ôte se na praxi {skill} prost≈ôednictv√≠m pokroƒçil√Ωch sc√©n√°≈ô≈Ø")
        return recommendations

class TrainingPathOptimizationAgent:
    """Agent pro optimalizaci v√Ωukov√Ωch cest"""
    
    def __init__(self, database: VRTrainingDatabase, scenario_agent: ScenarioGeneratorAgent):
        self.database = database
        self.scenario_agent = scenario_agent
        
    async def optimize_training_path(self, user: TrainingUser, 
                                   skill_analysis: Dict) -> Dict[str, Any]:
        """Optimalizace v√Ωukov√© cesty na z√°kladƒõ anal√Ωzy dovednost√≠"""
        try:
            # Z√≠sk√°n√≠ prioritn√≠ch dovednost√≠
            priority_skills = skill_analysis["priority_skills"]
            
            # Generov√°n√≠ optimalizovan√© sekvence sc√©n√°≈ô≈Ø
            training_sequence = await self._generate_training_sequence(user, priority_skills)
            
            # Nastaven√≠ miln√≠k≈Ø a checkpoint≈Ø
            milestones = self._define_milestones(user, training_sequence)
            
            # Odhad celkov√© doby v√Ωcviku
            total_duration = self._estimate_total_duration(training_sequence)
            
            optimized_path = {
                "user_id": user.user_id,
                "training_sequence": training_sequence,
                "milestones": milestones,
                "total_duration_hours": total_duration,
                "adaptive_checkpoints": self._define_adaptive_checkpoints(training_sequence),
                "success_metrics": self._define_success_metrics(priority_skills)
            }
            
            logger.info(f"Optimalizov√°na v√Ωukov√° cesta pro u≈æivatele {user.name}")
            return optimized_path
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi optimalizaci cesty: {e}")
            raise
    
    async def _generate_training_sequence(self, user: TrainingUser, 
                                        priority_skills: List[str]) -> List[Dict]:
        """Generov√°n√≠ sekvence tr√©ningov√Ωch sc√©n√°≈ô≈Ø"""
        sequence = []
        current_difficulty = 0.3  # Zaƒç√°tek s ni≈æ≈°√≠ obt√≠≈ænost√≠
        
        for skill in priority_skills:
            # Postupn√© zvy≈°ov√°n√≠ obt√≠≈ænosti
            skill_scenarios = []
            for i in range(3):  # 3 sc√©n√°≈ôe na dovednost
                scenario_type = self._map_skill_to_scenario_type(skill)
                scenario = await self.scenario_agent.generate_scenario(user, scenario_type)
                scenario.difficulty = min(current_difficulty + i * 0.2, 1.0)
                
                skill_scenarios.append({
                    "scenario": scenario,
                    "target_skill": skill,
                    "order": len(sequence) + 1
                })
            
            sequence.extend(skill_scenarios)
            current_difficulty = min(current_difficulty + 0.15, 0.9)
        
        return sequence
    
    def _map_skill_to_scenario_type(self, skill: str) -> ScenarioType:
        """Mapov√°n√≠ dovednosti na typ sc√©n√°≈ôe"""
        skill_mapping = {
            "bezpeƒçnost": ScenarioType.SAFETY,
            "komunikace": ScenarioType.COMMUNICATION,
            "technick√©_dovednosti": ScenarioType.TECHNICAL,
            "krizov√©_≈ôe≈°en√≠": ScenarioType.EMERGENCY
        }
        return skill_mapping.get(skill, ScenarioType.TECHNICAL)
    
    def _define_milestones(self, user: TrainingUser, sequence: List[Dict]) -> List[Dict]:
        """Definov√°n√≠ miln√≠k≈Ø ve v√Ωuce"""
        milestones = []
        for i in range(0, len(sequence), 3):  # Miln√≠k ka≈æd√© 3 sc√©n√°≈ôe
            milestones.append({
                "milestone_id": i // 3 + 1,
                "scenarios_completed": i + 3,
                "required_accuracy": 0.7 + (i // 3) * 0.1,
                "skills_to_assess": [seq["target_skill"] for seq in sequence[i:i+3]]
            })
        return milestones
    
    def _estimate_total_duration(self, sequence: List[Dict]) -> float:
        """Odhad celkov√© doby v√Ωcviku"""
        total_minutes = sum(seq["scenario"].duration_minutes for seq in sequence)
        return total_minutes / 60  # P≈ôevod na hodiny
    
    def _define_adaptive_checkpoints(self, sequence: List[Dict]) -> List[Dict]:
        """Definov√°n√≠ adaptivn√≠ch checkpoint≈Ø"""
        checkpoints = []
        for i, seq in enumerate(sequence):
            if i % 2 == 1:  # Checkpoint ka≈æd√Ω druh√Ω sc√©n√°≈ô
                checkpoints.append({
                    "checkpoint_id": i // 2 + 1,
                    "after_scenario": seq["scenario"].scenario_id,
                    "adaptation_criteria": {
                        "min_accuracy": 0.6,
                        "max_stress": 0.7,
                        "min_decision_quality": 0.5
                    }
                })
        return checkpoints
    
    def _define_success_metrics(self, priority_skills: List[str]) -> Dict:
        """Definov√°n√≠ metrik √∫spƒõchu"""
        return {
            "overall_accuracy": 0.8,
            "skill_improvement": {skill: 0.3 for skill in priority_skills},
            "completion_rate": 0.9,
            "consistency_score": 0.7
        }

class CertificationManagementAgent:
    """Agent pro spr√°vu certifikac√≠"""
    
    def __init__(self, database: VRTrainingDatabase):
        self.database = database
        
    async def evaluate_certification(self, user: TrainingUser, 
                                   completed_path: Dict) -> Dict[str, Any]:
        """Vyhodnocen√≠ certifikace na z√°kladƒõ dokonƒçen√© cesty"""
        try:
            # Anal√Ωza celkov√©ho v√Ωkonu
            overall_performance = self._calculate_overall_performance(user, completed_path)
            
            # Kontrola splnƒõn√≠ krit√©ri√≠
            certification_criteria = self._check_certification_criteria(overall_performance)
            
            # Generov√°n√≠ certifik√°tu
            if certification_criteria["passed"]:
                certificate = await self._generate_certificate(user, overall_performance)
            else:
                certificate = None
            
            # Doporuƒçen√≠ pro dal≈°√≠ kroky
            next_steps = self._recommend_next_steps(user, certification_criteria, overall_performance)
            
            evaluation = {
                "user_id": user.user_id,
                "evaluation_date": datetime.now().isoformat(),
                "overall_performance": overall_performance,
                "certification_criteria": certification_criteria,
                "certificate": certificate,
                "next_steps": next_steps,
                "validity_period_months": 12 if certificate else 0
            }
            
            logger.info(f"Vyhodnocena certifikace pro u≈æivatele {user.name}")
            return evaluation
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi vyhodnocen√≠ certifikace: {e}")
            raise
    
    def _calculate_overall_performance(self, user: TrainingUser, completed_path: Dict) -> Dict:
        """V√Ωpoƒçet celkov√©ho v√Ωkonu"""
        # Simulace v√Ωpoƒçtu na z√°kladƒõ dokonƒçen√Ωch sc√©n√°≈ô≈Ø
        scenarios_completed = len(completed_path.get("training_sequence", []))
        avg_accuracy = 0.75  # Simulovan√° hodnota
        consistency = 0.8    # Simulovan√° hodnota
        
        return {
            "scenarios_completed": scenarios_completed,
            "average_accuracy": avg_accuracy,
            "consistency_score": consistency,
            "skill_improvements": self._calculate_skill_improvements(user),
            "overall_score": (avg_accuracy + consistency) / 2
        }
    
    def _calculate_skill_improvements(self, user: TrainingUser) -> Dict[str, float]:
        """V√Ωpoƒçet zlep≈°en√≠ dovednost√≠"""
        # Simulace zlep≈°en√≠ na z√°kladƒõ absolvovan√©ho tr√©ninku
        improvements = {}
        for skill in user.target_skills:
            # P≈ôedpokl√°dan√© zlep≈°en√≠ na z√°kladƒõ tr√©ninku
            improvement = min(0.4, np.random.uniform(0.1, 0.4))
            improvements[skill] = improvement
        return improvements
    
    def _check_certification_criteria(self, performance: Dict) -> Dict:
        """Kontrola krit√©ri√≠ pro certifikaci"""
        criteria = {
            "min_accuracy": 0.7,
            "min_consistency": 0.6,
            "min_scenarios": 5,
            "min_overall_score": 0.7
        }
        
        results = {}
        results["accuracy_passed"] = performance["average_accuracy"] >= criteria["min_accuracy"]
        results["consistency_passed"] = performance["consistency_score"] >= criteria["min_consistency"]
        results["scenarios_passed"] = performance["scenarios_completed"] >= criteria["min_scenarios"]
        results["overall_passed"] = performance["overall_score"] >= criteria["min_overall_score"]
        
        results["passed"] = all([
            results["accuracy_passed"],
            results["consistency_passed"], 
            results["scenarios_passed"],
            results["overall_passed"]
        ])
        
        return results
    
    async def _generate_certificate(self, user: TrainingUser, performance: Dict) -> Dict:
        """Generov√°n√≠ certifik√°tu"""
        certificate_id = str(uuid.uuid4())
        
        certificate = {
            "certificate_id": certificate_id,
            "user_id": user.user_id,
            "user_name": user.name,
            "certification_level": self._determine_certification_level(performance),
            "issue_date": datetime.now().isoformat(),
            "expiry_date": (datetime.now() + timedelta(days=365)).isoformat(),
            "competencies_certified": list(user.target_skills.keys()),
            "performance_summary": {
                "overall_score": performance["overall_score"],
                "scenarios_completed": performance["scenarios_completed"],
                "key_strengths": self._identify_strengths(performance)
            },
            "issuing_authority": "VR Training Certification Board",
            "verification_code": f"VRT-{certificate_id[:8].upper()}"
        }
        
        return certificate
    
    def _determine_certification_level(self, performance: Dict) -> str:
        """Urƒçen√≠ √∫rovnƒõ certifikace"""
        score = performance["overall_score"]
        if score >= 0.9:
            return "Expert"
        elif score >= 0.8:
            return "Pokroƒçil√Ω"
        elif score >= 0.7:
            return "St≈ôedn√≠"
        else:
            return "Z√°kladn√≠"
    
    def _identify_strengths(self, performance: Dict) -> List[str]:
        """Identifikace siln√Ωch str√°nek"""
        strengths = []
        if performance["average_accuracy"] >= 0.85:
            strengths.append("Vysok√° p≈ôesnost")
        if performance["consistency_score"] >= 0.85:
            strengths.append("Konzistentn√≠ v√Ωkon")
        
        # Anal√Ωza zlep≈°en√≠ dovednost√≠
        improvements = performance.get("skill_improvements", {})
        for skill, improvement in improvements.items():
            if improvement >= 0.3:
                strengths.append(f"V√Ωrazn√© zlep≈°en√≠ v {skill}")
        
        return strengths
    
    def _recommend_next_steps(self, user: TrainingUser, criteria: Dict, performance: Dict) -> List[str]:
        """Doporuƒçen√≠ dal≈°√≠ch krok≈Ø"""
        recommendations = []
        
        if not criteria["passed"]:
            if not criteria["accuracy_passed"]:
                recommendations.append("Zamƒõ≈ôte se na zlep≈°en√≠ p≈ôesnosti prost≈ôednictv√≠m opakovan√©ho tr√©ninku")
            if not criteria["consistency_passed"]:
                recommendations.append("Pracujte na konzistenci v√Ωkonu")
            if not criteria["scenarios_passed"]:
                recommendations.append("Dokonƒçete zb√Ωvaj√≠c√≠ povinn√© sc√©n√°≈ôe")
        else:
            recommendations.extend([
                "Zva≈æte pokroƒçil√© certifikaƒçn√≠ kurzy",
                "Sta≈àte se mentorem pro nov√© u≈æivatele",
                "Prozkoumejte specializovan√© v√Ωcvikov√© moduly"
            ])
        
        return recommendations

class VRTrainingCoordinator:
    """Hlavn√≠ koordin√°tor VR tr√©ningov√©ho syst√©mu"""
    
    def __init__(self):
        # Inicializace datab√°ze a agent≈Ø
        self.database = VRTrainingDatabase()
        
        # Nastaven√≠ LLM pro generov√°n√≠ sc√©n√°≈ô≈Ø
        llm = OpenAI(temperature=0.7, max_tokens=1000)
        scenario_prompt = PromptTemplate(
            input_variables=["scenario_type", "skill_gaps", "user_level", "completed_scenarios"],
            template="""
            Vytvo≈ô JSON popis VR tr√©ningov√©ho sc√©n√°≈ôe:
            Typ sc√©n√°≈ôe: {scenario_type}
            Mezery v dovednostech: {skill_gaps}
            √örove≈à u≈æivatele: {user_level}
            Dokonƒçen√© sc√©n√°≈ôe: {completed_scenarios}
            
            Po≈æadovan√Ω form√°t JSON:
            {{
                "name": "n√°zev sc√©n√°≈ôe",
                "description": "detailn√≠ popis",
                "difficulty": 0.7,
                "required_skills": {{"skill1": 0.6, "skill2": 0.8}},
                "duration": 30,
                "objectives": ["c√≠l1", "c√≠l2"]
            }}
            """
        )
        llm_chain = LLMChain(llm=llm, prompt=scenario_prompt)
        
        # Inicializace agent≈Ø
        self.scenario_agent = ScenarioGeneratorAgent(llm_chain, self.database)
        self.performance_agent = PerformanceAssessmentAgent(self.database)
        self.skill_analysis_agent = SkillGapAnalysisAgent(self.database)
        self.path_optimization_agent = TrainingPathOptimizationAgent(self.database, self.scenario_agent)
        self.certification_agent = CertificationManagementAgent(self.database)
        
        logger.info("VR Training Coordinator inicializov√°n")
    
    async def process_user_training(self, user: TrainingUser) -> Dict[str, Any]:
        """Kompletn√≠ zpracov√°n√≠ u≈æivatelsk√©ho tr√©ninku"""
        try:
            logger.info(f"Zaƒç√≠n√°m zpracov√°n√≠ tr√©ninku pro u≈æivatele {user.name}")
            
            # 1. Anal√Ωza mezer v dovednostech
            skill_analysis = await self.skill_analysis_agent.analyze_skill_gaps(user)
            
            # 2. Optimalizace v√Ωukov√© cesty
            training_path = await self.path_optimization_agent.optimize_training_path(user, skill_analysis)
            
            # 3. Simulace pr≈Øbƒõhu tr√©ninku
            training_results = await self._simulate_training_execution(user, training_path)
            
            # 4. Vyhodnocen√≠ certifikace
            certification_result = await self.certification_agent.evaluate_certification(user, training_results)
            
            # Ulo≈æen√≠ aktualizovan√©ho u≈æivatele
            self.database.store_user(user)
            
            complete_result = {
                "user_id": user.user_id,
                "skill_analysis": skill_analysis,
                "training_path": training_path,
                "training_results": training_results,
                "certification": certification_result,
                "processing_completed": datetime.now().isoformat()
            }
            
            logger.info(f"Dokonƒçeno zpracov√°n√≠ tr√©ninku pro u≈æivatele {user.name}")
            return complete_result
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi zpracov√°n√≠ tr√©ninku: {e}")
            raise
    
    async def _simulate_training_execution(self, user: TrainingUser, training_path: Dict) -> Dict:
        """Simulace proveden√≠ tr√©ninku"""
        results = {
            "completed_scenarios": [],
            "performance_metrics": [],
            "adaptations_made": []
        }
        
        for sequence_item in training_path["training_sequence"]:
            scenario = sequence_item["scenario"]
            
            # Simulace VR tr√©ninku
            vr_data = self._simulate_vr_session(scenario)
            
            # Hodnocen√≠ v√Ωkonu
            performance = await self.performance_agent.assess_performance(
                user.user_id, scenario.scenario_id, vr_data
            )
            
            results["completed_scenarios"].append(scenario.scenario_id)
            results["performance_metrics"].append(performance)
            
            # Kontrola adaptivn√≠ch checkpoint≈Ø
            if self._should_adapt_path(performance):
                adaptation = await self._adapt_training_path(user, performance)
                results["adaptations_made"].append(adaptation)
        
        return results
    
    def _simulate_vr_session(self, scenario: TrainingScenario) -> Dict[str, Any]:
        """Simulace VR tr√©ningov√© relace"""
        # Generov√°n√≠ simulovan√Ωch dat z VR prost≈ôed√≠
        return {
            "completion_time": np.random.uniform(scenario.duration_minutes * 0.8, scenario.duration_minutes * 1.2),
            "actions": [{"action": f"action_{i}", "correct": np.random.choice([True, False], p=[0.8, 0.2])} 
                       for i in range(np.random.randint(5, 15))],
            "errors": np.random.randint(0, 3),
            "hesitation_time": np.random.uniform(0, 5),
            "movement_variability": np.random.uniform(0, 1)
        }
    
    def _should_adapt_path(self, performance: PerformanceMetrics) -> bool:
        """Kontrola pot≈ôeby adaptace cesty"""
        return (performance.accuracy_score < 0.5 or 
                performance.stress_level > 0.8 or 
                performance.decision_quality < 0.4)
    
    async def _adapt_training_path(self, user: TrainingUser, performance: PerformanceMetrics) -> Dict:
        """Adaptace v√Ωukov√© cesty na z√°kladƒõ v√Ωkonu"""
        adaptation = {
            "adaptation_id": str(uuid.uuid4()),
            "reason": "N√≠zk√Ω v√Ωkon vy≈æaduje √∫pravu obt√≠≈ænosti",
            "changes": ["Sn√≠≈æen√≠ obt√≠≈ænosti n√°sleduj√≠c√≠ch sc√©n√°≈ô≈Ø", "P≈ôid√°n√≠ dopl≈àkov√Ωch cviƒçen√≠"]
        }
        return adaptation

# FastAPI aplikace pro REST API
app = FastAPI(title="VR Training Coordinator API", version="1.0.0")

class UserRequest(BaseModel):
    name: str
    current_skills: Dict[str, float]
    target_skills: Dict[str, float]
    certification_level: str = "zaƒç√°teƒçn√≠k"

class TrainingRequest(BaseModel):
    user_id: str

# Glob√°ln√≠ instance koordin√°tora
coordinator = VRTrainingCoordinator()

@app.post("/users/create")
async def create_user(user_request: UserRequest):
    """Vytvo≈ôen√≠ nov√©ho u≈æivatele"""
    user = TrainingUser(
        user_id=str(uuid.uuid4()),
        name=user_request.name,
        current_skills=user_request.current_skills,
        target_skills=user_request.target_skills,
        completed_scenarios=[],
        performance_history=[],
        certification_level=user_request.certification_level
    )
    
    coordinator.database.store_user(user)
    return {"user_id": user.user_id, "message": "U≈æivatel vytvo≈ôen"}

@app.post("/training/start")
async def start_training(training_request: TrainingRequest):
    """Spu≈°tƒõn√≠ tr√©ninku pro u≈æivatele"""
    try:
        # Naƒçten√≠ u≈æivatele z datab√°ze (simulace)
        user = TrainingUser(
            user_id=training_request.user_id,
            name="Test User",
            current_skills={"bezpeƒçnost": 0.3, "komunikace": 0.5},
            target_skills={"bezpeƒçnost": 0.8, "komunikace": 0.9},
            completed_scenarios=[],
            performance_history=[],
            certification_level="zaƒç√°teƒçn√≠k"
        )
        
        result = await coordinator.process_user_training(user)
        return result
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Kontrola stavu syst√©mu"""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

# Hlavn√≠ funkce pro spu≈°tƒõn√≠
async def main():
    """Hlavn√≠ demonstraƒçn√≠ funkce"""
    print("üöÄ Spou≈°t√≠m VR Training Simulation Coordinator...")
    
    # Vytvo≈ôen√≠ testovac√≠ho u≈æivatele
    test_user = TrainingUser(
        user_id="user_001",
        name="Jan Nov√°k",
        current_skills={
            "bezpeƒçnost": 0.4,
            "komunikace": 0.3,
            "technick√©_dovednosti": 0.5,
            "krizov√©_≈ôe≈°en√≠": 0.2
        },
        target_skills={
            "bezpeƒçnost": 0.9,
            "komunikace": 0.8,
            "technick√©_dovednosti": 0.85,
            "krizov√©_≈ôe≈°en√≠": 0.7
        },
        completed_scenarios=[],
        performance_history=[],
        certification_level="zaƒç√°teƒçn√≠k"
    )
    
    # Zpracov√°n√≠ kompletn√≠ho tr√©ninku
    result = await coordinator.process_user_training(test_user)
    
    print("\nüìä V√Ωsledky zpracov√°n√≠:")
    print(f"U≈æivatel: {test_user.name}")
    print(f"Analyzovan√© mezery: {len(result['skill_analysis']['skill_gaps'])}")
    print(f"Navr≈æen√© sc√©n√°≈ôe: {len(result['training_path']['training_sequence'])}")
    print(f"Dokonƒçen√© sc√©n√°≈ôe: {len(result['training_results']['completed_scenarios'])}")
    print(f"Certifikace udƒõlena: {'Ano' if result['certification']['certificate'] else 'Ne'}")
    
    if result['certification']['certificate']:
        cert = result['certification']['certificate']
        print(f"√örove≈à certifikace: {cert['certification_level']}")
        print(f"Celkov√© sk√≥re: {cert['performance_summary']['overall_score']:.2f}")

if __name__ == "__main__":
    # Spu≈°tƒõn√≠ demonstrace
    asyncio.run(main())
    
    # Spu≈°tƒõn√≠ FastAPI serveru (odkomentujte pro API server)
    # uvicorn.run(app, host="0.0.0.0", port=8000)
````

### Uk√°zkov√© data pro testov√°n√≠

````python
from datetime import datetime
from vr_training_coordinator import TrainingUser, TrainingScenario, ScenarioType

def create_sample_users():
    """Vytvo≈ôen√≠ uk√°zkov√Ωch u≈æivatel≈Ø pro testov√°n√≠"""
    
    users = [
        TrainingUser(
            user_id="user_healthcare_001",
            name="Dr. Anna Svobodov√°",
            current_skills={
                "l√©ka≈ôsk√©_postupy": 0.7,
                "komunikace_s_pacienty": 0.6,
                "nouzov√©_situace": 0.4,
                "pou≈æit√≠_p≈ô√≠stroj≈Ø": 0.8
            },
            target_skills={
                "l√©ka≈ôsk√©_postupy": 0.95,
                "komunikace_s_pacienty": 0.9,
                "nouzov√©_situace": 0.85,
                "pou≈æit√≠_p≈ô√≠stroj≈Ø": 0.9
            },
            completed_scenarios=[],
            performance_history=[],
            certification_level="pokroƒçil√Ω"
        ),
        TrainingUser(
            user_id="user_safety_001", 
            name="Ing. Pavel Novotn√Ω",
            current_skills={
                "bezpeƒçnostn√≠_protokoly": 0.5,
                "≈ô√≠zen√≠_rizik": 0.3,
                "t√Ωmov√°_komunikace": 0.6,
                "technick√°_anal√Ωza": 0.7
            },
            target_skills={
                "bezpeƒçnostn√≠_protokoly": 0.9,
                "≈ô√≠zen√≠_rizik": 0.8,
                "t√Ωmov√°_komunikace": 0.85,
                "technick√°_anal√Ωza": 0.9
            },
            completed_scenarios=[],
            performance_history=[],
            certification_level="zaƒç√°teƒçn√≠k"
        )
    ]
    
    return users

def create_sample_scenarios():
    """Vytvo≈ôen√≠ uk√°zkov√Ωch sc√©n√°≈ô≈Ø"""
    
    scenarios = [
        TrainingScenario(
            scenario_id="scenario_medical_emergency",
            name="Resuscitace v nemocniƒçn√≠m prost≈ôed√≠",
            description="VR simulace kardiopulmon√°ln√≠ resuscitace s pokroƒçil√Ωmi p≈ô√≠stroji",
            type=ScenarioType.EMERGENCY,
            difficulty=0.8,
            required_skills={
                "l√©ka≈ôsk√©_postupy": 0.7,
                "nouzov√©_situace": 0.8,
                "pou≈æit√≠_p≈ô√≠stroj≈Ø": 0.6
            },
            duration_minutes=25,
            learning_objectives=[
                "Rychl√© rozpozn√°n√≠ kardiopulmon√°ln√≠ z√°stavy",
                "Spr√°vn√© proveden√≠ kompres√≠ hrudn√≠ku",
                "Koordinace t√Ωmu bƒõhem resuscitace"
            ]
        ),
        TrainingScenario(
            scenario_id="scenario_industrial_safety",
            name="√öniku chemik√°li√≠ v tov√°rnƒõ",
            description="VR simulace pr≈Ømyslov√© hav√°rie s √∫nikem nebezpeƒçn√Ωch l√°tek",
            type=ScenarioType.SAFETY,
            difficulty=0.6,
            required_skills={
                "bezpeƒçnostn√≠_protokoly": 0.7,
                "≈ô√≠zen√≠_rizik": 0.6,
                "t√Ωmov√°_komunikace": 0.5
            },
            duration_minutes=35,
            learning_objectives=[
                "Identifikace typu √∫niku",
                "Implementace evakuaƒçn√≠ch postup≈Ø",
                "Koordinace s hasiƒçsk√Ωmi jednotkami"
            ]
        )
    ]
    
    return scenarios
````

## Shrnut√≠ projektu

Virtual Reality Training Simulation Coordinator p≈ôedstavuje pokroƒçil√Ω multi-agentn√≠ syst√©m pro automatizovan√© ≈ô√≠zen√≠ VR v√Ωcvikov√Ωch program≈Ø. Projekt demonstruje komplexn√≠ orchestraci v√≠ce AI agent≈Ø spolupracuj√≠c√≠ch na personalizaci, optimalizaci a hodnocen√≠ vzdƒõl√°vac√≠ho procesu.

### Kl√≠ƒçov√© hodnoty projektu

**Personalizace v√Ωuky**: Syst√©m automaticky p≈ôizp≈Øsobuje obsah a obt√≠≈ænost na z√°kladƒõ individu√°ln√≠ch pot≈ôeb a pokroku ka≈æd√©ho u≈æivatele.

**Objektivn√≠ hodnocen√≠**: AI-driven metriky poskytuj√≠ konzistentn√≠ a spravedliv√© vyhodnocen√≠ v√Ωkonu nap≈ô√≠ƒç r≈Øzn√Ωmi sc√©n√°≈ôi a u≈æivateli.

**Adaptivn√≠ optimalizace**: V√Ωukov√© cesty se dynamicky upravuj√≠ na z√°kladƒõ real-time dat o v√Ωkonu a engagement u≈æivatel≈Ø.

**≈†k√°lovatelnost**: Architektura umo≈æ≈àuje souƒçasn√© vzdƒõl√°v√°n√≠ tis√≠c≈Ø u≈æivatel≈Ø s udr≈æen√≠m vysok√© kvality personalizace.

**Transparentn√≠ certifikace**: Automatizovan√Ω proces vyd√°v√°n√≠ certifik√°t≈Ø na z√°kladƒõ mƒõ≈ôiteln√Ωch kompetenc√≠ zvy≈°uje d≈Øvƒõryhodnost a uzn√°n√≠.

Syst√©m nach√°z√≠ uplatnƒõn√≠ v kritick√Ωch oblastech jako zdravotnictv√≠, pr≈Ømyslov√° bezpeƒçnost, letectv√≠ a ozbrojen√© s√≠ly, kde kvalitn√≠ v√Ωcvik m≈Ø≈æe zachr√°nit ≈æivoty a p≈ôedej√≠t katastrof√°m.