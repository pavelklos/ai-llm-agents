<small>Claude Sonnet 4 **(JazykovÃ½ Partner pro UÄenÃ­ s AI-LLM RAG)**</small>
# Language Learning Conversation Partner

## 1. KlÃ­ÄovÃ© Koncepty

### RAG (Retrieval-Augmented Generation)
Architektura kombinujÃ­cÃ­ vyhledÃ¡vÃ¡nÃ­ relevantnÃ­ch informacÃ­ z databÃ¡ze znalostÃ­ s generativnÃ­ AI pro pÅ™esnÄ›jÅ¡Ã­ a kontextuÃ¡lnÄ› relevantnÃ­ odpovÄ›di.

### GramatickÃ¡ Pravidla
StrukturovanÃ¡ databÃ¡ze jazykovÃ½ch pravidel, vÃ½jimek a vzorÅ¯ pro konkrÃ©tnÃ­ cÃ­lovÃ½ jazyk s moÅ¾nostÃ­ dynamickÃ©ho vyhledÃ¡vÃ¡nÃ­.

### KulturnÃ­ Kontext
ZnalostnÃ­ bÃ¡ze kulturnÃ­ch nuancÃ­, idiomÅ¯, spoleÄenskÃ½ch konvencÃ­ a historickÃ½ch pozadÃ­ pro hlubÅ¡Ã­ porozumÄ›nÃ­ jazyka.

### PrÅ¯vodce VÃ½slovnostÃ­
FonetickÃ© reprezentace, audio vzorky a artikulaÄnÃ­ pokyny pro sprÃ¡vnou vÃ½slovnost slov a frÃ¡zÃ­.

### PamÄ›Å¥ PÅ™ekladÅ¯
DatabÃ¡ze dÅ™Ã­ve pÅ™eloÅ¾enÃ½ch frÃ¡zÃ­ a vÃ½razÅ¯ pro konzistenci a zlepÅ¡enÃ­ kvality pÅ™ekladÅ¯.

### Google Translate API
CloudovÃ¡ sluÅ¾ba pro strojovÃ½ pÅ™eklad podporujÃ­cÃ­ vÃ­ce neÅ¾ 100 jazykÅ¯ s moÅ¾nostÃ­ detekce jazyka.

### RozpoznÃ¡vÃ¡nÃ­ Å˜eÄi
Technologie pÅ™evÃ¡dÄ›jÃ­cÃ­ mluvenÃ© slovo na text pro interaktivnÃ­ konverzaÄnÃ­ cviÄenÃ­.

### SledovÃ¡nÃ­ Pokroku
SystÃ©m metrovÃ¡nÃ­ a analÃ½zy studijnÃ­ho pokroku s personalizovanÃ½mi doporuÄenÃ­mi pro zlepÅ¡enÃ­.

## 2. KomplexnÃ­ VysvÄ›tlenÃ­ Projektu

### CÃ­le Projektu
VytvoÅ™enÃ­ inteligentnÃ­ho AI asistenta pro uÄenÃ­ jazykÅ¯, kterÃ½ kombinuje pokroÄilÃ© RAG technologie s personalizovanÃ½m pÅ™Ã­stupem. SystÃ©m poskytuje kontextuÃ¡lnÃ­ konverzace, gramatickÃ© korekce, kulturnÃ­ poznatky a sledovÃ¡nÃ­ pokroku.

### VÃ½zvy
- **MultimodÃ¡lnÃ­ interakce**: Integrace textu, Å™eÄi a audio pro pÅ™irozenÃ© uÄenÃ­
- **KontextuÃ¡lnÃ­ pÅ™esnost**: ZajiÅ¡tÄ›nÃ­ kulturnÄ› a gramaticky sprÃ¡vnÃ½ch odpovÄ›dÃ­
- **Personalizace**: Adaptace na individuÃ¡lnÃ­ ÃºroveÅˆ a styl uÄenÃ­
- **Realtime zpracovÃ¡nÃ­**: RychlÃ© odpovÄ›di pro plynulou konverzaci

### Dopad
Demokratizace jazykovÃ©ho vzdÄ›lÃ¡vÃ¡nÃ­ s 24/7 dostupnostÃ­ personalizovanÃ©ho tutora, snÃ­Å¾enÃ­ bariÃ©r pro multikulturnÃ­ komunikaci a zlepÅ¡enÃ­ efektivity uÄenÃ­.

## 3. KompletnÃ­ Python Implementace

````python
import os
import json
import sqlite3
import asyncio
import logging
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import requests
import speech_recognition as sr
import pyttsx3
import chromadb
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.llms import OpenAI
from langchain.chains import RetrievalQA
from langchain.docstore.document import Document
import openai
from gtts import gTTS
import io
import pygame

# Konfigurace logovÃ¡nÃ­
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class LearningSession:
    user_id: str
    target_language: str
    native_language: str
    proficiency_level: str
    session_start: datetime
    messages: List[Dict[str, Any]]
    grammar_corrections: int = 0
    vocabulary_learned: int = 0
    pronunciation_attempts: int = 0

@dataclass
class GrammarRule:
    rule_id: str
    language: str
    category: str
    rule_text: str
    examples: List[str]
    difficulty_level: str

@dataclass
class CulturalContext:
    context_id: str
    language: str
    topic: str
    description: str
    examples: List[str]
    cultural_notes: str

class DatabaseManager:
    def __init__(self, db_path: str = "language_learning.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Inicializace SQLite databÃ¡ze"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabulka pro gramatickÃ¡ pravidla
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS grammar_rules (
                rule_id TEXT PRIMARY KEY,
                language TEXT NOT NULL,
                category TEXT NOT NULL,
                rule_text TEXT NOT NULL,
                examples TEXT NOT NULL,
                difficulty_level TEXT NOT NULL
            )
        ''')
        
        # Tabulka pro kulturnÃ­ kontext
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cultural_contexts (
                context_id TEXT PRIMARY KEY,
                language TEXT NOT NULL,
                topic TEXT NOT NULL,
                description TEXT NOT NULL,
                examples TEXT NOT NULL,
                cultural_notes TEXT NOT NULL
            )
        ''')
        
        # Tabulka pro pokrok uÅ¾ivatelÅ¯
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS user_progress (
                user_id TEXT NOT NULL,
                language TEXT NOT NULL,
                session_date TEXT NOT NULL,
                proficiency_score REAL,
                grammar_score REAL,
                vocabulary_score REAL,
                pronunciation_score REAL,
                PRIMARY KEY (user_id, language, session_date)
            )
        ''')
        
        # Tabulka pro pamÄ›Å¥ pÅ™ekladÅ¯
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS translation_memory (
                source_text TEXT NOT NULL,
                target_text TEXT NOT NULL,
                source_language TEXT NOT NULL,
                target_language TEXT NOT NULL,
                confidence REAL,
                created_at TEXT NOT NULL,
                PRIMARY KEY (source_text, source_language, target_language)
            )
        ''')
        
        conn.commit()
        conn.close()
        
        # Inicializace vzorovÃ½ch dat
        self.populate_sample_data()
    
    def populate_sample_data(self):
        """NaplnÄ›nÃ­ databÃ¡ze vzorovÃ½mi daty"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # VzorovÃ¡ gramatickÃ¡ pravidla pro angliÄtinu
        grammar_rules = [
            GrammarRule("en_present_simple", "english", "tenses", 
                       "Present Simple se pouÅ¾Ã­vÃ¡ pro pravidelnÃ© akce a obecnÃ© pravdy",
                       ["I work every day", "She speaks English", "The sun rises in the east"],
                       "beginner"),
            GrammarRule("en_past_simple", "english", "tenses",
                       "Past Simple se pouÅ¾Ã­vÃ¡ pro dokonÄenÃ© akce v minulosti",
                       ["I worked yesterday", "She visited Paris", "They finished the project"],
                       "beginner"),
            GrammarRule("en_present_perfect", "english", "tenses",
                       "Present Perfect se pouÅ¾Ã­vÃ¡ pro akce s vazbou na souÄasnost",
                       ["I have worked here for 5 years", "She has visited many countries"],
                       "intermediate")
        ]
        
        for rule in grammar_rules:
            cursor.execute('''
                INSERT OR REPLACE INTO grammar_rules VALUES (?, ?, ?, ?, ?, ?)
            ''', (rule.rule_id, rule.language, rule.category, rule.rule_text, 
                  json.dumps(rule.examples), rule.difficulty_level))
        
        # VzorovÃ© kulturnÃ­ kontexty
        cultural_contexts = [
            CulturalContext("en_greetings", "english", "greetings",
                           "Pozdravy v angliÄtinÄ› se liÅ¡Ã­ podle formÃ¡lnosti situace",
                           ["Hello", "Hi", "Good morning", "How are you?"],
                           "V obchodnÃ­m prostÅ™edÃ­ pouÅ¾Ã­vejte formÃ¡lnÃ­ pozdravy"),
            CulturalContext("en_small_talk", "english", "conversation",
                           "Small talk je dÅ¯leÅ¾itÃ¡ souÄÃ¡st anglickÃ© konverzace",
                           ["Nice weather today", "How was your weekend?"],
                           "Small talk pomÃ¡hÃ¡ vybudovat vztahy a je spoleÄensky oÄekÃ¡vÃ¡nÃ½")
        ]
        
        for context in cultural_contexts:
            cursor.execute('''
                INSERT OR REPLACE INTO cultural_contexts VALUES (?, ?, ?, ?, ?, ?)
            ''', (context.context_id, context.language, context.topic, 
                  context.description, json.dumps(context.examples), context.cultural_notes))
        
        conn.commit()
        conn.close()

class GoogleTranslateAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://translation.googleapis.com/language/translate/v2"
    
    def translate_text(self, text: str, target_language: str, source_language: str = None) -> Dict[str, Any]:
        """PÅ™eklad textu pomocÃ­ Google Translate API"""
        try:
            params = {
                'key': self.api_key,
                'q': text,
                'target': target_language
            }
            if source_language:
                params['source'] = source_language
            
            response = requests.post(self.base_url, params=params)
            response.raise_for_status()
            
            result = response.json()
            return {
                'translated_text': result['data']['translations'][0]['translatedText'],
                'detected_language': result['data']['translations'][0].get('detectedSourceLanguage'),
                'confidence': 0.9  # Google API nevracÃ­ confidence score
            }
        except Exception as e:
            logger.error(f"Chyba pÅ™i pÅ™ekladu: {e}")
            return {'translated_text': text, 'detected_language': None, 'confidence': 0.0}

class SpeechManager:
    def __init__(self):
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        self.tts_engine = pyttsx3.init()
        pygame.mixer.init()
    
    def listen_and_recognize(self, language: str = "en-US") -> Optional[str]:
        """RozpoznÃ¡nÃ­ Å™eÄi z mikrofonu"""
        try:
            with self.microphone as source:
                logger.info("NaslouchÃ¡m...")
                self.recognizer.adjust_for_ambient_noise(source)
                audio = self.recognizer.listen(source, timeout=10, phrase_time_limit=5)
            
            logger.info("RozpoznÃ¡vÃ¡m Å™eÄ...")
            text = self.recognizer.recognize_google(audio, language=language)
            return text
        except sr.RequestError as e:
            logger.error(f"Chyba API rozpoznÃ¡vÃ¡nÃ­ Å™eÄi: {e}")
            return None
        except sr.UnknownValueError:
            logger.warning("NepodaÅ™ilo se rozpoznat Å™eÄ")
            return None
        except Exception as e:
            logger.error(f"NeoÄekÃ¡vanÃ¡ chyba pÅ™i rozpoznÃ¡vÃ¡nÃ­ Å™eÄi: {e}")
            return None
    
    def text_to_speech(self, text: str, language: str = "en") -> bool:
        """PÅ™evod textu na Å™eÄ"""
        try:
            tts = gTTS(text=text, lang=language, slow=False)
            audio_buffer = io.BytesIO()
            tts.write_to_fp(audio_buffer)
            audio_buffer.seek(0)
            
            pygame.mixer.music.load(audio_buffer)
            pygame.mixer.music.play()
            
            while pygame.mixer.music.get_busy():
                pygame.time.wait(100)
            
            return True
        except Exception as e:
            logger.error(f"Chyba pÅ™i pÅ™evodu textu na Å™eÄ: {e}")
            return False

class LanguageLearningRAG:
    def __init__(self, openai_api_key: str, google_translate_api_key: str):
        self.openai_api_key = openai_api_key
        self.google_translate_api = GoogleTranslateAPI(google_translate_api_key)
        self.db_manager = DatabaseManager()
        self.speech_manager = SpeechManager()
        
        # Inicializace RAG komponenty
        self.embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)
        self.llm = OpenAI(openai_api_key=openai_api_key, temperature=0.7)
        
        # Inicializace ChromaDB
        self.chroma_client = chromadb.Client()
        try:
            self.chroma_client.delete_collection("language_knowledge")
        except:
            pass
        self.knowledge_collection = self.chroma_client.create_collection("language_knowledge")
        
        self.setup_knowledge_base()
        
        # AktivnÃ­ uÄebnÃ­ session
        self.current_session: Optional[LearningSession] = None
    
    def setup_knowledge_base(self):
        """NastavenÃ­ znalostnÃ­ bÃ¡ze pro RAG"""
        # NaÄtenÃ­ gramatickÃ½ch pravidel a kulturnÃ­ch kontextÅ¯ z databÃ¡ze
        conn = sqlite3.connect(self.db_manager.db_path)
        cursor = conn.cursor()
        
        # NaÄtenÃ­ gramatickÃ½ch pravidel
        cursor.execute("SELECT * FROM grammar_rules")
        grammar_rules = cursor.fetchall()
        
        # NaÄtenÃ­ kulturnÃ­ch kontextÅ¯
        cursor.execute("SELECT * FROM cultural_contexts")
        cultural_contexts = cursor.fetchall()
        
        conn.close()
        
        # PÅ™Ã­prava dokumentÅ¯ pro indexaci
        documents = []
        metadatas = []
        ids = []
        
        for rule in grammar_rules:
            doc_text = f"GramatickÃ© pravidlo: {rule[3]} PÅ™Ã­klady: {rule[4]}"
            documents.append(doc_text)
            metadatas.append({
                "type": "grammar",
                "language": rule[1],
                "category": rule[2],
                "difficulty": rule[5]
            })
            ids.append(f"grammar_{rule[0]}")
        
        for context in cultural_contexts:
            doc_text = f"KulturnÃ­ kontext: {context[3]} PÅ™Ã­klady: {context[4]} PoznÃ¡mky: {context[5]}"
            documents.append(doc_text)
            metadatas.append({
                "type": "cultural",
                "language": context[1],
                "topic": context[2]
            })
            ids.append(f"cultural_{context[0]}")
        
        # Indexace dokumentÅ¯
        if documents:
            self.knowledge_collection.add(
                documents=documents,
                metadatas=metadatas,
                ids=ids
            )
        
        logger.info(f"ZnalostnÃ­ bÃ¡ze inicializovÃ¡na s {len(documents)} dokumenty")
    
    def start_learning_session(self, user_id: str, target_language: str, 
                              native_language: str, proficiency_level: str):
        """ZahÃ¡jenÃ­ novÃ© uÄebnÃ­ session"""
        self.current_session = LearningSession(
            user_id=user_id,
            target_language=target_language,
            native_language=native_language,
            proficiency_level=proficiency_level,
            session_start=datetime.now(),
            messages=[]
        )
        logger.info(f"ZahÃ¡jenÃ¡ novÃ¡ session pro uÅ¾ivatele {user_id}")
    
    def retrieve_relevant_knowledge(self, query: str, language: str, n_results: int = 3) -> List[str]:
        """VyhledÃ¡nÃ­ relevantnÃ­ch znalostÃ­ z RAG databÃ¡ze"""
        try:
            results = self.knowledge_collection.query(
                query_texts=[query],
                n_results=n_results,
                where={"language": language}
            )
            
            return results['documents'][0] if results['documents'] else []
        except Exception as e:
            logger.error(f"Chyba pÅ™i vyhledÃ¡vÃ¡nÃ­ znalostÃ­: {e}")
            return []
    
    def generate_contextual_response(self, user_message: str) -> Dict[str, Any]:
        """GenerovÃ¡nÃ­ kontextuÃ¡lnÃ­ odpovÄ›di s vyuÅ¾itÃ­m RAG"""
        if not self.current_session:
            return {"error": "Å½Ã¡dnÃ¡ aktivnÃ­ session"}
        
        try:
            # VyhledÃ¡nÃ­ relevantnÃ­ch znalostÃ­
            relevant_knowledge = self.retrieve_relevant_knowledge(
                user_message, 
                self.current_session.target_language
            )
            
            # SestavenÃ­ kontextu pro LLM
            knowledge_context = "\n".join(relevant_knowledge) if relevant_knowledge else ""
            
            prompt = f"""
            Jsi AI jazykovÃ½ tutor pro {self.current_session.target_language}.
            UÅ¾ivatel mÃ¡ ÃºroveÅˆ: {self.current_session.proficiency_level}
            
            RelevantnÃ­ znalosti:
            {knowledge_context}
            
            UÅ¾ivatelova zprÃ¡va: {user_message}
            
            Poskytni:
            1. OdpovÄ›Ä na dotaz
            2. GramatickÃ© korekce (pokud jsou potÅ™eba)
            3. KulturnÃ­ kontext (pokud je relevantnÃ­)
            4. DoporuÄenÃ­ pro zlepÅ¡enÃ­
            
            OdpovÃ­dej v ÄeÅ¡tinÄ›, ale pÅ™Ã­klady uvÃ¡dÄ›j v cÃ­lovÃ©m jazyce.
            """
            
            # GenerovÃ¡nÃ­ odpovÄ›di pomocÃ­ OpenAI
            response = openai.Completion.create(
                engine="gpt-3.5-turbo-instruct",
                prompt=prompt,
                max_tokens=500,
                temperature=0.7
            )
            
            ai_response = response.choices[0].text.strip()
            
            # AnalÃ½za a klasifikace zprÃ¡vy
            corrections_needed = self.analyze_grammar(user_message)
            new_vocabulary = self.extract_vocabulary(user_message)
            
            # Aktualizace session statistik
            if corrections_needed:
                self.current_session.grammar_corrections += 1
            if new_vocabulary:
                self.current_session.vocabulary_learned += len(new_vocabulary)
            
            # UloÅ¾enÃ­ do session historie
            self.current_session.messages.append({
                "timestamp": datetime.now().isoformat(),
                "user_message": user_message,
                "ai_response": ai_response,
                "corrections": corrections_needed,
                "new_vocabulary": new_vocabulary
            })
            
            return {
                "response": ai_response,
                "corrections": corrections_needed,
                "new_vocabulary": new_vocabulary,
                "cultural_notes": self.get_cultural_notes(user_message)
            }
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i generovÃ¡nÃ­ odpovÄ›di: {e}")
            return {"error": f"Chyba pÅ™i zpracovÃ¡nÃ­: {str(e)}"}
    
    def analyze_grammar(self, text: str) -> List[Dict[str, str]]:
        """AnalÃ½za gramatiky a nalezenÃ­ chyb"""
        # ZjednoduÅ¡enÃ¡ implementace - v reÃ¡lnÃ© aplikaci by byla komplexnÄ›jÅ¡Ã­
        corrections = []
        
        # ZÃ¡kladnÃ­ kontroly pro angliÄtinu
        if self.current_session and self.current_session.target_language == "english":
            # Kontrola sprÃ¡vnÃ©ho pouÅ¾itÃ­ "a" vs "an"
            words = text.lower().split()
            for i, word in enumerate(words[:-1]):
                if word == "a" and words[i+1][0] in "aeiou":
                    corrections.append({
                        "error": f"PouÅ¾ijte 'an' mÃ­sto 'a' pÅ™ed samohlÃ¡skou",
                        "correction": f"an {words[i+1]}"
                    })
        
        return corrections
    
    def extract_vocabulary(self, text: str) -> List[str]:
        """Extrakce novÃ½ch slov pro uÄenÃ­"""
        # ZjednoduÅ¡enÃ¡ implementace
        words = text.lower().split()
        # FiltrovÃ¡nÃ­ bÄ›Å¾nÃ½ch slov (v reÃ¡lnÃ© aplikaci by byla rozsÃ¡hlejÅ¡Ã­ databÃ¡ze)
        common_words = {"the", "a", "an", "is", "are", "was", "were", "i", "you", "he", "she", "it"}
        new_words = [word for word in words if word not in common_words and len(word) > 3]
        return new_words[:3]  # VrÃ¡tit max 3 novÃ¡ slova
    
    def get_cultural_notes(self, text: str) -> Optional[str]:
        """ZÃ­skÃ¡nÃ­ kulturnÃ­ch poznÃ¡mek relevantnÃ­ch k textu"""
        # VyhledÃ¡nÃ­ kulturnÃ­ho kontextu
        cultural_knowledge = self.retrieve_relevant_knowledge(
            f"cultural context {text}", 
            self.current_session.target_language
        )
        return cultural_knowledge[0] if cultural_knowledge else None
    
    def practice_pronunciation(self, text: str) -> Dict[str, Any]:
        """CviÄenÃ­ vÃ½slovnosti s audio zpÄ›tnou vazbou"""
        if not self.current_session:
            return {"error": "Å½Ã¡dnÃ¡ aktivnÃ­ session"}
        
        try:
            # Text-to-speech pro vzorovou vÃ½slovnost
            logger.info("PÅ™ehrÃ¡vÃ¡m vzorovou vÃ½slovnost...")
            lang_code = "en" if self.current_session.target_language == "english" else "cs"
            self.speech_manager.text_to_speech(text, lang_code)
            
            # RozpoznÃ¡nÃ­ uÅ¾ivatelovy vÃ½slovnosti
            logger.info("ÄŒekÃ¡m na vaÅ¡i vÃ½slovnost...")
            lang_recognition = "en-US" if self.current_session.target_language == "english" else "cs-CZ"
            user_speech = self.speech_manager.listen_and_recognize(lang_recognition)
            
            if user_speech:
                # PorovnÃ¡nÃ­ s pÅ¯vodnÃ­m textem
                similarity_score = self.calculate_pronunciation_similarity(text, user_speech)
                
                self.current_session.pronunciation_attempts += 1
                
                return {
                    "original_text": text,
                    "recognized_speech": user_speech,
                    "similarity_score": similarity_score,
                    "feedback": self.generate_pronunciation_feedback(similarity_score)
                }
            else:
                return {"error": "NepodaÅ™ilo se rozpoznat vaÅ¡i vÃ½slovnost"}
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i cviÄenÃ­ vÃ½slovnosti: {e}")
            return {"error": f"Chyba pÅ™i zpracovÃ¡nÃ­ audio: {str(e)}"}
    
    def calculate_pronunciation_similarity(self, original: str, recognized: str) -> float:
        """VÃ½poÄet podobnosti vÃ½slovnosti"""
        # ZjednoduÅ¡enÃ¡ metrika - v reÃ¡lnÃ© aplikaci by byla sofistikovanÄ›jÅ¡Ã­
        original_words = original.lower().split()
        recognized_words = recognized.lower().split()
        
        if not original_words or not recognized_words:
            return 0.0
        
        matches = sum(1 for word in original_words if word in recognized_words)
        return matches / max(len(original_words), len(recognized_words))
    
    def generate_pronunciation_feedback(self, similarity_score: float) -> str:
        """GenerovÃ¡nÃ­ zpÄ›tnÃ© vazby pro vÃ½slovnost"""
        if similarity_score >= 0.9:
            return "VÃ½bornÄ›! VaÅ¡e vÃ½slovnost je velmi pÅ™esnÃ¡."
        elif similarity_score >= 0.7:
            return "DobÅ™e! MalÃ© Ãºpravy by mohly zlepÅ¡it vaÅ¡i vÃ½slovnost."
        elif similarity_score >= 0.5:
            return "SluÅ¡nÃ©! PokraÄujte v cviÄenÃ­ pro zlepÅ¡enÃ­."
        else:
            return "PotÅ™ebujte vÃ­ce cviÄenÃ­. Zkuste mluvit pomaleji a jasnÄ›ji."
    
    def get_progress_report(self) -> Dict[str, Any]:
        """GenerovÃ¡nÃ­ reportu pokroku"""
        if not self.current_session:
            return {"error": "Å½Ã¡dnÃ¡ aktivnÃ­ session"}
        
        session_duration = (datetime.now() - self.current_session.session_start).total_seconds() / 60
        
        # VÃ½poÄet skÃ³re
        grammar_score = max(0, 100 - (self.current_session.grammar_corrections * 10))
        vocabulary_score = min(100, self.current_session.vocabulary_learned * 20)
        pronunciation_score = 85 if self.current_session.pronunciation_attempts > 0 else 0
        
        overall_score = (grammar_score + vocabulary_score + pronunciation_score) / 3
        
        # UloÅ¾enÃ­ pokroku do databÃ¡ze
        self.save_progress(overall_score, grammar_score, vocabulary_score, pronunciation_score)
        
        return {
            "session_duration_minutes": round(session_duration, 1),
            "messages_exchanged": len(self.current_session.messages),
            "grammar_corrections": self.current_session.grammar_corrections,
            "vocabulary_learned": self.current_session.vocabulary_learned,
            "pronunciation_attempts": self.current_session.pronunciation_attempts,
            "scores": {
                "overall": round(overall_score, 1),
                "grammar": grammar_score,
                "vocabulary": vocabulary_score,
                "pronunciation": pronunciation_score
            },
            "recommendations": self.generate_recommendations(grammar_score, vocabulary_score, pronunciation_score)
        }
    
    def save_progress(self, overall_score: float, grammar_score: float, 
                     vocabulary_score: float, pronunciation_score: float):
        """UloÅ¾enÃ­ pokroku do databÃ¡ze"""
        conn = sqlite3.connect(self.db_manager.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO user_progress VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            self.current_session.user_id,
            self.current_session.target_language,
            datetime.now().strftime("%Y-%m-%d"),
            overall_score,
            grammar_score,
            vocabulary_score,
            pronunciation_score
        ))
        
        conn.commit()
        conn.close()
    
    def generate_recommendations(self, grammar_score: float, vocabulary_score: float, 
                               pronunciation_score: float) -> List[str]:
        """GenerovÃ¡nÃ­ personalizovanÃ½ch doporuÄenÃ­"""
        recommendations = []
        
        if grammar_score < 70:
            recommendations.append("ZamÄ›Å™te se na gramatickÃ¡ cviÄenÃ­ a pravidla")
        if vocabulary_score < 70:
            recommendations.append("RozÅ¡iÅ™te svou slovnÃ­ zÃ¡sobu ÄtenÃ­m a konverzacÃ­")
        if pronunciation_score < 70:
            recommendations.append("VÃ­ce cviÄte vÃ½slovnost s audio materiÃ¡ly")
        
        if not recommendations:
            recommendations.append("VÃ½bornÃ½ pokrok! PokraÄujte v pravidelnÃ©m cviÄenÃ­")
        
        return recommendations

# HlavnÃ­ aplikaÄnÃ­ tÅ™Ã­da
class LanguageLearningApp:
    def __init__(self, openai_api_key: str, google_translate_api_key: str):
        self.rag_system = LanguageLearningRAG(openai_api_key, google_translate_api_key)
        self.running = False
    
    async def run_interactive_session(self):
        """SpuÅ¡tÄ›nÃ­ interaktivnÃ­ session"""
        print("=== AI JazykovÃ½ Partner ===")
        print("VÃ­tejte v pokroÄilÃ©m systÃ©mu pro uÄenÃ­ jazykÅ¯!")
        
        # Inicializace session
        user_id = input("Zadejte vaÅ¡e uÅ¾ivatelskÃ© ID: ")
        target_language = input("CÃ­lovÃ½ jazyk (english/spanish/french): ")
        native_language = input("VÃ¡Å¡ rodnÃ½ jazyk (czech): ")
        proficiency_level = input("VaÅ¡e ÃºroveÅˆ (beginner/intermediate/advanced): ")
        
        self.rag_system.start_learning_session(user_id, target_language, native_language, proficiency_level)
        
        print(f"\nğŸ“ Session zahÃ¡jena! UÄÃ­te se {target_language}")
        print("PÅ™Ã­kazy: 'quit' - ukonÄit, 'pronunciation' - cviÄit vÃ½slovnost, 'progress' - zobrazit pokrok")
        
        self.running = True
        
        while self.running:
            try:
                user_input = input("\nğŸ’¬ Vy: ").strip()
                
                if user_input.lower() == 'quit':
                    await self.handle_quit()
                    break
                elif user_input.lower() == 'pronunciation':
                    await self.handle_pronunciation_practice()
                elif user_input.lower() == 'progress':
                    await self.handle_progress_report()
                elif user_input:
                    await self.handle_conversation(user_input)
                
            except KeyboardInterrupt:
                await self.handle_quit()
                break
            except Exception as e:
                print(f"âŒ Chyba: {e}")
    
    async def handle_conversation(self, user_message: str):
        """ZpracovÃ¡nÃ­ konverzaÄnÃ­ zprÃ¡vy"""
        print("ğŸ¤– AI: ZpracovÃ¡vÃ¡m vaÅ¡i zprÃ¡vu...")
        
        response = self.rag_system.generate_contextual_response(user_message)
        
        if "error" in response:
            print(f"âŒ {response['error']}")
            return
        
        print(f"ğŸ¤– AI: {response['response']}")
        
        if response.get('corrections'):
            print("\nğŸ“ GramatickÃ© korekce:")
            for correction in response['corrections']:
                print(f"   â€¢ {correction['error']}: {correction['correction']}")
        
        if response.get('new_vocabulary'):
            print(f"\nğŸ“š NovÃ¡ slovÃ­Äka: {', '.join(response['new_vocabulary'])}")
        
        if response.get('cultural_notes'):
            print(f"\nğŸŒ KulturnÃ­ kontext: {response['cultural_notes']}")
    
    async def handle_pronunciation_practice(self):
        """ZpracovÃ¡nÃ­ cviÄenÃ­ vÃ½slovnosti"""
        text = input("Zadejte text pro cviÄenÃ­ vÃ½slovnosti: ").strip()
        if not text:
            print("âŒ PrÃ¡zdnÃ½ text")
            return
        
        print("ğŸ¤ SpouÅ¡tÃ­m cviÄenÃ­ vÃ½slovnosti...")
        result = self.rag_system.practice_pronunciation(text)
        
        if "error" in result:
            print(f"âŒ {result['error']}")
            return
        
        print(f"ğŸ“ PÅ¯vodnÃ­ text: {result['original_text']}")
        print(f"ğŸ¯ RozpoznanÃ½ text: {result['recognized_speech']}")
        print(f"ğŸ“Š SkÃ³re podobnosti: {result['similarity_score']:.2%}")
        print(f"ğŸ’¬ ZpÄ›tnÃ¡ vazba: {result['feedback']}")
    
    async def handle_progress_report(self):
        """ZobrazenÃ­ reportu pokroku"""
        print("ğŸ“Š Generuji report pokroku...")
        
        report = self.rag_system.get_progress_report()
        
        if "error" in report:
            print(f"âŒ {report['error']}")
            return
        
        print(f"\nğŸ“ˆ Report pokroku:")
        print(f"â±ï¸ DÃ©lka session: {report['session_duration_minutes']} minut")
        print(f"ğŸ’¬ VÃ½mÄ›na zprÃ¡v: {report['messages_exchanged']}")
        print(f"ğŸ“ GramatickÃ© korekce: {report['grammar_corrections']}")
        print(f"ğŸ“š NauÄenÃ¡ slovÃ­Äka: {report['vocabulary_learned']}")
        print(f"ğŸ¤ Pokusy o vÃ½slovnost: {report['pronunciation_attempts']}")
        
        print(f"\nğŸ¯ SkÃ³re:")
        scores = report['scores']
        print(f"   CelkovÃ©: {scores['overall']}%")
        print(f"   Gramatika: {scores['grammar']}%")
        print(f"   SlovnÃ­ zÃ¡soba: {scores['vocabulary']}%")
        print(f"   VÃ½slovnost: {scores['pronunciation']}%")
        
        print(f"\nğŸ’¡ DoporuÄenÃ­:")
        for recommendation in report['recommendations']:
            print(f"   â€¢ {recommendation}")
    
    async def handle_quit(self):
        """UkonÄenÃ­ aplikace"""
        print("\nğŸ‘‹ UkonÄujem session...")
        if self.rag_system.current_session:
            await self.handle_progress_report()
        print("DÄ›kuji za pouÅ¾itÃ­ AI JazykovÃ©ho Partnera! ğŸ“")
        self.running = False

# Funkce pro spuÅ¡tÄ›nÃ­ aplikace
async def main():
    # NastavenÃ­ API klÃ­ÄÅ¯
    openai_api_key = os.getenv("OPENAI_API_KEY", "your-openai-api-key")
    google_translate_api_key = os.getenv("GOOGLE_TRANSLATE_API_KEY", "your-google-translate-api-key")
    
    if openai_api_key == "your-openai-api-key" or google_translate_api_key == "your-google-translate-api-key":
        print("âŒ Chyba: Nastavte prosÃ­m API klÃ­Äe jako promÄ›nnÃ© prostÅ™edÃ­")
        print("   OPENAI_API_KEY=vÃ¡Å¡_openai_klÃ­Ä")
        print("   GOOGLE_TRANSLATE_API_KEY=vÃ¡Å¡_google_klÃ­Ä")
        return
    
    app = LanguageLearningApp(openai_api_key, google_translate_api_key)
    await app.run_interactive_session()

if __name__ == "__main__":
    asyncio.run(main())
````

````python
openai==0.28.1
langchain==0.0.354
chromadb==0.4.18
speechrecognition==3.10.0
pyttsx3==2.90
gtts==2.4.0
pygame==2.5.2
requests==2.31.0
sqlite3
asyncio
logging
dataclasses
datetime
json
io
````

````python
import os
import subprocess
import sys

def install_requirements():
    """Instalace poÅ¾adovanÃ½ch balÃ­ÄkÅ¯"""
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])
        print("âœ… VÅ¡echny balÃ­Äky byly ÃºspÄ›Å¡nÄ› nainstalovÃ¡ny")
    except subprocess.CalledProcessError as e:
        print(f"âŒ Chyba pÅ™i instalaci balÃ­ÄkÅ¯: {e}")

def setup_api_keys():
    """PrÅ¯vodce nastavenÃ­m API klÃ­ÄÅ¯"""
    print("ğŸ”‘ NastavenÃ­ API klÃ­ÄÅ¯")
    print("=" * 50)
    
    openai_key = input("Zadejte vÃ¡Å¡ OpenAI API klÃ­Ä: ").strip()
    google_key = input("Zadejte vÃ¡Å¡ Google Translate API klÃ­Ä: ").strip()
    
    # VytvoÅ™enÃ­ .env souboru
    with open(".env", "w") as f:
        f.write(f"OPENAI_API_KEY={openai_key}\n")
        f.write(f"GOOGLE_TRANSLATE_API_KEY={google_key}\n")
    
    print("âœ… API klÃ­Äe byly uloÅ¾eny do .env souboru")

def main():
    print("ğŸš€ NastavenÃ­ AI JazykovÃ©ho Partnera")
    print("=" * 50)
    
    print("1. Instalace zÃ¡vislostÃ­...")
    install_requirements()
    
    print("\n2. NastavenÃ­ API klÃ­ÄÅ¯...")
    setup_api_keys()
    
    print("\nâœ… NastavenÃ­ dokonÄeno!")
    print("SpusÅ¥te aplikaci pomocÃ­: python language_learning_rag.py")

if __name__ == "__main__":
    main()
````

## 4. ShrnutÃ­ Projektu

### KlÃ­ÄovÃ© Hodnoty
- **PersonalizovanÃ¡ vÃ½uka**: AdaptivnÃ­ pÅ™Ã­stup podle ÃºrovnÄ› a potÅ™eb uÅ¾ivatele
- **MultimodÃ¡lnÃ­ interakce**: Kombinace textu, Å™eÄi a audio pro pÅ™irozenÃ© uÄenÃ­
- **RAG-powered inteligence**: KontextuÃ¡lnÃ­ odpovÄ›di zaloÅ¾enÃ© na rozsÃ¡hlÃ© znalostnÃ­ bÃ¡zi
- **PokroÄilÃ© sledovÃ¡nÃ­ pokroku**: DetailnÃ­ metriky a personalizovanÃ¡ doporuÄenÃ­

### TechnologickÃ© Inovace
- VyuÅ¾itÃ­ ChromaDB pro efektivnÃ­ vektorovÃ© vyhledÃ¡vÃ¡nÃ­
- Integrace Google Translate API pro pÅ™eklady v reÃ¡lnÃ©m Äase
- Speech-to-text a text-to-speech pro interaktivnÃ­ cviÄenÃ­
- SQLite databÃ¡ze pro persistentnÃ­ uklÃ¡dÃ¡nÃ­ pokroku

### Scalabilita a RozÅ¡iÅ™itelnost
SystÃ©m je navrÅ¾en pro snadnÃ© rozÅ¡Ã­Å™enÃ­ o dalÅ¡Ã­ jazyky, pokroÄilÃ© gramatickÃ© kontroly, gamifikaÄnÃ­ prvky a integraci s dalÅ¡Ã­mi AI sluÅ¾bami.