<small>Claude Sonnet 4 **(Personalized Education Collective - Multi-Agent systÃ©m pro adaptivnÃ­ vzdÄ›lÃ¡vÃ¡nÃ­)**</small>
# Personalized Education Collective

## Key Concepts Explanation

### **Multi-Agent systÃ©my**
SystÃ©m sloÅ¾enÃ½ z vÃ­ce autonomnÃ­ch AI agentÅ¯, kteÅ™Ã­ spolupracujÃ­ na dosaÅ¾enÃ­ spoleÄnÃ©ho cÃ­le. KaÅ¾dÃ½ agent mÃ¡ specifickou roli a schopnosti, komunikuje s ostatnÃ­mi a pÅ™ispÃ­vÃ¡ k celkovÃ©mu Å™eÅ¡enÃ­.

### **AdaptivnÃ­ vzdÄ›lÃ¡vÃ¡nÃ­**
VzdÄ›lÃ¡vacÃ­ pÅ™Ã­stup, kterÃ½ se dynamicky pÅ™izpÅ¯sobuje individuÃ¡lnÃ­m potÅ™ebÃ¡m, schopnostem a uÄebnÃ­mu stylu kaÅ¾dÃ©ho studenta na zÃ¡kladÄ› kontinuÃ¡lnÃ­ho hodnocenÃ­ jeho pokroku.

### **LLM tutoÅ™i**
VirtuÃ¡lnÃ­ tutoÅ™i zaloÅ¾enÃ­ na velkÃ½ch jazykovÃ½ch modelech, kteÅ™Ã­ poskytujÃ­ personalizovanÃ© vyuÄovÃ¡nÃ­, odpovÃ­dajÃ­ na otÃ¡zky a vedou studenty skrze uÄebnÃ­ materiÃ¡l.

### **Multi-agent kurikulÃ¡rnÃ­ design**
Proces vytvÃ¡Å™enÃ­ vzdÄ›lÃ¡vacÃ­ch programÅ¯ pomocÃ­ spoluprÃ¡ce vÃ­ce AI agentÅ¯, kde kaÅ¾dÃ½ agent se specializuje na rÅ¯znÃ© aspekty (obsah, metodiku, hodnocenÃ­, personalizaci).

### **HodnocenÃ­ znalostÃ­**
SystematickÃ½ proces mÄ›Å™enÃ­ a vyhodnocovÃ¡nÃ­ studentovÃ½ch znalostÃ­, dovednostÃ­ a pokroku pomocÃ­ rÅ¯znÃ½ch metod a nÃ¡strojÅ¯.

## Comprehensive Project Explanation

**Personalized Education Collective** je pokroÄilÃ½ multi-agent systÃ©m navrÅ¾enÃ½ pro revoluci v personalizovanÃ©m vzdÄ›lÃ¡vÃ¡nÃ­. Projekt kombinuje sÃ­lu vÃ­ce specializovanÃ½ch AI agentÅ¯, kteÅ™Ã­ spolupracujÃ­ na vytvÃ¡Å™enÃ­, dodÃ¡vÃ¡nÃ­ a optimalizaci vzdÄ›lÃ¡vacÃ­ho obsahu pÅ™izpÅ¯sobenÃ©ho individuÃ¡lnÃ­m potÅ™ebÃ¡m kaÅ¾dÃ©ho studenta.

### **HlavnÃ­ cÃ­le:**
- VytvoÅ™enÃ­ adaptivnÃ­ho vzdÄ›lÃ¡vacÃ­ho ekosystÃ©mu
- Personalizace uÄebnÃ­ch cest na zÃ¡kladÄ› individuÃ¡lnÃ­ch potÅ™eb
- KontinuÃ¡lnÃ­ hodnocenÃ­ a Ãºprava vzdÄ›lÃ¡vacÃ­ho obsahu
- Maximalizace efektivity uÄenÃ­ a retention rate

### **Architektura systÃ©mu:**
SystÃ©m se sklÃ¡dÃ¡ z pÄ›ti specializovanÃ½ch agentÅ¯:
1. **Content Curator Agent** - SprÃ¡va a organizace vzdÄ›lÃ¡vacÃ­ho obsahu
2. **Assessment Agent** - HodnocenÃ­ znalostÃ­ a pokroku studentÅ¯
3. **Personalization Agent** - PÅ™izpÅ¯sobenÃ­ uÄebnÃ­ch cest
4. **Tutor Agent** - InteraktivnÃ­ vÃ½uka a podpora studentÅ¯
5. **Analytics Agent** - AnalÃ½za dat a optimalizace systÃ©mu

### **VÃ½zvy:**
- Koordinace mezi agenty v reÃ¡lnÃ©m Äase
- ZpracovÃ¡nÃ­ rÅ¯znorodÃ½ch uÄebnÃ­ch stylÅ¯
- ZabezpeÄenÃ­ kvality vzdÄ›lÃ¡vacÃ­ho obsahu
- Å kÃ¡lovatelnost pro tisÃ­ce studentÅ¯ souÄasnÄ›

### **PotenciÃ¡lnÃ­ dopad:**
- Demokratizace kvalitnÃ­ho vzdÄ›lÃ¡nÃ­
- ZvÃ½Å¡enÃ­ efektivity uÄenÃ­ o 40-60%
- SnÃ­Å¾enÃ­ dropout rate ve vzdÄ›lÃ¡vacÃ­ch institucÃ­ch
- PersonalizovanÃ© kariÃ©rnÃ­ poradenstvÃ­

## Comprehensive Project Example with Python Implementation

### **Instalace zÃ¡vislostÃ­:**

````python
# requirements.txt
crewai==0.1.55
langchain==0.1.0
openai==1.3.0
chromadb==0.4.18
pandas==2.1.0
numpy==1.24.0
scikit-learn==1.3.0
fastapi==0.104.0
uvicorn==0.24.0
pydantic==2.5.0
````

### **HlavnÃ­ implementace:**

````python
import os
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import json
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

from crewai import Agent, Task, Crew, Process
from langchain.llms import OpenAI
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document

import chromadb
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import logging

# NastavenÃ­ logovÃ¡nÃ­
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class Student:
    """Reprezentace studenta v systÃ©mu"""
    id: str
    name: str
    learning_style: str  # visual, auditory, kinesthetic
    current_level: int  # 1-10
    subjects: List[str]
    strengths: List[str]
    weaknesses: List[str]
    goals: List[str]
    progress_history: List[Dict]

@dataclass
class LearningContent:
    """VzdÄ›lÃ¡vacÃ­ obsah"""
    id: str
    title: str
    subject: str
    difficulty_level: int
    content_type: str  # text, video, interactive, quiz
    content: str
    metadata: Dict[str, Any]

class EducationCollective:
    """HlavnÃ­ tÅ™Ã­da pro personalizovanÃ© vzdÄ›lÃ¡vÃ¡nÃ­"""
    
    def __init__(self, openai_api_key: str):
        self.openai_api_key = openai_api_key
        os.environ["OPENAI_API_KEY"] = openai_api_key
        
        # Inicializace komponent
        self.llm = OpenAI(temperature=0.7)
        self.embeddings = OpenAIEmbeddings()
        self.vectorstore = None
        
        # ÃšloÅ¾iÅ¡tÄ› dat
        self.students: Dict[str, Student] = {}
        self.content_library: Dict[str, LearningContent] = {}
        self.learning_paths: Dict[str, List[str]] = {}
        
        # Inicializace agentÅ¯
        self._initialize_agents()
        self._create_sample_data()
        self._setup_vectorstore()
    
    def _initialize_agents(self):
        """Inicializace specializovanÃ½ch agentÅ¯"""
        
        # Content Curator Agent
        self.content_curator = Agent(
            role="KurÃ¡tor vzdÄ›lÃ¡vacÃ­ho obsahu",
            goal="Organizovat a spravovat kvalitnÃ­ vzdÄ›lÃ¡vacÃ­ materiÃ¡ly",
            backstory="Jsi expert na vzdÄ›lÃ¡vacÃ­ obsah s schopnostÃ­ identifikovat "
                     "relevantnÃ­ a kvalitnÃ­ materiÃ¡ly pro rÅ¯znÃ© ÃºrovnÄ› uÄenÃ­.",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
        
        # Assessment Agent
        self.assessment_agent = Agent(
            role="Specialista na hodnocenÃ­",
            goal="Hodnotit pokrok studentÅ¯ a identifikovat oblasti pro zlepÅ¡enÃ­",
            backstory="Jsi pedagog s expertizou v rÅ¯znÃ½ch metodÃ¡ch hodnocenÃ­ "
                     "a analÃ½ze studentskÃ©ho pokroku.",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
        
        # Personalization Agent
        self.personalization_agent = Agent(
            role="Specialista na personalizaci",
            goal="VytvÃ¡Å™et personalizovanÃ© uÄebnÃ­ cesty pro kaÅ¾dÃ©ho studenta",
            backstory="Jsi expert na adaptivnÃ­ vzdÄ›lÃ¡vÃ¡nÃ­ s hlubokÃ½m porozumÄ›nÃ­m "
                     "rÅ¯znÃ½ch uÄebnÃ­ch stylÅ¯ a potÅ™eb.",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
        
        # Tutor Agent
        self.tutor_agent = Agent(
            role="VirtuÃ¡lnÃ­ tutor",
            goal="Poskytovat interaktivnÃ­ vÃ½uku a podporu studentÅ¯m",
            backstory="Jsi zkuÅ¡enÃ½ tutor s schopnostÃ­ vysvÄ›tlit sloÅ¾itÃ© koncepty "
                     "jednoduchÃ½m a srozumitelnÃ½m zpÅ¯sobem.",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
        
        # Analytics Agent
        self.analytics_agent = Agent(
            role="Analytik vzdÄ›lÃ¡vacÃ­ch dat",
            goal="Analyzovat data a optimalizovat vzdÄ›lÃ¡vacÃ­ procesy",
            backstory="Jsi datovÃ½ analytik specializujÃ­cÃ­ se na vzdÄ›lÃ¡vacÃ­ metriky "
                     "a optimalizaci uÄebnÃ­ch procesÅ¯.",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
    
    def _create_sample_data(self):
        """VytvoÅ™enÃ­ ukÃ¡zkovÃ½ch dat"""
        
        # UkÃ¡zkovÃ­ studenti
        self.students = {
            "student_001": Student(
                id="student_001",
                name="Anna NovÃ¡kovÃ¡",
                learning_style="visual",
                current_level=5,
                subjects=["matematika", "fyzika"],
                strengths=["logickÃ© myÅ¡lenÃ­", "vizuÃ¡lnÃ­ zpracovÃ¡nÃ­"],
                weaknesses=["verbÃ¡lnÃ­ vyjadÅ™ovÃ¡nÃ­"],
                goals=["zlepÅ¡it znÃ¡mky z matematiky", "pÅ™ipravit se na maturitu"],
                progress_history=[]
            ),
            "student_002": Student(
                id="student_002",
                name="TomÃ¡Å¡ Svoboda",
                learning_style="kinesthetic",
                current_level=3,
                subjects=["chemie", "biologie"],
                strengths=["praktickÃ© experimenty"],
                weaknesses=["teoretickÃ© koncepty"],
                goals=["pochopit zÃ¡klady chemie", "zlepÅ¡it laboratornÃ­ dovednosti"],
                progress_history=[]
            )
        }
        
        # UkÃ¡zkovÃ½ vzdÄ›lÃ¡vacÃ­ obsah
        self.content_library = {
            "math_001": LearningContent(
                id="math_001",
                title="ZÃ¡klady lineÃ¡rnÃ­ch funkcÃ­",
                subject="matematika",
                difficulty_level=4,
                content_type="text",
                content="LineÃ¡rnÃ­ funkce je funkce tvaru f(x) = ax + b, kde a a b jsou reÃ¡lnÃ¡ ÄÃ­sla...",
                metadata={"duration": 30, "prerequisites": ["zÃ¡kladnÃ­ algebra"]}
            ),
            "physics_001": LearningContent(
                id="physics_001",
                title="Newtonovy zÃ¡kony pohybu",
                subject="fyzika",
                difficulty_level=5,
                content_type="interactive",
                content="PrvnÃ­ NewtonÅ¯v zÃ¡kon Å™Ã­kÃ¡, Å¾e tÄ›leso setrvÃ¡vÃ¡ v klidu nebo rovnomÄ›rnÃ©m pÅ™Ã­moÄarÃ©m pohybu...",
                metadata={"duration": 45, "prerequisites": ["zÃ¡klady mechaniky"]}
            )
        }
    
    def _setup_vectorstore(self):
        """NastavenÃ­ vektorovÃ©ho ÃºloÅ¾iÅ¡tÄ› pro obsah"""
        try:
            # PÅ™Ã­prava dokumentÅ¯ pro indexovÃ¡nÃ­
            documents = []
            for content in self.content_library.values():
                doc = Document(
                    page_content=content.content,
                    metadata={
                        "id": content.id,
                        "title": content.title,
                        "subject": content.subject,
                        "difficulty_level": content.difficulty_level,
                        "content_type": content.content_type
                    }
                )
                documents.append(doc)
            
            # RozdÄ›lenÃ­ textu
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=500,
                chunk_overlap=50
            )
            splits = text_splitter.split_documents(documents)
            
            # VytvoÅ™enÃ­ vektorovÃ©ho ÃºloÅ¾iÅ¡tÄ›
            self.vectorstore = Chroma.from_documents(
                documents=splits,
                embedding=self.embeddings,
                persist_directory="./chroma_db"
            )
            
            logger.info("VektorovÃ© ÃºloÅ¾iÅ¡tÄ› ÃºspÄ›Å¡nÄ› inicializovÃ¡no")
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i inicializaci vektorovÃ©ho ÃºloÅ¾iÅ¡tÄ›: {e}")
    
    def assess_student(self, student_id: str, assessment_data: Dict) -> Dict:
        """HodnocenÃ­ studenta Assessment Agentem"""
        
        student = self.students.get(student_id)
        if not student:
            raise ValueError(f"Student {student_id} nenalezen")
        
        # VytvoÅ™enÃ­ Ãºkolu pro Assessment Agent
        assessment_task = Task(
            description=f"""
            ProveÄ komplexnÃ­ hodnocenÃ­ studenta {student.name} na zÃ¡kladÄ› nÃ¡sledujÃ­cÃ­ch dat:
            
            SouÄasnÃ¡ ÃºroveÅˆ: {student.current_level}
            SilnÃ© strÃ¡nky: {', '.join(student.strengths)}
            SlabÃ© strÃ¡nky: {', '.join(student.weaknesses)}
            PÅ™edmÄ›ty: {', '.join(student.subjects)}
            
            Data z hodnocenÃ­: {json.dumps(assessment_data, indent=2)}
            
            Poskytni:
            1. CelkovÃ© skÃ³re (1-10)
            2. Oblasti pro zlepÅ¡enÃ­
            3. DoporuÄenÃ­ pro dalÅ¡Ã­ kroky
            4. UpravenÃ¡ ÃºroveÅˆ obtÃ­Å¾nosti
            """,
            agent=self.assessment_agent,
            expected_output="StrukturovanÃ© hodnocenÃ­ ve formÃ¡tu JSON"
        )
        
        # SpuÅ¡tÄ›nÃ­ hodnocenÃ­
        crew = Crew(
            agents=[self.assessment_agent],
            tasks=[assessment_task],
            process=Process.sequential
        )
        
        result = crew.kickoff()
        
        # ZpracovÃ¡nÃ­ vÃ½sledku
        try:
            assessment_result = {
                "student_id": student_id,
                "timestamp": datetime.now().isoformat(),
                "overall_score": assessment_data.get("score", 0),
                "areas_for_improvement": assessment_data.get("weak_areas", []),
                "recommendations": str(result),
                "adjusted_level": min(10, max(1, student.current_level + assessment_data.get("level_change", 0)))
            }
            
            # Aktualizace historie studenta
            student.progress_history.append(assessment_result)
            student.current_level = assessment_result["adjusted_level"]
            
            return assessment_result
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i zpracovÃ¡nÃ­ hodnocenÃ­: {e}")
            return {"error": str(e)}
    
    def create_personalized_path(self, student_id: str) -> List[str]:
        """VytvoÅ™enÃ­ personalizovanÃ© uÄebnÃ­ cesty"""
        
        student = self.students.get(student_id)
        if not student:
            raise ValueError(f"Student {student_id} nenalezen")
        
        # Ãškol pro Personalization Agent
        personalization_task = Task(
            description=f"""
            VytvoÅ™ personalizovanou uÄebnÃ­ cestu pro studenta {student.name}:
            
            Profil studenta:
            - UÄebnÃ­ styl: {student.learning_style}
            - SouÄasnÃ¡ ÃºroveÅˆ: {student.current_level}
            - PÅ™edmÄ›ty: {', '.join(student.subjects)}
            - CÃ­le: {', '.join(student.goals)}
            - SilnÃ© strÃ¡nky: {', '.join(student.strengths)}
            - SlabÃ© strÃ¡nky: {', '.join(student.weaknesses)}
            
            DostupnÃ½ obsah: {list(self.content_library.keys())}
            
            VytvoÅ™ optimÃ¡lnÃ­ sekvenci uÄebnÃ­ch materiÃ¡lÅ¯ s ohledem na:
            1. Postupnou obtÃ­Å¾nost
            2. UÄebnÃ­ styl studenta
            3. Jeho cÃ­le a slabÃ© strÃ¡nky
            4. Logickou nÃ¡vaznost tÃ©mat
            """,
            agent=self.personalization_agent,
            expected_output="Seznam ID obsahu v optimÃ¡lnÃ­m poÅ™adÃ­"
        )
        
        crew = Crew(
            agents=[self.personalization_agent],
            tasks=[personalization_task],
            process=Process.sequential
        )
        
        result = crew.kickoff()
        
        # VytvoÅ™enÃ­ uÄebnÃ­ cesty na zÃ¡kladÄ› dostupnÃ©ho obsahu
        learning_path = []
        for subject in student.subjects:
            for content_id, content in self.content_library.items():
                if content.subject == subject and content.difficulty_level <= student.current_level + 2:
                    learning_path.append(content_id)
        
        # SeÅ™azenÃ­ podle obtÃ­Å¾nosti
        learning_path.sort(key=lambda x: self.content_library[x].difficulty_level)
        
        self.learning_paths[student_id] = learning_path
        
        logger.info(f"VytvoÅ™ena uÄebnÃ­ cesta pro {student.name}: {learning_path}")
        return learning_path
    
    def get_tutoring_session(self, student_id: str, topic: str) -> str:
        """InteraktivnÃ­ tutorskÃ¡ session"""
        
        student = self.students.get(student_id)
        if not student:
            raise ValueError(f"Student {student_id} nenalezen")
        
        # VyhledÃ¡nÃ­ relevantnÃ­ho obsahu
        relevant_content = []
        if self.vectorstore:
            docs = self.vectorstore.similarity_search(topic, k=3)
            relevant_content = [doc.page_content for doc in docs]
        
        # Ãškol pro Tutor Agent
        tutoring_task = Task(
            description=f"""
            ProveÄ tutorskou session pro studenta {student.name} na tÃ©ma: {topic}
            
            Profil studenta:
            - UÄebnÃ­ styl: {student.learning_style}
            - SouÄasnÃ¡ ÃºroveÅˆ: {student.current_level}
            - SilnÃ© strÃ¡nky: {', '.join(student.strengths)}
            
            RelevantnÃ­ obsah: {' '.join(relevant_content[:500])}
            
            Poskytni:
            1. StrukturovanÃ© vysvÄ›tlenÃ­ tÃ©matu
            2. PraktickÃ© pÅ™Ã­klady
            3. KontrolnÃ­ otÃ¡zky
            4. DalÅ¡Ã­ doporuÄenÃ­
            
            PÅ™izpÅ¯sob styl vysvÄ›tlenÃ­ uÄebnÃ­mu stylu studenta.
            """,
            agent=self.tutor_agent,
            expected_output="KomplexnÃ­ tutorskÃ¡ session"
        )
        
        crew = Crew(
            agents=[self.tutor_agent],
            tasks=[tutoring_task],
            process=Process.sequential
        )
        
        result = crew.kickoff()
        return str(result)
    
    def analyze_system_performance(self) -> Dict:
        """AnalÃ½za vÃ½konnosti systÃ©mu Analytics Agentem"""
        
        # ShromÃ¡Å¾dÄ›nÃ­ dat o vÃ½konnosti
        performance_data = {
            "total_students": len(self.students),
            "total_content": len(self.content_library),
            "learning_paths_created": len(self.learning_paths),
            "average_student_level": np.mean([s.current_level for s in self.students.values()]),
            "subject_distribution": {}
        }
        
        # Distribuce pÅ™edmÄ›tÅ¯
        all_subjects = []
        for student in self.students.values():
            all_subjects.extend(student.subjects)
        
        from collections import Counter
        subject_counts = Counter(all_subjects)
        performance_data["subject_distribution"] = dict(subject_counts)
        
        # Ãškol pro Analytics Agent
        analytics_task = Task(
            description=f"""
            Analyzuj vÃ½konnost vzdÄ›lÃ¡vacÃ­ho systÃ©mu na zÃ¡kladÄ› nÃ¡sledujÃ­cÃ­ch dat:
            
            {json.dumps(performance_data, indent=2)}
            
            Poskytni:
            1. CelkovÃ© hodnocenÃ­ systÃ©mu
            2. IdentifikovanÃ© trendy
            3. Oblasti pro zlepÅ¡enÃ­
            4. DoporuÄenÃ­ pro optimalizaci
            5. Metriky ÃºspÄ›Å¡nosti
            """,
            agent=self.analytics_agent,
            expected_output="KomplexnÃ­ analytickÃ¡ zprÃ¡va"
        )
        
        crew = Crew(
            agents=[self.analytics_agent],
            tasks=[analytics_task],
            process=Process.sequential
        )
        
        result = crew.kickoff()
        
        performance_data["analysis"] = str(result)
        return performance_data

# FastAPI aplikace pro webovÃ© rozhranÃ­
app = FastAPI(title="Personalized Education Collective API")

# GlobÃ¡lnÃ­ instance systÃ©mu
education_system = None

@app.on_event("startup")
async def startup_event():
    global education_system
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY environment variable required")
    
    education_system = EducationCollective(api_key)
    logger.info("Education Collective system initialized")

class AssessmentRequest(BaseModel):
    student_id: str
    score: int
    weak_areas: List[str]
    level_change: int = 0

class TutoringRequest(BaseModel):
    student_id: str
    topic: str

@app.get("/students")
async def get_students():
    """ZÃ­skÃ¡nÃ­ seznamu studentÅ¯"""
    if not education_system:
        raise HTTPException(status_code=500, detail="System not initialized")
    
    return list(education_system.students.keys())

@app.get("/students/{student_id}")
async def get_student(student_id: str):
    """ZÃ­skÃ¡nÃ­ informacÃ­ o studentovi"""
    if not education_system:
        raise HTTPException(status_code=500, detail="System not initialized")
    
    student = education_system.students.get(student_id)
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")
    
    return student

@app.post("/assess")
async def assess_student(request: AssessmentRequest):
    """HodnocenÃ­ studenta"""
    if not education_system:
        raise HTTPException(status_code=500, detail="System not initialized")
    
    try:
        assessment_data = {
            "score": request.score,
            "weak_areas": request.weak_areas,
            "level_change": request.level_change
        }
        
        result = education_system.assess_student(request.student_id, assessment_data)
        return result
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/create-path/{student_id}")
async def create_learning_path(student_id: str):
    """VytvoÅ™enÃ­ personalizovanÃ© uÄebnÃ­ cesty"""
    if not education_system:
        raise HTTPException(status_code=500, detail="System not initialized")
    
    try:
        path = education_system.create_personalized_path(student_id)
        return {"student_id": student_id, "learning_path": path}
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/tutoring")
async def get_tutoring(request: TutoringRequest):
    """TutorskÃ¡ session"""
    if not education_system:
        raise HTTPException(status_code=500, detail="System not initialized")
    
    try:
        session = education_system.get_tutoring_session(request.student_id, request.topic)
        return {"student_id": request.student_id, "topic": request.topic, "session": session}
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/analytics")
async def get_analytics():
    """AnalÃ½za vÃ½konnosti systÃ©mu"""
    if not education_system:
        raise HTTPException(status_code=500, detail="System not initialized")
    
    try:
        analysis = education_system.analyze_system_performance()
        return analysis
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    
    # NastavenÃ­ API klÃ­Äe
    if not os.getenv("OPENAI_API_KEY"):
        print("Nastavte OPENAI_API_KEY environment variable")
        exit(1)
    
    # SpuÅ¡tÄ›nÃ­ serveru
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### **TestovacÃ­ script:**

````python
import asyncio
import requests
import json
import os

class EducationCollectiveClient:
    """Klient pro testovÃ¡nÃ­ Education Collective API"""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
    
    def test_system(self):
        """KompletnÃ­ test systÃ©mu"""
        
        print("ğŸ“ TestovÃ¡nÃ­ Personalized Education Collective")
        print("=" * 50)
        
        # 1. ZÃ­skÃ¡nÃ­ seznamu studentÅ¯
        print("\n1. Seznam studentÅ¯:")
        response = requests.get(f"{self.base_url}/students")
        if response.status_code == 200:
            students = response.json()
            print(f"   Nalezeno {len(students)} studentÅ¯: {students}")
        else:
            print(f"   Chyba: {response.status_code}")
        
        # 2. Detaily o studentovi
        student_id = "student_001"
        print(f"\n2. Detail studenta {student_id}:")
        response = requests.get(f"{self.base_url}/students/{student_id}")
        if response.status_code == 200:
            student = response.json()
            print(f"   JmÃ©no: {student['name']}")
            print(f"   UÄebnÃ­ styl: {student['learning_style']}")
            print(f"   ÃšroveÅˆ: {student['current_level']}")
            print(f"   PÅ™edmÄ›ty: {student['subjects']}")
        
        # 3. HodnocenÃ­ studenta
        print(f"\n3. HodnocenÃ­ studenta {student_id}:")
        assessment_data = {
            "student_id": student_id,
            "score": 7,
            "weak_areas": ["geometrie", "slovnÃ­ Ãºlohy"],
            "level_change": 1
        }
        
        response = requests.post(f"{self.base_url}/assess", json=assessment_data)
        if response.status_code == 200:
            result = response.json()
            print(f"   HodnocenÃ­ dokonÄeno: {result['overall_score']}/10")
            print(f"   NovÃ¡ ÃºroveÅˆ: {result['adjusted_level']}")
        
        # 4. VytvoÅ™enÃ­ uÄebnÃ­ cesty
        print(f"\n4. VytvoÅ™enÃ­ uÄebnÃ­ cesty pro {student_id}:")
        response = requests.post(f"{self.base_url}/create-path/{student_id}")
        if response.status_code == 200:
            result = response.json()
            print(f"   UÄebnÃ­ cesta: {result['learning_path']}")
        
        # 5. TutorskÃ¡ session
        print(f"\n5. TutorskÃ¡ session - lineÃ¡rnÃ­ funkce:")
        tutoring_data = {
            "student_id": student_id,
            "topic": "lineÃ¡rnÃ­ funkce"
        }
        
        response = requests.post(f"{self.base_url}/tutoring", json=tutoring_data)
        if response.status_code == 200:
            result = response.json()
            session = result['session'][:200] + "..." if len(result['session']) > 200 else result['session']
            print(f"   Session: {session}")
        
        # 6. AnalÃ½za systÃ©mu
        print(f"\n6. AnalÃ½za vÃ½konnosti systÃ©mu:")
        response = requests.get(f"{self.base_url}/analytics")
        if response.status_code == 200:
            analytics = response.json()
            print(f"   Celkem studentÅ¯: {analytics['total_students']}")
            print(f"   Celkem obsahu: {analytics['total_content']}")
            print(f"   PrÅ¯mÄ›rnÃ¡ ÃºroveÅˆ: {analytics['average_student_level']:.1f}")
        
        print("\nâœ… Test dokonÄen!")

def main():
    """HlavnÃ­ testovacÃ­ funkce"""
    
    # Kontrola API klÃ­Äe
    if not os.getenv("OPENAI_API_KEY"):
        print("âŒ Nastavte OPENAI_API_KEY environment variable")
        return
    
    print("ğŸš€ SpouÅ¡tÄ›nÃ­ testÅ¯...")
    print("ğŸ“ UjistÄ›te se, Å¾e server bÄ›Å¾Ã­ na http://localhost:8000")
    
    input("StisknÄ›te Enter pro pokraÄovÃ¡nÃ­...")
    
    client = EducationCollectiveClient()
    
    try:
        client.test_system()
    except requests.exceptions.ConnectionError:
        print("âŒ Nelze se pÅ™ipojit k serveru. UjistÄ›te se, Å¾e bÄ›Å¾Ã­ na portu 8000.")
    except Exception as e:
        print(f"âŒ Chyba pÅ™i testovÃ¡nÃ­: {e}")

if __name__ == "__main__":
    main()
````

### **SpuÅ¡tÄ›nÃ­ systÃ©mu:**

````bash
# Instalace zÃ¡vislostÃ­
pip install -r requirements.txt

# NastavenÃ­ API klÃ­Äe
set OPENAI_API_KEY=your_openai_api_key_here

# SpuÅ¡tÄ›nÃ­ serveru
python personalized_education_collective.py

# V druhÃ©m terminÃ¡lu - spuÅ¡tÄ›nÃ­ testÅ¯
python test_education_collective.py
````

## Project Summary

**Personalized Education Collective** pÅ™edstavuje pokroÄilÃ½ multi-agent systÃ©m, kterÃ½ revolucionizuje personalizovanÃ© vzdÄ›lÃ¡vÃ¡nÃ­ pomocÃ­ koordinovanÃ© spoluprÃ¡ce specializovanÃ½ch AI agentÅ¯. SystÃ©m kombinuje sÃ­lu velkÃ½ch jazykovÃ½ch modelÅ¯ s modernÃ­mi technikami machine learning pro vytvoÅ™enÃ­ adaptivnÃ­ho vzdÄ›lÃ¡vacÃ­ho ekosystÃ©mu.

### **KlÃ­ÄovÃ© hodnoty:**

**ğŸ¯ Personalizace na mÃ­ru** - KaÅ¾dÃ½ student dostÃ¡vÃ¡ uÄebnÃ­ cestu pÅ™izpÅ¯sobenou jeho stylu, Ãºrovni a cÃ­lÅ¯m

**ğŸ“Š KontinuÃ¡lnÃ­ hodnocenÃ­** - SystÃ©m prÅ¯bÄ›Å¾nÄ› vyhodnocuje pokrok a dynamicky upravuje obsah

**ğŸ¤ KolaborativnÃ­ agenti** - PÄ›t specializovanÃ½ch agentÅ¯ spolupracuje na optimalizaci vzdÄ›lÃ¡vacÃ­ho procesu

**ğŸ“ˆ DatovÃ¡ analÃ½za** - PokroÄilÃ© analytickÃ© nÃ¡stroje pro optimalizaci systÃ©mu a mÄ›Å™enÃ­ ÃºspÄ›Å¡nosti

**ğŸš€ Å kÃ¡lovatelnost** - Architektura navrÅ¾enÃ¡ pro podporu tisÃ­cÅ¯ studentÅ¯ souÄasnÄ›

### **TechnologickÃ© vÃ½hody:**

- **ModernÃ­ stack**: CrewAI, LangChain, ChromaDB, FastAPI
- **VektorovÃ© vyhledÃ¡vÃ¡nÃ­** pro relevantnÃ­ obsah
- **RESTful API** pro snadnou integraci
- **RobustnÃ­ error handling** a logovÃ¡nÃ­
- **ModulÃ¡rnÃ­ architektura** pro snadnou ÃºdrÅ¾bu

Tento systÃ©m pÅ™edstavuje budoucnost vzdÄ›lÃ¡vÃ¡nÃ­, kde AI agenti spolupracujÃ­ na vytvÃ¡Å™enÃ­ skuteÄnÄ› personalizovanÃ½ch a efektivnÃ­ch vzdÄ›lÃ¡vacÃ­ch zÃ¡Å¾itkÅ¯ pro kaÅ¾dÃ©ho studenta.