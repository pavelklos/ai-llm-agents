<small>Claude Sonnet 4 **(Music Discovery and Analysis Platform with RAG)**</small>
# Music Discovery and Analysis Platform

## Project Title

**AI-Powered Music Discovery and Analysis Platform with Retrieval-Augmented Generation**

## Key Concepts Explanation

### **RAG (Retrieval-Augmented Generation)**
A hybrid AI approach that combines information retrieval from comprehensive music databases with generative AI to provide contextual music recommendations, artist insights, and personalized music discovery experiences based on user preferences, listening history, and musical characteristics.

### **Artist Biographies**
Comprehensive profiles of musicians including career history, musical influences, discography, personal background, and cultural impact that provide context for understanding artists and their musical evolution over time.

### **Album Reviews**
Critical assessments and user reviews of music albums including professional critiques, ratings, thematic analysis, and cultural significance that help users understand artistic merit and reception.

### **Concert Information**
Live performance data including tour dates, venue information, setlists, ticket availability, and concert reviews that connect users to live music experiences and artist performance history.

### **Spotify API**
RESTful web service providing access to Spotify's music catalog, user playlists, listening history, audio features, and recommendation algorithms for comprehensive music data integration.

### **Last.fm Data**
Music listening tracking service providing scrobbling data, user statistics, artist popularity metrics, and social music discovery features that enhance understanding of music consumption patterns.

### **Genre Classification**
Automated categorization of music into genres and subgenres using audio features, metadata analysis, and machine learning to enable efficient music organization and discovery.

### **Lyric Analysis**
Natural language processing of song lyrics to extract themes, emotions, narrative elements, and cultural references that provide deeper understanding of musical content and meaning.

## Comprehensive Project Explanation

The Music Discovery and Analysis Platform represents an innovative AI-driven system that transforms how users discover, understand, and interact with music. By leveraging RAG architecture, this platform combines vast music databases with intelligent analysis capabilities to provide personalized recommendations, deep musical insights, and comprehensive artist information.

### **Objectives**

1. **Intelligent Music Discovery**: Enable users to find new music through natural language queries, mood-based searches, and sophisticated recommendation algorithms.

2. **Comprehensive Music Analysis**: Provide detailed insights into songs, albums, and artists including musical characteristics, lyrical themes, and cultural context.

3. **Personalized Recommendations**: Deliver tailored music suggestions based on listening history, preferences, and contextual factors like mood, activity, and time.

4. **Cultural and Historical Context**: Connect users to the broader context of music including influences, movements, and cultural significance.

### **Challenges**

1. **Music Taste Subjectivity**: Accounting for highly personal and subjective nature of music preferences in recommendation algorithms.

2. **Audio Feature Analysis**: Processing complex audio characteristics and translating them into meaningful insights and recommendations.

3. **Real-time Data Integration**: Handling continuous updates from multiple music platforms and maintaining data consistency.

4. **Scalability**: Managing massive music catalogs and user bases while maintaining responsive performance.

### **Potential Impact**

- **Enhanced Music Discovery**: Users discover music that aligns with their tastes while exploring new genres and artists
- **Artist Promotion**: Independent and emerging artists gain visibility through intelligent recommendation systems
- **Cultural Education**: Users learn about music history, influences, and cultural contexts
- **Music Industry Insights**: Labels and artists gain valuable analytics about listener preferences and trends

## Comprehensive Project Example with Python Implementation

````python
# requirements.txt
langchain==0.1.0
chromadb==0.4.18
openai==1.3.0
spotipy==2.22.1
requests==2.31.0
pandas==2.1.4
numpy==1.24.3
scikit-learn==1.3.2
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
nltk==3.8.1
textblob==0.17.1
librosa==0.10.1
matplotlib==3.8.2
seaborn==0.13.0
transformers==4.36.0
beautifulsoup4==4.12.2
````

````python
# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # API Keys
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    SPOTIFY_CLIENT_ID = os.getenv("SPOTIFY_CLIENT_ID")
    SPOTIFY_CLIENT_SECRET = os.getenv("SPOTIFY_CLIENT_SECRET")
    LASTFM_API_KEY = os.getenv("LASTFM_API_KEY")
    
    # Database
    CHROMA_PERSIST_DIRECTORY = "./chroma_db"
    
    # Model Configuration
    EMBEDDING_MODEL = "text-embedding-ada-002"
    CHAT_MODEL = "gpt-4-turbo-preview"
    
    # Application Settings
    MAX_RESULTS = 20
    SIMILARITY_THRESHOLD = 0.75
    
    # Music Analysis
    SUPPORTED_GENRES = [
        "rock", "pop", "hip-hop", "jazz", "classical", "electronic",
        "country", "folk", "blues", "reggae", "punk", "metal",
        "indie", "alternative", "r&b", "soul", "funk", "disco"
    ]
    
    AUDIO_FEATURES = [
        "danceability", "energy", "loudness", "speechiness",
        "acousticness", "instrumentalness", "liveness", "valence", "tempo"
    ]
    
    # Lyric Analysis
    LYRIC_THEMES = [
        "love", "heartbreak", "party", "social_issues", "personal_growth",
        "nostalgia", "rebellion", "spirituality", "nature", "urban_life"
    ]
````

````python
# models.py
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

class MusicGenre(str, Enum):
    ROCK = "rock"
    POP = "pop"
    HIP_HOP = "hip-hop"
    JAZZ = "jazz"
    CLASSICAL = "classical"
    ELECTRONIC = "electronic"
    COUNTRY = "country"
    FOLK = "folk"

class Artist(BaseModel):
    id: str
    name: str
    genres: List[str]
    biography: Optional[str]
    birth_date: Optional[str]
    origin: Optional[str]
    active_years: Optional[str]
    influences: List[str]
    similar_artists: List[str]
    popularity: Optional[int]
    followers: Optional[int]
    spotify_id: Optional[str]
    image_url: Optional[str]

class Album(BaseModel):
    id: str
    title: str
    artist_id: str
    artist_name: str
    release_date: str
    genres: List[str]
    track_count: int
    duration_ms: int
    description: Optional[str]
    label: Optional[str]
    album_type: str  # album, single, compilation
    spotify_id: Optional[str]
    cover_url: Optional[str]
    average_rating: Optional[float]

class Track(BaseModel):
    id: str
    title: str
    artist_id: str
    artist_name: str
    album_id: Optional[str]
    album_name: Optional[str]
    duration_ms: int
    explicit: bool
    popularity: Optional[int]
    spotify_id: Optional[str]
    preview_url: Optional[str]
    lyrics: Optional[str]
    audio_features: Optional[Dict[str, float]]

class AudioFeatures(BaseModel):
    track_id: str
    danceability: float
    energy: float
    key: int
    loudness: float
    mode: int
    speechiness: float
    acousticness: float
    instrumentalness: float
    liveness: float
    valence: float
    tempo: float
    time_signature: int

class Review(BaseModel):
    id: str
    item_id: str  # track, album, or artist ID
    item_type: str  # track, album, artist
    user_id: str
    rating: int  # 1-5
    review_text: Optional[str]
    helpful_votes: int
    created_date: datetime
    verified_purchase: bool

class Concert(BaseModel):
    id: str
    artist_id: str
    artist_name: str
    venue: str
    city: str
    country: str
    date: datetime
    ticket_url: Optional[str]
    setlist: Optional[List[str]]
    attendance: Optional[int]

class UserProfile(BaseModel):
    user_id: str
    favorite_genres: List[str]
    favorite_artists: List[str]
    listening_history: List[str]  # track IDs
    mood_preferences: Dict[str, float]
    discovery_settings: Dict[str, Any]

class LyricAnalysis(BaseModel):
    track_id: str
    themes: List[str]
    sentiment_score: float
    emotion_categories: Dict[str, float]
    language: str
    explicit_content: bool
    word_count: int
    reading_level: str
````

````python
# music_collectors.py
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import requests
import json
from typing import List, Dict, Optional, Any
from models import Artist, Album, Track, Concert
from config import Config
import time
from datetime import datetime

class SpotifyCollector:
    def __init__(self):
        if Config.SPOTIFY_CLIENT_ID and Config.SPOTIFY_CLIENT_SECRET:
            client_credentials_manager = SpotifyClientCredentials(
                client_id=Config.SPOTIFY_CLIENT_ID,
                client_secret=Config.SPOTIFY_CLIENT_SECRET
            )
            self.spotify = spotipy.Spotify(client_credentials_manager=client_credentials_manager)
        else:
            self.spotify = None
    
    def search_artists(self, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        """Search for artists on Spotify"""
        if not self.spotify:
            return []
        
        try:
            results = self.spotify.search(q=query, type='artist', limit=limit)
            
            artists = []
            for artist in results['artists']['items']:
                artist_data = {
                    'id': f"spotify_{artist['id']}",
                    'name': artist['name'],
                    'genres': artist.get('genres', []),
                    'popularity': artist.get('popularity', 0),
                    'followers': artist.get('followers', {}).get('total', 0),
                    'spotify_id': artist['id'],
                    'image_url': artist['images'][0]['url'] if artist['images'] else None
                }
                artists.append(artist_data)
            
            return artists
            
        except Exception as e:
            print(f"Error searching Spotify artists: {e}")
            return []
    
    def get_artist_albums(self, artist_id: str, limit: int = 50) -> List[Dict[str, Any]]:
        """Get albums for a specific artist"""
        if not self.spotify:
            return []
        
        try:
            results = self.spotify.artist_albums(artist_id, limit=limit)
            
            albums = []
            for album in results['items']:
                album_data = {
                    'id': f"spotify_{album['id']}",
                    'title': album['name'],
                    'artist_name': album['artists'][0]['name'],
                    'release_date': album['release_date'],
                    'track_count': album['total_tracks'],
                    'album_type': album['album_type'],
                    'spotify_id': album['id'],
                    'cover_url': album['images'][0]['url'] if album['images'] else None
                }
                albums.append(album_data)
            
            return albums
            
        except Exception as e:
            print(f"Error getting Spotify albums: {e}")
            return []
    
    def get_album_tracks(self, album_id: str) -> List[Dict[str, Any]]:
        """Get tracks for a specific album"""
        if not self.spotify:
            return []
        
        try:
            results = self.spotify.album_tracks(album_id)
            
            tracks = []
            for track in results['items']:
                track_data = {
                    'id': f"spotify_{track['id']}",
                    'title': track['name'],
                    'artist_name': track['artists'][0]['name'],
                    'duration_ms': track['duration_ms'],
                    'explicit': track['explicit'],
                    'spotify_id': track['id'],
                    'preview_url': track.get('preview_url')
                }
                tracks.append(track_data)
            
            return tracks
            
        except Exception as e:
            print(f"Error getting Spotify tracks: {e}")
            return []
    
    def get_audio_features(self, track_ids: List[str]) -> List[Dict[str, Any]]:
        """Get audio features for tracks"""
        if not self.spotify:
            return []
        
        try:
            # Spotify API accepts max 100 tracks at once
            all_features = []
            for i in range(0, len(track_ids), 100):
                batch = track_ids[i:i+100]
                features = self.spotify.audio_features(batch)
                all_features.extend([f for f in features if f is not None])
            
            return all_features
            
        except Exception as e:
            print(f"Error getting audio features: {e}")
            return []

class LastFmCollector:
    def __init__(self):
        self.api_key = Config.LASTFM_API_KEY
        self.base_url = "http://ws.audioscrobbler.com/2.0/"
    
    def get_artist_info(self, artist_name: str) -> Optional[Dict[str, Any]]:
        """Get artist information from Last.fm"""
        if not self.api_key:
            return None
        
        try:
            params = {
                'method': 'artist.getinfo',
                'artist': artist_name,
                'api_key': self.api_key,
                'format': 'json'
            }
            
            response = requests.get(self.base_url, params=params)
            if response.status_code == 200:
                data = response.json()
                if 'artist' in data:
                    return data['artist']
            
            return None
            
        except Exception as e:
            print(f"Error getting Last.fm artist info: {e}")
            return None
    
    def get_similar_artists(self, artist_name: str, limit: int = 10) -> List[str]:
        """Get similar artists from Last.fm"""
        if not self.api_key:
            return []
        
        try:
            params = {
                'method': 'artist.getsimilar',
                'artist': artist_name,
                'limit': limit,
                'api_key': self.api_key,
                'format': 'json'
            }
            
            response = requests.get(self.base_url, params=params)
            if response.status_code == 200:
                data = response.json()
                if 'similarartists' in data and 'artist' in data['similarartists']:
                    return [artist['name'] for artist in data['similarartists']['artist']]
            
            return []
            
        except Exception as e:
            print(f"Error getting similar artists: {e}")
            return []
    
    def get_top_tracks(self, artist_name: str, limit: int = 10) -> List[Dict[str, Any]]:
        """Get top tracks for an artist"""
        if not self.api_key:
            return []
        
        try:
            params = {
                'method': 'artist.gettoptracks',
                'artist': artist_name,
                'limit': limit,
                'api_key': self.api_key,
                'format': 'json'
            }
            
            response = requests.get(self.base_url, params=params)
            if response.status_code == 200:
                data = response.json()
                if 'toptracks' in data and 'track' in data['toptracks']:
                    return data['toptracks']['track']
            
            return []
            
        except Exception as e:
            print(f"Error getting top tracks: {e}")
            return []

class MusicDataAggregator:
    """Aggregate music data from multiple sources"""
    
    def __init__(self):
        self.spotify_collector = SpotifyCollector()
        self.lastfm_collector = LastFmCollector()
        self.sample_data = self._create_sample_data()
    
    def _create_sample_data(self) -> Dict[str, List[Dict[str, Any]]]:
        """Create sample music data"""
        return {
            'artists': [
                {
                    'id': 'the_beatles',
                    'name': 'The Beatles',
                    'genres': ['rock', 'pop', 'psychedelic'],
                    'biography': 'The Beatles were an English rock band formed in Liverpool in 1960.',
                    'birth_date': '1960',
                    'origin': 'Liverpool, England',
                    'active_years': '1960-1970',
                    'influences': ['Chuck Berry', 'Little Richard', 'Elvis Presley'],
                    'similar_artists': ['The Rolling Stones', 'The Who', 'Led Zeppelin'],
                    'popularity': 95
                },
                {
                    'id': 'taylor_swift',
                    'name': 'Taylor Swift',
                    'genres': ['pop', 'country', 'folk'],
                    'biography': 'Taylor Swift is an American singer-songwriter known for narrative songwriting.',
                    'birth_date': '1989-12-13',
                    'origin': 'West Reading, Pennsylvania',
                    'active_years': '2004-present',
                    'influences': ['Shania Twain', 'Dixie Chicks', 'Patsy Cline'],
                    'similar_artists': ['Olivia Rodrigo', 'Lorde', 'Phoebe Bridgers'],
                    'popularity': 98
                }
            ],
            'albums': [
                {
                    'id': 'abbey_road',
                    'title': 'Abbey Road',
                    'artist_id': 'the_beatles',
                    'artist_name': 'The Beatles',
                    'release_date': '1969-09-26',
                    'genres': ['rock', 'pop'],
                    'track_count': 17,
                    'duration_ms': 2830000,
                    'description': 'The eleventh studio album by The Beatles.',
                    'label': 'Apple Records',
                    'album_type': 'album',
                    'average_rating': 4.8
                }
            ],
            'tracks': [
                {
                    'id': 'come_together',
                    'title': 'Come Together',
                    'artist_id': 'the_beatles',
                    'artist_name': 'The Beatles',
                    'album_id': 'abbey_road',
                    'album_name': 'Abbey Road',
                    'duration_ms': 259000,
                    'explicit': False,
                    'popularity': 85,
                    'lyrics': 'Here come old flat top, he come grooving up slowly...',
                    'audio_features': {
                        'danceability': 0.65,
                        'energy': 0.7,
                        'valence': 0.6,
                        'tempo': 85
                    }
                }
            ]
        }
    
    def collect_comprehensive_data(self) -> Dict[str, List[Dict[str, Any]]]:
        """Collect music data from all sources"""
        all_data = {
            'artists': [],
            'albums': [],
            'tracks': [],
            'concerts': []
        }
        
        # Add sample data
        all_data['artists'].extend(self.sample_data['artists'])
        all_data['albums'].extend(self.sample_data['albums'])
        all_data['tracks'].extend(self.sample_data['tracks'])
        
        # Collect from Spotify if available
        if self.spotify_collector.spotify:
            try:
                # Search for popular artists
                spotify_artists = self.spotify_collector.search_artists('popular', 10)
                all_data['artists'].extend(spotify_artists)
                
                # Get albums for first few artists
                for artist in spotify_artists[:3]:
                    if artist.get('spotify_id'):
                        albums = self.spotify_collector.get_artist_albums(artist['spotify_id'], 5)
                        all_data['albums'].extend(albums)
                
            except Exception as e:
                print(f"Error collecting Spotify data: {e}")
        
        # Enhance with Last.fm data
        for artist in all_data['artists']:
            try:
                lastfm_info = self.lastfm_collector.get_artist_info(artist['name'])
                if lastfm_info:
                    artist['biography'] = lastfm_info.get('bio', {}).get('summary', artist.get('biography', ''))
                
                similar = self.lastfm_collector.get_similar_artists(artist['name'], 5)
                if similar:
                    artist['similar_artists'] = similar
                    
            except Exception as e:
                print(f"Error enhancing with Last.fm data: {e}")
        
        return all_data
````

````python
# vector_store.py
import chromadb
from chromadb.config import Settings
from langchain.embeddings import OpenAIEmbeddings
from typing import List, Dict, Any
from config import Config
import json

class MusicVectorStore:
    def __init__(self):
        self.embeddings = OpenAIEmbeddings(
            openai_api_key=Config.OPENAI_API_KEY,
            model=Config.EMBEDDING_MODEL
        )
        
        self.client = chromadb.PersistentClient(
            path=Config.CHROMA_PERSIST_DIRECTORY,
            settings=Settings(anonymized_telemetry=False)
        )
        
        # Initialize collections
        self.artists_collection = self._get_or_create_collection("artists")
        self.albums_collection = self._get_or_create_collection("albums")
        self.tracks_collection = self._get_or_create_collection("tracks")
        self.reviews_collection = self._get_or_create_collection("reviews")
        self.concerts_collection = self._get_or_create_collection("concerts")
    
    def _get_or_create_collection(self, name: str):
        try:
            return self.client.get_collection(name)
        except:
            return self.client.create_collection(name)
    
    def add_artist(self, artist_data: Dict[str, Any]):
        """Add artist to vector store"""
        try:
            searchable_text = f"""
            Artist: {artist_data.get('name', '')}
            Genres: {', '.join(artist_data.get('genres', []))}
            Biography: {artist_data.get('biography', '')}
            Origin: {artist_data.get('origin', '')}
            Active Years: {artist_data.get('active_years', '')}
            Influences: {', '.join(artist_data.get('influences', []))}
            Similar Artists: {', '.join(artist_data.get('similar_artists', []))}
            """
            
            embedding = self.embeddings.embed_query(searchable_text)
            
            self.artists_collection.add(
                documents=[searchable_text],
                embeddings=[embedding],
                metadatas=[artist_data],
                ids=[artist_data['id']]
            )
            
        except Exception as e:
            print(f"Error adding artist to vector store: {e}")
    
    def add_track(self, track_data: Dict[str, Any]):
        """Add track to vector store"""
        try:
            audio_features = track_data.get('audio_features', {})
            audio_desc = ", ".join([f"{k}: {v}" for k, v in audio_features.items()])
            
            searchable_text = f"""
            Track: {track_data.get('title', '')}
            Artist: {track_data.get('artist_name', '')}
            Album: {track_data.get('album_name', '')}
            Lyrics: {track_data.get('lyrics', '')[:500]}
            Audio Features: {audio_desc}
            Duration: {track_data.get('duration_ms', 0)} ms
            """
            
            embedding = self.embeddings.embed_query(searchable_text)
            
            self.tracks_collection.add(
                documents=[searchable_text],
                embeddings=[embedding],
                metadatas=[track_data],
                ids=[track_data['id']]
            )
            
        except Exception as e:
            print(f"Error adding track to vector store: {e}")
    
    def add_album(self, album_data: Dict[str, Any]):
        """Add album to vector store"""
        try:
            searchable_text = f"""
            Album: {album_data.get('title', '')}
            Artist: {album_data.get('artist_name', '')}
            Release Date: {album_data.get('release_date', '')}
            Genres: {', '.join(album_data.get('genres', []))}
            Description: {album_data.get('description', '')}
            Label: {album_data.get('label', '')}
            Track Count: {album_data.get('track_count', 0)}
            """
            
            embedding = self.embeddings.embed_query(searchable_text)
            
            self.albums_collection.add(
                documents=[searchable_text],
                embeddings=[embedding],
                metadatas=[album_data],
                ids=[album_data['id']]
            )
            
        except Exception as e:
            print(f"Error adding album to vector store: {e}")
    
    def search_similar(self, query: str, collection_name: str, n_results: int = 5) -> List[Dict]:
        """Search for similar items in specified collection"""
        try:
            collection = getattr(self, f"{collection_name}_collection")
            query_embedding = self.embeddings.embed_query(query)
            
            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results
            )
            
            return [
                {
                    'metadata': metadata,
                    'document': document,
                    'distance': distance
                }
                for metadata, document, distance in zip(
                    results['metadatas'][0],
                    results['documents'][0],
                    results['distances'][0]
                )
            ]
            
        except Exception as e:
            print(f"Error searching vector store: {e}")
            return []
    
    def find_similar_tracks(self, track_id: str, n_results: int = 5) -> List[Dict]:
        """Find tracks similar to a given track"""
        try:
            track_results = self.tracks_collection.get(ids=[track_id])
            if not track_results['metadatas']:
                return []
            
            track_data = track_results['metadatas'][0]
            
            # Create query based on track characteristics
            query_parts = [
                track_data.get('artist_name', ''),
                ', '.join(track_data.get('genres', [])),
                'energy' if track_data.get('audio_features', {}).get('energy', 0) > 0.7 else 'calm'
            ]
            
            query = ' '.join(filter(None, query_parts))
            
            # Search for similar tracks
            similar = self.search_similar(query, "tracks", n_results + 1)
            
            # Filter out the original track
            return [item for item in similar if item['metadata'].get('id') != track_id][:n_results]
            
        except Exception as e:
            print(f"Error finding similar tracks: {e}")
            return []
    
    def get_tracks_by_artist(self, artist_name: str, limit: int = 20) -> List[Dict]:
        """Get tracks by a specific artist"""
        try:
            results = self.search_similar(f"artist {artist_name}", "tracks", limit * 2)
            # Filter to only include tracks by the specified artist
            return [item for item in results if artist_name.lower() in item['metadata'].get('artist_name', '').lower()][:limit]
        except Exception as e:
            print(f"Error getting tracks by artist: {e}")
            return []
````

````python
# music_analysis_engine.py
from langchain.chat_models import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from vector_store import MusicVectorStore
from music_collectors import MusicDataAggregator
from typing import List, Dict, Any, Optional
from config import Config
import json
from collections import defaultdict
import nltk
from textblob import TextBlob

class MusicAnalysisEngine:
    def __init__(self):
        self.vector_store = MusicVectorStore()
        self.data_aggregator = MusicDataAggregator()
        
        self.chat_model = ChatOpenAI(
            openai_api_key=Config.OPENAI_API_KEY,
            model_name=Config.CHAT_MODEL,
            temperature=0.7
        )
        
        # Initialize NLTK data
        try:
            nltk.data.find('tokenizers/punkt')
        except LookupError:
            nltk.download('punkt')
    
    def populate_vector_store(self):
        """Populate vector store with music data"""
        print("Collecting comprehensive music data...")
        all_data = self.data_aggregator.collect_comprehensive_data()
        
        # Add artists
        for artist in all_data['artists']:
            self.vector_store.add_artist(artist)
        
        # Add albums
        for album in all_data['albums']:
            self.vector_store.add_album(album)
        
        # Add tracks
        for track in all_data['tracks']:
            self.vector_store.add_track(track)
        
        print(f"Added {len(all_data['artists'])} artists, {len(all_data['albums'])} albums, and {len(all_data['tracks'])} tracks")
    
    def get_music_recommendations(self, user_preferences: Dict[str, Any], 
                                num_recommendations: int = 10) -> Dict[str, Any]:
        """Generate personalized music recommendations"""
        try:
            # Build preference query
            preference_query = self._build_preference_query(user_preferences)
            
            # Get artist recommendations
            artist_results = self.vector_store.search_similar(preference_query, "artists", num_recommendations)
            
            # Get track recommendations
            track_results = self.vector_store.search_similar(preference_query, "tracks", num_recommendations)
            
            # Get album recommendations
            album_results = self.vector_store.search_similar(preference_query, "albums", num_recommendations)
            
            # Generate recommendation reasoning
            reasoning = self._generate_recommendation_reasoning(
                user_preferences, artist_results, track_results
            )
            
            return {
                'recommended_artists': [result['metadata'] for result in artist_results],
                'recommended_tracks': [result['metadata'] for result in track_results],
                'recommended_albums': [result['metadata'] for result in album_results],
                'reasoning': reasoning,
                'match_score': self._calculate_match_score(user_preferences, artist_results)
            }
            
        except Exception as e:
            return {'error': f'Error generating recommendations: {e}'}
    
    def _build_preference_query(self, preferences: Dict[str, Any]) -> str:
        """Build search query from user preferences"""
        query_parts = []
        
        # Add favorite genres
        if preferences.get('favorite_genres'):
            query_parts.extend(preferences['favorite_genres'])
        
        # Add favorite artists
        if preferences.get('favorite_artists'):
            query_parts.extend(preferences['favorite_artists'])
        
        # Add mood preferences
        if preferences.get('mood'):
            mood_map = {
                'happy': 'upbeat energetic positive',
                'sad': 'melancholy emotional slow',
                'energetic': 'high-energy dance electronic',
                'relaxed': 'calm peaceful acoustic'
            }
            query_parts.append(mood_map.get(preferences['mood'], preferences['mood']))
        
        return ' '.join(query_parts) if query_parts else 'popular music'
    
    def _generate_recommendation_reasoning(self, preferences: Dict, artists: List[Dict], 
                                         tracks: List[Dict]) -> str:
        """Generate explanation for recommendations"""
        try:
            context = self._prepare_recommendation_context(preferences, artists, tracks)
            
            prompt = f"""
            Based on the user's music preferences and recommended content, explain why these 
            artists and tracks are good matches. Be specific about musical connections.
            
            USER PREFERENCES:
            {json.dumps(preferences, indent=2)}
            
            RECOMMENDED CONTENT:
            {context}
            
            Provide a brief, engaging explanation (2-3 sentences) for why these recommendations 
            match the user's musical taste.
            """
            
            messages = [
                SystemMessage(content="You are a music recommendation expert who explains why certain music matches user preferences."),
                HumanMessage(content=prompt)
            ]
            
            response = self.chat_model(messages)
            return response.content
            
        except Exception as e:
            return "These recommendations are selected based on your musical preferences and listening history."
    
    def _prepare_recommendation_context(self, preferences: Dict, artists: List[Dict], 
                                      tracks: List[Dict]) -> str:
        """Prepare context for recommendation reasoning"""
        context_parts = []
        
        if artists:
            context_parts.append("RECOMMENDED ARTISTS:")
            for artist in artists[:3]:
                metadata = artist['metadata']
                context_parts.append(f"- {metadata.get('name', 'Unknown')}: {', '.join(metadata.get('genres', []))}")
        
        if tracks:
            context_parts.append("\nRECOMMENDED TRACKS:")
            for track in tracks[:3]:
                metadata = track['metadata']
                context_parts.append(f"- {metadata.get('title', 'Unknown')} by {metadata.get('artist_name', 'Unknown')}")
        
        return '\n'.join(context_parts)
    
    def _calculate_match_score(self, preferences: Dict, results: List[Dict]) -> float:
        """Calculate how well recommendations match preferences"""
        if not results or not preferences:
            return 0.5
        
        favorite_genres = set(g.lower() for g in preferences.get('favorite_genres', []))
        total_score = 0
        count = 0
        
        for result in results:
            metadata = result['metadata']
            artist_genres = set(g.lower() for g in metadata.get('genres', []))
            
            if favorite_genres and artist_genres:
                overlap = len(favorite_genres.intersection(artist_genres))
                total_score += overlap / len(favorite_genres)
                count += 1
        
        return total_score / count if count > 0 else 0.5
    
    def analyze_track_lyrics(self, track_id: str) -> Dict[str, Any]:
        """Analyze lyrics of a track"""
        try:
            track_results = self.vector_store.tracks_collection.get(ids=[track_id])
            if not track_results['metadatas']:
                return {'error': 'Track not found'}
            
            track_data = track_results['metadatas'][0]
            lyrics = track_data.get('lyrics')
            
            if not lyrics:
                return {'error': 'No lyrics available for this track'}
            
            # Perform lyrical analysis
            analysis = self._perform_lyrical_analysis(lyrics)
            
            return {
                'track': track_data,
                'lyric_analysis': analysis
            }
            
        except Exception as e:
            return {'error': f'Error analyzing track lyrics: {e}'}
    
    def _perform_lyrical_analysis(self, lyrics: str) -> Dict[str, Any]:
        """Perform detailed lyrical analysis"""
        try:
            # Sentiment analysis
            blob = TextBlob(lyrics)
            sentiment = blob.sentiment
            
            # Extract themes (simplified)
            themes = self._extract_themes(lyrics)
            
            # Language detection
            try:
                language = blob.detect_language()
            except:
                language = 'en'
            
            # Word count and reading level
            words = lyrics.split()
            word_count = len(words)
            
            # Emotion analysis (simplified)
            emotions = self._analyze_emotions(lyrics)
            
            return {
                'sentiment_score': sentiment.polarity,
                'subjectivity': sentiment.subjectivity,
                'themes': themes,
                'language': language,
                'word_count': word_count,
                'emotions': emotions,
                'explicit_content': self._check_explicit_content(lyrics)
            }
            
        except Exception as e:
            print(f"Error in lyrical analysis: {e}")
            return {'error': 'Unable to analyze lyrics'}
    
    def _extract_themes(self, lyrics: str) -> List[str]:
        """Extract themes from lyrics"""
        theme_keywords = {
            'love': ['love', 'heart', 'romance', 'kiss', 'together'],
            'heartbreak': ['broken', 'goodbye', 'alone', 'tears', 'lost'],
            'party': ['party', 'dance', 'night', 'fun', 'celebrate'],
            'social_issues': ['freedom', 'justice', 'change', 'society', 'politics'],
            'personal_growth': ['grow', 'learn', 'change', 'better', 'strength']
        }
        
        lyrics_lower = lyrics.lower()
        found_themes = []
        
        for theme, keywords in theme_keywords.items():
            if any(keyword in lyrics_lower for keyword in keywords):
                found_themes.append(theme)
        
        return found_themes[:5]  # Return top 5 themes
    
    def _analyze_emotions(self, lyrics: str) -> Dict[str, float]:
        """Analyze emotions in lyrics (simplified)"""
        emotion_keywords = {
            'joy': ['happy', 'joy', 'celebrate', 'smile', 'laugh'],
            'sadness': ['sad', 'cry', 'tears', 'pain', 'hurt'],
            'anger': ['angry', 'mad', 'rage', 'hate', 'fight'],
            'fear': ['afraid', 'scared', 'worry', 'anxious', 'fear'],
            'surprise': ['surprise', 'wow', 'amazing', 'unexpected']
        }
        
        lyrics_lower = lyrics.lower()
        emotions = {}
        
        for emotion, keywords in emotion_keywords.items():
            count = sum(1 for keyword in keywords if keyword in lyrics_lower)
            emotions[emotion] = count / len(keywords)
        
        return emotions
    
    def _check_explicit_content(self, lyrics: str) -> bool:
        """Check for explicit content in lyrics"""
        explicit_words = ['fuck', 'shit', 'damn', 'bitch']  # Simplified list
        lyrics_lower = lyrics.lower()
        return any(word in lyrics_lower for word in explicit_words)
    
    def discover_new_music(self, discovery_params: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Discover new music based on parameters"""
        try:
            # Build discovery query
            query_parts = []
            
            if discovery_params.get('genre'):
                query_parts.append(discovery_params['genre'])
            
            if discovery_params.get('mood'):
                query_parts.append(discovery_params['mood'])
            
            if discovery_params.get('era'):
                query_parts.append(discovery_params['era'])
            
            query = ' '.join(query_parts) if query_parts else 'new music discovery'
            
            # Search for artists and tracks
            artist_results = self.vector_store.search_similar(query, "artists", 10)
            track_results = self.vector_store.search_similar(query, "tracks", 10)
            
            # Combine and diversify results
            discoveries = []
            
            # Add diverse artists
            for result in artist_results:
                artist = result['metadata']
                artist['discovery_score'] = 1 - result['distance']
                artist['discovery_type'] = 'artist'
                discoveries.append(artist)
            
            # Add diverse tracks
            for result in track_results:
                track = result['metadata']
                track['discovery_score'] = 1 - result['distance']
                track['discovery_type'] = 'track'
                discoveries.append(track)
            
            # Sort by discovery score and return
            discoveries.sort(key=lambda x: x['discovery_score'], reverse=True)
            return discoveries[:15]
            
        except Exception as e:
            print(f"Error in music discovery: {e}")
            return []
    
    def get_concert_recommendations(self, user_location: str, 
                                  preferred_artists: List[str]) -> List[Dict[str, Any]]:
        """Get concert recommendations based on location and preferences"""
        try:
            # This would typically integrate with ticketing APIs
            # For demo, we'll simulate concert data
            
            sample_concerts = [
                {
                    'id': 'concert_1',
                    'artist_name': 'Taylor Swift',
                    'venue': 'Madison Square Garden',
                    'city': 'New York',
                    'date': '2024-06-15',
                    'ticket_url': 'https://ticketmaster.com/taylor-swift',
                    'price_range': '$150-$500'
                },
                {
                    'id': 'concert_2',
                    'artist_name': 'The Beatles Tribute',
                    'venue': 'Hollywood Bowl',
                    'city': 'Los Angeles',
                    'date': '2024-07-20',
                    'ticket_url': 'https://ticketmaster.com/beatles-tribute',
                    'price_range': '$50-$200'
                }
            ]
            
            # Filter by user preferences
            recommended_concerts = []
            for concert in sample_concerts:
                if any(artist.lower() in concert['artist_name'].lower() 
                      for artist in preferred_artists):
                    concert['match_reason'] = 'Matches your favorite artists'
                    recommended_concerts.append(concert)
            
            return recommended_concerts
            
        except Exception as e:
            print(f"Error getting concert recommendations: {e}")
            return []
````

````python
# api.py
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
from music_analysis_engine import MusicAnalysisEngine
import uvicorn
from datetime import datetime

app = FastAPI(title="Music Discovery and Analysis Platform", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize music engine
music_engine = MusicAnalysisEngine()

class UserPreferences(BaseModel):
    favorite_genres: List[str]
    favorite_artists: Optional[List[str]] = []
    mood: Optional[str] = None
    preferred_era: Optional[str] = None

class DiscoveryParams(BaseModel):
    genre: Optional[str] = None
    mood: Optional[str] = None
    era: Optional[str] = None
    limit: int = 15

@app.on_event("startup")
async def startup_event():
    print("Initializing Music Discovery and Analysis Platform...")
    music_engine.populate_vector_store()
    print("System initialized successfully!")

@app.get("/")
async def root():
    return {"message": "Music Discovery and Analysis Platform API"}

@app.post("/recommendations")
async def get_recommendations(preferences: UserPreferences):
    """Get personalized music recommendations"""
    try:
        recommendations = music_engine.get_music_recommendations(
            preferences.dict(), 10
        )
        
        if 'error' in recommendations:
            raise HTTPException(status_code=400, detail=recommendations['error'])
        
        return {
            "recommendations": recommendations,
            "generated_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/search/artists")
async def search_artists(
    query: str = Query(..., description="Search query"),
    limit: int = Query(10, ge=1, le=50)
):
    """Search for artists"""
    try:
        results = music_engine.vector_store.search_similar(query, "artists", limit)
        
        artists = []
        for result in results:
            artist = result['metadata']
            artist['relevance_score'] = 1 - result['distance']
            artists.append(artist)
        
        return {
            "query": query,
            "artists": artists,
            "total_found": len(artists)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/search/tracks")
async def search_tracks(
    query: str = Query(..., description="Search query"),
    limit: int = Query(10, ge=1, le=50)
):
    """Search for tracks"""
    try:
        results = music_engine.vector_store.search_similar(query, "tracks", limit)
        
        tracks = []
        for result in results:
            track = result['metadata']
            track['relevance_score'] = 1 - result['distance']
            tracks.append(track)
        
        return {
            "query": query,
            "tracks": tracks,
            "total_found": len(tracks)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tracks/{track_id}/analysis")
async def analyze_track(track_id: str):
    """Get comprehensive analysis of a track"""
    try:
        analysis = music_engine.analyze_track_lyrics(track_id)
        
        if 'error' in analysis:
            raise HTTPException(status_code=404, detail=analysis['error'])
        
        return {
            "track_id": track_id,
            "analysis": analysis,
            "analyzed_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tracks/{track_id}/similar")
async def get_similar_tracks(
    track_id: str,
    limit: int = Query(5, ge=1, le=20)
):
    """Get tracks similar to a specific track"""
    try:
        similar_tracks = music_engine.vector_store.find_similar_tracks(track_id, limit)
        
        tracks = []
        for result in similar_tracks:
            track = result['metadata']
            track['similarity_score'] = 1 - result['distance']
            tracks.append(track)
        
        return {
            "track_id": track_id,
            "similar_tracks": tracks,
            "total_found": len(tracks)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/discover")
async def discover_music(params: DiscoveryParams):
    """Discover new music based on parameters"""
    try:
        discoveries = music_engine.discover_new_music(params.dict())
        
        return {
            "discovery_params": params.dict(),
            "discoveries": discoveries,
            "total_found": len(discoveries)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/artists/{artist_name}/tracks")
async def get_artist_tracks(artist_name: str):
    """Get tracks by a specific artist"""
    try:
        tracks = music_engine.vector_store.get_tracks_by_artist(artist_name, 20)
        
        track_list = []
        for result in tracks:
            track = result['metadata']
            track['relevance_score'] = 1 - result['distance']
            track_list.append(track)
        
        return {
            "artist": artist_name,
            "tracks": track_list,
            "total_found": len(track_list)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/concerts")
async def get_concert_recommendations(
    location: str = Query(..., description="User location"),
    artists: List[str] = Query([], description="Preferred artists")
):
    """Get concert recommendations"""
    try:
        concerts = music_engine.get_concert_recommendations(location, artists)
        
        return {
            "location": location,
            "preferred_artists": artists,
            "concerts": concerts,
            "total_found": len(concerts)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/genres")
async def get_supported_genres():
    """Get list of supported music genres"""
    return {
        "genres": Config.SUPPORTED_GENRES,
        "description": "Supported music genres for search and recommendations"
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "Music Discovery and Analysis Platform"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````python
# main.py
from api import app
from music_analysis_engine import MusicAnalysisEngine

def demo_music_platform():
    """Demonstrate music discovery and analysis capabilities"""
    engine = MusicAnalysisEngine()
    
    print("="*60)
    print("MUSIC DISCOVERY AND ANALYSIS PLATFORM DEMO")
    print("="*60)
    
    # Initialize system
    print("Initializing music platform...")
    engine.populate_vector_store()
    
    # Demo 1: Personalized Recommendations
    print("\n1. PERSONALIZED MUSIC RECOMMENDATIONS")
    print("-" * 40)
    
    sample_preferences = {
        'favorite_genres': ['rock', 'pop'],
        'favorite_artists': ['The Beatles'],
        'mood': 'energetic'
    }
    
    recommendations = engine.get_music_recommendations(sample_preferences, 5)
    
    if 'error' not in recommendations:
        print("User Preferences: Rock, Pop, The Beatles, Energetic mood")
        print(f"Match Score: {recommendations.get('match_score', 0):.2f}")
        print(f"Reasoning: {recommendations.get('reasoning', 'No reasoning provided')}")
        
        print("\nRecommended Artists:")
        for i, artist in enumerate(recommendations.get('recommended_artists', [])[:3], 1):
            print(f"  {i}. {artist.get('name', 'Unknown')}")
            print(f"     Genres: {', '.join(artist.get('genres', []))}")
        
        print("\nRecommended Tracks:")
        for i, track in enumerate(recommendations.get('recommended_tracks', [])[:3], 1):
            print(f"  {i}. {track.get('title', 'Unknown')} by {track.get('artist_name', 'Unknown')}")
    
    # Demo 2: Lyric Analysis
    print("\n\n2. LYRIC ANALYSIS")
    print("-" * 40)
    
    analysis = engine.analyze_track_lyrics('come_together')
    
    if 'error' not in analysis:
        track = analysis['track']
        lyric_analysis = analysis['lyric_analysis']
        
        print(f"Track: {track.get('title', 'Unknown')} by {track.get('artist_name', 'Unknown')}")
        print(f"Sentiment Score: {lyric_analysis.get('sentiment_score', 0):.2f}")
        print(f"Themes: {', '.join(lyric_analysis.get('themes', []))}")
        print(f"Word Count: {lyric_analysis.get('word_count', 0)}")
        print(f"Language: {lyric_analysis.get('language', 'unknown')}")
    
    # Demo 3: Music Discovery
    print("\n\n3. MUSIC DISCOVERY")
    print("-" * 40)
    
    discovery_params = {
        'genre': 'rock',
        'mood': 'energetic',
        'era': '1960s'
    }
    
    discoveries = engine.discover_new_music(discovery_params)
    
    print("Discovery Parameters: Rock, Energetic, 1960s")
    print("Discovered Music:")
    for i, item in enumerate(discoveries[:5], 1):
        item_type = item.get('discovery_type', 'unknown')
        if item_type == 'artist':
            print(f"  {i}. Artist: {item.get('name', 'Unknown')}")
            print(f"     Genres: {', '.join(item.get('genres', []))}")
        else:
            print(f"  {i}. Track: {item.get('title', 'Unknown')} by {item.get('artist_name', 'Unknown')}")
        print(f"     Discovery Score: {item.get('discovery_score', 0):.2f}")
    
    # Demo 4: Similar Tracks
    print("\n\n4. SIMILAR TRACK DISCOVERY")
    print("-" * 40)
    
    similar_tracks = engine.vector_store.find_similar_tracks('come_together', 3)
    
    print("Base Track: Come Together by The Beatles")
    print("Similar Tracks:")
    for i, result in enumerate(similar_tracks, 1):
        track = result['metadata']
        print(f"  {i}. {track.get('title', 'Unknown')} by {track.get('artist_name', 'Unknown')}")
        print(f"     Similarity: {1 - result['distance']:.2f}")
    
    # Demo 5: Concert Recommendations
    print("\n\n5. CONCERT RECOMMENDATIONS")
    print("-" * 40)
    
    concerts = engine.get_concert_recommendations('New York', ['Taylor Swift', 'The Beatles'])
    
    print("Location: New York")
    print("Preferred Artists: Taylor Swift, The Beatles")
    print("Recommended Concerts:")
    for i, concert in enumerate(concerts, 1):
        print(f"  {i}. {concert.get('artist_name', 'Unknown')}")
        print(f"     Venue: {concert.get('venue', 'Unknown')}")
        print(f"     Date: {concert.get('date', 'Unknown')}")
        print(f"     Price Range: {concert.get('price_range', 'Unknown')}")

def run_api_demo():
    """Run the API server"""
    import uvicorn
    print("\n" + "="*60)
    print("STARTING API SERVER")
    print("="*60)
    print("Visit http://localhost:8000/docs for interactive API documentation")
    print("Available endpoints:")
    print("  - POST /recommendations - Get personalized recommendations")
    print("  - GET /search/artists - Search artists")
    print("  - GET /search/tracks - Search tracks")
    print("  - GET /tracks/{id}/analysis - Analyze track lyrics")
    print("  - GET /tracks/{id}/similar - Find similar tracks")
    print("  - POST /discover - Discover new music")
    print("  - GET /concerts - Get concert recommendations")
    
    uvicorn.run(app, host="0.0.0.0", port=8000)

if __name__ == "__main__":
    # Run music platform demo
    demo_music_platform()
    
    # Ask user if they want to start the API server
    response = input("\nWould you like to start the API server? (y/n): ")
    if response.lower() in ['y', 'yes']:
        run_api_demo()
    else:
        print("Demo completed. Keep discovering great music!")
````

## Project Summary

The **Music Discovery and Analysis Platform** represents a sophisticated application of RAG technology in music recommendation and analysis, combining comprehensive music databases with intelligent analysis capabilities to revolutionize how users discover, understand, and interact with music.

### **Key Value Propositions**

1. **Intelligent Music Discovery**: Leverages RAG architecture to enable natural language music search, mood-based recommendations, and sophisticated similarity matching that goes beyond simple genre classification.

2. **Comprehensive Music Analysis**: Provides deep insights into songs, albums, and artists including lyrical analysis, audio feature extraction, and cultural context understanding.

3. **Multi-Platform Integration**: Successfully integrates data from major music platforms (Spotify, Last.fm) while maintaining platform-agnostic analysis capabilities.

4. **Personalized Recommendation Engine**: Delivers tailored music suggestions through advanced preference learning and contextual recommendation algorithms.

5. **Cultural and Educational Context**: Connects users to music history, artist influences, and cultural significance for enhanced music appreciation.

### **Key Takeaways**

- **Advanced Audio Analysis**: Demonstrates integration of audio feature analysis with textual content for comprehensive music understanding
- **Scalable Content Management**: Built with modern frameworks ensuring efficient handling of large-scale music catalogs and real-time processing
- **Multi-Modal Data Integration**: Combines audio features, lyrics, metadata, and user preferences in a unified RAG system
- **Intelligent Recommendation System**: Balances personalization with music discovery to avoid filter bubbles while maintaining relevance
- **Cultural Context Enhancement**: Provides educational value by connecting music to broader cultural and historical contexts

This platform showcases how RAG technology can transform music discovery from simple keyword matching to intelligent, contextual recommendations that understand musical nuances, user preferences, and cultural significance, significantly enhancing the music listening and discovery experience while supporting both mainstream and independent artists.