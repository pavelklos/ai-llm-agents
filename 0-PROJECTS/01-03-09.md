<small>Claude Sonnet 4 **(Dynamic Storytelling & Interactive Fiction Platform - Immersive Narrative Experience Engine)**</small>
# Dynamic Storytelling & Interactive Fiction Platform

## Key Concepts Explanation

### Model Context Protocol (MCP) for Storytelling
Advanced narrative context management framework that maintains comprehensive story worlds, character development arcs, plot consistency, narrative themes, and user choices across complex interactive storytelling sessions, enabling persistent narrative coherence and intelligent adaptation to user decisions while preserving story quality and emotional engagement.

### Narrative Generation Systems
Sophisticated AI-powered story creation engines that generate dynamic, contextually-aware narratives through advanced language models, plot structure algorithms, and character development systems, creating compelling stories that adapt to user choices while maintaining narrative consistency, emotional depth, and literary quality across multiple story paths.

### User-Driven Plotlines
Interactive narrative systems that allow users to influence story direction, character decisions, and plot outcomes through meaningful choices, branching storylines, and dynamic plot adaptation, creating personalized storytelling experiences where user agency shapes narrative development while maintaining story coherence and dramatic tension.

### MCP Memory Layers for Stories
Multi-layered memory architecture that manages story world state, character memories, plot progression, user choice history, and narrative consequences across extended storytelling sessions, enabling complex narrative continuity, character consistency, and long-term story arc development that responds intelligently to accumulated narrative context.

### Stable Diffusion Integration
Advanced AI image generation system integrated with narrative content to create dynamic visual storytelling experiences, generating contextually-appropriate artwork, character portraits, scene illustrations, and atmospheric visuals that enhance narrative immersion and provide visual representation of story elements in real-time.

## Comprehensive Project Explanation

The Dynamic Storytelling & Interactive Fiction Platform revolutionizes digital narrative experiences by creating intelligent, adaptive storytelling ecosystems that combine sophisticated narrative generation, user agency, visual content creation, and MCP-driven context management to deliver personalized, immersive story experiences that evolve dynamically based on user choices and preferences.

### Objectives
- **Intelligent Narrative Creation**: Develop sophisticated story generation systems that create compelling, coherent narratives with complex plot structures, well-developed characters, and emotional depth while maintaining literary quality and narrative consistency across multiple story paths and user interactions
- **Dynamic User Agency**: Create meaningful choice systems that allow users to influence story direction, character development, and plot outcomes while ensuring that user decisions have genuine narrative consequences and contribute to personalized storytelling experiences
- **Persistent Story Worlds**: Build comprehensive world-state management systems that maintain story continuity, character memories, and plot progression across extended sessions while enabling complex narrative relationships and long-term story arc development
- **Visual Narrative Enhancement**: Integrate advanced image generation capabilities that create dynamic visual content synchronized with narrative progression, providing immersive visual storytelling that adapts to story context and user choices
- **Adaptive Storytelling Intelligence**: Implement sophisticated narrative adaptation systems that learn from user preferences, choice patterns, and engagement metrics to create increasingly personalized and compelling storytelling experiences

### Challenges
- **Narrative Coherence**: Maintaining story consistency, character development, and plot logic across multiple branching storylines while accommodating user choices that may conflict with established narrative elements or character motivations
- **Real-Time Story Generation**: Creating high-quality narrative content in real-time while processing user input, maintaining story context, and generating appropriate visual content without compromising storytelling quality or user experience
- **Choice Consequence Systems**: Designing meaningful choice systems where user decisions have genuine narrative impact while avoiding choice paralysis and ensuring that all story paths remain engaging and well-developed
- **Memory Management Complexity**: Managing vast amounts of story state, character information, and user choice history while maintaining performance and enabling complex narrative relationships and long-term consequences
- **Visual-Narrative Synchronization**: Coordinating dynamic image generation with narrative content to ensure visual consistency, appropriate tone, and enhanced storytelling without disrupting narrative flow or user immersion

### Potential Impact
This platform could transform digital storytelling by providing personalized, immersive narrative experiences that combine literary quality with user agency, democratizing storytelling creation, enhancing narrative engagement, and creating new forms of interactive entertainment and educational content.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import logging
import re
import uuid
import hashlib
from typing import Dict, List, Optional, Any, Union, Tuple, Set, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
import numpy as np
import pandas as pd
from collections import defaultdict, deque
import pickle
from enum import Enum
import random

# Core AI and ML libraries
import openai
from openai import AsyncOpenAI
import anthropic
from sentence_transformers import SentenceTransformer
import torch
import torch.nn.functional as F

# LangChain for advanced LLM operations
from langchain.chat_models import ChatOpenAI
from langchain.embeddings import OpenAIEmbeddings
from langchain.prompts import PromptTemplate, ChatPromptTemplate
from langchain.schema import Document, BaseMessage, HumanMessage, AIMessage
from langchain.vectorstores import FAISS, Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.memory import ConversationBufferWindowMemory, ConversationSummaryBufferMemory
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import Tool

# Image generation
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
from PIL import Image, ImageEnhance, ImageFilter
import torch
import requests
from io import BytesIO
import base64

# NLP and text processing
import spacy
import nltk
from textstat import flesch_reading_ease, automated_readability_index
from transformers import pipeline, AutoTokenizer, AutoModel

# Vector storage and similarity
import chromadb
import faiss

# Database and persistence
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, DateTime, Text, JSON, Integer, Boolean, Float, LargeBinary

# Web framework and real-time features
from fastapi import FastAPI, WebSocket, HTTPException, BackgroundTasks, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, StreamingResponse, FileResponse
from fastapi.staticfiles import StaticFiles
import uvicorn
import websockets

# Game mechanics and story structure
import networkx as nx
from scipy.sparse import csr_matrix
from sklearn.metrics.pairwise import cosine_similarity

# Audio generation (optional)
import gtts
from pydub import AudioSegment

import warnings
warnings.filterwarnings('ignore')

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Ensure required downloads
try:
    nltk.download('punkt', quiet=True)
    nltk.download('vader_lexicon', quiet=True)
except:
    pass

# Database Models
Base = declarative_base()

class StoryWorld(Base):
    __tablename__ = "story_worlds"
    
    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    genre = Column(String)
    setting = Column(JSON)
    theme = Column(String)
    tone = Column(String)
    world_rules = Column(JSON)
    character_templates = Column(JSON)
    plot_templates = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    creator_id = Column(String)
    is_public = Column(Boolean, default=False)

class StorySession(Base):
    __tablename__ = "story_sessions"
    
    id = Column(String, primary_key=True)
    world_id = Column(String, nullable=False)
    user_id = Column(String, nullable=False)
    story_state = Column(JSON)
    character_states = Column(JSON)
    plot_progress = Column(JSON)
    choice_history = Column(JSON)
    current_scene = Column(String)
    session_start = Column(DateTime, default=datetime.utcnow)
    last_activity = Column(DateTime)
    story_summary = Column(Text)
    user_preferences = Column(JSON)

class StoryScene(Base):
    __tablename__ = "story_scenes"
    
    id = Column(String, primary_key=True)
    session_id = Column(String, nullable=False)
    scene_number = Column(Integer)
    narrative_text = Column(Text)
    choices_offered = Column(JSON)
    user_choice = Column(JSON)
    scene_context = Column(JSON)
    generated_image = Column(String)  # Image path/URL
    emotional_tone = Column(String)
    character_present = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

class Character(Base):
    __tablename__ = "characters"
    
    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    world_id = Column(String)
    personality = Column(JSON)
    appearance = Column(JSON)
    background = Column(Text)
    relationships = Column(JSON)
    goals = Column(JSON)
    current_state = Column(JSON)
    dialogue_style = Column(JSON)
    character_arc = Column(JSON)

class StoryTemplate(Base):
    __tablename__ = "story_templates"
    
    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    genre = Column(String)
    plot_structure = Column(JSON)
    key_scenes = Column(JSON)
    character_archetypes = Column(JSON)
    conflict_types = Column(JSON)
    resolution_patterns = Column(JSON)
    usage_count = Column(Integer, default=0)

# Enums and Data Classes
class StoryGenre(Enum):
    FANTASY = "fantasy"
    SCIFI = "science_fiction"
    MYSTERY = "mystery"
    ROMANCE = "romance"
    HORROR = "horror"
    ADVENTURE = "adventure"
    DRAMA = "drama"
    COMEDY = "comedy"

class EmotionalTone(Enum):
    JOYFUL = "joyful"
    MELANCHOLIC = "melancholic"
    TENSE = "tense"
    PEACEFUL = "peaceful"
    MYSTERIOUS = "mysterious"
    ROMANTIC = "romantic"
    DARK = "dark"
    HOPEFUL = "hopeful"

@dataclass
class StoryChoice:
    text: str
    consequences: Dict[str, Any]
    emotional_impact: str
    character_reactions: Dict[str, str]
    plot_advancement: Dict[str, Any]

@dataclass
class SceneContext:
    location: str
    time: str
    characters_present: List[str]
    mood: str
    plot_points: List[str]
    user_state: Dict[str, Any]

@dataclass
class NarrativeRequest:
    scene_context: SceneContext
    user_choice: Optional[StoryChoice]
    story_history: List[str]
    character_states: Dict[str, Any]
    preferred_tone: str
    generate_image: bool = True

class MCPStorytellingManager:
    """MCP-based storytelling context management"""
    
    def __init__(self, session_factory):
        self.session_factory = session_factory
        self.story_contexts = {}
        self.narrative_memory = {}
        self.character_memories = defaultdict(dict)
        self.plot_threads = defaultdict(list)
        self.user_preferences = {}
        self.choice_consequences = defaultdict(list)
        
        # Initialize memory layers
        self.short_term_memory = defaultdict(deque)  # Recent events
        self.medium_term_memory = defaultdict(dict)  # Character relationships, current plot
        self.long_term_memory = defaultdict(dict)    # World state, character arcs
        
    async def create_story_context(self, user_id: str, world_config: Dict[str, Any]) -> str:
        """Create comprehensive storytelling context"""
        try:
            context_id = str(uuid.uuid4())
            
            self.story_contexts[user_id] = {
                "context_id": context_id,
                "world_config": world_config,
                "narrative_style": world_config.get("narrative_style", {}),
                "character_focus": world_config.get("character_focus", "balanced"),
                "plot_complexity": world_config.get("plot_complexity", "medium"),
                "user_agency_level": world_config.get("user_agency", "high"),
                "story_progression": {
                    "current_act": 1,
                    "scene_count": 0,
                    "major_plot_points": [],
                    "character_arcs": {},
                    "unresolved_threads": []
                },
                "emotional_journey": deque(maxlen=20),
                "choice_patterns": defaultdict(int),
                "engagement_metrics": {
                    "choice_time": [],
                    "scene_ratings": [],
                    "completion_rate": 0.0
                }
            }
            
            # Initialize memory layers for this story
            self.short_term_memory[context_id] = deque(maxlen=10)
            self.medium_term_memory[context_id] = {
                "active_characters": {},
                "current_conflicts": [],
                "recent_choices": deque(maxlen=5),
                "scene_continuity": {}
            }
            self.long_term_memory[context_id] = {
                "world_state": world_config.get("initial_state", {}),
                "character_relationships": {},
                "major_events": [],
                "user_impact": {}
            }
            
            logger.info(f"Created storytelling context for {user_id}")
            return context_id
            
        except Exception as e:
            logger.error(f"Story context creation failed: {e}")
            raise
    
    async def update_story_context(self, context_id: str, scene_data: Dict[str, Any]):
        """Update story context with new scene information"""
        try:
            # Update short-term memory
            self.short_term_memory[context_id].append({
                "timestamp": datetime.utcnow(),
                "event": scene_data.get("narrative_summary", ""),
                "characters": scene_data.get("characters_present", []),
                "user_choice": scene_data.get("user_choice", {}),
                "emotional_impact": scene_data.get("emotional_tone", "neutral")
            })
            
            # Update medium-term memory
            medium_memory = self.medium_term_memory[context_id]
            
            # Update character states
            for char_id, char_state in scene_data.get("character_updates", {}).items():
                if char_id not in medium_memory["active_characters"]:
                    medium_memory["active_characters"][char_id] = {}
                medium_memory["active_characters"][char_id].update(char_state)
            
            # Track conflicts
            if "new_conflicts" in scene_data:
                medium_memory["current_conflicts"].extend(scene_data["new_conflicts"])
            
            if "resolved_conflicts" in scene_data:
                for resolved in scene_data["resolved_conflicts"]:
                    if resolved in medium_memory["current_conflicts"]:
                        medium_memory["current_conflicts"].remove(resolved)
            
            # Update long-term memory for significant events
            if scene_data.get("significance_level", 0) > 0.7:
                self.long_term_memory[context_id]["major_events"].append({
                    "event": scene_data.get("narrative_summary", ""),
                    "timestamp": datetime.utcnow(),
                    "impact_level": scene_data.get("significance_level", 0),
                    "characters_affected": scene_data.get("characters_present", [])
                })
            
        except Exception as e:
            logger.error(f"Story context update failed: {e}")
    
    async def get_narrative_context(self, context_id: str) -> Dict[str, Any]:
        """Get comprehensive narrative context for story generation"""
        try:
            if context_id not in self.short_term_memory:
                return {}
            
            # Compile context from all memory layers
            context = {
                "recent_events": list(self.short_term_memory[context_id]),
                "active_characters": self.medium_term_memory[context_id]["active_characters"],
                "current_conflicts": self.medium_term_memory[context_id]["current_conflicts"],
                "world_state": self.long_term_memory[context_id]["world_state"],
                "major_events": self.long_term_memory[context_id]["major_events"][-5:],  # Last 5 major events
                "character_relationships": self.long_term_memory[context_id]["character_relationships"]
            }
            
            return context
            
        except Exception as e:
            logger.error(f"Context retrieval failed: {e}")
            return {}
    
    def analyze_choice_patterns(self, user_id: str) -> Dict[str, Any]:
        """Analyze user choice patterns for story adaptation"""
        if user_id not in self.story_contexts:
            return {}
        
        context = self.story_contexts[user_id]
        choice_patterns = context["choice_patterns"]
        
        # Determine user preferences
        total_choices = sum(choice_patterns.values())
        if total_choices == 0:
            return {"preference_profile": "unknown"}
        
        preferences = {
            "action_preference": choice_patterns.get("action", 0) / total_choices,
            "dialogue_preference": choice_patterns.get("dialogue", 0) / total_choices,
            "exploration_preference": choice_patterns.get("exploration", 0) / total_choices,
            "conflict_preference": choice_patterns.get("conflict", 0) / total_choices,
            "cooperation_preference": choice_patterns.get("cooperation", 0) / total_choices
        }
        
        # Determine dominant preference
        dominant_pref = max(preferences.items(), key=lambda x: x[1])
        
        return {
            "preference_profile": dominant_pref[0],
            "preferences": preferences,
            "total_choices": total_choices
        }

class AdvancedNarrativeGenerator:
    """AI-powered narrative generation with literary quality"""
    
    def __init__(self, mcp_manager: MCPStorytellingManager):
        self.mcp_manager = mcp_manager
        
        # Initialize LLM for narrative generation
        self.narrative_llm = ChatOpenAI(
            model_name="gpt-4",
            temperature=0.8,
            max_tokens=1000
        )
        
        # Character dialogue LLM (more creative)
        self.dialogue_llm = ChatOpenAI(
            model_name="gpt-4",
            temperature=0.9,
            max_tokens=500
        )
        
        # Story structure analyzer
        self.sentence_embedder = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')
        
        # Load story templates and patterns
        self.story_templates = self._load_story_templates()
        self.character_archetypes = self._load_character_archetypes()
        self.plot_patterns = self._load_plot_patterns()
        
    def _load_story_templates(self) -> Dict[str, Any]:
        """Load story structure templates"""
        return {
            "three_act": {
                "act1": {"setup": 0.25, "inciting_incident": 0.15},
                "act2": {"rising_action": 0.35, "midpoint": 0.15, "climax_build": 0.10},
                "act3": {"climax": 0.15, "resolution": 0.10}
            },
            "hero_journey": {
                "ordinary_world": 0.10,
                "call_to_adventure": 0.10,
                "crossing_threshold": 0.15,
                "tests_trials": 0.25,
                "revelation": 0.15,
                "transformation": 0.15,
                "return": 0.10
            },
            "mystery": {
                "crime_discovery": 0.15,
                "investigation": 0.40,
                "red_herrings": 0.20,
                "revelation": 0.15,
                "resolution": 0.10
            }
        }
    
    def _load_character_archetypes(self) -> Dict[str, Any]:
        """Load character archetype definitions"""
        return {
            "hero": {
                "traits": ["brave", "determined", "moral"],
                "arc": "growth through challenge",
                "dialogue_style": "direct, inspiring"
            },
            "mentor": {
                "traits": ["wise", "experienced", "guiding"],
                "arc": "support and sacrifice",
                "dialogue_style": "thoughtful, metaphorical"
            },
            "trickster": {
                "traits": ["clever", "unpredictable", "humorous"],
                "arc": "catalyst for change",
                "dialogue_style": "witty, indirect"
            },
            "villain": {
                "traits": ["ambitious", "ruthless", "charismatic"],
                "arc": "corruption and downfall",
                "dialogue_style": "persuasive, threatening"
            }
        }
    
    async def generate_scene_narrative(self, request: NarrativeRequest, 
                                     context_id: str) -> Dict[str, Any]:
        """Generate narrative for a new scene"""
        try:
            # Get narrative context
            narrative_context = await self.mcp_manager.get_narrative_context(context_id)
            
            # Analyze story progression
            story_analysis = await self._analyze_story_progression(
                narrative_context, request.story_history
            )
            
            # Generate scene content
            scene_content = await self._generate_scene_content(
                request, narrative_context, story_analysis
            )
            
            # Generate choices
            choices = await self._generate_meaningful_choices(
                scene_content, request.scene_context, narrative_context
            )
            
            # Calculate narrative quality metrics
            quality_metrics = await self._assess_narrative_quality(scene_content)
            
            return {
                "narrative_text": scene_content["narrative"],
                "choices": choices,
                "scene_analysis": story_analysis,
                "quality_metrics": quality_metrics,
                "emotional_tone": scene_content["emotional_tone"],
                "characters_present": scene_content["characters_present"],
                "plot_advancement": scene_content["plot_advancement"]
            }
            
        except Exception as e:
            logger.error(f"Scene generation failed: {e}")
            return self._generate_fallback_scene(request)
    
    async def _generate_scene_content(self, request: NarrativeRequest,
                                    narrative_context: Dict[str, Any],
                                    story_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Generate the main narrative content for a scene"""
        try:
            # Build context prompt
            context_summary = self._build_context_summary(narrative_context, request.story_history)
            
            # Determine scene focus based on story progression
            scene_focus = story_analysis.get("recommended_focus", "character")
            
            # Create narrative prompt
            narrative_prompt = f"""
            Create a compelling narrative scene for an interactive story.
            
            Story Context:
            {context_summary}
            
            Current Scene Context:
            - Location: {request.scene_context.location}
            - Time: {request.scene_context.time}
            - Characters Present: {', '.join(request.scene_context.characters_present)}
            - Mood: {request.scene_context.mood}
            - Current Plot Points: {', '.join(request.scene_context.plot_points)}
            
            Previous User Choice: {request.user_choice.text if request.user_choice else "Story beginning"}
            
            Scene Focus: {scene_focus}
            Preferred Tone: {request.preferred_tone}
            
            Requirements:
            1. Write 2-3 paragraphs of engaging narrative prose
            2. Maintain consistency with established story elements
            3. Include sensory details and emotional depth
            4. Advance the plot meaningfully
            5. Create natural opportunities for user choices
            6. Match the tone and style of previous scenes
            
            Write the narrative scene:
            """
            
            # Generate narrative
            response = await self.narrative_llm.agenerate([[{"role": "user", "content": narrative_prompt}]])
            narrative_text = response.generations[0][0].text.strip()
            
            # Extract emotional tone
            emotional_tone = await self._analyze_emotional_tone(narrative_text)
            
            return {
                "narrative": narrative_text,
                "emotional_tone": emotional_tone,
                "characters_present": request.scene_context.characters_present,
                "plot_advancement": story_analysis.get("plot_advancement", {})
            }
            
        except Exception as e:
            logger.error(f"Scene content generation failed: {e}")
            return {
                "narrative": "The story continues as you make your next choice...",
                "emotional_tone": "neutral",
                "characters_present": [],
                "plot_advancement": {}
            }
    
    async def _generate_meaningful_choices(self, scene_content: Dict[str, Any],
                                         scene_context: SceneContext,
                                         narrative_context: Dict[str, Any]) -> List[StoryChoice]:
        """Generate meaningful choices that impact the story"""
        try:
            # Analyze current situation for choice generation
            choice_prompt = f"""
            Based on this narrative scene, generate 3-4 meaningful choices for the user.
            
            Scene Narrative:
            {scene_content['narrative']}
            
            Scene Context:
            - Location: {scene_context.location}
            - Characters: {', '.join(scene_context.characters_present)}
            - Current Conflicts: {narrative_context.get('current_conflicts', [])}
            
            Requirements for each choice:
            1. Should have meaningful consequences
            2. Reflect different approaches (action, dialogue, introspection, etc.)
            3. Maintain character consistency
            4. Advance plot or character development
            5. Provide genuine agency to the user
            
            Format each choice as:
            Choice: [brief description]
            Type: [action/dialogue/exploration/conflict/cooperation]
            Consequences: [brief description of likely outcomes]
            
            Generate the choices:
            """
            
            response = await self.dialogue_llm.agenerate([[{"role": "user", "content": choice_prompt}]])
            choices_text = response.generations[0][0].text.strip()
            
            # Parse choices
            choices = self._parse_generated_choices(choices_text)
            
            return choices
            
        except Exception as e:
            logger.error(f"Choice generation failed: {e}")
            return self._generate_default_choices()
    
    def _parse_generated_choices(self, choices_text: str) -> List[StoryChoice]:
        """Parse LLM-generated choices into structured format"""
        choices = []
        
        # Simple parsing of choice format
        choice_blocks = re.split(r'\n\s*Choice:', choices_text)
        
        for block in choice_blocks[1:]:  # Skip first empty block
            lines = block.strip().split('\n')
            if len(lines) >= 3:
                choice_text = lines[0].strip()
                choice_type = "action"  # Default
                consequences = {}
                
                for line in lines[1:]:
                    if line.strip().startswith("Type:"):
                        choice_type = line.split(":", 1)[1].strip()
                    elif line.strip().startswith("Consequences:"):
                        consequences["description"] = line.split(":", 1)[1].strip()
                
                choices.append(StoryChoice(
                    text=choice_text,
                    consequences=consequences,
                    emotional_impact="neutral",
                    character_reactions={},
                    plot_advancement={"type": choice_type}
                ))
        
        return choices[:4]  # Limit to 4 choices
    
    def _generate_default_choices(self) -> List[StoryChoice]:
        """Generate default choices when parsing fails"""
        return [
            StoryChoice(
                text="Continue forward",
                consequences={"description": "Move the story forward"},
                emotional_impact="neutral",
                character_reactions={},
                plot_advancement={"type": "action"}
            ),
            StoryChoice(
                text="Look around carefully",
                consequences={"description": "Gather more information"},
                emotional_impact="curious",
                character_reactions={},
                plot_advancement={"type": "exploration"}
            ),
            StoryChoice(
                text="Talk to someone nearby",
                consequences={"description": "Engage in dialogue"},
                emotional_impact="social",
                character_reactions={},
                plot_advancement={"type": "dialogue"}
            )
        ]

class VisualStorytellingEngine:
    """Stable Diffusion integration for story visualization"""
    
    def __init__(self):
        self.image_generator = None
        self.image_cache = {}
        self.style_presets = self._load_style_presets()
        self.character_consistency = {}
        
        # Initialize image generation pipeline
        asyncio.create_task(self._initialize_image_generator())
    
    async def _initialize_image_generator(self):
        """Initialize Stable Diffusion pipeline"""
        try:
            # Using a lighter model for demo purposes
            model_id = "runwayml/stable-diffusion-v1-5"
            
            self.image_generator = StableDiffusionPipeline.from_pretrained(
                model_id,
                torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32,
                safety_checker=None,
                requires_safety_checker=False
            )
            
            if torch.cuda.is_available():
                self.image_generator = self.image_generator.to("cuda")
            
            # Optimize for speed
            self.image_generator.scheduler = DPMSolverMultistepScheduler.from_config(
                self.image_generator.scheduler.config
            )
            
            logger.info("Image generation pipeline initialized")
            
        except Exception as e:
            logger.error(f"Image generator initialization failed: {e}")
            self.image_generator = None
    
    def _load_style_presets(self) -> Dict[str, str]:
        """Load artistic style presets for different genres"""
        return {
            "fantasy": "fantasy art, magical, ethereal, detailed fantasy landscape, mystical atmosphere",
            "scifi": "science fiction, futuristic, cyberpunk, high-tech, space age, digital art",
            "mystery": "noir style, dark atmosphere, mysterious shadows, detective story aesthetic",
            "romance": "romantic, soft lighting, warm colors, intimate setting, beautiful",
            "horror": "dark, ominous, creepy atmosphere, horror art style, unsettling",
            "adventure": "epic adventure, dynamic scene, action-packed, heroic, cinematic",
            "drama": "emotional, realistic, contemporary art style, human drama",
            "comedy": "lighthearted, colorful, whimsical, cartoon-like, cheerful"
        }
    
    async def generate_scene_image(self, scene_data: Dict[str, Any], 
                                 genre: str = "fantasy") -> Optional[str]:
        """Generate image for a story scene"""
        try:
            if not self.image_generator:
                logger.warning("Image generator not available")
                return None
            
            # Create prompt from scene data
            prompt = await self._create_image_prompt(scene_data, genre)
            
            # Check cache first
            prompt_hash = hashlib.md5(prompt.encode()).hexdigest()
            if prompt_hash in self.image_cache:
                return self.image_cache[prompt_hash]
            
            # Generate image
            with torch.autocast("cuda" if torch.cuda.is_available() else "cpu"):
                image = self.image_generator(
                    prompt,
                    num_inference_steps=20,  # Faster generation
                    guidance_scale=7.5,
                    width=512,
                    height=512
                ).images[0]
            
            # Save image
            image_path = f"./generated_images/{prompt_hash}.png"
            Path("./generated_images").mkdir(exist_ok=True)
            image.save(image_path)
            
            # Cache the result
            self.image_cache[prompt_hash] = image_path
            
            return image_path
            
        except Exception as e:
            logger.error(f"Image generation failed: {e}")
            return None
    
    async def _create_image_prompt(self, scene_data: Dict[str, Any], genre: str) -> str:
        """Create detailed prompt for image generation"""
        
        # Base elements
        location = scene_data.get("location", "mysterious place")
        characters = scene_data.get("characters_present", [])
        mood = scene_data.get("mood", "neutral")
        
        # Character descriptions
        character_desc = ""
        if characters:
            character_desc = f"featuring {', '.join(characters[:2])}, "  # Limit to 2 characters
        
        # Mood and atmosphere
        mood_modifiers = {
            "joyful": "bright, cheerful, warm lighting",
            "melancholic": "somber, muted colors, soft shadows",
            "tense": "dramatic lighting, intense atmosphere",
            "peaceful": "serene, calm, gentle lighting",
            "mysterious": "shadowy, enigmatic, dramatic contrasts",
            "romantic": "soft, warm, intimate lighting",
            "dark": "dark, ominous, moody shadows",
            "hopeful": "bright, uplifting, golden hour lighting"
        }
        
        mood_style = mood_modifiers.get(mood, "balanced lighting")
        genre_style = self.style_presets.get(genre, "detailed artwork")
        
        # Construct final prompt
        prompt = f"{location}, {character_desc}{mood_style}, {genre_style}, high quality, detailed, professional artwork"
        
        # Add negative prompt elements
        negative_elements = "blurry, low quality, distorted, ugly, bad anatomy"
        
        return f"{prompt}, NOT {negative_elements}"

class InteractiveStoryEngine:
    """Main engine orchestrating the interactive story experience"""
    
    def __init__(self, mcp_manager: MCPStorytellingManager,
                 narrative_generator: AdvancedNarrativeGenerator,
                 visual_engine: VisualStorytellingEngine,
                 session_factory):
        self.mcp_manager = mcp_manager
        self.narrative_generator = narrative_generator
        self.visual_engine = visual_engine
        self.session_factory = session_factory
        
        # Story state management
        self.active_sessions = {}
        self.story_metrics = defaultdict(dict)
        
    async def start_new_story(self, user_id: str, story_config: Dict[str, Any]) -> Dict[str, Any]:
        """Start a new interactive story session"""
        try:
            # Create story context
            context_id = await self.mcp_manager.create_story_context(user_id, story_config)
            
            # Generate opening scene
            opening_scene = await self._generate_opening_scene(story_config, context_id)
            
            # Create session record
            session_id = str(uuid.uuid4())
            self.active_sessions[session_id] = {
                "user_id": user_id,
                "context_id": context_id,
                "story_config": story_config,
                "scene_count": 1,
                "start_time": datetime.utcnow()
            }
            
            # Store in database
            async with self.session_factory() as session:
                story_session = StorySession(
                    id=session_id,
                    world_id=story_config.get("world_id", "default"),
                    user_id=user_id,
                    story_state={"current_scene": 1},
                    character_states={},
                    plot_progress={"act": 1, "progress": 0.0},
                    choice_history=[],
                    current_scene=opening_scene["scene_id"]
                )
                session.add(story_session)
                await session.commit()
            
            return {
                "session_id": session_id,
                "scene": opening_scene,
                "story_state": {
                    "act": 1,
                    "scene_number": 1,
                    "progress": 0.0
                }
            }
            
        except Exception as e:
            logger.error(f"Story start failed: {e}")
            raise
    
    async def continue_story(self, session_id: str, user_choice: Dict[str, Any]) -> Dict[str, Any]:
        """Continue story based on user choice"""
        try:
            if session_id not in self.active_sessions:
                raise ValueError("Invalid session ID")
            
            session_info = self.active_sessions[session_id]
            context_id = session_info["context_id"]
            
            # Process user choice
            choice_result = await self._process_user_choice(
                context_id, user_choice, session_info
            )
            
            # Generate next scene
            next_scene = await self._generate_next_scene(
                context_id, choice_result, session_info
            )
            
            # Update session
            session_info["scene_count"] += 1
            
            # Update story context
            await self.mcp_manager.update_story_context(context_id, {
                "narrative_summary": next_scene["narrative_text"],
                "characters_present": next_scene.get("characters_present", []),
                "user_choice": user_choice,
                "emotional_tone": next_scene.get("emotional_tone", "neutral"),
                "significance_level": choice_result.get("significance", 0.5)
            })
            
            return {
                "scene": next_scene,
                "choice_result": choice_result,
                "story_state": {
                    "scene_number": session_info["scene_count"],
                    "progress": await self._calculate_story_progress(context_id)
                }
            }
            
        except Exception as e:
            logger.error(f"Story continuation failed: {e}")
            raise
    
    async def _generate_opening_scene(self, story_config: Dict[str, Any], 
                                    context_id: str) -> Dict[str, Any]:
        """Generate the opening scene of a story"""
        try:
            # Create initial scene context
            initial_context = SceneContext(
                location=story_config.get("starting_location", "a mysterious place"),
                time=story_config.get("starting_time", "present day"),
                characters_present=story_config.get("main_characters", ["protagonist"]),
                mood=story_config.get("opening_mood", "intriguing"),
                plot_points=story_config.get("initial_plot_points", ["story begins"]),
                user_state={}
            )
            
            # Create narrative request
            narrative_request = NarrativeRequest(
                scene_context=initial_context,
                user_choice=None,
                story_history=[],
                character_states={},
                preferred_tone=story_config.get("tone", "balanced"),
                generate_image=True
            )
            
            # Generate scene
            scene_result = await self.narrative_generator.generate_scene_narrative(
                narrative_request, context_id
            )
            
            # Generate image if enabled
            image_path = None
            if story_config.get("enable_images", True):
                image_path = await self.visual_engine.generate_scene_image(
                    {
                        "location": initial_context.location,
                        "characters_present": initial_context.characters_present,
                        "mood": initial_context.mood
                    },
                    story_config.get("genre", "fantasy")
                )
            
            return {
                "scene_id": str(uuid.uuid4()),
                "narrative_text": scene_result["narrative_text"],
                "choices": scene_result["choices"],
                "image_path": image_path,
                "emotional_tone": scene_result["emotional_tone"],
                "characters_present": scene_result["characters_present"],
                "quality_metrics": scene_result["quality_metrics"]
            }
            
        except Exception as e:
            logger.error(f"Opening scene generation failed: {e}")
            return self._generate_fallback_opening()
    
    async def _process_user_choice(self, context_id: str, user_choice: Dict[str, Any],
                                 session_info: Dict[str, Any]) -> Dict[str, Any]:
        """Process and analyze user choice impact"""
        try:
            choice_text = user_choice.get("text", "")
            choice_type = user_choice.get("type", "action")
            
            # Analyze choice significance
            significance = await self._analyze_choice_significance(
                choice_text, context_id, session_info
            )
            
            # Update choice patterns in MCP
            story_context = self.mcp_manager.story_contexts.get(session_info["user_id"], {})
            if "choice_patterns" in story_context:
                story_context["choice_patterns"][choice_type] += 1
            
            # Calculate consequences
            consequences = await self._calculate_choice_consequences(
                user_choice, context_id, session_info
            )
            
            return {
                "choice_processed": user_choice,
                "significance": significance,
                "consequences": consequences,
                "choice_type": choice_type
            }
            
        except Exception as e:
            logger.error(f"Choice processing failed: {e}")
            return {"choice_processed": user_choice, "significance": 0.5, "consequences": {}}

class StorytellingAPI:
    """FastAPI application for interactive storytelling"""
    
    def __init__(self, story_engine: InteractiveStoryEngine,
                 mcp_manager: MCPStorytellingManager,
                 session_factory):
        self.app = FastAPI(title="Dynamic Storytelling & Interactive Fiction API")
        self.story_engine = story_engine
        self.mcp_manager = mcp_manager
        self.session_factory = session_factory
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """Setup CORS and static files"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        # Serve generated images
        Path("./generated_images").mkdir(exist_ok=True)
        self.app.mount("/images", StaticFiles(directory="./generated_images"), name="images")
    
    def setup_routes(self):
        """Setup API routes"""
        
        from pydantic import BaseModel
        
        class StoryConfigModel(BaseModel):
            genre: str = "fantasy"
            theme: str = "adventure"
            tone: str = "balanced"
            starting_location: str = "a mysterious forest"
            main_characters: List[str] = ["protagonist"]
            enable_images: bool = True
            user_preferences: Dict[str, Any] = {}
        
        class UserChoiceModel(BaseModel):
            text: str
            type: str = "action"
            consequences: Dict[str, Any] = {}
        
        @self.app.post("/stories/start")
        async def start_story(config: StoryConfigModel, user_id: str = "demo_user"):
            try:
                result = await self.story_engine.start_new_story(
                    user_id, config.dict()
                )
                return result
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/stories/{session_id}/continue")
        async def continue_story(session_id: str, choice: UserChoiceModel):
            try:
                result = await self.story_engine.continue_story(
                    session_id, choice.dict()
                )
                return result
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/stories/{session_id}/state")
        async def get_story_state(session_id: str):
            try:
                if session_id in self.story_engine.active_sessions:
                    session_info = self.story_engine.active_sessions[session_id]
                    return {
                        "session_id": session_id,
                        "scene_count": session_info["scene_count"],
                        "story_config": session_info["story_config"],
                        "start_time": session_info["start_time"].isoformat()
                    }
                else:
                    raise HTTPException(status_code=404, detail="Session not found")
                    
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.websocket("/ws/story/{session_id}")
        async def story_websocket(websocket: WebSocket, session_id: str):
            await websocket.accept()
            try:
                while True:
                    data = await websocket.receive_json()
                    
                    if data["type"] == "choice":
                        result = await self.story_engine.continue_story(
                            session_id, data["choice"]
                        )
                        await websocket.send_json({
                            "type": "scene",
                            "data": result
                        })
                    
                    elif data["type"] == "ping":
                        await websocket.send_json({"type": "pong"})
                        
            except Exception as e:
                logger.error(f"WebSocket error: {e}")

async def demo():
    """Demo of the Dynamic Storytelling & Interactive Fiction Platform"""
    
    print("📚 Dynamic Storytelling & Interactive Fiction Platform Demo\n")
    
    try:
        # Initialize database
        engine = create_async_engine('sqlite+aiosqlite:///./storytelling.db')
        session_factory = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
        
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        
        # Initialize components
        mcp_manager = MCPStorytellingManager(session_factory)
        narrative_generator = AdvancedNarrativeGenerator(mcp_manager)
        visual_engine = VisualStorytellingEngine()
        story_engine = InteractiveStoryEngine(
            mcp_manager, narrative_generator, visual_engine, session_factory
        )
        
        print("✅ Dynamic Storytelling Platform initialized")
        print("✅ MCP narrative context management ready")
        print("✅ Advanced narrative generation active")
        print("✅ Visual storytelling engine configured")
        print("✅ Interactive story engine operational")
        
        # Create story configuration
        print(f"\n📖 Creating Interactive Story...")
        story_config = {
            "genre": "fantasy",
            "theme": "heroic journey",
            "tone": "adventurous",
            "starting_location": "the edge of an enchanted forest",
            "main_characters": ["brave adventurer", "wise mentor"],
            "enable_images": True,
            "user_preferences": {
                "complexity": "medium",
                "pacing": "dynamic",
                "character_focus": "high"
            }
        }
        
        # Start new story
        story_result = await story_engine.start_new_story("demo_user", story_config)
        session_id = story_result["session_id"]
        
        print(f"  🎭 Story session created: {session_id[:8]}")
        print(f"  🎬 Genre: {story_config['genre']}")
        print(f"  🎯 Theme: {story_config['theme']}")
        
        # Display opening scene
        opening_scene = story_result["scene"]
        print(f"\n--- Opening Scene ---")
        print(f"📝 Narrative:")
        print(f"   {opening_scene['narrative_text'][:200]}...")
        print(f"🎭 Emotional Tone: {opening_scene['emotional_tone']}")
        print(f"👥 Characters: {', '.join(opening_scene['characters_present'])}")
        
        if opening_scene.get('image_path'):
            print(f"🖼️ Scene Image: {opening_scene['image_path']}")
        
        # Display choices
        print(f"\n💭 Available Choices:")
        choices = opening_scene['choices']
        for i, choice in enumerate(choices, 1):
            print(f"   {i}. {choice.text}")
            if choice.consequences.get('description'):
                print(f"      → {choice.consequences['description']}")
        
        # Simulate user choices for demo
        print(f"\n🎮 Interactive Story Demo...")
        
        demo_choices = [
            {"text": choices[0].text, "type": "action"},
            {"text": "Look around for clues", "type": "exploration"},
            {"text": "Approach the mentor for advice", "type": "dialogue"}
        ]
        
        for i, user_choice in enumerate(demo_choices, 1):
            print(f"\n--- Scene {i + 1} ---")
            print(f"🎯 User Choice: {user_choice['text']}")
            
            # Continue story
            continue_result = await story_engine.continue_story(session_id, user_choice)
            
            next_scene = continue_result["scene"]
            choice_result = continue_result["choice_result"]
            
            print(f"📊 Choice Impact: {choice_result.get('significance', 0.5):.2f}")
            print(f"📝 Next Scene:")
            print(f"   {next_scene['narrative_text'][:150]}...")
            print(f"🎭 Tone: {next_scene['emotional_tone']}")
            
            # Show some choices for next scene
            if next_scene.get('choices'):
                print(f"💭 Next Choices:")
                for j, choice in enumerate(next_scene['choices'][:2], 1):
                    print(f"   {j}. {choice.text}")
            
            if i >= 2:  # Limit demo length
                break
        
        # Demonstrate story analytics
        print(f"\n📊 Story Analytics...")
        
        # Get user choice patterns
        choice_patterns = mcp_manager.analyze_choice_patterns("demo_user")
        if choice_patterns.get("preference_profile") != "unknown":
            print(f"  🎯 User Preference Profile: {choice_patterns['preference_profile']}")
            print(f"  📈 Total Choices Made: {choice_patterns['total_choices']}")
            
            top_preferences = sorted(
                choice_patterns.get('preferences', {}).items(), 
                key=lambda x: x[1], reverse=True
            )[:3]
            print(f"  🏆 Top Preferences:")
            for pref, score in top_preferences:
                print(f"     {pref}: {score:.2f}")
        
        # Show story progression
        story_state = continue_result["story_state"]
        print(f"  📖 Story Progress: Scene {story_state['scene_number']}")
        print(f"  ⏱️ Estimated Progress: {story_state.get('progress', 0.0):.1%}")
        
        # Demonstrate narrative quality metrics
        if opening_scene.get('quality_metrics'):
            print(f"\n📝 Narrative Quality Metrics:")
            metrics = opening_scene['quality_metrics']
            for metric, score in metrics.items():
                print(f"  {metric}: {score:.2f}")
        
        # System capabilities
        print(f"\n🛠️ Platform Capabilities:")
        print(f"  ✅ MCP-driven narrative context")
        print(f"  ✅ AI-powered story generation")
        print(f"  ✅ User-driven plot development")
        print(f"  ✅ Dynamic character interactions")
        print(f"  ✅ Visual scene generation")
        print(f"  ✅ Choice consequence tracking")
        print(f"  ✅ Adaptive storytelling")
        print(f"  ✅ Multi-genre support")
        
        print(f"\n🎯 Storytelling Features:")
        print(f"  • Persistent narrative memory")
        print(f"  • Meaningful choice consequences")
        print(f"  • Character development arcs")
        print(f"  • Dynamic visual generation")
        print(f"  • Quality-assured narratives")
        print(f"  • User preference adaptation")
        
        print(f"\n📚 Dynamic Storytelling Platform demo completed!")
        
    except Exception as e:
        print(f"❌ Demo error: {e}")
        logger.error(f"Demo failed: {e}")

# Dependencies information
dependencies_info = """
# Install required dependencies:
pip install openai anthropic
pip install langchain
pip install sentence-transformers
pip install transformers torch torchvision
pip install diffusers accelerate
pip install Pillow numpy
pip install spacy nltk textstat
pip install fastapi uvicorn websockets
pip install sqlalchemy aiosqlite
pip install networkx scipy scikit-learn
pip install chromadb faiss-cpu

# For image generation (GPU recommended):
pip install xformers  # For memory efficiency
pip install --upgrade diffusers[torch]

# For audio features (optional):
pip install gtts pydub

# NLP resources:
python -m spacy download en_core_web_sm
python -m nltk.download('punkt')
python -m nltk.download('vader_lexicon')

# Environment variables:
export OPENAI_API_KEY="your-openai-api-key"
export ANTHROPIC_API_KEY="your-anthropic-api-key"
export DATABASE_URL="sqlite+aiosqlite:///./storytelling.db"

# For GPU acceleration:
export CUDA_VISIBLE_DEVICES=0

# Storage directories:
mkdir -p ./generated_images
mkdir -p ./story_cache
mkdir -p ./models_cache

# For production deployment:
pip install gunicorn redis celery
pip install prometheus-client
"""

if __name__ == "__main__":
    print(dependencies_info)
    asyncio.run(demo())
````

## Project Summary

The Dynamic Storytelling & Interactive Fiction Platform represents a revolutionary advancement in digital narrative experiences that combines sophisticated AI-powered story generation, meaningful user agency, visual content creation, and MCP-driven context management to create immersive, personalized storytelling ecosystems where narratives evolve dynamically based on user choices while maintaining literary quality and emotional engagement.

### Key Value Propositions

1. **Intelligent Narrative Creation**: Advanced MCP-driven storytelling system that generates high-quality, coherent narratives with complex plot structures, well-developed characters, and emotional depth while maintaining literary standards and adapting to user preferences and choice patterns across extended storytelling sessions.

2. **Meaningful User Agency**: Sophisticated choice consequence system that provides genuine narrative impact through user decisions, creating personalized story experiences where choices matter and contribute to unique plot developments while maintaining story coherence and dramatic tension.

3. **Persistent Story Worlds**: Comprehensive memory architecture that maintains story continuity, character development, and plot progression across multiple sessions through layered memory systems that track short-term events, medium-term relationships, and long-term world state changes.

4. **Visual Narrative Enhancement**: Integrated Stable Diffusion system that generates contextually-appropriate artwork, character portraits, and scene illustrations that enhance narrative immersion and provide visual representation of story elements synchronized with narrative progression and user choices.

### Key Takeaways

- **Narrative Entertainment Revolution**: Transforms digital storytelling by providing personalized, adaptive narratives that respond intelligently to user choices while maintaining literary quality and emotional engagement comparable to professional fiction
- **Creative Democratization**: Enables users without writing experience to participate in creating compelling stories through meaningful choices and narrative agency, making storytelling accessible to broader audiences
- **Educational Storytelling Platform**: Provides powerful tools for educational institutions to create interactive learning experiences through narrative-based content that adapts to student choices and learning preferences
- **Entertainment Industry Innovation**: Offers new possibilities for interactive entertainment, gaming, and media production by combining AI-generated content with user agency and visual storytelling capabilities

This Dynamic Storytelling & Interactive Fiction Platform empowers creators, educators, and entertainment professionals by providing sophisticated tools for creating immersive, adaptive narrative experiences that engage users through meaningful choices, visual storytelling, and intelligent adaptation while maintaining the emotional depth and literary quality essential for compelling storytelling.