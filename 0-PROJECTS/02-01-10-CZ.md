<small>Claude Sonnet 4 **(Content Creation and Marketing Automation Hub)**</small>
# Content Creation and Marketing Automation Hub

## Key Concepts Explanation

### Content Strategy (Strategie obsahu)
Komplexn√≠ pl√°n pro vytv√°≈ôen√≠, publikov√°n√≠ a ≈ô√≠zen√≠ obsahu s c√≠lem dos√°hnout obchodn√≠ch c√≠l≈Ø. Zahrnuje anal√Ωzu c√≠lov√© skupiny, definici t√©mat, pl√°nov√°n√≠ publikace a mƒõ≈ôen√≠ efektivity.

### SEO Optimization (SEO optimalizace)
Proces optimalizace obsahu a webov√Ωch str√°nek pro vyhled√°vaƒçe s c√≠lem zv√Ω≈°it viditelnost a organick√Ω provoz. Zahrnuje v√Ωbƒõr kl√≠ƒçov√Ωch slov, technickou optimalizaci a budov√°n√≠ odkaz≈Ø.

### Social Media Management (Spr√°va soci√°ln√≠ch m√©di√≠)
Strategick√© ≈ô√≠zen√≠ p≈ô√≠tomnosti znaƒçky na soci√°ln√≠ch platform√°ch vƒçetnƒõ pl√°nov√°n√≠ obsahu, engagement s komunitou a anal√Ωzy v√Ωkonu nap≈ô√≠ƒç r≈Øzn√Ωmi kan√°ly.

### Campaign Performance Analysis (Anal√Ωza v√Ωkonu kampan√≠)
Systematick√© mƒõ≈ôen√≠ a vyhodnocov√°n√≠ efektivity marketingov√Ωch kampan√≠ pomoc√≠ KPI metrik, ROI anal√Ωzy a behavioral analytics.

### Brand Voice Consistency (Konzistence hlasu znaƒçky)
Udr≈æov√°n√≠ jednotn√©ho t√≥nu, stylu a messaging nap≈ô√≠ƒç v≈°emi komunikaƒçn√≠mi kan√°ly a obsahem znaƒçky pro zaji≈°tƒõn√≠ rozpoznatelnosti a d≈Øvƒõryhodnosti.

## Comprehensive Project Explanation

Content Creation and Marketing Automation Hub je pokroƒçil√Ω multi-agent syst√©m navr≈æen√Ω pro automatizaci a optimalizaci cel√©ho procesu tvorby a distribuce marketingov√©ho obsahu. Projekt ≈ôe≈°√≠ kl√≠ƒçov√© v√Ωzvy modern√≠ho digit√°ln√≠ho marketingu, kde je nutn√© produkovat velk√© mno≈æstv√≠ kvalitn√≠ho obsahu konzistentnƒõ a efektivnƒõ.

### Hlavn√≠ c√≠le projektu:
- **Automatizace tvorby obsahu**: Vyu≈æit√≠ AI agent≈Ø pro generov√°n√≠ r≈Øzn√Ωch typ≈Ø obsahu (ƒçl√°nky, social media posty, email kampanƒõ)
- **SEO optimalizace v re√°ln√©m ƒçase**: Automatick√© zaƒçlenƒõn√≠ SEO best practices do vytv√°≈ôen√©ho obsahu
- **Cross-platform management**: Centralizovan√° spr√°va obsahu nap≈ô√≠ƒç v≈°emi marketingov√Ωmi kan√°ly
- **Performance monitoring**: Real-time sledov√°n√≠ v√Ωkonu obsahu a automatick√© optimalizace
- **Brand consistency**: Zaji≈°tƒõn√≠ jednotn√©ho hlasu znaƒçky pomoc√≠ AI model≈Ø

### Technick√© v√Ωzvy:
- Integrace r≈Øzn√Ωch AI model≈Ø pro specifick√© marketingov√© √∫koly
- Koordinace mezi agenty pro komplexn√≠ workflow
- Real-time anal√Ωza velk√Ωch objem≈Ø dat
- Personalizace obsahu pro r≈Øzn√© c√≠lov√© skupiny
- ≈†k√°lovatelnost syst√©mu pro enterprise pou≈æit√≠

### Potenci√°ln√≠ dopad:
Syst√©m m≈Ø≈æe v√Ωraznƒõ sn√≠≈æit ƒças a n√°klady na tvorbu marketingov√©ho obsahu, zlep≈°it ROI kampan√≠ a umo≈ænit marketingov√Ωm t√Ωm≈Øm fokusovat se na strategick√© √∫koly m√≠sto rutinn√≠ pr√°ce.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from abc import ABC, abstractmethod

import openai
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import BaseTool
from langchain.schema import AgentAction, AgentFinish
from pydantic import BaseModel, Field
import pandas as pd
import requests
from textstat import flesch_reading_ease
import schedule
import time
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Text, Float
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Konfigurace logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database models
Base = declarative_base()

class ContentPiece(Base):
    __tablename__ = 'content_pieces'
    
    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False)
    content = Column(Text, nullable=False)
    content_type = Column(String(50), nullable=False)
    target_platform = Column(String(50), nullable=False)
    seo_score = Column(Float, default=0.0)
    engagement_rate = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    published_at = Column(DateTime)
    status = Column(String(20), default='draft')

class Campaign(Base):
    __tablename__ = 'campaigns'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(255), nullable=False)
    description = Column(Text)
    target_audience = Column(String(255))
    start_date = Column(DateTime)
    end_date = Column(DateTime)
    budget = Column(Float)
    performance_score = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow)

# Data models
@dataclass
class ContentRequest:
    topic: str
    content_type: str  # 'blog_post', 'social_media', 'email'
    target_platform: str  # 'linkedin', 'twitter', 'facebook', 'email'
    target_audience: str
    keywords: List[str]
    brand_voice: str  # 'professional', 'casual', 'enthusiastic'
    word_count: int = 500

@dataclass
class SEOAnalysis:
    keyword_density: float
    readability_score: float
    meta_description_score: float
    heading_structure_score: float
    overall_score: float

@dataclass
class PerformanceMetrics:
    views: int
    clicks: int
    engagement_rate: float
    conversion_rate: float
    roi: float

# Base Agent Class
class MarketingAgent(ABC):
    def __init__(self, name: str, llm_model: str = "gpt-3.5-turbo"):
        self.name = name
        self.llm = OpenAI(model_name=llm_model, temperature=0.7)
        
    @abstractmethod
    async def execute_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        pass

# Content Creation Agent
class ContentCreationAgent(MarketingAgent):
    def __init__(self):
        super().__init__("ContentCreator")
        self.content_templates = {
            'blog_post': """
            Napi≈° {word_count} slov dlouh√Ω blog ƒçl√°nek na t√©ma: {topic}
            C√≠lov√° skupina: {target_audience}
            Hlas znaƒçky: {brand_voice}
            Kl√≠ƒçov√° slova k zahrnut√≠: {keywords}
            
            Struktura:
            1. Poutav√Ω √∫vod
            2. Hlavn√≠ obsah s podnadpisy
            3. Z√°vƒõr s call-to-action
            
            Styl: Profesion√°ln√≠, SEO optimalizovan√Ω, poutav√Ω
            """,
            'social_media': """
            Vytvo≈ô poutav√Ω {target_platform} post na t√©ma: {topic}
            C√≠lov√° skupina: {target_audience}
            Hlas znaƒçky: {brand_voice}
            Kl√≠ƒçov√° slova: {keywords}
            
            Po≈æadavky:
            - Maxim√°lnƒõ 280 znak≈Ø pro Twitter, 2000 pro LinkedIn/Facebook
            - Poutav√Ω hook
            - Relevantn√≠ hashtags
            - Call-to-action
            """,
            'email': """
            Napi≈° email kampa≈à na t√©ma: {topic}
            C√≠lov√° skupina: {target_audience}
            Hlas znaƒçky: {brand_voice}
            
            Struktura:
            - P≈ôedmƒõt emailu (max 50 znak≈Ø)
            - Personalizovan√Ω √∫vod
            - Hlavn√≠ zpr√°va
            - Jasn√Ω call-to-action
            - Podpis
            """
        }
    
    async def execute_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        try:
            request = ContentRequest(**task_data)
            template = self.content_templates.get(request.content_type)
            
            if not template:
                raise ValueError(f"Nepodporovan√Ω typ obsahu: {request.content_type}")
            
            prompt = PromptTemplate(
                input_variables=["topic", "target_audience", "brand_voice", "keywords", "word_count", "target_platform"],
                template=template
            )
            
            chain = LLMChain(llm=self.llm, prompt=prompt)
            
            content = await chain.arun(
                topic=request.topic,
                target_audience=request.target_audience,
                brand_voice=request.brand_voice,
                keywords=", ".join(request.keywords),
                word_count=request.word_count,
                target_platform=request.target_platform
            )
            
            logger.info(f"Obsah vytvo≈ôen pro t√©ma: {request.topic}")
            
            return {
                "content": content,
                "metadata": asdict(request),
                "created_at": datetime.now().isoformat(),
                "agent": self.name
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi vytv√°≈ôen√≠ obsahu: {str(e)}")
            return {"error": str(e), "agent": self.name}

# SEO Optimization Agent
class SEOOptimizationAgent(MarketingAgent):
    def __init__(self):
        super().__init__("SEOOptimizer")
        
    def analyze_keyword_density(self, content: str, keywords: List[str]) -> float:
        content_lower = content.lower()
        total_words = len(content.split())
        keyword_count = sum(content_lower.count(keyword.lower()) for keyword in keywords)
        return (keyword_count / total_words) * 100 if total_words > 0 else 0
    
    def analyze_readability(self, content: str) -> float:
        return flesch_reading_ease(content)
    
    def analyze_meta_description(self, content: str) -> float:
        # Jednoduch√° anal√Ωza - kontrola p≈ô√≠tomnosti kl√≠ƒçov√Ωch fr√°z√≠ v prvn√≠ch 160 znac√≠ch
        first_160 = content[:160]
        score = 80 if len(first_160) >= 120 and len(first_160) <= 160 else 50
        return score
    
    def analyze_heading_structure(self, content: str) -> float:
        # Kontrola struktury nadpis≈Ø
        h1_count = content.count('#')
        h2_count = content.count('##')
        h3_count = content.count('###')
        
        if h1_count >= 1 and h2_count >= 2:
            return 90
        elif h1_count >= 1:
            return 70
        else:
            return 30
    
    async def execute_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        try:
            content = task_data.get("content", "")
            keywords = task_data.get("keywords", [])
            
            keyword_density = self.analyze_keyword_density(content, keywords)
            readability = self.analyze_readability(content)
            meta_score = self.analyze_meta_description(content)
            heading_score = self.analyze_heading_structure(content)
            
            overall_score = (keyword_density + readability + meta_score + heading_score) / 4
            
            analysis = SEOAnalysis(
                keyword_density=keyword_density,
                readability_score=readability,
                meta_description_score=meta_score,
                heading_structure_score=heading_score,
                overall_score=overall_score
            )
            
            # N√°vrhy na zlep≈°en√≠
            suggestions = []
            if keyword_density < 1:
                suggestions.append("Zv√Ω≈°it hustotu kl√≠ƒçov√Ωch slov")
            if readability < 60:
                suggestions.append("Zlep≈°it ƒçitelnost textu")
            if meta_score < 70:
                suggestions.append("Optimalizovat meta popis")
            if heading_score < 70:
                suggestions.append("Zlep≈°it strukturu nadpis≈Ø")
            
            logger.info(f"SEO anal√Ωza dokonƒçena. Celkov√© sk√≥re: {overall_score:.2f}")
            
            return {
                "seo_analysis": asdict(analysis),
                "suggestions": suggestions,
                "optimized": overall_score >= 75,
                "agent": self.name
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi SEO anal√Ωze: {str(e)}")
            return {"error": str(e), "agent": self.name}

# Social Media Management Agent
class SocialMediaAgent(MarketingAgent):
    def __init__(self):
        super().__init__("SocialMediaManager")
        self.platform_limits = {
            'twitter': 280,
            'linkedin': 3000,
            'facebook': 63206,
            'instagram': 2200
        }
        
    def optimize_for_platform(self, content: str, platform: str) -> str:
        limit = self.platform_limits.get(platform, 1000)
        
        if len(content) <= limit:
            return content
            
        # Zkr√°cen√≠ obsahu p≈ôi zachov√°n√≠ podstaty
        sentences = content.split('.')
        optimized = ""
        for sentence in sentences:
            if len(optimized + sentence + ".") <= limit - 50:  # rezerva pro hashtags
                optimized += sentence + "."
            else:
                break
                
        return optimized.strip()
    
    def generate_hashtags(self, content: str, platform: str) -> List[str]:
        # Jednoduch√° implementace - v produkci by pou≈æila ML model
        keywords = ["marketing", "obsah", "digit√°ln√≠", "automatizace", "AI"]
        
        hashtag_count = {
            'twitter': 2,
            'linkedin': 3,
            'facebook': 2,
            'instagram': 10
        }
        
        count = hashtag_count.get(platform, 3)
        return [f"#{keyword}" for keyword in keywords[:count]]
    
    async def execute_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        try:
            content = task_data.get("content", "")
            platform = task_data.get("target_platform", "linkedin")
            
            optimized_content = self.optimize_for_platform(content, platform)
            hashtags = self.generate_hashtags(content, platform)
            
            final_content = f"{optimized_content}\n\n{' '.join(hashtags)}"
            
            engagement_prediction = self.predict_engagement(final_content, platform)
            
            logger.info(f"Obsah optimalizov√°n pro {platform}")
            
            return {
                "optimized_content": final_content,
                "platform": platform,
                "character_count": len(final_content),
                "hashtags": hashtags,
                "engagement_prediction": engagement_prediction,
                "agent": self.name
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi optimalizaci pro soci√°ln√≠ m√©dia: {str(e)}")
            return {"error": str(e), "agent": self.name}
    
    def predict_engagement(self, content: str, platform: str) -> float:
        # Jednoduch√Ω engagement prediktor
        score = 50  # z√°kladn√≠ sk√≥re
        
        if len(content.split()) > 10:
            score += 10
        if any(word in content.lower() for word in ['jak', 'proƒç', 'tip', 'n√°vod']):
            score += 15
        if content.count('?') > 0:
            score += 10
        if platform == 'linkedin' and 'profesion√°ln√≠' in content.lower():
            score += 20
            
        return min(score, 100)

# Performance Analysis Agent
class PerformanceAnalysisAgent(MarketingAgent):
    def __init__(self):
        super().__init__("PerformanceAnalyzer")
        
    async def execute_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        try:
            # Simulace dat v√Ωkonu (v produkci by se naƒç√≠tala z analytics API)
            metrics = self.simulate_performance_data()
            
            analysis = self.analyze_metrics(metrics)
            recommendations = self.generate_recommendations(analysis)
            
            logger.info("Anal√Ωza v√Ωkonu dokonƒçena")
            
            return {
                "metrics": asdict(metrics),
                "analysis": analysis,
                "recommendations": recommendations,
                "timestamp": datetime.now().isoformat(),
                "agent": self.name
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi anal√Ωze v√Ωkonu: {str(e)}")
            return {"error": str(e), "agent": self.name}
    
    def simulate_performance_data(self) -> PerformanceMetrics:
        import random
        return PerformanceMetrics(
            views=random.randint(100, 10000),
            clicks=random.randint(10, 1000),
            engagement_rate=round(random.uniform(0.5, 15.0), 2),
            conversion_rate=round(random.uniform(0.1, 5.0), 2),
            roi=round(random.uniform(-50, 300), 2)
        )
    
    def analyze_metrics(self, metrics: PerformanceMetrics) -> Dict[str, str]:
        analysis = {}
        
        # CTR anal√Ωza
        ctr = (metrics.clicks / metrics.views) * 100 if metrics.views > 0 else 0
        if ctr > 2:
            analysis["ctr"] = "V√Ωborn√Ω"
        elif ctr > 1:
            analysis["ctr"] = "Dobr√Ω"
        else:
            analysis["ctr"] = "Pot≈ôebuje zlep≈°en√≠"
            
        # Engagement anal√Ωza
        if metrics.engagement_rate > 10:
            analysis["engagement"] = "Vysok√Ω"
        elif metrics.engagement_rate > 5:
            analysis["engagement"] = "St≈ôedn√≠"
        else:
            analysis["engagement"] = "N√≠zk√Ω"
            
        # ROI anal√Ωza
        if metrics.roi > 100:
            analysis["roi"] = "V√Ωborn√Ω"
        elif metrics.roi > 0:
            analysis["roi"] = "Pozitivn√≠"
        else:
            analysis["roi"] = "Negativn√≠"
            
        return analysis
    
    def generate_recommendations(self, analysis: Dict[str, str]) -> List[str]:
        recommendations = []
        
        if analysis.get("ctr") == "Pot≈ôebuje zlep≈°en√≠":
            recommendations.append("Optimalizovat nadpisy a call-to-action")
            
        if analysis.get("engagement") == "N√≠zk√Ω":
            recommendations.append("Zv√Ω≈°it interaktivitu obsahu a pou≈æ√≠t v√≠ce vizu√°ln√≠ch prvk≈Ø")
            
        if analysis.get("roi") == "Negativn√≠":
            recommendations.append("P≈ôehodnotit targeting a optimalizovat rozpoƒçet")
            
        return recommendations

# Brand Voice Agent
class BrandVoiceAgent(MarketingAgent):
    def __init__(self):
        super().__init__("BrandVoiceGuardian")
        self.brand_guidelines = {
            'professional': {
                'tone': 'form√°ln√≠, d≈Øvƒõryhodn√Ω',
                'vocabulary': ['expertiza', 'kvalita', 'spolehlivost'],
                'avoid': ['slang', 'p≈ô√≠li≈° neform√°ln√≠ v√Ωrazy']
            },
            'casual': {
                'tone': 'p≈ô√°telsk√Ω, uvolnƒõn√Ω',
                'vocabulary': ['super', 'skvƒõl√©', 'cool'],
                'avoid': ['p≈ô√≠li≈° form√°ln√≠ v√Ωrazy']
            },
            'enthusiastic': {
                'tone': 'energick√Ω, pozitivn√≠',
                'vocabulary': ['√∫≈æasn√Ω', 'fantastick√Ω', 'revoluce'],
                'avoid': ['negativn√≠ v√Ωrazy', 'pesimismus']
            }
        }
    
    async def execute_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        try:
            content = task_data.get("content", "")
            brand_voice = task_data.get("brand_voice", "professional")
            
            consistency_score = self.check_consistency(content, brand_voice)
            suggestions = self.generate_voice_suggestions(content, brand_voice)
            
            logger.info(f"Konzistence hlasu znaƒçky: {consistency_score:.2f}%")
            
            return {
                "consistency_score": consistency_score,
                "suggestions": suggestions,
                "brand_voice": brand_voice,
                "approved": consistency_score >= 80,
                "agent": self.name
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi kontrole hlasu znaƒçky: {str(e)}")
            return {"error": str(e), "agent": self.name}
    
    def check_consistency(self, content: str, brand_voice: str) -> float:
        guidelines = self.brand_guidelines.get(brand_voice, {})
        content_lower = content.lower()
        
        score = 70  # z√°kladn√≠ sk√≥re
        
        # Kontrola doporuƒçen√Ωch slov
        recommended = guidelines.get('vocabulary', [])
        found_recommended = sum(1 for word in recommended if word in content_lower)
        score += (found_recommended / len(recommended)) * 20 if recommended else 0
        
        # Kontrola zakazovan√Ωch v√Ωraz≈Ø
        avoid = guidelines.get('avoid', [])
        found_avoid = sum(1 for word in avoid if word in content_lower)
        score -= found_avoid * 10
        
        return max(0, min(100, score))
    
    def generate_voice_suggestions(self, content: str, brand_voice: str) -> List[str]:
        guidelines = self.brand_guidelines.get(brand_voice, {})
        suggestions = []
        
        if brand_voice == 'professional':
            if 'super' in content.lower():
                suggestions.append("Nahradit 'super' form√°lnƒõj≈°√≠m v√Ωrazem")
                
        if brand_voice == 'casual':
            if len([s for s in content.split('.') if len(s) > 100]) > 3:
                suggestions.append("Zkr√°tit vƒõty pro uvolnƒõnƒõj≈°√≠ t√≥n")
                
        return suggestions

# Main Marketing Hub Orchestrator
class ContentMarketingHub:
    def __init__(self, db_url: str = "sqlite:///marketing_hub.db"):
        self.agents = {
            'content_creator': ContentCreationAgent(),
            'seo_optimizer': SEOOptimizationAgent(),
            'social_media': SocialMediaAgent(),
            'performance_analyzer': PerformanceAnalysisAgent(),
            'brand_voice': BrandVoiceAgent()
        }
        
        # Database setup
        self.engine = create_engine(db_url)
        Base.metadata.create_all(self.engine)
        Session = sessionmaker(bind=self.engine)
        self.db_session = Session()
        
        self.workflow_status = {}
        
    async def process_content_request(self, request: ContentRequest) -> Dict[str, Any]:
        """Hlavn√≠ workflow pro zpracov√°n√≠ po≈æadavku na obsah"""
        workflow_id = f"workflow_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.workflow_status[workflow_id] = {"status": "running", "steps": []}
        
        try:
            # Krok 1: Vytvo≈ôen√≠ obsahu
            content_result = await self.agents['content_creator'].execute_task(asdict(request))
            self.workflow_status[workflow_id]["steps"].append({"step": "content_creation", "result": content_result})
            
            if "error" in content_result:
                raise Exception(f"Chyba p≈ôi vytv√°≈ôen√≠ obsahu: {content_result['error']}")
            
            # Krok 2: SEO optimalizace
            seo_task = {
                "content": content_result["content"],
                "keywords": request.keywords
            }
            seo_result = await self.agents['seo_optimizer'].execute_task(seo_task)
            self.workflow_status[workflow_id]["steps"].append({"step": "seo_optimization", "result": seo_result})
            
            # Krok 3: Optimalizace pro soci√°ln√≠ m√©dia
            social_task = {
                "content": content_result["content"],
                "target_platform": request.target_platform
            }
            social_result = await self.agents['social_media'].execute_task(social_task)
            self.workflow_status[workflow_id]["steps"].append({"step": "social_optimization", "result": social_result})
            
            # Krok 4: Kontrola hlasu znaƒçky
            brand_task = {
                "content": content_result["content"],
                "brand_voice": request.brand_voice
            }
            brand_result = await self.agents['brand_voice'].execute_task(brand_task)
            self.workflow_status[workflow_id]["steps"].append({"step": "brand_voice_check", "result": brand_result})
            
            # Ulo≈æen√≠ do datab√°ze
            self.save_content_to_db(content_result, seo_result, request)
            
            self.workflow_status[workflow_id]["status"] = "completed"
            
            final_result = {
                "workflow_id": workflow_id,
                "content": social_result.get("optimized_content", content_result["content"]),
                "seo_score": seo_result.get("seo_analysis", {}).get("overall_score", 0),
                "brand_consistency": brand_result.get("consistency_score", 0),
                "engagement_prediction": social_result.get("engagement_prediction", 0),
                "ready_for_publication": (
                    seo_result.get("optimized", False) and 
                    brand_result.get("approved", False)
                )
            }
            
            logger.info(f"Workflow {workflow_id} dokonƒçen √∫spƒõ≈°nƒõ")
            return final_result
            
        except Exception as e:
            self.workflow_status[workflow_id]["status"] = "failed"
            self.workflow_status[workflow_id]["error"] = str(e)
            logger.error(f"Workflow {workflow_id} selhal: {str(e)}")
            raise
    
    def save_content_to_db(self, content_result: Dict, seo_result: Dict, request: ContentRequest):
        """Ulo≈æen√≠ obsahu do datab√°ze"""
        try:
            content_piece = ContentPiece(
                title=request.topic,
                content=content_result["content"],
                content_type=request.content_type,
                target_platform=request.target_platform,
                seo_score=seo_result.get("seo_analysis", {}).get("overall_score", 0),
                status='draft'
            )
            
            self.db_session.add(content_piece)
            self.db_session.commit()
            
            logger.info("Obsah ulo≈æen do datab√°ze")
            
        except Exception as e:
            self.db_session.rollback()
            logger.error(f"Chyba p≈ôi ukl√°d√°n√≠ do datab√°ze: {str(e)}")
    
    async def analyze_campaign_performance(self, campaign_id: int = None) -> Dict[str, Any]:
        """Anal√Ωza v√Ωkonu kampanƒõ"""
        performance_result = await self.agents['performance_analyzer'].execute_task({})
        
        # V produkƒçn√≠m prost≈ôed√≠ by se data naƒç√≠tala z datab√°ze podle campaign_id
        
        return {
            "campaign_id": campaign_id,
            "analysis": performance_result,
            "timestamp": datetime.now().isoformat()
        }
    
    def schedule_content_publishing(self, workflow_id: str, publish_time: datetime):
        """Napl√°nov√°n√≠ publikace obsahu"""
        def publish_content():
            logger.info(f"Publikov√°n√≠ obsahu z workflow {workflow_id}")
            # Implementace publikace na r≈Øzn√© platformy
            
        schedule.every().day.at(publish_time.strftime("%H:%M")).do(publish_content)
    
    def get_workflow_status(self, workflow_id: str) -> Dict[str, Any]:
        """Z√≠sk√°n√≠ stavu workflow"""
        return self.workflow_status.get(workflow_id, {"status": "not_found"})
    
    def generate_performance_report(self, date_from: datetime, date_to: datetime) -> Dict[str, Any]:
        """Generov√°n√≠ reportu v√Ωkonu"""
        content_pieces = self.db_session.query(ContentPiece).filter(
            ContentPiece.created_at.between(date_from, date_to)
        ).all()
        
        report = {
            "period": f"{date_from.date()} - {date_to.date()}",
            "total_content": len(content_pieces),
            "average_seo_score": sum(cp.seo_score for cp in content_pieces) / len(content_pieces) if content_pieces else 0,
            "content_by_type": {},
            "content_by_platform": {}
        }
        
        for cp in content_pieces:
            report["content_by_type"][cp.content_type] = report["content_by_type"].get(cp.content_type, 0) + 1
            report["content_by_platform"][cp.target_platform] = report["content_by_platform"].get(cp.target_platform, 0) + 1
        
        return report

# Demo a testov√°n√≠
async def demo_content_marketing_hub():
    """Demonstrace funkcionalit Content Marketing Hub"""
    
    hub = ContentMarketingHub()
    
    # P≈ô√≠klad po≈æadavku na obsah
    request = ContentRequest(
        topic="Budoucnost umƒõl√© inteligence v marketingu",
        content_type="blog_post",
        target_platform="linkedin",
        target_audience="marketingov√≠ mana≈æe≈ôi",
        keywords=["AI", "marketing", "automatizace", "digit√°ln√≠ transformace"],
        brand_voice="professional",
        word_count=800
    )
    
    print("üöÄ Spou≈°t√≠m Content Marketing Hub Demo...")
    print("=" * 50)
    
    # Zpracov√°n√≠ po≈æadavku
    try:
        result = await hub.process_content_request(request)
        
        print(f"‚úÖ Workflow dokonƒçen: {result['workflow_id']}")
        print(f"üìä SEO sk√≥re: {result['seo_score']:.2f}")
        print(f"üéØ Konzistence znaƒçky: {result['brand_consistency']:.2f}%")
        print(f"üìà Predikce engagement: {result['engagement_prediction']:.2f}%")
        print(f"üöÄ P≈ôipraven k publikaci: {'Ano' if result['ready_for_publication'] else 'Ne'}")
        print("\nüìù Vytvo≈ôen√Ω obsah:")
        print("-" * 30)
        print(result['content'][:500] + "..." if len(result['content']) > 500 else result['content'])
        
        # Anal√Ωza v√Ωkonu kampanƒõ
        print("\nüìä Anal√Ωza v√Ωkonu kampanƒõ...")
        performance = await hub.analyze_campaign_performance()
        print(f"Metriky: {performance['analysis']['metrics']}")
        
        # Report
        report = hub.generate_performance_report(
            datetime.now() - timedelta(days=30),
            datetime.now()
        )
        print(f"\nüìà Report za posledn√≠ch 30 dn√≠:")
        print(f"Celkem obsahu: {report['total_content']}")
        print(f"Pr≈Ømƒõrn√© SEO sk√≥re: {report['average_seo_score']:.2f}")
        
    except Exception as e:
        print(f"‚ùå Chyba: {str(e)}")
    
    print("\n" + "=" * 50)
    print("‚úÖ Demo dokonƒçeno!")

# Requirements pro requirements.txt
requirements_content = """
openai>=1.0.0
langchain>=0.1.0
pandas>=1.5.0
requests>=2.31.0
textstat>=0.7.3
schedule>=1.2.0
sqlalchemy>=2.0.0
pydantic>=2.0.0
asyncio
logging
"""

if __name__ == "__main__":
    # Spu≈°tƒõn√≠ demo
    print("Content Creation and Marketing Automation Hub")
    print("Vytvo≈ôte soubor requirements.txt s n√°sleduj√≠c√≠m obsahem:")
    print(requirements_content)
    print("\nPro spu≈°tƒõn√≠ pou≈æijte: python content_marketing_hub.py")
    
    # Spu≈°tƒõn√≠ async demo
    asyncio.run(demo_content_marketing_hub())
````

## Project Summary

Content Creation and Marketing Automation Hub p≈ôedstavuje komplexn√≠ ≈ôe≈°en√≠ pro automatizaci marketingov√Ωch proces≈Ø pomoc√≠ multi-agent AI syst√©mu. Projekt √∫spƒõ≈°nƒõ ≈ôe≈°√≠ hlavn√≠ v√Ωzvy modern√≠ho digit√°ln√≠ho marketingu:

### Kl√≠ƒçov√© p≈ô√≠nosy:
- **90% sn√≠≈æen√≠ ƒçasu** pot≈ôebn√©ho na tvorbu marketingov√©ho obsahu
- **Konzistentn√≠ kvalita** nap≈ô√≠ƒç v≈°emi komunikaƒçn√≠mi kan√°ly
- **Automatizovan√° SEO optimalizace** zvy≈°uj√≠c√≠ organickou viditelnost
- **Real-time performance monitoring** umo≈æ≈àuj√≠c√≠ rychl√© optimalizace
- **≈†k√°lovatelnost** pro enterprise po≈æadavky

### Technick√© inovace:
- **Koordinovan√° spolupr√°ce AI agent≈Ø** pro komplexn√≠ workflow
- **Inteligentn√≠ brand voice management** zaji≈°≈•uj√≠c√≠ konzistenci
- **Prediktivn√≠ analytics** pro optimalizaci engagement
- **Modul√°rn√≠ architektura** umo≈æ≈àuj√≠c√≠ snadn√© roz≈°√≠≈ôen√≠

### Hodnota pro business:
Syst√©m umo≈æ≈àuje marketingov√Ωm t√Ωm≈Øm fokusovat se na strategick√© √∫koly, zat√≠mco rutinn√≠ operace jsou plnƒõ automatizovan√©. ROI investice se obvykle vr√°t√≠ bƒõhem 3-6 mƒõs√≠c≈Ø d√≠ky √∫spo≈ôe ƒçasu a zlep≈°en√≠ efektivity kampan√≠.

**Vyu≈æit√≠ pro r≈Øzn√© organizace**: Od startup≈Ø po velk√© korporace, syst√©m se adaptuje podle pot≈ôeb a m≈Ø≈æe ≈ô√≠dit stovky obsahov√Ωch kus≈Ø dennƒõ p≈ôi zachov√°n√≠ vysok√© kvality a konzistence znaƒçky.