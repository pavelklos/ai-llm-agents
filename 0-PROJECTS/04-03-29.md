<small>Claude Sonnet 4 **(AI Town (Virtual Society) - Multi-Agent Systems and Emergent Behavior)**</small>
# AI Town (Virtual Society)

## Key Concepts Explanation

### Multi-Agent Systems (MAS)
Computational frameworks where multiple autonomous agents interact within a shared environment, each possessing individual goals, behaviors, and decision-making capabilities. These systems enable complex emergent behaviors through agent-to-agent communication, coordination protocols, and distributed problem-solving mechanisms that mirror real-world social dynamics.

### Emergent Behavior
Complex patterns and phenomena that arise spontaneously from simple interactions between system components, where the collective behavior exhibits properties not present in individual agents. In virtual societies, this includes formation of social groups, economic patterns, cultural evolution, and adaptive responses to environmental changes.

### Agent Autonomy and Intelligence
Individual agents possess independent decision-making capabilities, memory systems, learning mechanisms, and personality traits that influence their interactions with the environment and other agents. This includes goal-directed behavior, adaptive responses, and the ability to form relationships and social structures.

### Virtual Environment Simulation
Digital representation of physical and social spaces where agents interact, including spatial navigation, resource management, communication channels, and environmental dynamics. The environment serves as both a constraint and facilitator for agent interactions and emergent behaviors.

### Social Dynamics and Interaction
Complex patterns of communication, cooperation, competition, and relationship formation between agents that mirror real-world social phenomena. This includes friendship networks, economic transactions, information propagation, and collective decision-making processes.

### Behavioral Modeling and Psychology
Implementation of realistic psychological models, personality traits, emotional states, and cognitive biases that influence agent behavior and social interactions. This creates more authentic and unpredictable social dynamics within the virtual society.

## Comprehensive Project Explanation

### Project Overview
AI Town is a sophisticated virtual society simulation where autonomous AI agents live, work, and interact in a persistent digital environment. Each agent possesses unique personalities, goals, and memories, creating complex social dynamics through emergent behaviors that mirror real-world communities while providing insights into social phenomena and human behavior patterns.

### Objectives
- **Social Simulation**: Create realistic virtual societies with authentic social dynamics and relationships
- **Emergent Behavior Study**: Observe and analyze how complex patterns emerge from simple agent interactions
- **AI Research Platform**: Provide testbed for multi-agent AI research and behavioral modeling
- **Social Science Tool**: Enable controlled experiments in sociology, psychology, and economics
- **Entertainment Innovation**: Develop engaging virtual worlds with autonomous, believable characters
- **Policy Testing**: Simulate social policies and interventions before real-world implementation

### Key Challenges
- **Computational Complexity**: Managing large numbers of interacting agents with real-time performance
- **Behavioral Authenticity**: Creating believable agent personalities and realistic social interactions
- **Emergent Control**: Guiding emergent behaviors while maintaining agent autonomy
- **Memory Management**: Maintaining long-term agent memories and relationship histories
- **Social Coherence**: Ensuring stable social structures while allowing for dynamic change
- **Scalability**: Supporting growing populations and expanding virtual environments

### Potential Impact
- **Social Science Advancement**: New insights into human behavior and social phenomena
- **AI Development**: Progress in multi-agent systems and collective intelligence
- **Virtual Worlds**: Enhanced gaming and entertainment experiences with autonomous NPCs
- **Policy Simulation**: Testing social policies and interventions in controlled environments
- **Educational Applications**: Interactive learning environments for social science education
- **Research Platform**: Standardized framework for studying complex social systems

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.3.0
langchain==0.0.350
langchain-openai==0.0.2
autogen==0.2.0
crewai==0.1.0
chromadb==0.4.18
numpy==1.25.2
pandas==2.1.3
scipy==1.11.4
networkx==3.2.1
matplotlib==3.8.2
plotly==5.17.0
pygame==2.5.2
asyncio==3.4.3
aiofiles==23.2.1
fastapi==0.104.1
uvicorn==0.24.0
websockets==12.0
pydantic==2.5.0
sqlalchemy==2.0.23
redis==5.0.1
celery==5.3.4
streamlit==1.28.1
dash==2.16.1
rich==13.7.0
typer==0.9.0
python-dotenv==1.0.0
faker==20.1.0
python-dateutil==2.8.2
uuid==1.30
logging==0.4.9.6
json==2.0.9
random==1.0.1
threading==3.12.0
queue==3.13.0
time==1.0.0
````

### Core Implementation

````python
import asyncio
import logging
import json
import uuid
import random
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import threading
from queue import Queue
import numpy as np
import pandas as pd
import networkx as nx

from openai import AsyncOpenAI
from langchain_openai import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from langchain.memory import ConversationBufferWindowMemory
import chromadb

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from pydantic import BaseModel, Field
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from rich.console import Console
from faker import Faker

from dotenv import load_dotenv

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
console = Console()
fake = Faker()

class AgentState(Enum):
    IDLE = "idle"
    WORKING = "working"
    SOCIALIZING = "socializing"
    MOVING = "moving"
    SLEEPING = "sleeping"
    EATING = "eating"
    SHOPPING = "shopping"
    LEARNING = "learning"

class LocationType(Enum):
    HOME = "home"
    WORKPLACE = "workplace"
    STORE = "store"
    PARK = "park"
    RESTAURANT = "restaurant"
    SCHOOL = "school"
    LIBRARY = "library"
    HOSPITAL = "hospital"

class RelationshipType(Enum):
    STRANGER = "stranger"
    ACQUAINTANCE = "acquaintance"
    FRIEND = "friend"
    CLOSE_FRIEND = "close_friend"
    FAMILY = "family"
    ROMANTIC = "romantic"
    RIVAL = "rival"
    ENEMY = "enemy"

@dataclass
class Personality:
    openness: float = 0.5          # 0-1, willingness to try new things
    conscientiousness: float = 0.5  # 0-1, organization and reliability
    extraversion: float = 0.5      # 0-1, social energy and assertiveness
    agreeableness: float = 0.5     # 0-1, cooperation and trust
    neuroticism: float = 0.5       # 0-1, emotional instability
    
    def __post_init__(self):
        # Ensure values are in valid range
        for attr in ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism']:
            setattr(self, attr, max(0.0, min(1.0, getattr(self, attr))))

@dataclass
class Location:
    id: str
    name: str
    type: LocationType
    position: Tuple[float, float]
    capacity: int
    current_occupants: Set[str] = field(default_factory=set)
    resources: Dict[str, int] = field(default_factory=dict)
    
    def is_full(self) -> bool:
        return len(self.current_occupants) >= self.capacity
    
    def add_occupant(self, agent_id: str) -> bool:
        if not self.is_full():
            self.current_occupants.add(agent_id)
            return True
        return False
    
    def remove_occupant(self, agent_id: str):
        self.current_occupants.discard(agent_id)

@dataclass
class Relationship:
    target_agent_id: str
    relationship_type: RelationshipType
    strength: float  # 0-1, strength of relationship
    last_interaction: datetime
    interaction_count: int = 0
    shared_memories: List[str] = field(default_factory=list)
    
    def update_relationship(self, interaction_quality: float):
        """Update relationship based on interaction quality (-1 to 1)."""
        # Adjust strength based on interaction
        strength_change = interaction_quality * 0.1
        self.strength = max(0.0, min(1.0, self.strength + strength_change))
        
        # Update interaction tracking
        self.last_interaction = datetime.now()
        self.interaction_count += 1
        
        # Evolve relationship type based on strength
        if self.strength > 0.8 and self.relationship_type == RelationshipType.FRIEND:
            self.relationship_type = RelationshipType.CLOSE_FRIEND
        elif self.strength < 0.3 and self.relationship_type in [RelationshipType.FRIEND, RelationshipType.CLOSE_FRIEND]:
            self.relationship_type = RelationshipType.ACQUAINTANCE
        elif self.strength < 0.1:
            self.relationship_type = RelationshipType.STRANGER

@dataclass
class Memory:
    id: str
    content: str
    timestamp: datetime
    importance: float  # 0-1, how important this memory is
    emotional_impact: float  # -1 to 1, emotional valence
    associated_agents: List[str] = field(default_factory=list)
    location_id: Optional[str] = None
    tags: List[str] = field(default_factory=list)

class Agent:
    """Autonomous AI agent with personality, memories, and goals."""
    
    def __init__(
        self,
        agent_id: str,
        name: str,
        personality: Personality,
        initial_location: str,
        occupation: str = "unemployed"
    ):
        self.agent_id = agent_id
        self.name = name
        self.personality = personality
        self.occupation = occupation
        
        # State management
        self.current_location = initial_location
        self.current_state = AgentState.IDLE
        self.current_goal = None
        self.energy = 1.0
        self.happiness = 0.5
        self.social_battery = 1.0
        
        # Memory and relationships
        self.memories: List[Memory] = []
        self.relationships: Dict[str, Relationship] = {}
        self.conversation_memory = ConversationBufferWindowMemory(k=5)
        
        # Scheduling and planning
        self.daily_schedule: List[Dict[str, Any]] = []
        self.current_activity = None
        self.activity_start_time = None
        
        # AI components
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0.7,
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )
        
        # Initialize basic memories and schedule
        self._initialize_agent()
    
    def _initialize_agent(self):
        """Initialize agent with basic memories and daily schedule."""
        # Create initial memories
        initial_memories = [
            f"My name is {self.name} and I work as a {self.occupation}.",
            f"I consider myself to be {'outgoing' if self.personality.extraversion > 0.6 else 'introverted'}.",
            f"I {'enjoy' if self.personality.openness > 0.6 else 'prefer routine over'} trying new things.",
        ]
        
        for memory_content in initial_memories:
            memory = Memory(
                id=str(uuid.uuid4()),
                content=memory_content,
                timestamp=datetime.now(),
                importance=0.7,
                emotional_impact=0.1
            )
            self.memories.append(memory)
        
        # Create basic daily schedule
        self._generate_daily_schedule()
    
    def _generate_daily_schedule(self):
        """Generate a basic daily schedule based on personality and occupation."""
        schedule = []
        
        # Wake up time based on conscientiousness
        wake_time = 6 + (1 - self.personality.conscientiousness) * 3  # 6-9 AM
        
        # Work schedule
        if self.occupation != "unemployed":
            work_start = 9.0
            work_end = 17.0
            schedule.append({
                "time": work_start,
                "activity": "work",
                "location_type": LocationType.WORKPLACE,
                "duration": work_end - work_start
            })
        
        # Social activities based on extraversion
        if self.personality.extraversion > 0.5:
            social_time = 19.0 + random.random() * 2  # 7-9 PM
            schedule.append({
                "time": social_time,
                "activity": "socialize",
                "location_type": LocationType.PARK,
                "duration": 2.0
            })
        
        # Sleep time
        sleep_time = 22 + (1 - self.personality.conscientiousness) * 2  # 10 PM - 12 AM
        schedule.append({
            "time": sleep_time,
            "activity": "sleep",
            "location_type": LocationType.HOME,
            "duration": 8.0
        })
        
        self.daily_schedule = sorted(schedule, key=lambda x: x["time"])
    
    async def think_and_act(self, world_state: Dict[str, Any]) -> Dict[str, Any]:
        """Main decision-making process for the agent."""
        try:
            # Update internal state based on world
            self._update_internal_state(world_state)
            
            # Determine current goals and priorities
            current_goals = await self._assess_goals_and_priorities()
            
            # Make decision about next action
            action = await self._decide_action(current_goals, world_state)
            
            # Update memories with current experience
            await self._process_experiences(world_state)
            
            return action
            
        except Exception as e:
            logger.error(f"Agent {self.name} thinking failed: {e}")
            return {"action": "idle", "duration": 1.0}
    
    def _update_internal_state(self, world_state: Dict[str, Any]):
        """Update agent's internal state based on world information."""
        # Update energy based on time and activities
        current_time = world_state.get("current_time", datetime.now())
        
        if self.current_state == AgentState.SLEEPING:
            self.energy = min(1.0, self.energy + 0.1)
        elif self.current_state == AgentState.WORKING:
            self.energy = max(0.0, self.energy - 0.05)
        elif self.current_state == AgentState.SOCIALIZING:
            if self.personality.extraversion > 0.5:
                self.happiness = min(1.0, self.happiness + 0.05)
                self.social_battery = min(1.0, self.social_battery + 0.03)
            else:
                self.social_battery = max(0.0, self.social_battery - 0.05)
        
        # Update happiness based on personality and current state
        if self.current_state == AgentState.IDLE and self.personality.neuroticism > 0.6:
            self.happiness = max(0.0, self.happiness - 0.02)
    
    async def _assess_goals_and_priorities(self) -> List[str]:
        """Assess current goals and priorities."""
        goals = []
        
        # Basic needs
        if self.energy < 0.3:
            goals.append("rest")
        elif self.energy < 0.6 and datetime.now().hour > 22:
            goals.append("sleep")
        
        # Social needs
        if self.personality.extraversion > 0.5 and self.social_battery < 0.4:
            goals.append("socialize")
        elif self.personality.extraversion < 0.3 and self.social_battery < 0.8:
            goals.append("solitude")
        
        # Work obligations
        current_hour = datetime.now().hour
        if 9 <= current_hour <= 17 and self.occupation != "unemployed":
            goals.append("work")
        
        # Exploration (openness-driven)
        if self.personality.openness > 0.7 and random.random() < 0.1:
            goals.append("explore")
        
        return goals
    
    async def _decide_action(self, goals: List[str], world_state: Dict[str, Any]) -> Dict[str, Any]:
        """Decide on the next action based on goals and world state."""
        try:
            # Create decision prompt
            available_locations = world_state.get("nearby_locations", [])
            nearby_agents = world_state.get("nearby_agents", [])
            
            decision_prompt = self._create_decision_prompt(goals, available_locations, nearby_agents)
            
            # Get AI decision
            messages = [
                SystemMessage(content=f"You are {self.name}, {self._get_personality_description()}"),
                HumanMessage(content=decision_prompt)
            ]
            
            response = await self.llm.ainvoke(messages)
            
            # Parse response into action
            action = self._parse_action_response(response.content)
            
            return action
            
        except Exception as e:
            logger.error(f"Decision making failed for {self.name}: {e}")
            return {"action": "idle", "duration": 1.0}
    
    def _create_decision_prompt(self, goals: List[str], available_locations: List[str], nearby_agents: List[str]) -> str:
        """Create a prompt for decision making."""
        prompt = f"""
Current Status:
- Energy: {self.energy:.2f}
- Happiness: {self.happiness:.2f}
- Social Battery: {self.social_battery:.2f}
- Current Location: {self.current_location}
- Current State: {self.current_state.value}

Current Goals: {', '.join(goals) if goals else 'None'}

Available Options:
- Nearby Locations: {', '.join(available_locations)}
- Nearby People: {', '.join(nearby_agents)}

Recent Memories:
{self._get_recent_memories_summary()}

What would you like to do next? Choose an action and provide reasoning.

Available actions:
- move_to: [location_name]
- interact_with: [agent_name]
- work: start working
- rest: rest in current location
- explore: explore the area
- idle: do nothing

Respond in JSON format:
{{"action": "action_name", "target": "target_if_needed", "reasoning": "why you chose this", "duration": estimated_minutes}}
"""
        return prompt
    
    def _get_personality_description(self) -> str:
        """Get a natural language description of the agent's personality."""
        traits = []
        
        if self.personality.extraversion > 0.6:
            traits.append("outgoing and social")
        elif self.personality.extraversion < 0.4:
            traits.append("introverted and reflective")
        
        if self.personality.conscientiousness > 0.6:
            traits.append("organized and reliable")
        elif self.personality.conscientiousness < 0.4:
            traits.append("spontaneous and flexible")
        
        if self.personality.openness > 0.6:
            traits.append("curious and creative")
        elif self.personality.openness < 0.4:
            traits.append("practical and traditional")
        
        if self.personality.agreeableness > 0.6:
            traits.append("cooperative and trusting")
        elif self.personality.agreeableness < 0.4:
            traits.append("competitive and skeptical")
        
        if self.personality.neuroticism > 0.6:
            traits.append("emotionally sensitive")
        elif self.personality.neuroticism < 0.4:
            traits.append("emotionally stable")
        
        return f"a {self.occupation} who is " + ", ".join(traits)
    
    def _get_recent_memories_summary(self, num_memories: int = 3) -> str:
        """Get a summary of recent memories."""
        recent_memories = sorted(self.memories, key=lambda m: m.timestamp, reverse=True)[:num_memories]
        
        if not recent_memories:
            return "No recent memories."
        
        summary = []
        for memory in recent_memories:
            time_ago = datetime.now() - memory.timestamp
            if time_ago.days > 0:
                time_str = f"{time_ago.days} days ago"
            elif time_ago.seconds > 3600:
                time_str = f"{time_ago.seconds // 3600} hours ago"
            else:
                time_str = f"{time_ago.seconds // 60} minutes ago"
            
            summary.append(f"- {time_str}: {memory.content}")
        
        return "\n".join(summary)
    
    def _parse_action_response(self, response: str) -> Dict[str, Any]:
        """Parse AI response into structured action."""
        try:
            # Try to parse as JSON
            if "{" in response and "}" in response:
                json_start = response.find("{")
                json_end = response.rfind("}") + 1
                json_str = response[json_start:json_end]
                action_data = json.loads(json_str)
                
                # Validate required fields
                if "action" not in action_data:
                    action_data["action"] = "idle"
                if "duration" not in action_data:
                    action_data["duration"] = 5.0
                
                return action_data
            else:
                # Fallback parsing
                return {"action": "idle", "duration": 5.0, "reasoning": "Could not parse response"}
                
        except Exception as e:
            logger.warning(f"Failed to parse action response: {e}")
            return {"action": "idle", "duration": 5.0}
    
    async def _process_experiences(self, world_state: Dict[str, Any]):
        """Process current experiences into memories."""
        try:
            # Create memory of current state
            current_time = datetime.now()
            
            if self.current_state != AgentState.IDLE:
                memory_content = f"I was {self.current_state.value}"
                
                if self.current_location:
                    memory_content += f" at {self.current_location}"
                
                # Add context from world state
                nearby_agents = world_state.get("nearby_agents", [])
                if nearby_agents:
                    memory_content += f" with {', '.join(nearby_agents[:2])}"
                    if len(nearby_agents) > 2:
                        memory_content += f" and {len(nearby_agents) - 2} others"
                
                # Calculate importance and emotional impact
                importance = self._calculate_memory_importance(self.current_state, nearby_agents)
                emotional_impact = self._calculate_emotional_impact(self.current_state)
                
                memory = Memory(
                    id=str(uuid.uuid4()),
                    content=memory_content,
                    timestamp=current_time,
                    importance=importance,
                    emotional_impact=emotional_impact,
                    associated_agents=nearby_agents,
                    location_id=self.current_location
                )
                
                self.memories.append(memory)
                
                # Limit memory size
                if len(self.memories) > 100:
                    # Remove least important old memories
                    self.memories.sort(key=lambda m: m.importance * (1 + (current_time - m.timestamp).days * 0.01))
                    self.memories = self.memories[-80:]
        
        except Exception as e:
            logger.error(f"Experience processing failed for {self.name}: {e}")
    
    def _calculate_memory_importance(self, state: AgentState, nearby_agents: List[str]) -> float:
        """Calculate the importance of a memory."""
        base_importance = {
            AgentState.SOCIALIZING: 0.7,
            AgentState.WORKING: 0.5,
            AgentState.LEARNING: 0.8,
            AgentState.EATING: 0.3,
            AgentState.MOVING: 0.2,
            AgentState.IDLE: 0.1,
            AgentState.SLEEPING: 0.1
        }.get(state, 0.3)
        
        # Increase importance if interacting with others
        if nearby_agents:
            base_importance += 0.2
        
        # Add personality-based modifiers
        if state == AgentState.SOCIALIZING and self.personality.extraversion > 0.6:
            base_importance += 0.2
        
        return min(1.0, base_importance)
    
    def _calculate_emotional_impact(self, state: AgentState) -> float:
        """Calculate emotional impact of current state."""
        base_impact = {
            AgentState.SOCIALIZING: 0.3 if self.personality.extraversion > 0.5 else -0.1,
            AgentState.WORKING: 0.1 if self.personality.conscientiousness > 0.5 else -0.2,
            AgentState.LEARNING: 0.4 if self.personality.openness > 0.5 else 0.0,
            AgentState.IDLE: -0.1 if self.personality.neuroticism > 0.5 else 0.0
        }.get(state, 0.0)
        
        # Add random variation
        return max(-1.0, min(1.0, base_impact + (random.random() - 0.5) * 0.2))
    
    def interact_with_agent(self, other_agent: 'Agent', interaction_type: str = "casual") -> float:
        """Interact with another agent and return interaction quality."""
        try:
            # Calculate compatibility
            compatibility = self._calculate_compatibility(other_agent)
            
            # Base interaction quality
            quality = compatibility
            
            # Modify based on personalities
            if interaction_type == "casual":
                if self.personality.extraversion > 0.5 and other_agent.personality.extraversion > 0.5:
                    quality += 0.2
                elif self.personality.extraversion < 0.3 and other_agent.personality.extraversion < 0.3:
                    quality += 0.1  # Introverts can connect too
            
            # Add randomness
            quality += (random.random() - 0.5) * 0.3
            quality = max(-1.0, min(1.0, quality))
            
            # Update relationships
            self._update_relationship_with_agent(other_agent.agent_id, quality)
            other_agent._update_relationship_with_agent(self.agent_id, quality)
            
            # Create memory of interaction
            memory_content = f"I had a {'pleasant' if quality > 0 else 'difficult'} interaction with {other_agent.name}"
            memory = Memory(
                id=str(uuid.uuid4()),
                content=memory_content,
                timestamp=datetime.now(),
                importance=0.6,
                emotional_impact=quality * 0.5,
                associated_agents=[other_agent.agent_id],
                location_id=self.current_location
            )
            self.memories.append(memory)
            
            return quality
            
        except Exception as e:
            logger.error(f"Interaction between {self.name} and {other_agent.name} failed: {e}")
            return 0.0
    
    def _calculate_compatibility(self, other_agent: 'Agent') -> float:
        """Calculate personality compatibility with another agent."""
        # Similarity in some traits, complementarity in others
        openness_compat = 1.0 - abs(self.personality.openness - other_agent.personality.openness)
        agree_compat = (self.personality.agreeableness + other_agent.personality.agreeableness) / 2
        
        # Extraversion can be similar or complementary
        extrav_diff = abs(self.personality.extraversion - other_agent.personality.extraversion)
        extrav_compat = max(1.0 - extrav_diff, 0.5)  # Similar or moderately different is good
        
        # Neuroticism - lower is generally better for relationships
        neuro_compat = 1.0 - (self.personality.neuroticism + other_agent.personality.neuroticism) / 2
        
        # Conscientiousness similarity
        consc_compat = 1.0 - abs(self.personality.conscientiousness - other_agent.personality.conscientiousness)
        
        # Weighted average
        compatibility = (
            openness_compat * 0.2 +
            agree_compat * 0.3 +
            extrav_compat * 0.2 +
            neuro_compat * 0.2 +
            consc_compat * 0.1
        )
        
        return compatibility
    
    def _update_relationship_with_agent(self, other_agent_id: str, interaction_quality: float):
        """Update relationship with another agent."""
        if other_agent_id not in self.relationships:
            # Create new relationship
            self.relationships[other_agent_id] = Relationship(
                target_agent_id=other_agent_id,
                relationship_type=RelationshipType.STRANGER,
                strength=0.5,
                last_interaction=datetime.now()
            )
        
        # Update existing relationship
        relationship = self.relationships[other_agent_id]
        relationship.update_relationship(interaction_quality)

class World:
    """The virtual world containing locations and managing agent interactions."""
    
    def __init__(self):
        self.locations: Dict[str, Location] = {}
        self.agents: Dict[str, Agent] = {}
        self.time_step = 0
        self.current_time = datetime.now().replace(hour=6, minute=0, second=0, microsecond=0)  # Start at 6 AM
        self.time_multiplier = 60  # 1 real second = 60 sim seconds
        
        # Social network
        self.social_network = nx.Graph()
        
        # Event system
        self.events: List[Dict[str, Any]] = []
        
        # Initialize world
        self._initialize_world()
    
    def _initialize_world(self):
        """Initialize the world with locations and basic structure."""
        # Create locations
        locations_data = [
            ("town_square", "Town Square", LocationType.PARK, (0, 0), 50),
            ("library", "Public Library", LocationType.LIBRARY, (-2, 1), 20),
            ("cafe", "Corner Cafe", LocationType.RESTAURANT, (1, 1), 15),
            ("office_building", "Office Building", LocationType.WORKPLACE, (2, 0), 100),
            ("grocery_store", "Grocery Store", LocationType.STORE, (-1, -1), 30),
            ("hospital", "General Hospital", LocationType.HOSPITAL, (0, 2), 40),
            ("school", "Elementary School", LocationType.SCHOOL, (-2, 0), 60),
            ("park", "Central Park", LocationType.PARK, (0, -2), 100),
        ]
        
        for loc_id, name, loc_type, position, capacity in locations_data:
            self.locations[loc_id] = Location(
                id=loc_id,
                name=name,
                type=loc_type,
                position=position,
                capacity=capacity
            )
        
        # Add residential area
        for i in range(10):
            home_id = f"home_{i:02d}"
            self.locations[home_id] = Location(
                id=home_id,
                name=f"Residence {i+1}",
                type=LocationType.HOME,
                position=(random.uniform(-3, 3), random.uniform(-3, 3)),
                capacity=4
            )
    
    def add_agent(self, agent: Agent):
        """Add an agent to the world."""
        self.agents[agent.agent_id] = agent
        self.social_network.add_node(agent.agent_id, name=agent.name)
        
        # Place agent in a random home if not already located
        if agent.current_location not in self.locations:
            available_homes = [loc_id for loc_id, loc in self.locations.items() 
                             if loc.type == LocationType.HOME and not loc.is_full()]
            if available_homes:
                home = random.choice(available_homes)
                agent.current_location = home
                self.locations[home].add_occupant(agent.agent_id)
    
    def get_nearby_agents(self, agent_id: str, max_distance: float = 0.1) -> List[str]:
        """Get agents in the same or nearby locations."""
        if agent_id not in self.agents:
            return []
        
        agent = self.agents[agent_id]
        current_location = self.locations.get(agent.current_location)
        
        if not current_location:
            return []
        
        # Get agents in same location
        nearby_agents = []
        for other_agent_id in current_location.current_occupants:
            if other_agent_id != agent_id:
                nearby_agents.append(self.agents[other_agent_id].name)
        
        return nearby_agents
    
    def get_nearby_locations(self, agent_id: str, max_distance: float = 2.0) -> List[str]:
        """Get locations within walking distance."""
        if agent_id not in self.agents:
            return []
        
        agent = self.agents[agent_id]
        current_location = self.locations.get(agent.current_location)
        
        if not current_location:
            return list(self.locations.keys())
        
        nearby_locations = []
        current_pos = current_location.position
        
        for loc_id, location in self.locations.items():
            if loc_id != agent.current_location:
                distance = ((location.position[0] - current_pos[0])**2 + 
                           (location.position[1] - current_pos[1])**2)**0.5
                
                if distance <= max_distance:
                    nearby_locations.append(location.name)
        
        return nearby_locations
    
    async def simulate_step(self):
        """Simulate one time step of the world."""
        try:
            self.time_step += 1
            self.current_time += timedelta(seconds=self.time_multiplier)
            
            # Prepare world state for agents
            world_state = {
                "current_time": self.current_time,
                "time_step": self.time_step
            }
            
            # Process each agent
            agent_actions = {}
            for agent_id, agent in self.agents.items():
                # Add agent-specific world state
                agent_world_state = world_state.copy()
                agent_world_state["nearby_agents"] = self.get_nearby_agents(agent_id)
                agent_world_state["nearby_locations"] = self.get_nearby_locations(agent_id)
                
                # Get agent's action
                action = await agent.think_and_act(agent_world_state)
                agent_actions[agent_id] = action
            
            # Execute actions
            await self._execute_actions(agent_actions)
            
            # Process interactions
            await self._process_interactions()
            
            # Update social network
            self._update_social_network()
            
            # Log interesting events
            self._log_events()
            
        except Exception as e:
            logger.error(f"Simulation step failed: {e}")
    
    async def _execute_actions(self, agent_actions: Dict[str, Dict[str, Any]]):
        """Execute all agent actions."""
        for agent_id, action in agent_actions.items():
            await self._execute_agent_action(agent_id, action)
    
    async def _execute_agent_action(self, agent_id: str, action: Dict[str, Any]):
        """Execute a single agent's action."""
        try:
            agent = self.agents[agent_id]
            action_type = action.get("action", "idle")
            
            if action_type == "move_to":
                target_location = action.get("target")
                if target_location:
                    await self._move_agent(agent_id, target_location)
            
            elif action_type == "interact_with":
                target_agent = action.get("target")
                if target_agent:
                    await self._facilitate_interaction(agent_id, target_agent)
            
            elif action_type in ["work", "rest", "explore"]:
                # Update agent state
                state_map = {
                    "work": AgentState.WORKING,
                    "rest": AgentState.IDLE,
                    "explore": AgentState.MOVING
                }
                agent.current_state = state_map.get(action_type, AgentState.IDLE)
            
            # Update activity timing
            agent.current_activity = action_type
            agent.activity_start_time = self.current_time
            
        except Exception as e:
            logger.error(f"Failed to execute action for agent {agent_id}: {e}")
    
    async def _move_agent(self, agent_id: str, target_location_name: str):
        """Move an agent to a new location."""
        try:
            agent = self.agents[agent_id]
            
            # Find target location
            target_location = None
            for loc_id, location in self.locations.items():
                if location.name.lower() == target_location_name.lower():
                    target_location = location
                    break
            
            if not target_location:
                logger.warning(f"Location '{target_location_name}' not found")
                return
            
            # Remove from current location
            if agent.current_location in self.locations:
                self.locations[agent.current_location].remove_occupant(agent_id)
            
            # Add to new location (if space available)
            if target_location.add_occupant(agent_id):
                agent.current_location = target_location.id
                agent.current_state = AgentState.MOVING
                
                # Create memory of movement
                memory = Memory(
                    id=str(uuid.uuid4()),
                    content=f"I moved to {target_location.name}",
                    timestamp=self.current_time,
                    importance=0.3,
                    emotional_impact=0.1,
                    location_id=target_location.id
                )
                agent.memories.append(memory)
            
        except Exception as e:
            logger.error(f"Failed to move agent {agent_id}: {e}")
    
    async def _facilitate_interaction(self, agent1_id: str, target_agent_name: str):
        """Facilitate interaction between two agents."""
        try:
            agent1 = self.agents[agent1_id]
            
            # Find target agent
            agent2 = None
            for aid, a in self.agents.items():
                if a.name.lower() == target_agent_name.lower():
                    agent2 = a
                    break
            
            if not agent2:
                logger.warning(f"Agent '{target_agent_name}' not found")
                return
            
            # Check if agents are in same location
            if agent1.current_location == agent2.current_location:
                # Facilitate interaction
                interaction_quality = agent1.interact_with_agent(agent2, "casual")
                
                # Update states
                agent1.current_state = AgentState.SOCIALIZING
                agent2.current_state = AgentState.SOCIALIZING
                
                # Log event
                self.events.append({
                    "type": "interaction",
                    "timestamp": self.current_time,
                    "participants": [agent1.name, agent2.name],
                    "location": agent1.current_location,
                    "quality": interaction_quality
                })
            
        except Exception as e:
            logger.error(f"Failed to facilitate interaction between {agent1_id} and {target_agent_name}: {e}")
    
    async def _process_interactions(self):
        """Process spontaneous interactions between agents in same locations."""
        try:
            # Group agents by location
            location_agents = {}
            for agent_id, agent in self.agents.items():
                if agent.current_location not in location_agents:
                    location_agents[agent.current_location] = []
                location_agents[agent.current_location].append(agent_id)
            
            # Process interactions in each location
            for location_id, agent_ids in location_agents.items():
                if len(agent_ids) > 1:
                    # Randomly select pairs for interaction
                    random.shuffle(agent_ids)
                    
                    for i in range(0, len(agent_ids) - 1, 2):
                        agent1 = self.agents[agent_ids[i]]
                        agent2 = self.agents[agent_ids[i + 1]]
                        
                        # Check if interaction should occur (based on personality and randomness)
                        interaction_prob = (agent1.personality.extraversion + agent2.personality.extraversion) / 4
                        interaction_prob += 0.1 if agent1.current_state == AgentState.SOCIALIZING else 0
                        
                        if random.random() < interaction_prob:
                            interaction_quality = agent1.interact_with_agent(agent2, "spontaneous")
                            
                            # Log event
                            self.events.append({
                                "type": "spontaneous_interaction",
                                "timestamp": self.current_time,
                                "participants": [agent1.name, agent2.name],
                                "location": location_id,
                                "quality": interaction_quality
                            })
        
        except Exception as e:
            logger.error(f"Failed to process interactions: {e}")
    
    def _update_social_network(self):
        """Update the social network based on agent relationships."""
        try:
            # Clear existing edges
            self.social_network.clear_edges()
            
            # Add edges based on relationships
            for agent_id, agent in self.agents.items():
                for other_agent_id, relationship in agent.relationships.items():
                    if relationship.strength > 0.3:  # Only include meaningful relationships
                        weight = relationship.strength
                        self.social_network.add_edge(
                            agent_id, 
                            other_agent_id, 
                            weight=weight,
                            relationship_type=relationship.relationship_type.value
                        )
        
        except Exception as e:
            logger.error(f"Failed to update social network: {e}")
    
    def _log_events(self):
        """Log interesting events that occurred this step."""
        # Keep only recent events
        cutoff_time = self.current_time - timedelta(hours=24)
        self.events = [event for event in self.events if event["timestamp"] > cutoff_time]
    
    def get_world_statistics(self) -> Dict[str, Any]:
        """Get current world statistics."""
        try:
            stats = {
                "current_time": self.current_time.strftime("%Y-%m-%d %H:%M"),
                "time_step": self.time_step,
                "total_agents": len(self.agents),
                "total_locations": len(self.locations),
                "total_relationships": sum(len(agent.relationships) for agent in self.agents.values()),
                "recent_events": len(self.events),
                "agent_states": {},
                "location_occupancy": {},
                "social_network_stats": {
                    "nodes": self.social_network.number_of_nodes(),
                    "edges": self.social_network.number_of_edges(),
                    "average_degree": sum(dict(self.social_network.degree()).values()) / max(self.social_network.number_of_nodes(), 1) if self.social_network.number_of_nodes() > 0 else 0
                }
            }
            
            # Count agent states
            for agent in self.agents.values():
                state = agent.current_state.value
                stats["agent_states"][state] = stats["agent_states"].get(state, 0) + 1
            
            # Count location occupancy
            for location in self.locations.values():
                occupancy = len(location.current_occupants)
                if occupancy > 0:
                    stats["location_occupancy"][location.name] = occupancy
            
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get world statistics: {e}")
            return {}

class AITownSimulation:
    """Main simulation controller for AI Town."""
    
    def __init__(self):
        self.world = World()
        self.running = False
        self.simulation_thread = None
        self.step_delay = 1.0  # Seconds between simulation steps
        
    def initialize_town(self, num_agents: int = 10):
        """Initialize the town with a population of agents."""
        try:
            logger.info(f"Initializing AI Town with {num_agents} agents")
            
            occupations = [
                "teacher", "doctor", "shopkeeper", "librarian", "chef",
                "office worker", "artist", "mechanic", "nurse", "student"
            ]
            
            for i in range(num_agents):
                # Generate random personality
                personality = Personality(
                    openness=random.random(),
                    conscientiousness=random.random(),
                    extraversion=random.random(),
                    agreeableness=random.random(),
                    neuroticism=random.random()
                )
                
                # Create agent
                agent_id = str(uuid.uuid4())
                name = fake.first_name()
                occupation = random.choice(occupations)
                
                agent = Agent(
                    agent_id=agent_id,
                    name=name,
                    personality=personality,
                    initial_location="town_square",
                    occupation=occupation
                )
                
                self.world.add_agent(agent)
            
            logger.info(f"Town initialized with {len(self.world.agents)} agents")
            
        except Exception as e:
            logger.error(f"Failed to initialize town: {e}")
            raise
    
    async def run_simulation(self, max_steps: Optional[int] = None):
        """Run the main simulation loop."""
        try:
            self.running = True
            step_count = 0
            
            logger.info("Starting AI Town simulation")
            
            while self.running:
                if max_steps and step_count >= max_steps:
                    break
                
                # Run simulation step
                await self.world.simulate_step()
                step_count += 1
                
                # Log progress
                if step_count % 10 == 0:
                    stats = self.world.get_world_statistics()
                    logger.info(f"Step {step_count}: {stats.get('current_time', 'Unknown time')}")
                
                # Wait for next step
                await asyncio.sleep(self.step_delay)
            
            logger.info(f"Simulation completed after {step_count} steps")
            
        except Exception as e:
            logger.error(f"Simulation failed: {e}")
            raise
        finally:
            self.running = False
    
    def stop_simulation(self):
        """Stop the simulation."""
        self.running = False
    
    def get_simulation_data(self) -> Dict[str, Any]:
        """Get comprehensive simulation data for analysis."""
        try:
            # Get world statistics
            world_stats = self.world.get_world_statistics()
            
            # Get agent data
            agent_data = []
            for agent in self.world.agents.values():
                agent_info = {
                    "id": agent.agent_id,
                    "name": agent.name,
                    "occupation": agent.occupation,
                    "current_location": agent.current_location,
                    "current_state": agent.current_state.value,
                    "energy": agent.energy,
                    "happiness": agent.happiness,
                    "social_battery": agent.social_battery,
                    "personality": {
                        "openness": agent.personality.openness,
                        "conscientiousness": agent.personality.conscientiousness,
                        "extraversion": agent.personality.extraversion,
                        "agreeableness": agent.personality.agreeableness,
                        "neuroticism": agent.personality.neuroticism
                    },
                    "relationships_count": len(agent.relationships),
                    "memories_count": len(agent.memories)
                }
                agent_data.append(agent_info)
            
            # Get location data
            location_data = []
            for location in self.world.locations.values():
                location_info = {
                    "id": location.id,
                    "name": location.name,
                    "type": location.type.value,
                    "position": location.position,
                    "capacity": location.capacity,
                    "current_occupancy": len(location.current_occupants),
                    "occupants": list(location.current_occupants)
                }
                location_data.append(location_info)
            
            # Get social network data
            social_network_data = {
                "nodes": [{"id": node, "name": self.world.agents[node].name} 
                         for node in self.world.social_network.nodes()],
                "edges": [{"source": edge[0], "target": edge[1], 
                          "weight": self.world.social_network[edge[0]][edge[1]].get("weight", 0)}
                         for edge in self.world.social_network.edges()]
            }
            
            return {
                "world_statistics": world_stats,
                "agents": agent_data,
                "locations": location_data,
                "social_network": social_network_data,
                "recent_events": self.world.events[-20:],  # Last 20 events
                "simulation_time": self.world.current_time.isoformat()
            }
            
        except Exception as e:
            logger.error(f"Failed to get simulation data: {e}")
            return {}

# FastAPI Application
app = FastAPI(title="AI Town Simulation", version="1.0.0")
simulation = AITownSimulation()

class SimulationRequest(BaseModel):
    num_agents: int = Field(10, description="Number of agents to create")
    max_steps: Optional[int] = Field(None, description="Maximum simulation steps")
    step_delay: float = Field(1.0, description="Delay between steps in seconds")

@app.post("/start-simulation")
async def start_simulation(request: SimulationRequest):
    """Start a new AI Town simulation."""
    try:
        if simulation.running:
            raise HTTPException(status_code=400, detail="Simulation already running")
        
        # Initialize town
        simulation.initialize_town(request.num_agents)
        simulation.step_delay = request.step_delay
        
        # Start simulation in background
        asyncio.create_task(simulation.run_simulation(request.max_steps))
        
        return {
            "message": "Simulation started",
            "num_agents": len(simulation.world.agents),
            "num_locations": len(simulation.world.locations)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/stop-simulation")
async def stop_simulation():
    """Stop the current simulation."""
    simulation.stop_simulation()
    return {"message": "Simulation stopped"}

@app.get("/simulation-status")
async def get_simulation_status():
    """Get current simulation status."""
    return {
        "running": simulation.running,
        "current_time": simulation.world.current_time.isoformat(),
        "time_step": simulation.world.time_step,
        "num_agents": len(simulation.world.agents),
        "statistics": simulation.world.get_world_statistics()
    }

@app.get("/simulation-data")
async def get_simulation_data():
    """Get comprehensive simulation data."""
    return simulation.get_simulation_data()

@app.get("/agent/{agent_id}")
async def get_agent_details(agent_id: str):
    """Get detailed information about a specific agent."""
    if agent_id not in simulation.world.agents:
        raise HTTPException(status_code=404, detail="Agent not found")
    
    agent = simulation.world.agents[agent_id]
    
    return {
        "id": agent.agent_id,
        "name": agent.name,
        "occupation": agent.occupation,
        "current_location": agent.current_location,
        "current_state": agent.current_state.value,
        "energy": agent.energy,
        "happiness": agent.happiness,
        "social_battery": agent.social_battery,
        "personality": {
            "openness": agent.personality.openness,
            "conscientiousness": agent.personality.conscientiousness,
            "extraversion": agent.personality.extraversion,
            "agreeableness": agent.personality.agreeableness,
            "neuroticism": agent.personality.neuroticism
        },
        "relationships": [
            {
                "target": rel.target_agent_id,
                "target_name": simulation.world.agents[rel.target_agent_id].name,
                "type": rel.relationship_type.value,
                "strength": rel.strength,
                "last_interaction": rel.last_interaction.isoformat()
            }
            for rel in agent.relationships.values()
        ],
        "recent_memories": [
            {
                "content": mem.content,
                "timestamp": mem.timestamp.isoformat(),
                "importance": mem.importance,
                "emotional_impact": mem.emotional_impact
            }
            for mem in sorted(agent.memories, key=lambda m: m.timestamp, reverse=True)[:10]
        ]
    }

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "simulation_running": simulation.running,
        "world_initialized": len(simulation.world.agents) > 0
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

## Project Summary

AI Town represents a groundbreaking advancement in multi-agent systems and social simulation, creating persistent virtual societies where autonomous AI agents develop authentic relationships, emergent behaviors, and complex social dynamics that provide unprecedented insights into human behavior patterns and collective intelligence phenomena.

### Key Value Propositions

**Emergent Social Dynamics**: Complex social patterns arise naturally from simple agent interactions, including friendship formation, economic behaviors, cultural evolution, and community structures that mirror real-world social phenomena while remaining completely autonomous and unpredictable.

**Advanced Multi-Agent Intelligence**: Sophisticated AI agents with unique personalities, memories, goals, and decision-making capabilities that create authentic individual behaviors while contributing to collective intelligence and emergent group behaviors through natural social interactions.

**Research and Analysis Platform**: Comprehensive framework for studying social science, psychology, and collective behavior through controlled experiments, policy simulations, and behavioral analysis in a persistent, observable virtual environment.

**Scalable Virtual Societies**: Robust architecture supporting growing populations, expanding environments, and increasing complexity while maintaining real-time performance and meaningful agent interactions across diverse social contexts.

### Technical Innovation

- **Personality-Driven Behavior**: Five-factor personality models influencing agent decisions and social interactions
- **Dynamic Relationship Systems**: Evolving social connections with memory, emotional history, and relationship progression
- **Emergent Event Generation**: Spontaneous social events and community behaviors arising from agent interactions
- **Real-time Social Network Analysis**: Live tracking and visualization of social connections and influence patterns
- **Persistent Memory Systems**: Long-term agent memories affecting future decisions and relationship development
- **Multi-layered Decision Making**: Complex AI reasoning combining personality, goals, social context, and environmental factors

### Impact and Applications

Organizations and researchers implementing this solution achieve:
- **Social Science Advancement**: Novel insights into human behavior, social formation, and community dynamics
- **Policy Testing**: Safe simulation environments for testing social policies and interventions before real-world implementation
- **Entertainment Innovation**: Revolutionary gaming experiences with truly autonomous, believable NPCs and dynamic storylines
- **Educational Enhancement**: Interactive learning environments for sociology, psychology, and behavioral science education
- **AI Research Progress**: Advancement in multi-agent systems, collective intelligence, and social AI development
- **Virtual World Development**: Next-generation virtual environments with authentic social ecosystems

AI Town demonstrates how artificial intelligence can create living, breathing virtual societies that evolve autonomously while providing valuable insights into the fundamental mechanisms of social behavior, community formation, and collective intelligence that govern both digital and physical world interactions.