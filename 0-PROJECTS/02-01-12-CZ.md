<small>Claude Sonnet 4 **(Smart Agriculture Ecosystem - Multi-Agent System)**</small>
# Smart Agriculture Ecosystem

## 1. N√°zev Projektu

**Inteligentn√≠ Zemƒõdƒõlsk√Ω Ekosyst√©m s Multi-Agent Syst√©mem**

Pokroƒçil√Ω syst√©m vyu≈æ√≠vaj√≠c√≠ umƒõlou inteligenci pro koordinaci a automatizaci zemƒõdƒõlsk√Ωch proces≈Ø prost≈ôednictv√≠m specializovan√Ωch AI agent≈Ø.

## 2. Vysvƒõtlen√≠ Kl√≠ƒçov√Ωch Koncept≈Ø

### Multi-Agent Systems (V√≠ceagentn√≠ syst√©my)
Distribuovan√Ω syst√©m slo≈æen√Ω z v√≠ce autonomn√≠ch AI agent≈Ø, kte≈ô√≠ spolupracuj√≠ na dosa≈æen√≠ spoleƒçn√Ωch c√≠l≈Ø. Ka≈æd√Ω agent m√° specifickou roli a schopnosti.

### Crop Monitoring (Monitorov√°n√≠ plodin)
Kontinu√°ln√≠ sledov√°n√≠ stavu plodin pomoc√≠ senzor≈Ø, satelitn√≠ch sn√≠mk≈Ø a AI anal√Ωzy pro optimalizaci r≈Østu a vƒçasn√© odhalen√≠ probl√©m≈Ø.

### Weather Prediction (P≈ôedpovƒõƒè poƒças√≠)
Vyu≈æit√≠ meteorologick√Ωch dat a strojov√©ho uƒçen√≠ pro p≈ôesn√© p≈ôedpov√≠d√°n√≠ poƒças√≠ s dopadem na zemƒõdƒõlsk√© aktivity.

### Pest Detection (Detekce ≈°k≈Ødc≈Ø)
Automatick√© rozpozn√°v√°n√≠ ≈°k≈Ødc≈Ø a chorob rostlin pomoc√≠ poƒç√≠taƒçov√©ho vidƒõn√≠ a anal√Ωzy obrazu.

### Irrigation Optimization (Optimalizace zavla≈æov√°n√≠)
Inteligentn√≠ ≈ô√≠zen√≠ zavla≈æovac√≠ch syst√©m≈Ø na z√°kladƒõ p≈Ødn√≠ vlhkosti, poƒças√≠ a pot≈ôeb plodin.

### Harvest Timing Coordination (Koordinace ƒçasu skliznƒõ)
Optim√°ln√≠ pl√°nov√°n√≠ skliznƒõ na z√°kladƒõ zralosti plodin, poƒças√≠ a dostupnosti pracovn√≠ s√≠ly.

## 3. Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Tento projekt vytv√°≈ô√≠ inteligentn√≠ zemƒõdƒõlsk√Ω ekosyst√©m, kter√Ω automatizuje a optimalizuje kl√≠ƒçov√© zemƒõdƒõlsk√© procesy pomoc√≠ koordinovan√Ωch AI agent≈Ø. Syst√©m m√° za c√≠l:

- **Zv√Ω≈°it produktivitu**: Optimalizac√≠ v≈°ech aspekt≈Ø pƒõstov√°n√≠
- **Sn√≠≈æit n√°klady**: Efektivn√≠m vyu≈æ√≠v√°n√≠m zdroj≈Ø
- **Minimalizovat environment√°ln√≠ dopad**: P≈ôesn√Ωm d√°vkov√°n√≠m hnojiv a pesticid≈Ø
- **Zlep≈°it kvalitu plodin**: Kontinu√°ln√≠m monitorov√°n√≠m a vƒçasnou intervenc√≠

### V√Ωzvy Projektu
- **Integrace heterogenn√≠ch dat**: Kombinace dat ze senzor≈Ø, satelit≈Ø, meteorologick√Ωch stanic
- **Koordinace agent≈Ø**: Zaji≈°tƒõn√≠ efektivn√≠ komunikace mezi r≈Øzn√Ωmi AI agenty
- **Real-time rozhodov√°n√≠**: Rychl√© reakce na mƒõn√≠c√≠ se podm√≠nky
- **≈†k√°lovatelnost**: Schopnost obslou≈æit farmy r≈Øzn√Ωch velikost√≠

### Potenci√°ln√≠ Dopad
- **Ekonomick√Ω**: Zv√Ω≈°en√≠ v√Ωnos≈Ø a sn√≠≈æen√≠ provozn√≠ch n√°klad≈Ø o 20-30%
- **Environment√°ln√≠**: Redukce spot≈ôeby vody o 25% a pesticid≈Ø o 40%
- **Soci√°ln√≠**: Zlep≈°en√≠ bezpeƒçnosti pr√°ce a kvality potravin

## 4. Komplexn√≠ P≈ô√≠klad Projektu s Python Implementac√≠

### Instalace Z√°vislost√≠

````python
# AI Framework
crewai==0.30.0
langchain==0.1.0
langchain-openai==0.0.8

# Data Processing
pandas==2.0.3
numpy==1.24.3
scikit-learn==1.3.0

# Weather API
requests==2.31.0
python-dotenv==1.0.0

# Computer Vision
opencv-python==4.8.0.74
pillow==9.5.0

# Visualization
matplotlib==3.7.1
plotly==5.15.0

# IoT Simulation
paho-mqtt==1.6.1
````

### Hlavn√≠ Implementace

````python
import os
import json
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import requests
from typing import Dict, List, Any
from dataclasses import dataclass
from crewai import Agent, Task, Crew, Process
from langchain_openai import ChatOpenAI
import cv2
from sklearn.ensemble import RandomForestRegressor
import matplotlib.pyplot as plt

# Nastaven√≠ API kl√≠ƒç≈Ø
os.environ["OPENAI_API_KEY"] = "your_openai_api_key_here"

@dataclass
class CropData:
    """Struktura dat pro plodiny"""
    field_id: str
    crop_type: str
    growth_stage: str
    soil_moisture: float
    temperature: float
    humidity: float
    ph_level: float
    nutrient_levels: Dict[str, float]
    timestamp: datetime

@dataclass
class WeatherData:
    """Struktura meteorologick√Ωch dat"""
    temperature: float
    humidity: float
    rainfall: float
    wind_speed: float
    solar_radiation: float
    forecast_days: int
    timestamp: datetime

@dataclass
class PestDetectionResult:
    """V√Ωsledek detekce ≈°k≈Ødc≈Ø"""
    field_id: str
    pest_type: str
    confidence: float
    severity: str
    recommended_action: str
    timestamp: datetime

class WeatherAgent:
    """Agent pro p≈ôedpovƒõƒè poƒças√≠"""
    
    def __init__(self):
        self.api_key = "your_weather_api_key"
        self.model = ChatOpenAI(temperature=0.1)
        
    def get_weather_forecast(self, location: str, days: int = 7) -> WeatherData:
        """Z√≠sk√°n√≠ p≈ôedpovƒõdi poƒças√≠"""
        # Simulace API vol√°n√≠ (v re√°ln√©m p≈ô√≠padƒõ by se pou≈æilo skuteƒçn√© API)
        simulated_data = {
            "temperature": np.random.normal(25, 5),
            "humidity": np.random.normal(60, 15),
            "rainfall": np.random.exponential(2),
            "wind_speed": np.random.normal(10, 3),
            "solar_radiation": np.random.normal(20, 5)
        }
        
        return WeatherData(
            temperature=simulated_data["temperature"],
            humidity=simulated_data["humidity"],
            rainfall=simulated_data["rainfall"],
            wind_speed=simulated_data["wind_speed"],
            solar_radiation=simulated_data["solar_radiation"],
            forecast_days=days,
            timestamp=datetime.now()
        )
    
    def analyze_weather_impact(self, weather_data: WeatherData, crop_type: str) -> Dict[str, Any]:
        """Anal√Ωza dopadu poƒças√≠ na plodiny"""
        analysis = {
            "irrigation_needed": weather_data.rainfall < 5,
            "frost_risk": weather_data.temperature < 2,
            "heat_stress_risk": weather_data.temperature > 35,
            "optimal_harvest_window": 3 <= weather_data.rainfall <= 10 and 15 <= weather_data.temperature <= 28
        }
        
        return analysis

class CropMonitoringAgent:
    """Agent pro monitorov√°n√≠ plodin"""
    
    def __init__(self):
        self.model = ChatOpenAI(temperature=0.1)
        self.growth_model = self._init_growth_model()
    
    def _init_growth_model(self):
        """Inicializace modelu r≈Østu plodin"""
        return RandomForestRegressor(n_estimators=100, random_state=42)
    
    def monitor_crop_health(self, field_id: str) -> CropData:
        """Monitorov√°n√≠ zdrav√≠ plodin"""
        # Simulace sensorov√Ωch dat
        return CropData(
            field_id=field_id,
            crop_type="wheat",
            growth_stage="flowering",
            soil_moisture=np.random.normal(45, 10),
            temperature=np.random.normal(22, 3),
            humidity=np.random.normal(65, 8),
            ph_level=np.random.normal(6.5, 0.5),
            nutrient_levels={
                "nitrogen": np.random.normal(40, 10),
                "phosphorus": np.random.normal(20, 5),
                "potassium": np.random.normal(30, 8)
            },
            timestamp=datetime.now()
        )
    
    def predict_yield(self, crop_data: List[CropData]) -> float:
        """Predikce v√Ωnosu"""
        # P≈ô√≠prava dat pro model
        features = []
        for data in crop_data:
            feature_row = [
                data.soil_moisture,
                data.temperature,
                data.humidity,
                data.ph_level,
                data.nutrient_levels["nitrogen"],
                data.nutrient_levels["phosphorus"],
                data.nutrient_levels["potassium"]
            ]
            features.append(feature_row)
        
        # Simulace predikce (v re√°ln√©m p≈ô√≠padƒõ by model byl natr√©nov√°n na historick√Ωch datech)
        if features:
            avg_conditions = np.mean(features, axis=0)
            predicted_yield = 50 + (avg_conditions[0] - 40) * 0.5  # Zjednodu≈°en√Ω model
            return max(0, predicted_yield)
        
        return 0

class PestDetectionAgent:
    """Agent pro detekci ≈°k≈Ødc≈Ø"""
    
    def __init__(self):
        self.model = ChatOpenAI(temperature=0.1)
        self.detection_threshold = 0.7
    
    def analyze_field_image(self, image_path: str, field_id: str) -> PestDetectionResult:
        """Anal√Ωza obrazu pole pro detekci ≈°k≈Ødc≈Ø"""
        # Simulace anal√Ωzy obrazu (v re√°ln√©m p≈ô√≠padƒõ by se pou≈æil CNN model)
        pest_types = ["aphids", "spider_mites", "thrips", "whiteflies"]
        detected_pest = np.random.choice(pest_types)
        confidence = np.random.uniform(0.6, 0.95)
        
        if confidence > self.detection_threshold:
            severity = "high" if confidence > 0.85 else "medium"
            action = self._get_treatment_recommendation(detected_pest, severity)
        else:
            severity = "low"
            action = "continue_monitoring"
        
        return PestDetectionResult(
            field_id=field_id,
            pest_type=detected_pest,
            confidence=confidence,
            severity=severity,
            recommended_action=action,
            timestamp=datetime.now()
        )
    
    def _get_treatment_recommendation(self, pest_type: str, severity: str) -> str:
        """Doporuƒçen√≠ l√©ƒçby na z√°kladƒõ typu ≈°k≈Ødce"""
        treatments = {
            "aphids": "Apply neem oil spray",
            "spider_mites": "Increase humidity, use predatory mites",
            "thrips": "Use sticky traps, apply insecticidal soap",
            "whiteflies": "Use yellow sticky traps, beneficial insects"
        }
        
        base_treatment = treatments.get(pest_type, "Consult agricultural expert")
        
        if severity == "high":
            return f"URGENT: {base_treatment}"
        else:
            return base_treatment

class IrrigationAgent:
    """Agent pro optimalizaci zavla≈æov√°n√≠"""
    
    def __init__(self):
        self.model = ChatOpenAI(temperature=0.1)
    
    def calculate_irrigation_needs(self, crop_data: CropData, weather_data: WeatherData) -> Dict[str, Any]:
        """V√Ωpoƒçet pot≈ôeby zavla≈æov√°n√≠"""
        # Faktory ovliv≈àuj√≠c√≠ zavla≈æov√°n√≠
        soil_moisture_deficit = max(0, 60 - crop_data.soil_moisture)
        evapotranspiration = self._calculate_evapotranspiration(weather_data)
        rainfall_factor = max(0, 10 - weather_data.rainfall)
        
        irrigation_amount = (soil_moisture_deficit * 0.5 + 
                           evapotranspiration * 0.3 + 
                           rainfall_factor * 0.2)
        
        return {
            "irrigation_needed": irrigation_amount > 5,
            "irrigation_amount_mm": round(irrigation_amount, 2),
            "optimal_timing": self._get_optimal_irrigation_time(weather_data),
            "efficiency_score": self._calculate_efficiency(crop_data, weather_data)
        }
    
    def _calculate_evapotranspiration(self, weather_data: WeatherData) -> float:
        """V√Ωpoƒçet evapotranspirace"""
        # Zjednodu≈°en√Ω Penman-Monteith model
        et0 = (0.0023 * (weather_data.temperature + 17.8) * 
               np.sqrt(abs(weather_data.temperature - weather_data.humidity)) * 
               (weather_data.solar_radiation + 1))
        return max(0, et0)
    
    def _get_optimal_irrigation_time(self, weather_data: WeatherData) -> str:
        """Optim√°ln√≠ ƒças pro zavla≈æov√°n√≠"""
        if weather_data.temperature < 15:
            return "morning"
        elif weather_data.wind_speed > 15:
            return "evening"
        else:
            return "early_morning"
    
    def _calculate_efficiency(self, crop_data: CropData, weather_data: WeatherData) -> float:
        """V√Ωpoƒçet efektivity zavla≈æov√°n√≠"""
        base_efficiency = 0.8
        
        # √öprava na z√°kladƒõ podm√≠nek
        if weather_data.wind_speed > 20:
            base_efficiency -= 0.2
        if weather_data.humidity < 30:
            base_efficiency -= 0.1
        if crop_data.soil_moisture < 20:
            base_efficiency += 0.1
            
        return max(0.3, min(1.0, base_efficiency))

class HarvestCoordinationAgent:
    """Agent pro koordinaci skliznƒõ"""
    
    def __init__(self):
        self.model = ChatOpenAI(temperature=0.1)
    
    def determine_harvest_timing(self, crop_data: CropData, weather_data: WeatherData) -> Dict[str, Any]:
        """Urƒçen√≠ optim√°ln√≠ho ƒçasu skliznƒõ"""
        maturity_score = self._calculate_maturity_score(crop_data)
        weather_suitability = self._assess_weather_suitability(weather_data)
        
        optimal_harvest = maturity_score > 0.8 and weather_suitability > 0.7
        
        return {
            "ready_for_harvest": optimal_harvest,
            "maturity_score": round(maturity_score, 2),
            "weather_suitability": round(weather_suitability, 2),
            "recommended_harvest_date": self._get_recommended_date(weather_data),
            "quality_prediction": self._predict_harvest_quality(crop_data, weather_data)
        }
    
    def _calculate_maturity_score(self, crop_data: CropData) -> float:
        """V√Ωpoƒçet sk√≥re zralosti"""
        # Simulace na z√°kladƒõ f√°ze r≈Østu
        growth_stages = {
            "seedling": 0.1,
            "vegetative": 0.3,
            "flowering": 0.6,
            "fruiting": 0.8,
            "mature": 1.0
        }
        return growth_stages.get(crop_data.growth_stage, 0.5)
    
    def _assess_weather_suitability(self, weather_data: WeatherData) -> float:
        """Hodnocen√≠ vhodnosti poƒças√≠ pro sklize≈à"""
        score = 1.0
        
        if weather_data.rainfall > 10:
            score -= 0.4
        if weather_data.humidity > 80:
            score -= 0.2
        if weather_data.wind_speed > 25:
            score -= 0.3
            
        return max(0, score)
    
    def _get_recommended_date(self, weather_data: WeatherData) -> str:
        """Doporuƒçen√© datum skliznƒõ"""
        optimal_date = datetime.now() + timedelta(days=3)
        return optimal_date.strftime("%Y-%m-%d")
    
    def _predict_harvest_quality(self, crop_data: CropData, weather_data: WeatherData) -> str:
        """Predikce kvality skliznƒõ"""
        quality_factors = [
            crop_data.soil_moisture / 100,
            (100 - abs(weather_data.humidity - 60)) / 100,
            (40 - abs(weather_data.temperature - 22)) / 40
        ]
        
        avg_quality = np.mean(quality_factors)
        
        if avg_quality > 0.8:
            return "excellent"
        elif avg_quality > 0.6:
            return "good"
        elif avg_quality > 0.4:
            return "fair"
        else:
            return "poor"

class SmartAgricultureSystem:
    """Hlavn√≠ syst√©m koordinuj√≠c√≠ v≈°echny agenty"""
    
    def __init__(self):
        self.weather_agent = WeatherAgent()
        self.crop_agent = CropMonitoringAgent()
        self.pest_agent = PestDetectionAgent()
        self.irrigation_agent = IrrigationAgent()
        self.harvest_agent = HarvestCoordinationAgent()
        
        # CrewAI setup
        self.llm = ChatOpenAI(temperature=0.1)
        self._setup_crew()
    
    def _setup_crew(self):
        """Nastaven√≠ CrewAI t√Ωmu"""
        # Definice agent≈Ø
        coordinator = Agent(
            role='Farm Coordinator',
            goal='Coordinate all farming activities for optimal crop production',
            backstory='Expert agricultural coordinator with deep knowledge of crop management',
            verbose=True,
            allow_delegation=True,
            llm=self.llm
        )
        
        analyst = Agent(
            role='Data Analyst',
            goal='Analyze agricultural data and provide insights',
            backstory='Agricultural data scientist specializing in crop optimization',
            verbose=True,
            llm=self.llm
        )
        
        # Definice √∫kol≈Ø
        analysis_task = Task(
            description='Analyze current field conditions and provide recommendations',
            agent=analyst,
            expected_output='Detailed analysis report with recommendations'
        )
        
        coordination_task = Task(
            description='Coordinate farming activities based on analysis',
            agent=coordinator,
            expected_output='Action plan for farming operations'
        )
        
        # Vytvo≈ôen√≠ t√Ωmu
        self.crew = Crew(
            agents=[coordinator, analyst],
            tasks=[analysis_task, coordination_task],
            process=Process.sequential,
            verbose=True
        )
    
    def run_complete_analysis(self, field_id: str) -> Dict[str, Any]:
        """Spu≈°tƒõn√≠ kompletn√≠ anal√Ωzy pole"""
        try:
            # Z√≠sk√°n√≠ dat od v≈°ech agent≈Ø
            crop_data = self.crop_agent.monitor_crop_health(field_id)
            weather_data = self.weather_agent.get_weather_forecast("farm_location")
            pest_result = self.pest_agent.analyze_field_image("field_image.jpg", field_id)
            irrigation_plan = self.irrigation_agent.calculate_irrigation_needs(crop_data, weather_data)
            harvest_plan = self.harvest_agent.determine_harvest_timing(crop_data, weather_data)
            
            # Koordinace a optimalizace
            comprehensive_plan = {
                "field_id": field_id,
                "timestamp": datetime.now().isoformat(),
                "crop_status": {
                    "type": crop_data.crop_type,
                    "growth_stage": crop_data.growth_stage,
                    "health_score": self._calculate_health_score(crop_data)
                },
                "weather_analysis": self.weather_agent.analyze_weather_impact(weather_data, crop_data.crop_type),
                "pest_management": {
                    "threat_level": pest_result.severity,
                    "action_required": pest_result.recommended_action
                },
                "irrigation_optimization": irrigation_plan,
                "harvest_coordination": harvest_plan,
                "overall_recommendations": self._generate_recommendations(
                    crop_data, weather_data, pest_result, irrigation_plan, harvest_plan
                )
            }
            
            return comprehensive_plan
            
        except Exception as e:
            return {"error": f"Analysis failed: {str(e)}"}
    
    def _calculate_health_score(self, crop_data: CropData) -> float:
        """V√Ωpoƒçet celkov√©ho zdravotn√≠ho sk√≥re plodiny"""
        factors = [
            min(crop_data.soil_moisture / 60, 1.0),
            min(crop_data.nutrient_levels["nitrogen"] / 50, 1.0),
            min(crop_data.nutrient_levels["phosphorus"] / 25, 1.0),
            max(0, 1 - abs(crop_data.ph_level - 6.5) / 2)
        ]
        return round(np.mean(factors), 2)
    
    def _generate_recommendations(self, crop_data, weather_data, pest_result, 
                                irrigation_plan, harvest_plan) -> List[str]:
        """Generov√°n√≠ celkov√Ωch doporuƒçen√≠"""
        recommendations = []
        
        # Prioritn√≠ akce
        if pest_result.severity == "high":
            recommendations.append(f"üö® URGENT: {pest_result.recommended_action}")
        
        if irrigation_plan["irrigation_needed"]:
            recommendations.append(f"üíß Irrigation needed: {irrigation_plan['irrigation_amount_mm']}mm")
        
        if harvest_plan["ready_for_harvest"]:
            recommendations.append(f"üåæ Ready for harvest on {harvest_plan['recommended_harvest_date']}")
        
        # Preventivn√≠ opat≈ôen√≠
        if weather_data.temperature > 30:
            recommendations.append("üå°Ô∏è Heat stress risk - consider shade cloth or increased irrigation")
        
        if crop_data.soil_moisture < 30:
            recommendations.append("üíß Low soil moisture - increase irrigation frequency")
        
        return recommendations
    
    def generate_dashboard_data(self, field_ids: List[str]) -> Dict[str, Any]:
        """Generov√°n√≠ dat pro dashboard"""
        dashboard_data = {
            "overview": {
                "total_fields": len(field_ids),
                "healthy_fields": 0,
                "fields_needing_attention": 0,
                "ready_for_harvest": 0
            },
            "field_details": []
        }
        
        for field_id in field_ids:
            analysis = self.run_complete_analysis(field_id)
            if "error" not in analysis:
                dashboard_data["field_details"].append(analysis)
                
                # Aktualizace p≈ôehledu
                if analysis["crop_status"]["health_score"] > 0.7:
                    dashboard_data["overview"]["healthy_fields"] += 1
                else:
                    dashboard_data["overview"]["fields_needing_attention"] += 1
                
                if analysis["harvest_coordination"]["ready_for_harvest"]:
                    dashboard_data["overview"]["ready_for_harvest"] += 1
        
        return dashboard_data

# Demonstrace pou≈æit√≠
def main():
    """Hlavn√≠ demonstraƒçn√≠ funkce"""
    print("üåæ Spou≈°tƒõn√≠ Smart Agriculture System...")
    
    # Inicializace syst√©mu
    agriculture_system = SmartAgricultureSystem()
    
    # Anal√Ωza nƒõkolika pol√≠
    field_ids = ["field_001", "field_002", "field_003"]
    
    print("\nüìä Generov√°n√≠ dashboard dat...")
    dashboard = agriculture_system.generate_dashboard_data(field_ids)
    
    print(f"\nüèûÔ∏è P≈ôehled farmy:")
    print(f"Celkov√Ω poƒçet pol√≠: {dashboard['overview']['total_fields']}")
    print(f"Zdrav√° pole: {dashboard['overview']['healthy_fields']}")
    print(f"Pole vy≈æaduj√≠c√≠ pozornost: {dashboard['overview']['fields_needing_attention']}")
    print(f"Pole p≈ôipraven√° ke sklizni: {dashboard['overview']['ready_for_harvest']}")
    
    # Detailn√≠ anal√Ωza prvn√≠ho pole
    if dashboard["field_details"]:
        field_detail = dashboard["field_details"][0]
        print(f"\nüîç Detailn√≠ anal√Ωza pole {field_detail['field_id']}:")
        print(f"Plodina: {field_detail['crop_status']['type']}")
        print(f"F√°ze r≈Østu: {field_detail['crop_status']['growth_stage']}")
        print(f"Zdravotn√≠ sk√≥re: {field_detail['crop_status']['health_score']}")
        
        print("\nüìã Doporuƒçen√≠:")
        for rec in field_detail["overall_recommendations"]:
            print(f"  ‚Ä¢ {rec}")

if __name__ == "__main__":
    main()
````

### Uk√°zka Konfigurace a Testov√°n√≠

````python
import unittest
from datetime import datetime
import numpy as np
from smart_agriculture_system import (
    SmartAgricultureSystem, CropData, WeatherData, 
    WeatherAgent, CropMonitoringAgent
)

class TestSmartAgricultureSystem(unittest.TestCase):
    """Testy pro Smart Agriculture System"""
    
    def setUp(self):
        """Nastaven√≠ testovac√≠ho prost≈ôed√≠"""
        self.system = SmartAgricultureSystem()
        self.sample_crop_data = CropData(
            field_id="test_field",
            crop_type="wheat",
            growth_stage="flowering",
            soil_moisture=45.0,
            temperature=22.0,
            humidity=65.0,
            ph_level=6.5,
            nutrient_levels={"nitrogen": 40, "phosphorus": 20, "potassium": 30},
            timestamp=datetime.now()
        )
    
    def test_weather_agent_forecast(self):
        """Test p≈ôedpovƒõdi poƒças√≠"""
        weather_agent = WeatherAgent()
        forecast = weather_agent.get_weather_forecast("test_location")
        
        self.assertIsInstance(forecast, WeatherData)
        self.assertGreater(forecast.temperature, -50)
        self.assertLess(forecast.temperature, 60)
    
    def test_crop_health_monitoring(self):
        """Test monitorov√°n√≠ zdrav√≠ plodin"""
        crop_agent = CropMonitoringAgent()
        crop_data = crop_agent.monitor_crop_health("test_field")
        
        self.assertIsInstance(crop_data, CropData)
        self.assertEqual(crop_data.field_id, "test_field")
        self.assertIn("nitrogen", crop_data.nutrient_levels)
    
    def test_irrigation_calculation(self):
        """Test v√Ωpoƒçtu zavla≈æov√°n√≠"""
        irrigation_agent = self.system.irrigation_agent
        weather_data = WeatherData(
            temperature=25, humidity=60, rainfall=2, 
            wind_speed=10, solar_radiation=20, 
            forecast_days=7, timestamp=datetime.now()
        )
        
        irrigation_plan = irrigation_agent.calculate_irrigation_needs(
            self.sample_crop_data, weather_data
        )
        
        self.assertIn("irrigation_needed", irrigation_plan)
        self.assertIn("irrigation_amount_mm", irrigation_plan)
    
    def test_complete_analysis(self):
        """Test kompletn√≠ anal√Ωzy"""
        result = self.system.run_complete_analysis("test_field")
        
        self.assertIn("field_id", result)
        self.assertIn("crop_status", result)
        self.assertIn("overall_recommendations", result)

if __name__ == "__main__":
    unittest.main()
````

## 5. Shrnut√≠ Projektu

### Kl√≠ƒçov√© V√Ωhody
- **Autonomn√≠ rozhodov√°n√≠**: AI agenti samostatnƒõ analyzuj√≠ a reaguj√≠ na zmƒõny
- **Koordinovan√° spolupr√°ce**: V≈°ichni agenti sd√≠lej√≠ informace pro optim√°ln√≠ rozhodnut√≠
- **Real-time monitoring**: Kontinu√°ln√≠ sledov√°n√≠ v≈°ech d≈Øle≈æit√Ωch parametr≈Ø
- **Prediktivn√≠ anal√Ωza**: P≈ôedpov√≠d√°n√≠ probl√©m≈Ø p≈ôed jejich vznikem

### Technick√© Inovace
- **Multi-agent architektura**: Vyu≈æit√≠ CrewAI pro koordinaci specializovan√Ωch agent≈Ø
- **Integrovan√© senzorov√© syst√©my**: Kombinace IoT senzor≈Ø, satelitn√≠ch dat a meteorologick√Ωch informac√≠
- **Pokroƒçil√© algoritmy**: Strojov√© uƒçen√≠ pro predikci v√Ωnos≈Ø a optimalizaci proces≈Ø
- **≈†k√°lovateln√° architektura**: Mo≈ænost roz≈°√≠≈ôen√≠ na velk√© farmy i agricultural kooperativy

### Ekonomick√Ω P≈ô√≠nos
Tento syst√©m p≈ôedstavuje v√Ωznamn√Ω krok vp≈ôed v precizn√≠m zemƒõdƒõlstv√≠ s potenci√°lem transformovat zp≈Øsob, jak√Ωm se farmy spravuj√≠. Kombinace AI agent≈Ø, real-time monitoringu a prediktivn√≠ anal√Ωzy vytv√°≈ô√≠ synergii, kter√° m≈Ø≈æe dramaticky zv√Ω≈°it efektivitu a udr≈æitelnost zemƒõdƒõlsk√© produkce.

**N√°vratnost investice**: 2-3 roky d√≠ky √∫spor√°m n√°klad≈Ø a zv√Ω≈°en√≠ v√Ωnos≈Ø
**Environment√°ln√≠ dopad**: V√Ωznamn√© sn√≠≈æen√≠ spot≈ôeby zdroj≈Ø a chemick√Ωch l√°tek
**Budouc√≠ rozvoj**: Integrace s robotick√Ωmi syst√©my a autonomn√≠mi vozidly pro plnƒõ automatizovan√© farmy