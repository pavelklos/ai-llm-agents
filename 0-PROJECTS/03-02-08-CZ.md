<small>Claude Sonnet 4 **(Analyz√°tor Z√°kaznick√Ωch L√≠stk≈Ø s AI)**</small>
# Customer Support Ticket Analyzer

## Kl√≠ƒçov√© Koncepty

### RAG (Retrieval-Augmented Generation)
**RAG** kombinuje vyhled√°v√°n√≠ relevantn√≠ch informac√≠ z datab√°ze znalost√≠ s generov√°n√≠m odpovƒõd√≠ pomoc√≠ LLM. Umo≈æ≈àuje AI syst√©m≈Øm p≈ôistupovat k aktu√°ln√≠m a specifick√Ωm informac√≠m bez nutnosti p≈ôetr√©nov√°n√≠ modelu.

### LangChain
**LangChain** je framework pro v√Ωvoj aplikac√≠ vyu≈æ√≠vaj√≠c√≠ch jazykov√© modely. Poskytuje n√°stroje pro ≈ôetƒõzen√≠ operac√≠, spr√°vu prompt≈Ø, integraci s datab√°zemi a orchestraci komplexn√≠ch AI workflow.

### ElasticSearch
**ElasticSearch** je distribuovan√Ω vyhled√°vac√≠ engine zalo≈æen√Ω na Apache Lucene. Umo≈æ≈àuje rychl√© full-textov√© vyhled√°v√°n√≠, anal√Ωzu dokument≈Ø a pokroƒçil√© filtrov√°n√≠ dat.

### Email Parsing
**Email Parsing** je proces extrakce strukturovan√Ωch dat z emailov√Ωch zpr√°v - vƒçetnƒõ hlaviƒçek, tƒõla zpr√°vy, p≈ô√≠loh a metadat pro dal≈°√≠ zpracov√°n√≠.

### OpenAI Functions
**OpenAI Functions** umo≈æ≈àuj√≠ LLM volat externe definovan√© funkce, ƒç√≠m≈æ roz≈°i≈ôuj√≠ schopnosti modelu o konkr√©tn√≠ akce jako datab√°zov√© dotazy nebo API vol√°n√≠.

### Retrieval Filters
**Retrieval Filters** jsou mechanismy pro filtrov√°n√≠ a prioritizaci relevantn√≠ch dokument≈Ø bƒõhem vyhled√°v√°n√≠, ƒçasto zalo≈æen√© na metadatech, kategorii nebo podobnosti.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

Analyz√°tor z√°kaznick√Ωch l√≠stk≈Ø p≈ôedstavuje pokroƒçil√Ω AI syst√©m navr≈æen√Ω pro automatizaci a optimalizaci z√°kaznick√© podpory. Syst√©m vyu≈æ√≠v√° historick√° data z p≈ôedchoz√≠ch l√≠stk≈Ø k poskytov√°n√≠ inteligentn√≠ch odpovƒõd√≠ a automatick√© klasifikaci nov√Ωch po≈æadavk≈Ø.

### C√≠le Projektu
- **Automatizace rutinn√≠ch odpovƒõd√≠** na ƒçasto kladen√© ot√°zky
- **Inteligentn√≠ klasifikace** l√≠stk≈Ø podle priority a kategorie
- **Asistence agent≈Øm** s navrhovan√Ωmi ≈ôe≈°en√≠mi na z√°kladƒõ historick√Ωch dat
- **Zlep≈°en√≠ konzistence** odpovƒõd√≠ nap≈ô√≠ƒç t√Ωmem podpory
- **Redukce ƒçasu odezvy** na z√°kaznick√© dotazy

### Hlavn√≠ V√Ωzvy
- **Kvalita dat**: Historick√© l√≠stky mohou obsahovat nekonzistentn√≠ informace
- **Kontext**: Pochopen√≠ specifick√©ho kontextu z√°kaznick√©ho probl√©mu
- **Escalace**: Rozpozn√°n√≠ kdy p≈ôedat l√≠stek lidsk√©mu agentovi
- **Aktualizace znalost√≠**: Kontinu√°ln√≠ uƒçen√≠ z nov√Ωch l√≠stk≈Ø

### Potenci√°ln√≠ Dopad
Implementace m≈Ø≈æe sn√≠≈æit ƒças ≈ôe≈°en√≠ l√≠stk≈Ø o 40-60%, zv√Ω≈°it spokojenost z√°kazn√≠k≈Ø a umo≈ænit agent≈Øm zamƒõ≈ôit se na komplexnƒõj≈°√≠ probl√©my.

## Komplexn√≠ Implementace v Pythonu

````python
langchain==0.1.0
langchain-community==0.0.13
langchain-openai==0.0.5
elasticsearch==8.11.0
python-dotenv==1.0.0
pandas==2.1.4
pydantic==2.5.2
email-validator==2.1.0
beautifulsoup4==4.12.2
numpy==1.24.3
scikit-learn==1.3.2
````

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    ELASTICSEARCH_URL = os.getenv("ELASTICSEARCH_URL", "http://localhost:9200")
    ELASTICSEARCH_INDEX = "support_tickets"
    MODEL_NAME = "gpt-4"
    EMBEDDING_MODEL = "text-embedding-ada-002"
    MAX_TOKENS = 1000
    TEMPERATURE = 0.3
````

````python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, List, Dict, Any
from enum import Enum

class TicketPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class TicketCategory(str, Enum):
    TECHNICAL = "technical"
    BILLING = "billing"
    GENERAL = "general"
    BUG_REPORT = "bug_report"
    FEATURE_REQUEST = "feature_request"

class TicketStatus(str, Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    CLOSED = "closed"

class SupportTicket(BaseModel):
    id: str
    subject: str
    content: str
    customer_email: str
    category: Optional[TicketCategory] = None
    priority: Optional[TicketPriority] = None
    status: TicketStatus = TicketStatus.OPEN
    created_at: datetime
    updated_at: Optional[datetime] = None
    resolution: Optional[str] = None
    agent_id: Optional[str] = None
    tags: List[str] = Field(default_factory=list)
    
class TicketAnalysis(BaseModel):
    ticket_id: str
    predicted_category: TicketCategory
    predicted_priority: TicketPriority
    confidence_score: float
    suggested_response: str
    similar_tickets: List[str]
    escalation_required: bool
    estimated_resolution_time: int  # v hodin√°ch
````

````python
import json
import uuid
from datetime import datetime, timedelta
import random
from models import SupportTicket, TicketCategory, TicketPriority, TicketStatus

class TicketDataGenerator:
    def __init__(self):
        self.sample_tickets = [
            {
                "subject": "Probl√©m s p≈ôihl√°≈°en√≠m",
                "content": "Nemohu se p≈ôihl√°sit do sv√©ho √∫ƒçtu. Zobrazuje se chyba 'Neplatn√© p≈ôihla≈°ovac√≠ √∫daje'.",
                "category": TicketCategory.TECHNICAL,
                "priority": TicketPriority.MEDIUM,
                "resolution": "Reset hesla vy≈ôe≈°il probl√©m. Heslo bylo vypr≈°el√©."
            },
            {
                "subject": "Chybn√© √∫ƒçtov√°n√≠",
                "content": "Na faktu≈ôe je √∫ƒçtov√°na slu≈æba, kterou jsem nezakazoval.",
                "category": TicketCategory.BILLING,
                "priority": TicketPriority.HIGH,
                "resolution": "Slu≈æba byla omylem p≈ôid√°na p≈ôi aktualizaci syst√©mu. Provedena refundace."
            },
            {
                "subject": "Aplikace se neust√°le restartuje",
                "content": "Mobiln√≠ aplikace se neust√°le restartuje p≈ôi pokusu o naƒçten√≠ dat.",
                "category": TicketCategory.BUG_REPORT,
                "priority": TicketPriority.HIGH,
                "resolution": "Bug v API vol√°n√≠. Vyd√°na aktualizace verze 2.1.3."
            },
            {
                "subject": "Jak zmƒõnit email",
                "content": "Pot≈ôebuji zmƒõnit emailovou adresu v profilu.",
                "category": TicketCategory.GENERAL,
                "priority": TicketPriority.LOW,
                "resolution": "N√°vod odesl√°n. Email lze zmƒõnit v nastaven√≠ profilu."
            },
            {
                "subject": "Po≈æadavek na novou funkci",
                "content": "Bylo by mo≈æn√© p≈ôidat mo≈ænost exportu dat do CSV?",
                "category": TicketCategory.FEATURE_REQUEST,
                "priority": TicketPriority.LOW,
                "resolution": "Po≈æadavek p≈ôelo≈æen do product backlogu. Pl√°nov√°no do Q2."
            }
        ]
    
    def generate_tickets(self, count: int = 100) -> List[SupportTicket]:
        tickets = []
        for i in range(count):
            sample = random.choice(self.sample_tickets)
            created_at = datetime.now() - timedelta(days=random.randint(1, 365))
            
            ticket = SupportTicket(
                id=str(uuid.uuid4()),
                subject=sample["subject"] + f" #{i+1}",
                content=sample["content"],
                customer_email=f"customer{i+1}@example.com",
                category=sample["category"],
                priority=sample["priority"],
                status=random.choice(list(TicketStatus)),
                created_at=created_at,
                updated_at=created_at + timedelta(hours=random.randint(1, 48)),
                resolution=sample["resolution"] if random.random() > 0.3 else None,
                agent_id=f"agent_{random.randint(1, 10)}",
                tags=[f"tag_{random.randint(1, 5)}" for _ in range(random.randint(0, 3))]
            )
            tickets.append(ticket)
        
        return tickets
    
    def save_tickets_to_json(self, tickets: List[SupportTicket], filename: str = "sample_tickets.json"):
        data = [ticket.model_dump(mode='json') for ticket in tickets]
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2, default=str)
````

````python
from elasticsearch import Elasticsearch
from langchain_openai import OpenAIEmbeddings
from typing import List, Dict, Any
import json
from models import SupportTicket
from config import Config

class ElasticSearchManager:
    def __init__(self):
        self.client = Elasticsearch([Config.ELASTICSEARCH_URL])
        self.index_name = Config.ELASTICSEARCH_INDEX
        self.embeddings = OpenAIEmbeddings(api_key=Config.OPENAI_API_KEY)
        self._create_index()
    
    def _create_index(self):
        if not self.client.indices.exists(index=self.index_name):
            mapping = {
                "mappings": {
                    "properties": {
                        "id": {"type": "keyword"},
                        "subject": {"type": "text", "analyzer": "standard"},
                        "content": {"type": "text", "analyzer": "standard"},
                        "customer_email": {"type": "keyword"},
                        "category": {"type": "keyword"},
                        "priority": {"type": "keyword"},
                        "status": {"type": "keyword"},
                        "created_at": {"type": "date"},
                        "resolution": {"type": "text"},
                        "tags": {"type": "keyword"},
                        "embedding": {"type": "dense_vector", "dims": 1536}
                    }
                }
            }
            self.client.indices.create(index=self.index_name, body=mapping)
    
    def index_ticket(self, ticket: SupportTicket):
        try:
            # Generov√°n√≠ embeddingu pro obsah l√≠stku
            combined_text = f"{ticket.subject} {ticket.content}"
            embedding = self.embeddings.embed_query(combined_text)
            
            doc = ticket.model_dump(mode='json')
            doc['embedding'] = embedding
            
            self.client.index(
                index=self.index_name,
                id=ticket.id,
                body=doc
            )
        except Exception as e:
            print(f"Chyba p≈ôi indexov√°n√≠ l√≠stku {ticket.id}: {e}")
    
    def search_similar_tickets(self, query: str, category: str = None, limit: int = 5) -> List[Dict]:
        try:
            # Generov√°n√≠ embeddingu pro dotaz
            query_embedding = self.embeddings.embed_query(query)
            
            # Sestaven√≠ dotazu
            search_body = {
                "size": limit,
                "query": {
                    "bool": {
                        "must": [
                            {
                                "script_score": {
                                    "query": {"match_all": {}},
                                    "script": {
                                        "source": "cosineSimilarity(params.query_vector, 'embedding') + 1.0",
                                        "params": {"query_vector": query_embedding}
                                    }
                                }
                            }
                        ]
                    }
                }
            }
            
            # P≈ôid√°n√≠ filtru pro kategorii
            if category:
                search_body["query"]["bool"]["filter"] = [
                    {"term": {"category": category}}
                ]
            
            response = self.client.search(index=self.index_name, body=search_body)
            return [hit["_source"] for hit in response["hits"]["hits"]]
        
        except Exception as e:
            print(f"Chyba p≈ôi vyhled√°v√°n√≠: {e}")
            return []
    
    def get_ticket_statistics(self) -> Dict[str, Any]:
        try:
            stats = {}
            
            # Celkov√Ω poƒçet l√≠stk≈Ø
            total_response = self.client.count(index=self.index_name)
            stats['total_tickets'] = total_response['count']
            
            # Statistiky podle kategorie
            category_agg = self.client.search(
                index=self.index_name,
                body={
                    "size": 0,
                    "aggs": {
                        "categories": {
                            "terms": {"field": "category"}
                        }
                    }
                }
            )
            stats['by_category'] = {
                bucket['key']: bucket['doc_count']
                for bucket in category_agg['aggregations']['categories']['buckets']
            }
            
            return stats
        except Exception as e:
            print(f"Chyba p≈ôi z√≠sk√°v√°n√≠ statistik: {e}")
            return {}
````

````python
from langchain_openai import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from langchain.tools import tool
from typing import List, Dict, Any
import json
import re
from models import SupportTicket, TicketAnalysis, TicketCategory, TicketPriority
from elasticsearch_manager import ElasticSearchManager
from config import Config

class TicketAnalyzer:
    def __init__(self):
        self.llm = ChatOpenAI(
            api_key=Config.OPENAI_API_KEY,
            model_name=Config.MODEL_NAME,
            temperature=Config.TEMPERATURE
        )
        self.es_manager = ElasticSearchManager()
    
    @tool
    def search_knowledge_base(self, query: str, category: str = None) -> str:
        """Vyhled√° podobn√© l√≠stky v knowledge base"""
        similar_tickets = self.es_manager.search_similar_tickets(query, category)
        if not similar_tickets:
            return "Nenalezeny podobn√© l√≠stky."
        
        results = []
        for ticket in similar_tickets[:3]:
            if ticket.get('resolution'):
                results.append(f"Probl√©m: {ticket['subject']}\n≈òe≈°en√≠: {ticket['resolution']}")
        
        return "\n\n".join(results) if results else "Nenalezena vy≈ôe≈°en√° podobn√° p≈ô√≠pady."
    
    def classify_ticket(self, ticket: SupportTicket) -> TicketAnalysis:
        try:
            # Vyhled√°n√≠ podobn√Ωch l√≠stk≈Ø
            similar_tickets = self.es_manager.search_similar_tickets(
                f"{ticket.subject} {ticket.content}",
                limit=5
            )
            
            similar_ids = [t['id'] for t in similar_tickets]
            
            # P≈ô√≠prava kontextu z podobn√Ωch l√≠stk≈Ø
            context = self._prepare_context(similar_tickets)
            
            system_prompt = """Jsi AI asistent pro anal√Ωzu z√°kaznick√Ωch l√≠stk≈Ø. 
            Tv√Ωm √∫kolem je klasifikovat l√≠stek a navrhnout ≈ôe≈°en√≠ na z√°kladƒõ historick√Ωch dat.
            
            Kategorie: technical, billing, general, bug_report, feature_request
            Priority: low, medium, high, critical
            
            Vra≈• odpovƒõƒè v JSON form√°tu:
            {
                "category": "kategorie",
                "priority": "priorita", 
                "confidence": 0.0-1.0,
                "response": "navrhovan√° odpovƒõƒè",
                "escalation_required": true/false,
                "estimated_hours": poƒçet_hodin
            }"""
            
            user_prompt = f"""
            NOV√ù L√çSTEK:
            P≈ôedmƒõt: {ticket.subject}
            Obsah: {ticket.content}
            Email: {ticket.customer_email}
            
            PODOBN√â VY≈òE≈†EN√â P≈ò√çPADY:
            {context}
            
            Analyzuj l√≠stek a navrhni ≈ôe≈°en√≠."""
            
            messages = [
                SystemMessage(content=system_prompt),
                HumanMessage(content=user_prompt)
            ]
            
            response = self.llm(messages)
            
            # Parsov√°n√≠ JSON odpovƒõdi
            result = self._parse_analysis_response(response.content)
            
            return TicketAnalysis(
                ticket_id=ticket.id,
                predicted_category=TicketCategory(result.get('category', 'general')),
                predicted_priority=TicketPriority(result.get('priority', 'medium')),
                confidence_score=result.get('confidence', 0.5),
                suggested_response=result.get('response', 'L√≠stek vy≈æaduje ruƒçn√≠ zpracov√°n√≠.'),
                similar_tickets=similar_ids,
                escalation_required=result.get('escalation_required', False),
                estimated_resolution_time=result.get('estimated_hours', 24)
            )
            
        except Exception as e:
            print(f"Chyba p≈ôi anal√Ωze l√≠stku: {e}")
            return self._create_fallback_analysis(ticket)
    
    def _prepare_context(self, similar_tickets: List[Dict]) -> str:
        context_parts = []
        for i, ticket in enumerate(similar_tickets[:3], 1):
            if ticket.get('resolution'):
                context_parts.append(
                    f"{i}. Probl√©m: {ticket['subject']}\n"
                    f"   Kategorie: {ticket['category']}\n"
                    f"   ≈òe≈°en√≠: {ticket['resolution']}"
                )
        return "\n\n".join(context_parts) if context_parts else "≈Ω√°dn√© podobn√© vy≈ôe≈°en√© p≈ô√≠pady."
    
    def _parse_analysis_response(self, response_text: str) -> Dict[str, Any]:
        try:
            # Extrakce JSON z odpovƒõdi
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                return json.loads(json_match.group())
        except:
            pass
        
        # Fallback parsing
        return {
            'category': 'general',
            'priority': 'medium',
            'confidence': 0.3,
            'response': 'Automatick√° anal√Ωza selhala. Vy≈æaduje ruƒçn√≠ zpracov√°n√≠.',
            'escalation_required': True,
            'estimated_hours': 24
        }
    
    def _create_fallback_analysis(self, ticket: SupportTicket) -> TicketAnalysis:
        return TicketAnalysis(
            ticket_id=ticket.id,
            predicted_category=TicketCategory.GENERAL,
            predicted_priority=TicketPriority.MEDIUM,
            confidence_score=0.3,
            suggested_response="Syst√©m nemohl automaticky analyzovat l√≠stek. P≈ôed√°v√°no lidsk√©mu agentovi.",
            similar_tickets=[],
            escalation_required=True,
            estimated_resolution_time=24
        )
    
    def generate_response(self, ticket: SupportTicket, analysis: TicketAnalysis) -> str:
        """Generuje personalizovanou odpovƒõƒè z√°kazn√≠kovi"""
        system_prompt = """Jsi profesion√°ln√≠ z√°kaznick√Ω agent. 
        Napi≈° zdvo≈ôilou a u≈æiteƒçnou odpovƒõƒè z√°kazn√≠kovi na z√°kladƒõ anal√Ωzy l√≠stku.
        Odpovƒõƒè by mƒõla b√Ωt v ƒçe≈°tinƒõ, profesion√°ln√≠ a empatick√°."""
        
        user_prompt = f"""
        Z√ÅKAZNICK√ù L√çSTEK:
        P≈ôedmƒõt: {ticket.subject}
        Obsah: {ticket.content}
        
        ANAL√ùZA:
        Kategorie: {analysis.predicted_category}
        Priorita: {analysis.predicted_priority}
        Navrhovan√© ≈ôe≈°en√≠: {analysis.suggested_response}
        
        Napi≈° odpovƒõƒè z√°kazn√≠kovi."""
        
        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(content=user_prompt)
        ]
        
        response = self.llm(messages)
        return response.content
````

````python
import email
import re
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, List, Optional
from datetime import datetime
from models import SupportTicket
import uuid

class EmailParser:
    def __init__(self):
        self.email_pattern = re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b')
    
    def parse_email(self, email_content: str) -> Optional[SupportTicket]:
        """Parse email content and create SupportTicket"""
        try:
            msg = email.message_from_string(email_content)
            
            # Extrakce z√°kladn√≠ch informac√≠
            subject = self._decode_header(msg.get('Subject', 'Bez p≈ôedmƒõtu'))
            from_addr = self._extract_email_address(msg.get('From', ''))
            date_str = msg.get('Date', '')
            
            # Extrakce tƒõla zpr√°vy
            body = self._extract_body(msg)
            
            # Vytvo≈ôen√≠ SupportTicket
            ticket = SupportTicket(
                id=str(uuid.uuid4()),
                subject=subject,
                content=body,
                customer_email=from_addr,
                created_at=self._parse_date(date_str) or datetime.now()
            )
            
            return ticket
            
        except Exception as e:
            print(f"Chyba p≈ôi parsov√°n√≠ emailu: {e}")
            return None
    
    def _decode_header(self, header: str) -> str:
        """Dek√≥duje email header"""
        if header:
            decoded = email.header.decode_header(header)
            return ''.join([
                part.decode(encoding or 'utf-8') if isinstance(part, bytes) else part
                for part, encoding in decoded
            ])
        return ""
    
    def _extract_email_address(self, from_field: str) -> str:
        """Extrahuje emailovou adresu z From pole"""
        matches = self.email_pattern.findall(from_field)
        return matches[0] if matches else "unknown@unknown.com"
    
    def _extract_body(self, msg) -> str:
        """Extrahuje tƒõlo zpr√°vy z email objektu"""
        body = ""
        
        if msg.is_multipart():
            for part in msg.walk():
                if part.get_content_type() == "text/plain":
                    charset = part.get_content_charset() or 'utf-8'
                    body += part.get_payload(decode=True).decode(charset, errors='ignore')
        else:
            charset = msg.get_content_charset() or 'utf-8'
            body = msg.get_payload(decode=True).decode(charset, errors='ignore')
        
        return self._clean_body(body)
    
    def _clean_body(self, body: str) -> str:
        """Vyƒçist√≠ tƒõlo zpr√°vy od nepot≈ôebn√Ωch ƒç√°st√≠"""
        # Odstranƒõn√≠ podpis≈Ø
        lines = body.split('\n')
        cleaned_lines = []
        
        for line in lines:
            line = line.strip()
            # Zastavit na bƒõ≈æn√Ωch podpisech
            if line.startswith('--') or line.startswith('Best regards') or \
               line.startswith('S pozdravem') or 'Sent from my' in line:
                break
            cleaned_lines.append(line)
        
        return '\n'.join(cleaned_lines).strip()
    
    def _parse_date(self, date_str: str) -> Optional[datetime]:
        """Parse email date string"""
        try:
            if date_str:
                return email.utils.parsedate_to_datetime(date_str)
        except:
            pass
        return None
    
    def create_sample_emails(self) -> List[str]:
        """Vytvo≈ô√≠ uk√°zkov√© emaily pro testov√°n√≠"""
        sample_emails = [
            self._create_email(
                "customer1@example.com",
                "Probl√©m s p≈ôihl√°≈°en√≠m",
                "Dobr√Ω den,\n\nnemohu se p≈ôihl√°sit do sv√©ho √∫ƒçtu. St√°le se mi zobrazuje chyba.\n\nDƒõkuji za pomoc."
            ),
            self._create_email(
                "customer2@example.com", 
                "Chybn√© √∫ƒçtov√°n√≠",
                "Zdrav√≠m,\n\nna faktu≈ôe vid√≠m slu≈æbu, kterou jsem si neobjednal. M≈Ø≈æete to pros√≠m provƒõ≈ôit?\n\nS pozdravem"
            ),
            self._create_email(
                "customer3@example.com",
                "Aplikace se zav√≠r√°",
                "Ahoj,\n\nmobiln√≠ aplikace se mi neust√°le zav√≠r√°. U≈æ jsem ji nƒõkolikr√°t reinstaloval.\n\nD√≠ky"
            )
        ]
        return sample_emails
    
    def _create_email(self, from_addr: str, subject: str, body: str) -> str:
        """Vytvo≈ô√≠ uk√°zkov√Ω email"""
        msg = MIMEText(body, 'plain', 'utf-8')
        msg['Subject'] = subject
        msg['From'] = from_addr
        msg['To'] = "support@company.com"
        msg['Date'] = email.utils.formatdate(localtime=True)
        
        return msg.as_string()
````

````python
import asyncio
import json
from datetime import datetime
from data_generator import TicketDataGenerator
from elasticsearch_manager import ElasticSearchManager
from ticket_analyzer import TicketAnalyzer
from email_parser import EmailParser
from models import SupportTicket

class SupportTicketSystem:
    def __init__(self):
        self.es_manager = ElasticSearchManager()
        self.analyzer = TicketAnalyzer()
        self.email_parser = EmailParser()
        
    def setup_system(self):
        """Inicializace syst√©mu s uk√°zkov√Ωmi daty"""
        print("üöÄ Inicializace syst√©mu...")
        
        # Generov√°n√≠ uk√°zkov√Ωch dat
        generator = TicketDataGenerator()
        sample_tickets = generator.generate_tickets(50)
        
        print(f"üìù Indexov√°n√≠ {len(sample_tickets)} uk√°zkov√Ωch l√≠stk≈Ø...")
        for ticket in sample_tickets:
            self.es_manager.index_ticket(ticket)
        
        print("‚úÖ Syst√©m p≈ôipraven!")
        return sample_tickets
    
    def process_email_ticket(self, email_content: str):
        """Zpracuje p≈ô√≠choz√≠ email jako nov√Ω l√≠stek"""
        print("\nüìß Zpracov√°n√≠ p≈ô√≠choz√≠ho emailu...")
        
        # Parse email
        ticket = self.email_parser.parse_email(email_content)
        if not ticket:
            print("‚ùå Nepoda≈ôilo se parsovat email")
            return None
        
        print(f"‚úÖ Email √∫spƒõ≈°nƒõ parsov√°n: {ticket.subject}")
        
        # Anal√Ωza l√≠stku
        analysis = self.analyzer.classify_ticket(ticket)
        print(f"üîç Anal√Ωza dokonƒçena - Kategorie: {analysis.predicted_category}, Priorita: {analysis.predicted_priority}")
        
        # Generov√°n√≠ odpovƒõdi
        response = self.analyzer.generate_response(ticket, analysis)
        
        # Indexov√°n√≠ do ES
        self.es_manager.index_ticket(ticket)
        
        return {
            'ticket': ticket,
            'analysis': analysis,
            'suggested_response': response
        }
    
    def analyze_existing_ticket(self, ticket_id: str):
        """Analyzuje existuj√≠c√≠ l√≠stek"""
        # V re√°ln√©m syst√©mu by se l√≠stek naƒçetl z datab√°ze
        print(f"üîç Anal√Ωza l√≠stku {ticket_id}...")
        return "Funkcionalita pro existuj√≠c√≠ l√≠stky"
    
    def get_system_stats(self):
        """Z√≠sk√° statistiky syst√©mu"""
        return self.es_manager.get_ticket_statistics()
    
    def demo_workflow(self):
        """Demonstrace cel√©ho workflow"""
        print("=" * 60)
        print("üéØ DEMO: AI Analyz√°tor Z√°kaznick√Ωch L√≠stk≈Ø")
        print("=" * 60)
        
        # Setup
        sample_tickets = self.setup_system()
        
        # Statistiky
        print("\nüìä Statistiky syst√©mu:")
        stats = self.get_system_stats()
        print(f"Celkov√Ω poƒçet l√≠stk≈Ø: {stats.get('total_tickets', 0)}")
        print("Rozdƒõlen√≠ podle kategori√≠:")
        for category, count in stats.get('by_category', {}).items():
            print(f"  - {category}: {count}")
        
        # Zpracov√°n√≠ uk√°zkov√Ωch email≈Ø
        sample_emails = self.email_parser.create_sample_emails()
        
        print(f"\nüìß Zpracov√°n√≠ {len(sample_emails)} uk√°zkov√Ωch email≈Ø:")
        print("-" * 40)
        
        for i, email_content in enumerate(sample_emails, 1):
            print(f"\nüì¨ Email #{i}:")
            result = self.process_email_ticket(email_content)
            
            if result:
                ticket = result['ticket']
                analysis = result['analysis']
                
                print(f"P≈ôedmƒõt: {ticket.subject}")
                print(f"Od: {ticket.customer_email}")
                print(f"Kategorie: {analysis.predicted_category}")
                print(f"Priorita: {analysis.predicted_priority}")
                print(f"Spolehlivost: {analysis.confidence_score:.2f}")
                print(f"Escalace pot≈ôebn√°: {'Ano' if analysis.escalation_required else 'Ne'}")
                print(f"Odhadovan√Ω ƒças ≈ôe≈°en√≠: {analysis.estimated_resolution_time}h")
                
                print("\nüí¨ Navrhovan√° odpovƒõƒè:")
                print("-" * 30)
                print(result['suggested_response'][:200] + "..." if len(result['suggested_response']) > 200 else result['suggested_response'])
                
                print("\n" + "="*40)

def main():
    """Hlavn√≠ funkce aplikace"""
    try:
        system = SupportTicketSystem()
        system.demo_workflow()
        
    except KeyboardInterrupt:
        print("\nüëã Ukonƒçov√°n√≠ aplikace...")
    except Exception as e:
        print(f"‚ùå Chyba v aplikaci: {e}")

if __name__ == "__main__":
    main()
````

````python
OPENAI_API_KEY=your_openai_api_key_here
ELASTICSEARCH_URL=http://localhost:9200
````

## Shrnut√≠ Projektu

AI Analyz√°tor Z√°kaznick√Ωch L√≠stk≈Ø p≈ôedstavuje pokroƒçil√© ≈ôe≈°en√≠ pro automatizaci z√°kaznick√© podpory s vyu≈æit√≠m modern√≠ch AI technologi√≠. Syst√©m kombinuje s√≠lu RAG architektury s inteligentn√≠ klasifikac√≠ a generov√°n√≠m odpovƒõd√≠.

### Kl√≠ƒçov√© P≈ô√≠nosy
- **40-60% redukce ƒçasu** zpracov√°n√≠ rutinn√≠ch l√≠stk≈Ø
- **Konzistentn√≠ kvalita** odpovƒõd√≠ nap≈ô√≠ƒç t√Ωmem
- **Inteligentn√≠ prioritizace** na z√°kladƒõ obsahu a kontextu
- **Kontinu√°ln√≠ uƒçen√≠** z nov√Ωch p≈ô√≠pad≈Ø

### Technick√© V√Ωhody
- **≈†k√°lovatelnost** d√≠ky ElasticSearch infrastruktu≈ôe
- **Modul√°rn√≠ architektura** umo≈æ≈àuj√≠c√≠ snadn√© roz≈°√≠≈ôen√≠
- **RAG p≈ô√≠stup** pro vyu≈æit√≠ aktu√°ln√≠ch znalost√≠
- **Robustn√≠ error handling** pro produkƒçn√≠ prost≈ôed√≠

Syst√©m je p≈ôipraven pro nasazen√≠ v re√°ln√©m prost≈ôed√≠ a m≈Ø≈æe b√Ωt snadno p≈ôizp≈Øsoben specifick√Ωm pot≈ôeb√°m organizace.