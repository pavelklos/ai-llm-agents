<small>Claude Sonnet 4 **(Urban Planning and Smart City Solutions with RAG)**</small>
# Urban Planning and Smart City Solutions

## Key Concepts Explanation

### Retrieval-Augmented Generation (RAG)
A technique that combines information retrieval with generative AI to provide intelligent urban planning insights by first retrieving relevant data from population datasets, infrastructure reports, traffic patterns, and zoning regulations, then using an LLM to generate comprehensive planning recommendations and policy analysis.

### Population Data
Comprehensive demographic information including population density, age distribution, income levels, employment patterns, migration trends, and growth projections that form the foundation for evidence-based urban planning decisions and resource allocation strategies.

### Infrastructure Reports
Technical assessments of urban infrastructure systems including transportation networks, utilities, telecommunications, public facilities, and their condition, capacity, and maintenance requirements that inform investment priorities and development planning.

### Traffic Patterns
Real-time and historical data on vehicle movement, congestion patterns, public transit usage, pedestrian flows, and transportation mode preferences that enable optimization of mobility systems and infrastructure planning.

### Zoning Laws
Legal frameworks that regulate land use, building heights, density requirements, and development standards across different urban areas, serving as constraints and guidelines for sustainable urban development and planning decisions.

### City Planning Documents
Official municipal plans, development strategies, master plans, and policy documents that outline long-term vision, growth management strategies, and regulatory frameworks governing urban development and land use decisions.

### GIS Integration
Geographic Information Systems that combine spatial data with urban planning information, enabling visualization, analysis, and modeling of urban phenomena to support data-driven planning decisions and spatial analysis.

### Public Transportation
Mass transit systems including buses, trains, subways, and alternative transportation modes that provide sustainable mobility solutions and influence urban development patterns, accessibility, and quality of life.

## Comprehensive Project Explanation

The Urban Planning and Smart City Solutions platform is an AI-powered system that revolutionizes urban planning and city management through intelligent analysis of complex urban data. By leveraging RAG technology, this platform integrates diverse urban datasets to provide evidence-based recommendations for sustainable development, infrastructure optimization, and improved quality of life for urban residents.

### Objectives
- **Data-Driven Planning**: Enable urban planners to make informed decisions based on comprehensive analysis of demographic, infrastructure, and environmental data
- **Smart Infrastructure**: Optimize infrastructure investments and maintenance through predictive analytics and performance monitoring
- **Sustainable Development**: Promote sustainable urban growth through integrated analysis of environmental impact, resource consumption, and development patterns
- **Citizen Engagement**: Enhance public participation in planning processes through accessible data visualization and transparent decision-making tools
- **Policy Optimization**: Support evidence-based policy development through comprehensive analysis of planning regulations, outcomes, and best practices

### Challenges
- **Data Integration**: Combining heterogeneous data sources from multiple departments, agencies, and time periods while maintaining data quality and consistency
- **Scale Complexity**: Managing planning decisions across multiple spatial and temporal scales from neighborhood to metropolitan area levels
- **Stakeholder Coordination**: Balancing competing interests of residents, businesses, developers, and government agencies in planning processes
- **Regulatory Compliance**: Ensuring planning recommendations comply with complex zoning laws, environmental regulations, and development standards
- **Real-time Adaptation**: Incorporating dynamic data streams like traffic patterns and population movements into long-term planning frameworks

### Potential Impact
- **Planning Efficiency**: Transforming urban planning from lengthy manual processes to data-driven, rapid analysis and recommendation generation
- **Resource Optimization**: Improving allocation of public resources through evidence-based infrastructure and service planning
- **Quality of Life**: Enhancing urban livability through better transportation, housing, and public space planning
- **Environmental Sustainability**: Supporting climate-resilient urban development through integrated environmental impact analysis
- **Economic Development**: Facilitating strategic economic development through data-driven business district and industrial zone planning

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
langchain==0.1.0
openai==1.3.0
chromadb==0.4.18
pandas==2.1.4
numpy==1.24.3
requests==2.31.0
python-dotenv==1.0.0
pydantic==2.5.0
fastapi==0.104.1
uvicorn==0.24.0
geopandas==0.14.1
folium==0.15.0
plotly==5.17.0
streamlit==1.28.1
osmnx==1.6.0
networkx==3.2.1
scikit-learn==1.3.2
scipy==1.11.4
shapely==2.0.2
rasterio==1.3.9
contextily==1.4.0
pyproj==3.6.1
rtree==1.1.0
psycopg2-binary==2.9.9
sqlalchemy==2.0.23
sqlalchemy-utils==0.41.1
alembic==1.13.0
celery==5.3.4
redis==5.0.1
matplotlib==3.8.2
seaborn==0.13.0
openpyxl==3.1.2
geopy==2.4.0
h3==3.7.6
descartes==1.1.0
````

### Core Implementation

````python
# main.py
import os
import json
import pandas as pd
import numpy as np
import geopandas as gpd
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple, Union
from dataclasses import dataclass, asdict, field
from pydantic import BaseModel
import asyncio
import logging
from pathlib import Path
from enum import Enum
import uuid

from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import Document
import chromadb
import openai
from dotenv import load_dotenv

import folium
from folium import plugins
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from shapely.geometry import Point, Polygon, LineString
from shapely.ops import unary_union
import osmnx as ox
import networkx as nx
from sklearn.cluster import KMeans, DBSCAN
from sklearn.preprocessing import StandardScaler
from geopy.distance import geodesic
import h3

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ZoneType(Enum):
    RESIDENTIAL = "residential"
    COMMERCIAL = "commercial"
    INDUSTRIAL = "industrial"
    MIXED_USE = "mixed_use"
    PUBLIC = "public"
    GREEN_SPACE = "green_space"
    TRANSPORTATION = "transportation"

class InfrastructureType(Enum):
    ROADS = "roads"
    WATER = "water"
    SEWER = "sewer"
    ELECTRICITY = "electricity"
    TELECOMMUNICATIONS = "telecommunications"
    PUBLIC_TRANSIT = "public_transit"
    HEALTHCARE = "healthcare"
    EDUCATION = "education"

class TransportMode(Enum):
    WALKING = "walking"
    CYCLING = "cycling"
    PUBLIC_TRANSIT = "public_transit"
    PRIVATE_VEHICLE = "private_vehicle"
    SHARED_MOBILITY = "shared_mobility"

@dataclass
class PopulationData:
    area_id: str
    area_name: str
    geometry: Polygon
    total_population: int
    population_density: float  # per sq km
    age_distribution: Dict[str, int]  # age_group: count
    income_levels: Dict[str, int]  # income_bracket: count
    employment_rate: float
    education_levels: Dict[str, int]  # education_level: count
    household_size_avg: float
    growth_rate_annual: float
    demographic_trends: Dict[str, float]

@dataclass
class InfrastructureAsset:
    asset_id: str
    asset_type: InfrastructureType
    name: str
    location: Point
    service_area: Polygon
    capacity: float
    current_usage: float
    condition_score: float  # 0-1, 1 being excellent
    age_years: int
    maintenance_cost_annual: float
    replacement_cost: float
    last_maintenance: datetime
    expected_lifespan: int
    performance_metrics: Dict[str, float]

@dataclass
class TrafficPattern:
    measurement_id: str
    location: Point
    measurement_time: datetime
    vehicle_count: int
    average_speed: float
    congestion_level: float  # 0-1, 1 being severe congestion
    transport_mode_split: Dict[TransportMode, float]
    peak_hours: List[Tuple[int, int]]  # (start_hour, end_hour)
    seasonal_patterns: Dict[str, float]
    incidents_count: int

@dataclass
class ZoneRegulation:
    zone_id: str
    zone_type: ZoneType
    geometry: Polygon
    max_building_height: Optional[float]
    max_density: Optional[float]  # units per acre
    min_green_space: Optional[float]  # percentage
    allowed_uses: List[str]
    parking_requirements: Dict[str, float]
    setback_requirements: Dict[str, float]
    environmental_restrictions: List[str]
    approval_process: str
    last_updated: datetime

@dataclass
class PlanningDocument:
    document_id: str
    title: str
    document_type: str  # master_plan, zoning_code, development_plan
    area_coverage: Polygon
    adoption_date: datetime
    expiration_date: Optional[datetime]
    content_summary: str
    key_policies: List[str]
    implementation_status: str
    related_documents: List[str]
    stakeholder_input: Dict[str, str]
    performance_indicators: Dict[str, float]

@dataclass
class TransportationNetwork:
    network_id: str
    network_type: str  # road, rail, bus, bike
    nodes: List[Point]
    edges: List[Dict[str, any]]  # connections between nodes
    service_frequency: Optional[Dict[str, int]]  # for public transit
    capacity: Dict[str, float]
    current_usage: Dict[str, float]
    accessibility_score: float
    connectivity_index: float
    maintenance_status: Dict[str, str]

@dataclass
class DevelopmentProject:
    project_id: str
    name: str
    location: Point
    project_area: Polygon
    project_type: str
    status: str  # proposed, approved, under_construction, completed
    developer: str
    estimated_cost: float
    timeline: Dict[str, datetime]
    expected_population: int
    infrastructure_requirements: Dict[InfrastructureType, float]
    environmental_impact: Dict[str, float]
    community_benefits: List[str]

class UrbanDataCollector:
    """Collects and manages urban planning data from various sources"""
    
    def __init__(self):
        self.sample_data = self._generate_sample_data()
    
    def _generate_sample_data(self):
        """Generate comprehensive sample urban planning data"""
        
        # Sample population data
        population_areas = [
            PopulationData(
                area_id="area_001",
                area_name="Downtown Core",
                geometry=Polygon([(-122.42, 37.77), (-122.40, 37.77), (-122.40, 37.79), (-122.42, 37.79)]),
                total_population=45000,
                population_density=12500.0,
                age_distribution={"0-18": 8000, "19-35": 18000, "36-55": 15000, "56+": 4000},
                income_levels={"low": 12000, "medium": 20000, "high": 13000},
                employment_rate=0.82,
                education_levels={"high_school": 15000, "bachelor": 20000, "graduate": 10000},
                household_size_avg=2.3,
                growth_rate_annual=0.025,
                demographic_trends={"young_professionals": 0.4, "families": 0.3, "seniors": 0.1}
            ),
            PopulationData(
                area_id="area_002",
                area_name="Residential District A",
                geometry=Polygon([(-122.45, 37.75), (-122.43, 37.75), (-122.43, 37.77), (-122.45, 37.77)]),
                total_population=32000,
                population_density=8500.0,
                age_distribution={"0-18": 9000, "19-35": 8000, "36-55": 12000, "56+": 3000},
                income_levels={"low": 8000, "medium": 18000, "high": 6000},
                employment_rate=0.78,
                education_levels={"high_school": 12000, "bachelor": 15000, "graduate": 5000},
                household_size_avg=2.8,
                growth_rate_annual=0.015,
                demographic_trends={"families": 0.6, "young_professionals": 0.25, "seniors": 0.15}
            ),
            PopulationData(
                area_id="area_003",
                area_name="Industrial Zone",
                geometry=Polygon([(-122.48, 37.73), (-122.46, 37.73), (-122.46, 37.75), (-122.48, 37.75)]),
                total_population=8000,
                population_density=2000.0,
                age_distribution={"0-18": 1500, "19-35": 3500, "36-55": 2500, "56+": 500},
                income_levels={"low": 3000, "medium": 4000, "high": 1000},
                employment_rate=0.85,
                education_levels={"high_school": 4000, "bachelor": 3000, "graduate": 1000},
                household_size_avg=2.1,
                growth_rate_annual=0.005,
                demographic_trends={"workers": 0.7, "families": 0.2, "young_professionals": 0.1}
            )
        ]
        
        # Sample infrastructure assets
        infrastructure_assets = [
            InfrastructureAsset(
                asset_id="infra_001",
                asset_type=InfrastructureType.WATER,
                name="Central Water Treatment Plant",
                location=Point(-122.41, 37.78),
                service_area=Polygon([(-122.45, 37.75), (-122.38, 37.75), (-122.38, 37.82), (-122.45, 37.82)]),
                capacity=100000000.0,  # liters per day
                current_usage=75000000.0,
                condition_score=0.85,
                age_years=15,
                maintenance_cost_annual=2500000.0,
                replacement_cost=150000000.0,
                last_maintenance=datetime(2024, 3, 15),
                expected_lifespan=50,
                performance_metrics={"efficiency": 0.92, "quality_score": 0.95, "uptime": 0.98}
            ),
            InfrastructureAsset(
                asset_id="infra_002",
                asset_type=InfrastructureType.PUBLIC_TRANSIT,
                name="Metro Line 1",
                location=Point(-122.42, 37.76),
                service_area=Polygon([(-122.48, 37.72), (-122.35, 37.72), (-122.35, 37.82), (-122.48, 37.82)]),
                capacity=45000.0,  # passengers per hour
                current_usage=32000.0,
                condition_score=0.78,
                age_years=25,
                maintenance_cost_annual=15000000.0,
                replacement_cost=2000000000.0,
                last_maintenance=datetime(2024, 4, 20),
                expected_lifespan=40,
                performance_metrics={"on_time_performance": 0.87, "safety_score": 0.92, "customer_satisfaction": 0.75}
            ),
            InfrastructureAsset(
                asset_id="infra_003",
                asset_type=InfrastructureType.ROADS,
                name="Highway 101 Corridor",
                location=Point(-122.43, 37.77),
                service_area=Polygon([(-122.50, 37.70), (-122.35, 37.70), (-122.35, 37.85), (-122.50, 37.85)]),
                capacity=8000.0,  # vehicles per hour per lane
                current_usage=6500.0,
                condition_score=0.65,
                age_years=35,
                maintenance_cost_annual=8000000.0,
                replacement_cost=500000000.0,
                last_maintenance=datetime(2024, 2, 10),
                expected_lifespan=25,
                performance_metrics={"pavement_condition": 0.6, "safety_rating": 0.7, "congestion_index": 0.8}
            )
        ]
        
        # Sample traffic patterns
        traffic_patterns = [
            TrafficPattern(
                measurement_id="traffic_001",
                location=Point(-122.42, 37.77),
                measurement_time=datetime(2024, 5, 15, 8, 0),
                vehicle_count=850,
                average_speed=25.5,
                congestion_level=0.7,
                transport_mode_split={
                    TransportMode.PRIVATE_VEHICLE: 0.65,
                    TransportMode.PUBLIC_TRANSIT: 0.20,
                    TransportMode.WALKING: 0.10,
                    TransportMode.CYCLING: 0.05
                },
                peak_hours=[(7, 9), (17, 19)],
                seasonal_patterns={"summer": 1.1, "winter": 0.9, "spring": 1.0, "fall": 0.95},
                incidents_count=2
            ),
            TrafficPattern(
                measurement_id="traffic_002",
                location=Point(-122.44, 37.76),
                measurement_time=datetime(2024, 5, 15, 14, 0),
                vehicle_count=420,
                average_speed=35.2,
                congestion_level=0.3,
                transport_mode_split={
                    TransportMode.PRIVATE_VEHICLE: 0.55,
                    TransportMode.PUBLIC_TRANSIT: 0.25,
                    TransportMode.WALKING: 0.15,
                    TransportMode.CYCLING: 0.05
                },
                peak_hours=[(12, 14), (18, 20)],
                seasonal_patterns={"summer": 1.05, "winter": 0.95, "spring": 1.0, "fall": 1.0},
                incidents_count=0
            )
        ]
        
        # Sample zoning regulations
        zoning_regulations = [
            ZoneRegulation(
                zone_id="zone_001",
                zone_type=ZoneType.RESIDENTIAL,
                geometry=Polygon([(-122.45, 37.75), (-122.43, 37.75), (-122.43, 37.77), (-122.45, 37.77)]),
                max_building_height=35.0,  # feet
                max_density=25.0,  # units per acre
                min_green_space=0.15,  # 15% minimum
                allowed_uses=["single_family", "multi_family", "small_retail"],
                parking_requirements={"residential": 1.5, "retail": 3.0},  # spaces per unit/1000sqft
                setback_requirements={"front": 15.0, "side": 5.0, "rear": 20.0},
                environmental_restrictions=["flood_zone", "noise_limits"],
                approval_process="administrative",
                last_updated=datetime(2023, 8, 15)
            ),
            ZoneRegulation(
                zone_id="zone_002",
                zone_type=ZoneType.COMMERCIAL,
                geometry=Polygon([(-122.42, 37.77), (-122.40, 37.77), (-122.40, 37.79), (-122.42, 37.79)]),
                max_building_height=150.0,
                max_density=None,
                min_green_space=0.05,
                allowed_uses=["retail", "office", "restaurant", "hotel"],
                parking_requirements={"office": 2.5, "retail": 4.0, "restaurant": 8.0},
                setback_requirements={"front": 0.0, "side": 0.0, "rear": 10.0},
                environmental_restrictions=["air_quality_standards"],
                approval_process="planning_commission",
                last_updated=datetime(2024, 1, 20)
            )
        ]
        
        # Sample planning documents
        planning_documents = [
            PlanningDocument(
                document_id="doc_001",
                title="City General Plan 2040",
                document_type="master_plan",
                area_coverage=Polygon([(-122.52, 37.70), (-122.35, 37.70), (-122.35, 37.85), (-122.52, 37.85)]),
                adoption_date=datetime(2022, 6, 15),
                expiration_date=datetime(2040, 12, 31),
                content_summary="Comprehensive long-range plan for sustainable growth and development",
                key_policies=["compact_development", "transit_oriented_development", "climate_resilience", "affordable_housing"],
                implementation_status="active",
                related_documents=["doc_002", "doc_003"],
                stakeholder_input={"community_meetings": "25 sessions", "public_comments": "1200 responses"},
                performance_indicators={"housing_production": 0.75, "transit_ridership": 0.68, "carbon_reduction": 0.45}
            ),
            PlanningDocument(
                document_id="doc_002",
                title="Transportation Master Plan",
                document_type="transportation_plan",
                area_coverage=Polygon([(-122.52, 37.70), (-122.35, 37.70), (-122.35, 37.85), (-122.52, 37.85)]),
                adoption_date=datetime(2023, 3, 10),
                expiration_date=datetime(2035, 12, 31),
                content_summary="Integrated transportation strategy for multimodal connectivity",
                key_policies=["complete_streets", "public_transit_expansion", "bike_infrastructure", "traffic_calming"],
                implementation_status="active",
                related_documents=["doc_001"],
                stakeholder_input={"workshops": "15 sessions", "survey_responses": "3500 responses"},
                performance_indicators={"mode_shift": 0.32, "safety_improvement": 0.58, "accessibility_index": 0.71}
            )
        ]
        
        return {
            'population_data': population_areas,
            'infrastructure_assets': infrastructure_assets,
            'traffic_patterns': traffic_patterns,
            'zoning_regulations': zoning_regulations,
            'planning_documents': planning_documents
        }
    
    async def analyze_land_use_patterns(self, area_geometry: Polygon) -> Dict[str, any]:
        """Analyze land use patterns within a specific area"""
        
        # Calculate area metrics
        area_sqkm = area_geometry.area * 111000 * 111000  # rough conversion to sq km
        
        # Analyze population distribution
        population_in_area = 0
        for pop_data in self.sample_data['population_data']:
            if area_geometry.intersects(pop_data.geometry):
                intersection = area_geometry.intersection(pop_data.geometry)
                overlap_ratio = intersection.area / pop_data.geometry.area
                population_in_area += pop_data.total_population * overlap_ratio
        
        # Analyze zoning distribution
        zoning_distribution = {}
        for zone in self.sample_data['zoning_regulations']:
            if area_geometry.intersects(zone.geometry):
                intersection = area_geometry.intersection(zone.geometry)
                overlap_ratio = intersection.area / area_geometry.area
                zoning_distribution[zone.zone_type.value] = overlap_ratio
        
        # Infrastructure accessibility
        accessible_infrastructure = []
        for asset in self.sample_data['infrastructure_assets']:
            if area_geometry.intersects(asset.service_area):
                accessible_infrastructure.append({
                    'type': asset.asset_type.value,
                    'name': asset.name,
                    'capacity_utilization': asset.current_usage / asset.capacity,
                    'condition': asset.condition_score
                })
        
        return {
            'area_analysis': {
                'total_area_sqkm': area_sqkm,
                'estimated_population': int(population_in_area),
                'population_density': population_in_area / area_sqkm if area_sqkm > 0 else 0,
                'zoning_distribution': zoning_distribution,
                'accessible_infrastructure': accessible_infrastructure
            }
        }
    
    async def assess_transportation_connectivity(self, origin: Point, radius_km: float = 5.0) -> Dict[str, any]:
        """Assess transportation connectivity from a given point"""
        
        # Create buffer around origin point
        # Note: This is a simplified calculation
        buffer_degrees = radius_km / 111.0  # rough conversion
        analysis_area = origin.buffer(buffer_degrees)
        
        # Find intersecting traffic patterns
        traffic_in_area = []
        for pattern in self.sample_data['traffic_patterns']:
            if analysis_area.contains(pattern.location):
                traffic_in_area.append(pattern)
        
        # Calculate connectivity metrics
        avg_congestion = np.mean([p.congestion_level for p in traffic_in_area]) if traffic_in_area else 0
        avg_speed = np.mean([p.average_speed for p in traffic_in_area]) if traffic_in_area else 0
        
        # Transit accessibility
        transit_access = []
        for asset in self.sample_data['infrastructure_assets']:
            if asset.asset_type == InfrastructureType.PUBLIC_TRANSIT:
                distance = origin.distance(asset.location) * 111000  # rough conversion to meters
                if distance <= radius_km * 1000:
                    transit_access.append({
                        'name': asset.name,
                        'distance_m': distance,
                        'capacity_utilization': asset.current_usage / asset.capacity,
                        'condition': asset.condition_score
                    })
        
        return {
            'connectivity_analysis': {
                'average_congestion': avg_congestion,
                'average_speed_kmh': avg_speed * 1.60934,  # convert mph to kmh
                'transit_accessibility': transit_access,
                'walkability_score': 0.8 if len(transit_access) > 0 else 0.3,  # simplified
                'connectivity_index': (1 - avg_congestion) * 0.5 + (len(transit_access) / 3) * 0.5
            }
        }

class UrbanPlanningRAG:
    """RAG system for intelligent urban planning and smart city solutions"""
    
    def __init__(self):
        # Initialize OpenAI
        openai.api_key = os.getenv("OPENAI_API_KEY")
        
        # Initialize components
        self.embeddings = OpenAIEmbeddings()
        self.llm = ChatOpenAI(model="gpt-4", temperature=0.3)
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        
        # Initialize vector store
        self.client = chromadb.PersistentClient(path="./urban_planning_db")
        self.vectorstore = Chroma(
            client=self.client,
            collection_name="urban_knowledge",
            embedding_function=self.embeddings
        )
        
        self.data_collector = UrbanDataCollector()
    
    async def initialize_knowledge_base(self):
        """Initialize the knowledge base with urban planning data"""
        logger.info("Initializing urban planning knowledge base...")
        
        documents = []
        
        # Add population data
        for pop_data in self.data_collector.sample_data['population_data']:
            doc_content = f"""
            Area: {pop_data.area_name}
            Population: {pop_data.total_population:,}
            Density: {pop_data.population_density:,.1f} per sq km
            Age Distribution: {', '.join([f'{k}: {v:,}' for k, v in pop_data.age_distribution.items()])}
            Income Levels: {', '.join([f'{k}: {v:,}' for k, v in pop_data.income_levels.items()])}
            Employment Rate: {pop_data.employment_rate:.1%}
            Education Levels: {', '.join([f'{k}: {v:,}' for k, v in pop_data.education_levels.items()])}
            Average Household Size: {pop_data.household_size_avg}
            Annual Growth Rate: {pop_data.growth_rate_annual:.1%}
            Demographic Trends: {', '.join([f'{k}: {v:.1%}' for k, v in pop_data.demographic_trends.items()])}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "population_data",
                    "area_id": pop_data.area_id,
                    "area_name": pop_data.area_name,
                    "population": pop_data.total_population,
                    "density": pop_data.population_density,
                    "growth_rate": pop_data.growth_rate_annual
                }
            ))
        
        # Add infrastructure information
        for asset in self.data_collector.sample_data['infrastructure_assets']:
            doc_content = f"""
            Infrastructure: {asset.name}
            Type: {asset.asset_type.value}
            Capacity: {asset.capacity:,.0f}
            Current Usage: {asset.current_usage:,.0f} ({asset.current_usage/asset.capacity:.1%} utilization)
            Condition Score: {asset.condition_score:.2f}/1.0
            Age: {asset.age_years} years
            Annual Maintenance Cost: ${asset.maintenance_cost_annual:,.0f}
            Replacement Cost: ${asset.replacement_cost:,.0f}
            Expected Lifespan: {asset.expected_lifespan} years
            Performance Metrics: {', '.join([f'{k}: {v:.2f}' for k, v in asset.performance_metrics.items()])}
            Last Maintenance: {asset.last_maintenance.strftime('%Y-%m-%d')}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "infrastructure",
                    "asset_id": asset.asset_id,
                    "asset_type": asset.asset_type.value,
                    "condition": asset.condition_score,
                    "utilization": asset.current_usage / asset.capacity,
                    "age": asset.age_years
                }
            ))
        
        # Add traffic pattern data
        for pattern in self.data_collector.sample_data['traffic_patterns']:
            doc_content = f"""
            Traffic Measurement Location: {pattern.location.x:.4f}, {pattern.location.y:.4f}
            Time: {pattern.measurement_time.strftime('%Y-%m-%d %H:%M')}
            Vehicle Count: {pattern.vehicle_count}
            Average Speed: {pattern.average_speed:.1f} mph
            Congestion Level: {pattern.congestion_level:.2f} (0=none, 1=severe)
            Transport Mode Split: {', '.join([f'{k.value}: {v:.1%}' for k, v in pattern.transport_mode_split.items()])}
            Peak Hours: {', '.join([f'{start}:00-{end}:00' for start, end in pattern.peak_hours])}
            Incidents: {pattern.incidents_count}
            Seasonal Patterns: {', '.join([f'{k}: {v:.2f}x' for k, v in pattern.seasonal_patterns.items()])}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "traffic_pattern",
                    "measurement_id": pattern.measurement_id,
                    "congestion_level": pattern.congestion_level,
                    "vehicle_count": pattern.vehicle_count,
                    "incidents": pattern.incidents_count
                }
            ))
        
        # Add zoning information
        for zone in self.data_collector.sample_data['zoning_regulations']:
            doc_content = f"""
            Zone Type: {zone.zone_type.value}
            Maximum Building Height: {zone.max_building_height} feet
            Maximum Density: {zone.max_density} units per acre
            Minimum Green Space: {zone.min_green_space:.1%}
            Allowed Uses: {', '.join(zone.allowed_uses)}
            Parking Requirements: {', '.join([f'{k}: {v} spaces' for k, v in zone.parking_requirements.items()])}
            Setback Requirements: {', '.join([f'{k}: {v} feet' for k, v in zone.setback_requirements.items()])}
            Environmental Restrictions: {', '.join(zone.environmental_restrictions)}
            Approval Process: {zone.approval_process}
            Last Updated: {zone.last_updated.strftime('%Y-%m-%d')}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "zoning",
                    "zone_id": zone.zone_id,
                    "zone_type": zone.zone_type.value,
                    "max_height": zone.max_building_height,
                    "max_density": zone.max_density
                }
            ))
        
        # Add planning documents
        for doc in self.data_collector.sample_data['planning_documents']:
            doc_content = f"""
            Document: {doc.title}
            Type: {doc.document_type}
            Summary: {doc.content_summary}
            Adoption Date: {doc.adoption_date.strftime('%Y-%m-%d')}
            Expiration: {doc.expiration_date.strftime('%Y-%m-%d') if doc.expiration_date else 'None'}
            Key Policies: {', '.join(doc.key_policies)}
            Implementation Status: {doc.implementation_status}
            Stakeholder Input: {', '.join([f'{k}: {v}' for k, v in doc.stakeholder_input.items()])}
            Performance Indicators: {', '.join([f'{k}: {v:.1%}' for k, v in doc.performance_indicators.items()])}
            Related Documents: {', '.join(doc.related_documents)}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "planning_document",
                    "document_id": doc.document_id,
                    "document_type": doc.document_type,
                    "status": doc.implementation_status
                }
            ))
        
        # Add urban planning best practices
        planning_concepts = [
            {
                "title": "Transit-Oriented Development",
                "content": "TOD promotes compact, mixed-use development around transit stations to reduce car dependency, increase ridership, and create walkable communities. Key principles include density bonuses, reduced parking requirements, and pedestrian-friendly design."
            },
            {
                "title": "Complete Streets Design",
                "content": "Complete streets accommodate all users including pedestrians, cyclists, transit riders, and vehicles. Design elements include bike lanes, sidewalks, crossing signals, transit stops, and traffic calming measures to improve safety and accessibility."
            },
            {
                "title": "Green Infrastructure",
                "content": "Green infrastructure uses natural systems to manage stormwater, improve air quality, and provide ecosystem services. Examples include green roofs, bioswales, urban forests, and permeable pavements that support environmental sustainability."
            },
            {
                "title": "Smart Growth Principles",
                "content": "Smart growth promotes sustainable development through compact building design, walkable neighborhoods, mixed housing options, and preservation of open space. It focuses on revitalizing existing communities rather than sprawling development."
            },
            {
                "title": "Zoning Reform Strategies",
                "content": "Modern zoning reforms include form-based codes, inclusionary zoning, and reduced parking minimums. These strategies promote affordable housing, mixed-use development, and sustainable transportation while maintaining neighborhood character."
            }
        ]
        
        for concept in planning_concepts:
            documents.append(Document(
                page_content=f"Title: {concept['title']}\nContent: {concept['content']}",
                metadata={
                    "type": "planning_concept",
                    "title": concept['title']
                }
            ))
        
        # Add documents to vector store
        if documents:
            self.vectorstore.add_documents(documents)
        
        logger.info(f"Added {len(documents)} documents to knowledge base")
    
    def retrieve_relevant_information(self, query: str, k: int = 8) -> List[Document]:
        """Retrieve relevant urban planning information"""
        return self.vectorstore.similarity_search(query, k=k)
    
    async def analyze_development_proposal(self, proposal_details: Dict[str, any]) -> Dict[str, any]:
        """Analyze a development proposal for planning compliance and impacts"""
        
        location = Point(proposal_details.get('longitude', -122.42), 
                        proposal_details.get('latitude', 37.77))
        project_type = proposal_details.get('project_type', 'mixed_use')
        proposed_units = proposal_details.get('units', 100)
        proposed_height = proposal_details.get('height_feet', 50)
        
        # Analyze land use compatibility
        land_use_analysis = await self.data_collector.analyze_land_use_patterns(
            location.buffer(0.005)  # roughly 500m buffer
        )
        
        # Check zoning compliance
        zoning_compliance = self._check_zoning_compliance(location, proposed_height, project_type)
        
        # Assess infrastructure capacity
        infrastructure_assessment = await self._assess_infrastructure_impacts(
            location, proposed_units
        )
        
        # Get relevant planning context
        query = f"development proposal {project_type} zoning compliance infrastructure impact"
        relevant_docs = self.retrieve_relevant_information(query, k=8)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Generate comprehensive analysis
        prompt = ChatPromptTemplate.from_template("""
        Analyze this development proposal for planning compliance and community impacts:
        
        Proposal Details:
        - Location: {latitude}, {longitude}
        - Project Type: {project_type}
        - Proposed Units: {units}
        - Proposed Height: {height} feet
        
        Land Use Analysis:
        {land_use_analysis}
        
        Zoning Compliance:
        {zoning_compliance}
        
        Infrastructure Assessment:
        {infrastructure_assessment}
        
        Planning Context: {context}
        
        Provide comprehensive development analysis including:
        1. Zoning compliance assessment and required approvals
        2. Infrastructure capacity and upgrade requirements
        3. Transportation and traffic impact analysis
        4. Community benefits and potential concerns
        5. Environmental considerations and sustainability
        6. Recommendations for project modifications
        7. Approval process timeline and requirements
        8. Mitigation measures for identified impacts
        
        Focus on practical planning considerations and regulatory compliance.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "latitude": location.y,
            "longitude": location.x,
            "project_type": project_type,
            "units": proposed_units,
            "height": proposed_height,
            "land_use_analysis": str(land_use_analysis),
            "zoning_compliance": str(zoning_compliance),
            "infrastructure_assessment": str(infrastructure_assessment),
            "context": context
        })
        
        return {
            "proposal_details": proposal_details,
            "land_use_analysis": land_use_analysis,
            "zoning_compliance": zoning_compliance,
            "infrastructure_assessment": infrastructure_assessment,
            "comprehensive_analysis": response.content,
            "analysis_date": datetime.now().isoformat()
        }
    
    def _check_zoning_compliance(self, location: Point, height: float, project_type: str) -> Dict[str, any]:
        """Check zoning compliance for a development proposal"""
        
        compliance_issues = []
        applicable_zones = []
        
        for zone in self.data_collector.sample_data['zoning_regulations']:
            if zone.geometry.contains(location):
                applicable_zones.append(zone)
                
                # Check height compliance
                if zone.max_building_height and height > zone.max_building_height:
                    compliance_issues.append(f"Height exceeds limit: {height} ft > {zone.max_building_height} ft")
                
                # Check use compliance
                if project_type not in zone.allowed_uses and "mixed_use" not in zone.allowed_uses:
                    compliance_issues.append(f"Use '{project_type}' not permitted in {zone.zone_type.value} zone")
        
        return {
            "applicable_zones": [{"type": z.zone_type.value, "max_height": z.max_building_height} for z in applicable_zones],
            "compliance_issues": compliance_issues,
            "compliant": len(compliance_issues) == 0
        }
    
    async def _assess_infrastructure_impacts(self, location: Point, additional_units: int) -> Dict[str, any]:
        """Assess infrastructure capacity and impacts"""
        
        impacts = {}
        
        # Estimate additional demand
        additional_population = additional_units * 2.3  # average household size
        water_demand_daily = additional_population * 150  # liters per person per day
        
        # Check water infrastructure
        for asset in self.data_collector.sample_data['infrastructure_assets']:
            if asset.asset_type == InfrastructureType.WATER:
                if asset.service_area.contains(location):
                    current_capacity_available = asset.capacity - asset.current_usage
                    if water_demand_daily > current_capacity_available:
                        impacts['water'] = {
                            'adequate_capacity': False,
                            'shortfall': water_demand_daily - current_capacity_available,
                            'upgrade_required': True
                        }
                    else:
                        impacts['water'] = {
                            'adequate_capacity': True,
                            'remaining_capacity': current_capacity_available - water_demand_daily,
                            'upgrade_required': False
                        }
        
        # Check transportation impacts
        connectivity_analysis = await self.data_collector.assess_transportation_connectivity(location)
        impacts['transportation'] = connectivity_analysis['connectivity_analysis']
        
        return impacts
    
    async def optimize_transportation_network(self, area_bounds: Dict[str, float]) -> Dict[str, any]:
        """Optimize transportation network for an area"""
        
        # Create analysis area
        min_lon, min_lat = area_bounds['min_longitude'], area_bounds['min_latitude']
        max_lon, max_lat = area_bounds['max_longitude'], area_bounds['max_latitude']
        analysis_area = Polygon([(min_lon, min_lat), (max_lon, min_lat), 
                                (max_lon, max_lat), (min_lon, max_lat)])
        
        # Analyze current transportation patterns
        traffic_in_area = []
        for pattern in self.data_collector.sample_data['traffic_patterns']:
            if analysis_area.contains(pattern.location):
                traffic_in_area.append(pattern)
        
        # Calculate optimization metrics
        avg_congestion = np.mean([p.congestion_level for p in traffic_in_area]) if traffic_in_area else 0
        total_vehicles = sum([p.vehicle_count for p in traffic_in_area])
        
        # Get relevant planning context
        query = f"transportation optimization traffic management public transit network planning"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Generate optimization recommendations
        prompt = ChatPromptTemplate.from_template("""
        Provide transportation network optimization recommendations for this area:
        
        Area Analysis:
        - Bounds: {min_lat:.4f}, {min_lon:.4f} to {max_lat:.4f}, {max_lon:.4f}
        - Current Traffic Patterns: {traffic_count} measurement points
        - Average Congestion Level: {avg_congestion:.2f} (0=none, 1=severe)
        - Total Vehicle Count: {total_vehicles}
        
        Transportation Context: {context}
        
        Provide comprehensive optimization recommendations including:
        1. Traffic flow improvements and bottleneck solutions
        2. Public transit enhancements and new routes
        3. Active transportation infrastructure (bike/pedestrian)
        4. Smart traffic management systems
        5. Parking strategy and demand management
        6. Integration with land use planning
        7. Implementation timeline and priorities
        8. Expected outcomes and performance metrics
        
        Focus on evidence-based solutions that improve mobility and reduce congestion.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "min_lat": min_lat,
            "min_lon": min_lon,
            "max_lat": max_lat,
            "max_lon": max_lon,
            "traffic_count": len(traffic_in_area),
            "avg_congestion": avg_congestion,
            "total_vehicles": total_vehicles,
            "context": context
        })
        
        return {
            "area_bounds": area_bounds,
            "current_conditions": {
                "traffic_measurement_points": len(traffic_in_area),
                "average_congestion": avg_congestion,
                "total_vehicles": total_vehicles
            },
            "optimization_recommendations": response.content,
            "analysis_date": datetime.now().isoformat()
        }
    
    async def assess_housing_needs(self, target_area: str) -> Dict[str, any]:
        """Assess housing needs and affordability in a target area"""
        
        # Find population data for the area
        area_population = None
        for pop_data in self.data_collector.sample_data['population_data']:
            if target_area.lower() in pop_data.area_name.lower():
                area_population = pop_data
                break
        
        if not area_population:
            return {"error": f"No population data found for area: {target_area}"}
        
        # Calculate housing metrics
        total_households = area_population.total_population / area_population.household_size_avg
        low_income_households = area_population.income_levels.get('low', 0) / area_population.household_size_avg
        
        # Get relevant housing context
        query = f"housing needs affordability {target_area} residential development"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Generate housing needs assessment
        prompt = ChatPromptTemplate.from_template("""
        Assess housing needs and development strategy for this area:
        
        Area: {area_name}
        Population Analysis:
        - Total Population: {total_population:,}
        - Population Density: {density:,.1f} per sq km
        - Estimated Households: {total_households:,.0f}
        - Average Household Size: {household_size}
        - Income Distribution: {income_levels}
        - Age Distribution: {age_distribution}
        - Annual Growth Rate: {growth_rate:.1%}
        
        Housing Context: {context}
        
        Provide comprehensive housing needs assessment including:
        1. Current housing demand and supply analysis
        2. Affordability challenges and income matching
        3. Housing type recommendations (single-family, multi-family, etc.)
        4. Density and zoning considerations
        5. Infrastructure requirements for new housing
        6. Affordable housing strategies and incentives
        7. Timeline for addressing housing needs
        8. Community impact and displacement prevention
        
        Focus on data-driven recommendations that address housing equity and affordability.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "area_name": area_population.area_name,
            "total_population": area_population.total_population,
            "density": area_population.population_density,
            "total_households": total_households,
            "household_size": area_population.household_size_avg,
            "income_levels": str(area_population.income_levels),
            "age_distribution": str(area_population.age_distribution),
            "growth_rate": area_population.growth_rate_annual,
            "context": context
        })
        
        return {
            "area_analysis": asdict(area_population),
            "housing_metrics": {
                "estimated_households": total_households,
                "low_income_households": low_income_households,
                "affordability_ratio": low_income_households / total_households
            },
            "housing_assessment": response.content,
            "assessment_date": datetime.now().isoformat()
        }

class SmartCityAssistant:
    """Main assistant orchestrating urban planning and smart city solutions"""
    
    def __init__(self):
        self.rag_system = UrbanPlanningRAG()
        self.initialized = False
    
    async def initialize(self):
        """Initialize the smart city assistant"""
        if not self.initialized:
            await self.rag_system.initialize_knowledge_base()
            self.initialized = True
            logger.info("Smart City Assistant initialized successfully")
    
    async def analyze_development(self, proposal: Dict[str, any]) -> Dict[str, any]:
        """Analyze development proposal"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.analyze_development_proposal(proposal)
    
    async def optimize_transportation(self, area_bounds: Dict[str, float]) -> Dict[str, any]:
        """Optimize transportation network"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.optimize_transportation_network(area_bounds)
    
    async def assess_housing(self, area_name: str) -> Dict[str, any]:
        """Assess housing needs"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.assess_housing_needs(area_name)

# Example usage and testing
async def main():
    """Main function demonstrating the Smart City Assistant"""
    
    print(" Initializing Urban Planning and Smart City Solutions Assistant...")
    assistant = SmartCityAssistant()
    
    try:
        # Initialize the system
        await assistant.initialize()
        print(" Smart City Assistant initialized successfully")
        
        # Analyze development proposal
        print("\n Analyzing development proposal...")
        development_proposal = {
            'longitude': -122.42,
            'latitude': 37.77,
            'project_type': 'mixed_use',
            'units': 150,
            'height_feet': 75
        }
        
        development_analysis = await assistant.analyze_development(development_proposal)
        
        print(" Development Analysis Complete:")
        print(f"Proposal: {development_proposal['units']} units, {development_proposal['height_feet']} ft")
        print(f"Zoning compliant: {development_analysis['zoning_compliance']['compliant']}")
        print(f"Analysis preview: {development_analysis['comprehensive_analysis'][:200]}...")
        
        # Optimize transportation network
        print("\n Optimizing transportation network...")
        area_bounds = {
            'min_longitude': -122.45,
            'min_latitude': 37.75,
            'max_longitude': -122.40,
            'max_latitude': 37.80
        }
        
        transport_optimization = await assistant.optimize_transportation(area_bounds)
        
        print(" Transportation Optimization Complete:")
        conditions = transport_optimization['current_conditions']
        print(f"Traffic points analyzed: {conditions['traffic_measurement_points']}")
        print(f"Average congestion: {conditions['average_congestion']:.2f}")
        print(f"Recommendations preview: {transport_optimization['optimization_recommendations'][:200]}...")
        
        # Assess housing needs
        print("\n Assessing housing needs...")
        housing_assessment = await assistant.assess_housing("Downtown Core")
        
        print(" Housing Assessment Complete:")
        if 'area_analysis' in housing_assessment:
            area = housing_assessment['area_analysis']
            metrics = housing_assessment['housing_metrics']
            print(f"Area: {area['area_name']}")
            print(f"Population: {area['total_population']:,}")
            print(f"Estimated households: {metrics['estimated_households']:,.0f}")
            print(f"Assessment preview: {housing_assessment['housing_assessment'][:200]}...")
        
        print("\n Urban Planning and Smart City Solutions demonstration completed successfully!")
        
    except Exception as e:
        logger.error(f"Error in main execution: {str(e)}")
        print(f" Error: {str(e)}")

if __name__ == "__main__":
    # Set up environment variables
    os.environ.setdefault("OPENAI_API_KEY", "your-openai-api-key-here")
    
    # Run the main function
    asyncio.run(main())
````

## Project Summary

The **Urban Planning and Smart City Solutions** platform represents a revolutionary advancement in data-driven urban governance, combining RAG technology with comprehensive spatial analysis and policy intelligence to transform how cities plan, develop, and manage urban growth. This system democratizes access to sophisticated planning tools previously available only to major consulting firms and large municipalities.

### Key Value Propositions

**Evidence-Based Planning**: Leverages comprehensive demographic, infrastructure, and regulatory data to provide scientifically-grounded planning recommendations that optimize resource allocation and improve urban outcomes through data-driven decision making.

**Integrated Analysis**: Combines multiple urban systems including transportation, housing, zoning, and infrastructure into cohesive planning strategies that consider complex interdependencies and promote sustainable development patterns.

**Policy Compliance**: Ensures development proposals and planning initiatives comply with zoning regulations, environmental standards, and community goals while identifying opportunities for strategic policy improvements and regulatory streamlining.

**Stakeholder Engagement**: Provides transparent, accessible analysis that enhances public participation in planning processes and builds community trust through evidence-based explanations of planning decisions and their expected impacts.

### Technical Excellence

The implementation showcases advanced geospatial and planning analysis with **LangChain** for RAG orchestration, **GeoPandas** for spatial data processing, **OSMnx** for network analysis, **Folium** for interactive mapping, and **ChromaDB** for planning knowledge storage. The architecture supports real-time spatial analysis, multi-criteria optimization, and scalable urban data integration.

### Impact and Applications

This platform serves urban planners, city officials, developers, community organizations, and residents. Applications include development review processes, transportation planning, housing policy development, infrastructure investment prioritization, and community engagement in planning decisions.

The project demonstrates how AI can transform urban planning from intuition-based practice to evidence-driven science, making complex urban analysis accessible to smaller municipalities while improving planning outcomes through comprehensive data integration. By combining spatial intelligence with policy knowledge, this system enables more equitable, sustainable, and effective urban development that serves community needs while respecting environmental constraints and regulatory requirements.