<small>Claude Sonnet 4 **(Financial Advisor Agent)**</small>
# Financial Advisor Agent

## Key Concepts Explanation

### LLM Integration with Time Series
Combining large language models with financial time series data to provide intelligent interpretation of market trends, economic indicators, and portfolio performance through natural language processing and quantitative analysis for comprehensive financial insights.

### Budget Optimization
Mathematical optimization techniques applied to personal and institutional budgets using linear programming, portfolio theory, and constraint optimization to maximize returns while minimizing risk and meeting specific financial goals and constraints.

### OpenBB Integration
Leveraging OpenBB Terminal's open-source financial data platform to access real-time market data, economic indicators, financial statements, and analytical tools for comprehensive financial analysis and decision-making support.

### Portfolio Management
Systematic approach to investment allocation, risk assessment, and performance monitoring using modern portfolio theory, asset allocation models, and diversification strategies to optimize investment returns while managing risk exposure.

### Financial Risk Analysis
Comprehensive evaluation of market risk, credit risk, liquidity risk, and operational risk using statistical models, stress testing, and scenario analysis to identify potential threats to financial objectives and develop mitigation strategies.

## Comprehensive Project Explanation

### Objectives
The Financial Advisor Agent provides intelligent financial guidance by combining LLM capabilities with quantitative analysis, real-time market data, and optimization algorithms to deliver personalized investment advice, budget planning, and risk management strategies.

### Key Features
- **Intelligent Financial Advisory**: LLM-powered advice generation with market context
- **Real-time Market Analysis**: Integration with OpenBB for live financial data
- **Portfolio Optimization**: Advanced algorithms for asset allocation and risk management
- **Budget Planning**: Automated budget optimization with goal-based constraints
- **Risk Assessment**: Comprehensive financial risk analysis and monitoring

### Challenges
- **Data Integration**: Combining multiple financial data sources effectively
- **Real-time Processing**: Handling live market data with low latency requirements
- **Regulatory Compliance**: Ensuring advice meets financial regulations and standards
- **Market Volatility**: Adapting strategies to rapidly changing market conditions

### Potential Impact
This system can democratize financial advisory services, improve investment decision-making, reduce financial planning costs, and provide sophisticated analysis tools for both individual and institutional investors.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
openbb==4.1.0
yfinance==0.2.18
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
scikit-learn==1.3.2
scipy==1.11.4
cvxpy==1.4.1
ta==0.10.2
quantlib==1.31
datetime
logging
typing
dataclasses
enum
````

### Core Implementation

````python
import numpy as np
import pandas as pd
import yfinance as yf
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import json
import warnings
warnings.filterwarnings('ignore')

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Financial analysis libraries
import ta
from scipy.optimize import minimize
import cvxpy as cp
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor

# LLM integration
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import BaseMessage

# Try to import OpenBB (fallback if not available)
try:
    from openbb import obb
    OPENBB_AVAILABLE = True
except ImportError:
    OPENBB_AVAILABLE = False
    logging.warning("OpenBB not available, using yfinance fallback")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class RiskTolerance(Enum):
    CONSERVATIVE = "conservative"
    MODERATE = "moderate"
    AGGRESSIVE = "aggressive"

class InvestmentGoal(Enum):
    RETIREMENT = "retirement"
    EDUCATION = "education"
    HOME_PURCHASE = "home_purchase"
    WEALTH_BUILDING = "wealth_building"
    INCOME_GENERATION = "income_generation"

class AssetClass(Enum):
    STOCKS = "stocks"
    BONDS = "bonds"
    REAL_ESTATE = "real_estate"
    COMMODITIES = "commodities"
    CASH = "cash"
    CRYPTO = "crypto"

@dataclass
class FinancialProfile:
    profile_id: str
    age: int
    annual_income: float
    monthly_expenses: float
    current_savings: float
    investment_experience: str
    risk_tolerance: RiskTolerance
    investment_goals: List[InvestmentGoal]
    time_horizon: int  # years
    liquidity_needs: float
    debt_obligations: float = 0.0

@dataclass
class Portfolio:
    portfolio_id: str
    assets: Dict[str, float]  # symbol -> allocation percentage
    total_value: float
    last_updated: datetime
    expected_return: Optional[float] = None
    risk_level: Optional[float] = None
    sharpe_ratio: Optional[float] = None

@dataclass
class BudgetItem:
    category: str
    amount: float
    is_fixed: bool
    priority: int  # 1-5, 1 being highest priority

@dataclass
class BudgetPlan:
    monthly_income: float
    expenses: List[BudgetItem]
    savings_target: float
    emergency_fund_target: float
    investment_allocation: float

class DataProvider:
    """Handles financial data retrieval from multiple sources."""
    
    def __init__(self):
        self.cache = {}
        self.cache_duration = 300  # 5 minutes
    
    def get_stock_data(self, symbols: List[str], period: str = "1y") -> pd.DataFrame:
        """Get stock price data."""
        try:
            if OPENBB_AVAILABLE:
                return self._get_openbb_data(symbols, period)
            else:
                return self._get_yfinance_data(symbols, period)
        except Exception as e:
            logger.error(f"Error fetching stock data: {e}")
            return self._generate_mock_data(symbols, period)
    
    def _get_openbb_data(self, symbols: List[str], period: str) -> pd.DataFrame:
        """Get data using OpenBB."""
        # This would use actual OpenBB API calls
        # For demo purposes, fallback to yfinance
        return self._get_yfinance_data(symbols, period)
    
    def _get_yfinance_data(self, symbols: List[str], period: str) -> pd.DataFrame:
        """Get data using yfinance."""
        data = {}
        
        for symbol in symbols:
            try:
                ticker = yf.Ticker(symbol)
                hist = ticker.history(period=period)
                if not hist.empty:
                    data[symbol] = hist['Close']
            except Exception as e:
                logger.warning(f"Could not fetch data for {symbol}: {e}")
        
        if data:
            return pd.DataFrame(data)
        else:
            return self._generate_mock_data(symbols, period)
    
    def _generate_mock_data(self, symbols: List[str], period: str) -> pd.DataFrame:
        """Generate mock financial data for demonstration."""
        days = {"1mo": 30, "3mo": 90, "6mo": 180, "1y": 365, "2y": 730}.get(period, 365)
        
        dates = pd.date_range(end=datetime.now(), periods=days, freq='D')
        data = {}
        
        for symbol in symbols:
            # Generate realistic stock price movements
            np.random.seed(hash(symbol) % 2**32)
            returns = np.random.normal(0.0008, 0.02, days)  # Daily returns
            
            # Starting price based on symbol
            start_price = 50 + (hash(symbol) % 200)
            prices = [start_price]
            
            for ret in returns[1:]:
                prices.append(prices[-1] * (1 + ret))
            
            data[symbol] = prices
        
        return pd.DataFrame(data, index=dates)
    
    def get_economic_indicators(self) -> Dict[str, float]:
        """Get current economic indicators."""
        # Mock economic data - in production would use OpenBB or other APIs
        return {
            "inflation_rate": 3.2,
            "fed_funds_rate": 5.25,
            "unemployment_rate": 3.8,
            "gdp_growth": 2.1,
            "vix": 18.5,
            "treasury_10y": 4.2
        }
    
    def get_sector_performance(self) -> Dict[str, float]:
        """Get sector performance data."""
        sectors = [
            "Technology", "Healthcare", "Financial", "Consumer Discretionary",
            "Communication Services", "Industrials", "Consumer Staples",
            "Energy", "Utilities", "Real Estate", "Materials"
        ]
        
        # Mock sector returns (YTD)
        np.random.seed(42)
        returns = np.random.normal(0.08, 0.15, len(sectors))
        
        return dict(zip(sectors, returns))

class PortfolioOptimizer:
    """Handles portfolio optimization using modern portfolio theory."""
    
    def __init__(self):
        self.risk_free_rate = 0.02  # 2% risk-free rate
    
    def optimize_portfolio(self, returns: pd.DataFrame, 
                         risk_tolerance: RiskTolerance,
                         constraints: Dict[str, Any] = None) -> Dict[str, float]:
        """Optimize portfolio allocation using mean-variance optimization."""
        try:
            # Calculate expected returns and covariance matrix
            expected_returns = returns.mean() * 252  # Annualized
            cov_matrix = returns.cov() * 252  # Annualized
            
            n_assets = len(expected_returns)
            
            # Define optimization variables
            weights = cp.Variable(n_assets)
            
            # Portfolio return and risk
            portfolio_return = expected_returns.values @ weights
            portfolio_risk = cp.quad_form(weights, cov_matrix.values)
            
            # Risk tolerance mapping
            risk_aversion = {
                RiskTolerance.CONSERVATIVE: 10,
                RiskTolerance.MODERATE: 5,
                RiskTolerance.AGGRESSIVE: 2
            }.get(risk_tolerance, 5)
            
            # Objective: maximize return - risk_aversion * risk
            objective = cp.Maximize(portfolio_return - risk_aversion * portfolio_risk)
            
            # Constraints
            constraints_list = [
                cp.sum(weights) == 1,  # Weights sum to 1
                weights >= 0  # Long-only positions
            ]
            
            # Additional constraints based on risk tolerance
            if risk_tolerance == RiskTolerance.CONSERVATIVE:
                # Limit individual asset allocation
                constraints_list.append(weights <= 0.3)
            elif risk_tolerance == RiskTolerance.MODERATE:
                constraints_list.append(weights <= 0.4)
            
            # Add custom constraints if provided
            if constraints:
                min_allocations = constraints.get('min_allocations', {})
                max_allocations = constraints.get('max_allocations', {})
                
                for i, asset in enumerate(expected_returns.index):
                    if asset in min_allocations:
                        constraints_list.append(weights[i] >= min_allocations[asset])
                    if asset in max_allocations:
                        constraints_list.append(weights[i] <= max_allocations[asset])
            
            # Solve optimization problem
            problem = cp.Problem(objective, constraints_list)
            problem.solve()
            
            if problem.status == 'optimal':
                optimal_weights = weights.value
                allocation = dict(zip(expected_returns.index, optimal_weights))
                return {k: max(0, v) for k, v in allocation.items()}  # Ensure non-negative
            else:
                logger.warning("Optimization failed, using equal weights")
                return self._equal_weight_portfolio(expected_returns.index)
        
        except Exception as e:
            logger.error(f"Portfolio optimization error: {e}")
            return self._equal_weight_portfolio(returns.columns)
    
    def _equal_weight_portfolio(self, assets: List[str]) -> Dict[str, float]:
        """Create equal-weight portfolio as fallback."""
        weight = 1.0 / len(assets)
        return {asset: weight for asset in assets}
    
    def calculate_portfolio_metrics(self, returns: pd.DataFrame, 
                                  weights: Dict[str, float]) -> Dict[str, float]:
        """Calculate portfolio performance metrics."""
        try:
            # Align weights with returns
            common_assets = set(returns.columns) & set(weights.keys())
            if not common_assets:
                return {"error": "No common assets found"}
            
            aligned_weights = np.array([weights.get(asset, 0) for asset in returns.columns])
            aligned_weights = aligned_weights / aligned_weights.sum()  # Normalize
            
            # Calculate portfolio returns
            portfolio_returns = (returns * aligned_weights).sum(axis=1)
            
            # Performance metrics
            annual_return = portfolio_returns.mean() * 252
            annual_volatility = portfolio_returns.std() * np.sqrt(252)
            sharpe_ratio = (annual_return - self.risk_free_rate) / annual_volatility if annual_volatility > 0 else 0
            
            # Downside metrics
            downside_returns = portfolio_returns[portfolio_returns < 0]
            max_drawdown = self._calculate_max_drawdown(portfolio_returns)
            
            return {
                "annual_return": annual_return,
                "annual_volatility": annual_volatility,
                "sharpe_ratio": sharpe_ratio,
                "max_drawdown": max_drawdown,
                "var_95": np.percentile(portfolio_returns, 5) * np.sqrt(252),  # Value at Risk
                "total_return": (1 + portfolio_returns).prod() - 1
            }
        
        except Exception as e:
            logger.error(f"Error calculating portfolio metrics: {e}")
            return {"error": str(e)}
    
    def _calculate_max_drawdown(self, returns: pd.Series) -> float:
        """Calculate maximum drawdown."""
        cumulative = (1 + returns).cumprod()
        running_max = cumulative.cummax()
        drawdown = (cumulative - running_max) / running_max
        return drawdown.min()

class BudgetOptimizer:
    """Optimizes budget allocation and financial planning."""
    
    def __init__(self):
        pass
    
    def optimize_budget(self, profile: FinancialProfile, 
                       current_expenses: List[BudgetItem]) -> BudgetPlan:
        """Optimize budget allocation based on financial profile."""
        monthly_income = profile.annual_income / 12
        
        # Calculate optimal savings rate based on age and goals
        optimal_savings_rate = self._calculate_optimal_savings_rate(profile)
        
        # Emergency fund target (3-6 months of expenses)
        total_monthly_expenses = sum(item.amount for item in current_expenses)
        emergency_fund_target = total_monthly_expenses * 6
        
        # Optimize expense allocation
        optimized_expenses = self._optimize_expenses(
            current_expenses, monthly_income, optimal_savings_rate
        )
        
        # Calculate investment allocation
        total_optimized_expenses = sum(item.amount for item in optimized_expenses)
        available_for_savings = monthly_income - total_optimized_expenses
        
        # Split between emergency fund and investments
        if profile.current_savings < emergency_fund_target:
            emergency_fund_contribution = min(
                available_for_savings * 0.5,
                (emergency_fund_target - profile.current_savings) / 12
            )
            investment_allocation = available_for_savings - emergency_fund_contribution
        else:
            emergency_fund_contribution = available_for_savings * 0.1
            investment_allocation = available_for_savings * 0.9
        
        return BudgetPlan(
            monthly_income=monthly_income,
            expenses=optimized_expenses,
            savings_target=available_for_savings,
            emergency_fund_target=emergency_fund_contribution,
            investment_allocation=investment_allocation
        )
    
    def _calculate_optimal_savings_rate(self, profile: FinancialProfile) -> float:
        """Calculate optimal savings rate based on profile."""
        base_rate = 0.20  # 20% base savings rate
        
        # Adjust for age (younger = higher savings rate for compound growth)
        age_factor = max(0.1, (65 - profile.age) / 40)
        
        # Adjust for risk tolerance
        risk_factor = {
            RiskTolerance.CONSERVATIVE: 0.8,
            RiskTolerance.MODERATE: 1.0,
            RiskTolerance.AGGRESSIVE: 1.2
        }.get(profile.risk_tolerance, 1.0)
        
        # Adjust for goals
        goal_factor = 1.0
        if InvestmentGoal.RETIREMENT in profile.investment_goals:
            goal_factor += 0.1
        if InvestmentGoal.EDUCATION in profile.investment_goals:
            goal_factor += 0.05
        
        optimal_rate = base_rate * age_factor * risk_factor * goal_factor
        return min(optimal_rate, 0.5)  # Cap at 50%
    
    def _optimize_expenses(self, expenses: List[BudgetItem], 
                          income: float, target_savings_rate: float) -> List[BudgetItem]:
        """Optimize expense allocation."""
        target_expenses = income * (1 - target_savings_rate)
        current_total = sum(item.amount for item in expenses)
        
        if current_total <= target_expenses:
            return expenses  # No optimization needed
        
        # Separate fixed and variable expenses
        fixed_expenses = [item for item in expenses if item.is_fixed]
        variable_expenses = [item for item in expenses if not item.is_fixed]
        
        fixed_total = sum(item.amount for item in fixed_expenses)
        available_for_variable = target_expenses - fixed_total
        
        if available_for_variable <= 0:
            # Even fixed expenses exceed target - flag this issue
            logger.warning("Fixed expenses exceed income target")
            return expenses
        
        # Optimize variable expenses based on priority
        variable_expenses.sort(key=lambda x: x.priority)
        
        optimized_variable = []
        remaining_budget = available_for_variable
        
        for expense in variable_expenses:
            # Reduce non-essential expenses more aggressively
            reduction_factor = 1.0 - (expense.priority - 1) * 0.15
            optimized_amount = min(expense.amount * reduction_factor, remaining_budget)
            
            if optimized_amount > 0:
                optimized_variable.append(BudgetItem(
                    category=expense.category,
                    amount=optimized_amount,
                    is_fixed=expense.is_fixed,
                    priority=expense.priority
                ))
                remaining_budget -= optimized_amount
        
        return fixed_expenses + optimized_variable

class RiskAnalyzer:
    """Analyzes various types of financial risk."""
    
    def __init__(self):
        pass
    
    def analyze_portfolio_risk(self, portfolio: Portfolio, 
                             market_data: pd.DataFrame) -> Dict[str, Any]:
        """Comprehensive portfolio risk analysis."""
        try:
            # Calculate portfolio returns
            weights = np.array(list(portfolio.assets.values()))
            weights = weights / weights.sum()  # Normalize
            
            aligned_data = market_data[[asset for asset in portfolio.assets.keys() 
                                     if asset in market_data.columns]]
            
            if aligned_data.empty:
                return {"error": "No matching assets found in market data"}
            
            returns = aligned_data.pct_change().dropna()
            portfolio_returns = (returns * weights[:len(returns.columns)]).sum(axis=1)
            
            # Risk metrics
            var_95 = np.percentile(portfolio_returns, 5)
            var_99 = np.percentile(portfolio_returns, 1)
            
            # Expected Shortfall (Conditional VaR)
            es_95 = portfolio_returns[portfolio_returns <= var_95].mean()
            
            # Beta calculation (market proxy)
            market_returns = returns.mean(axis=1)  # Equal-weight market proxy
            beta = np.cov(portfolio_returns, market_returns)[0, 1] / np.var(market_returns)
            
            # Correlation analysis
            correlation_matrix = returns.corr()
            avg_correlation = correlation_matrix.values[np.triu_indices_from(correlation_matrix.values, k=1)].mean()
            
            # Concentration risk
            concentration_risk = max(weights) if len(weights) > 0 else 0
            
            return {
                "value_at_risk_95": var_95,
                "value_at_risk_99": var_99,
                "expected_shortfall_95": es_95,
                "beta": beta,
                "average_correlation": avg_correlation,
                "concentration_risk": concentration_risk,
                "diversification_ratio": self._calculate_diversification_ratio(returns, weights),
                "volatility": portfolio_returns.std() * np.sqrt(252)
            }
        
        except Exception as e:
            logger.error(f"Risk analysis error: {e}")
            return {"error": str(e)}
    
    def _calculate_diversification_ratio(self, returns: pd.DataFrame, weights: np.ndarray) -> float:
        """Calculate portfolio diversification ratio."""
        try:
            individual_volatilities = returns.std() * np.sqrt(252)
            weighted_avg_vol = (weights[:len(individual_volatilities)] * individual_volatilities).sum()
            
            portfolio_vol = (returns * weights[:len(returns.columns)]).sum(axis=1).std() * np.sqrt(252)
            
            return weighted_avg_vol / portfolio_vol if portfolio_vol > 0 else 1.0
        except:
            return 1.0

class FinancialAdvisorLLM:
    """LLM-powered financial advisory system."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.3,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self._initialize_prompts()
    
    def _initialize_prompts(self):
        """Initialize advisory prompts."""
        self.advisory_prompt = ChatPromptTemplate.from_template("""
        You are a professional financial advisor. Provide personalized financial advice based on the client's profile and current market conditions.
        
        Client Profile:
        - Age: {age}
        - Annual Income: ${annual_income:,.2f}
        - Risk Tolerance: {risk_tolerance}
        - Investment Goals: {investment_goals}
        - Time Horizon: {time_horizon} years
        
        Current Market Data:
        {market_context}
        
        Portfolio Analysis:
        {portfolio_analysis}
        
        Question/Request: {query}
        
        Provide specific, actionable advice considering:
        1. Risk-return tradeoffs
        2. Diversification principles
        3. Tax implications
        4. Market conditions
        5. Time horizon and goals
        
        Format your response with clear sections and bullet points.
        """)
        
        self.market_analysis_prompt = ChatPromptTemplate.from_template("""
        Analyze the current market conditions and provide insights:
        
        Economic Indicators:
        {economic_data}
        
        Sector Performance:
        {sector_data}
        
        Portfolio Context:
        {portfolio_context}
        
        Provide analysis on:
        1. Market outlook
        2. Sector opportunities/risks
        3. Economic impact on portfolio
        4. Recommended actions
        
        Keep analysis concise but informative.
        """)
    
    def get_financial_advice(self, profile: FinancialProfile, 
                           portfolio: Optional[Portfolio],
                           market_data: Dict[str, Any],
                           query: str) -> str:
        """Generate personalized financial advice."""
        if not self.llm:
            return self._generate_basic_advice(profile, portfolio, query)
        
        try:
            # Prepare context
            market_context = self._format_market_context(market_data)
            portfolio_analysis = self._format_portfolio_analysis(portfolio)
            
            response = self.llm.invoke(
                self.advisory_prompt.format(
                    age=profile.age,
                    annual_income=profile.annual_income,
                    risk_tolerance=profile.risk_tolerance.value,
                    investment_goals=", ".join([goal.value for goal in profile.investment_goals]),
                    time_horizon=profile.time_horizon,
                    market_context=market_context,
                    portfolio_analysis=portfolio_analysis,
                    query=query
                )
            )
            
            return response.content
        
        except Exception as e:
            logger.error(f"LLM advice generation error: {e}")
            return self._generate_basic_advice(profile, portfolio, query)
    
    def analyze_market_conditions(self, economic_data: Dict[str, Any],
                                sector_data: Dict[str, Any],
                                portfolio_context: str) -> str:
        """Analyze current market conditions."""
        if not self.llm:
            return self._generate_basic_market_analysis(economic_data, sector_data)
        
        try:
            response = self.llm.invoke(
                self.market_analysis_prompt.format(
                    economic_data=json.dumps(economic_data, indent=2),
                    sector_data=json.dumps(sector_data, indent=2),
                    portfolio_context=portfolio_context
                )
            )
            
            return response.content
        
        except Exception as e:
            logger.error(f"Market analysis error: {e}")
            return self._generate_basic_market_analysis(economic_data, sector_data)
    
    def _format_market_context(self, market_data: Dict[str, Any]) -> str:
        """Format market data for LLM context."""
        economic = market_data.get('economic_indicators', {})
        sectors = market_data.get('sector_performance', {})
        
        context = "Economic Indicators:\n"
        for key, value in economic.items():
            context += f"- {key.replace('_', ' ').title()}: {value}%\n"
        
        context += "\nTop Performing Sectors:\n"
        sorted_sectors = sorted(sectors.items(), key=lambda x: x[1], reverse=True)
        for sector, performance in sorted_sectors[:5]:
            context += f"- {sector}: {performance:.1%}\n"
        
        return context
    
    def _format_portfolio_analysis(self, portfolio: Optional[Portfolio]) -> str:
        """Format portfolio data for LLM context."""
        if not portfolio:
            return "No current portfolio data available."
        
        analysis = f"Portfolio Value: ${portfolio.total_value:,.2f}\n"
        analysis += "Asset Allocation:\n"
        
        for asset, allocation in portfolio.assets.items():
            analysis += f"- {asset}: {allocation:.1%}\n"
        
        if portfolio.expected_return:
            analysis += f"Expected Return: {portfolio.expected_return:.1%}\n"
        if portfolio.risk_level:
            analysis += f"Risk Level: {portfolio.risk_level:.1%}\n"
        if portfolio.sharpe_ratio:
            analysis += f"Sharpe Ratio: {portfolio.sharpe_ratio:.2f}\n"
        
        return analysis
    
    def _generate_basic_advice(self, profile: FinancialProfile, 
                             portfolio: Optional[Portfolio], query: str) -> str:
        """Generate basic advice without LLM."""
        advice = f"Based on your profile (Age: {profile.age}, Risk Tolerance: {profile.risk_tolerance.value}):\n\n"
        
        if profile.risk_tolerance == RiskTolerance.CONSERVATIVE:
            advice += "‚Ä¢ Focus on bonds and dividend-paying stocks\n"
            advice += "‚Ä¢ Maintain 6-12 months emergency fund\n"
            advice += "‚Ä¢ Consider index funds for diversification\n"
        elif profile.risk_tolerance == RiskTolerance.AGGRESSIVE:
            advice += "‚Ä¢ Higher allocation to growth stocks\n"
            advice += "‚Ä¢ Consider international diversification\n"
            advice += "‚Ä¢ May include alternative investments\n"
        else:
            advice += "‚Ä¢ Balanced approach with 60/40 stocks/bonds\n"
            advice += "‚Ä¢ Regular rebalancing recommended\n"
            advice += "‚Ä¢ Focus on low-cost index funds\n"
        
        advice += f"\nFor your {profile.time_horizon}-year time horizon, consider dollar-cost averaging for investments."
        
        return advice
    
    def _generate_basic_market_analysis(self, economic_data: Dict, sector_data: Dict) -> str:
        """Generate basic market analysis without LLM."""
        analysis = "Market Analysis:\n\n"
        
        inflation = economic_data.get('inflation_rate', 0)
        if inflation > 4:
            analysis += "‚Ä¢ High inflation environment - consider inflation-protected securities\n"
        
        fed_rate = economic_data.get('fed_funds_rate', 0)
        if fed_rate > 4:
            analysis += "‚Ä¢ High interest rates - bonds may become more attractive\n"
        
        # Top sectors
        if sector_data:
            top_sector = max(sector_data.items(), key=lambda x: x[1])
            analysis += f"‚Ä¢ {top_sector[0]} is the top performing sector ({top_sector[1]:.1%})\n"
        
        return analysis

class FinancialAdvisorAgent:
    """Main financial advisor agent orchestrating all components."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.data_provider = DataProvider()
        self.portfolio_optimizer = PortfolioOptimizer()
        self.budget_optimizer = BudgetOptimizer()
        self.risk_analyzer = RiskAnalyzer()
        self.llm_advisor = FinancialAdvisorLLM(openai_api_key)
        
        # Sample assets for portfolio optimization
        self.default_assets = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'SPY', 'BND', 'GLD']
    
    def create_investment_recommendation(self, profile: FinancialProfile) -> Dict[str, Any]:
        """Create comprehensive investment recommendation."""
        try:
            # Get market data
            market_data = self.data_provider.get_stock_data(self.default_assets, "1y")
            economic_indicators = self.data_provider.get_economic_indicators()
            sector_performance = self.data_provider.get_sector_performance()
            
            # Calculate returns for optimization
            returns = market_data.pct_change().dropna()
            
            # Optimize portfolio
            optimal_allocation = self.portfolio_optimizer.optimize_portfolio(
                returns, profile.risk_tolerance
            )
            
            # Calculate portfolio metrics
            portfolio_metrics = self.portfolio_optimizer.calculate_portfolio_metrics(
                returns, optimal_allocation
            )
            
            # Create portfolio object
            portfolio = Portfolio(
                portfolio_id=f"portfolio_{profile.profile_id}",
                assets=optimal_allocation,
                total_value=profile.current_savings,
                last_updated=datetime.now(),
                expected_return=portfolio_metrics.get('annual_return'),
                risk_level=portfolio_metrics.get('annual_volatility'),
                sharpe_ratio=portfolio_metrics.get('sharpe_ratio')
            )
            
            # Risk analysis
            risk_analysis = self.risk_analyzer.analyze_portfolio_risk(portfolio, market_data)
            
            # Market context
            market_context = {
                'economic_indicators': economic_indicators,
                'sector_performance': sector_performance
            }
            
            # Generate advice
            advice = self.llm_advisor.get_financial_advice(
                profile, portfolio, market_context,
                "Please provide a comprehensive investment recommendation based on my profile and current market conditions."
            )
            
            return {
                'portfolio': portfolio,
                'portfolio_metrics': portfolio_metrics,
                'risk_analysis': risk_analysis,
                'market_context': market_context,
                'advice': advice,
                'allocation_chart_data': self._prepare_allocation_chart_data(optimal_allocation)
            }
        
        except Exception as e:
            logger.error(f"Investment recommendation error: {e}")
            return {'error': str(e)}
    
    def create_budget_plan(self, profile: FinancialProfile, 
                          current_expenses: List[BudgetItem]) -> Dict[str, Any]:
        """Create optimized budget plan."""
        try:
            budget_plan = self.budget_optimizer.optimize_budget(profile, current_expenses)
            
            # Generate budget advice
            budget_advice = self.llm_advisor.get_financial_advice(
                profile, None, {},
                f"Please provide budget optimization advice. My monthly income is ${budget_plan.monthly_income:,.2f} and I want to save ${budget_plan.savings_target:,.2f} per month."
            )
            
            return {
                'budget_plan': budget_plan,
                'advice': budget_advice,
                'savings_rate': budget_plan.savings_target / budget_plan.monthly_income,
                'expense_breakdown': self._prepare_expense_breakdown(budget_plan)
            }
        
        except Exception as e:
            logger.error(f"Budget planning error: {e}")
            return {'error': str(e)}
    
    def analyze_market_outlook(self) -> Dict[str, Any]:
        """Provide current market analysis and outlook."""
        try:
            economic_indicators = self.data_provider.get_economic_indicators()
            sector_performance = self.data_provider.get_sector_performance()
            
            # Get recent market data for trend analysis
            market_data = self.data_provider.get_stock_data(['SPY', 'QQQ', 'IWM'], "3mo")
            
            # Calculate market trends
            market_trends = self._calculate_market_trends(market_data)
            
            # Generate market analysis
            market_analysis = self.llm_advisor.analyze_market_conditions(
                economic_indicators, sector_performance,
                f"Recent market trends: {market_trends}"
            )
            
            return {
                'economic_indicators': economic_indicators,
                'sector_performance': sector_performance,
                'market_trends': market_trends,
                'analysis': market_analysis
            }
        
        except Exception as e:
            logger.error(f"Market analysis error: {e}")
            return {'error': str(e)}
    
    def _prepare_allocation_chart_data(self, allocation: Dict[str, float]) -> Dict[str, List]:
        """Prepare data for allocation pie chart."""
        assets = list(allocation.keys())
        values = [allocation[asset] * 100 for asset in assets]  # Convert to percentages
        
        return {'assets': assets, 'values': values}
    
    def _prepare_expense_breakdown(self, budget_plan: BudgetPlan) -> Dict[str, List]:
        """Prepare expense breakdown for visualization."""
        categories = [item.category for item in budget_plan.expenses]
        amounts = [item.amount for item in budget_plan.expenses]
        
        # Add savings and investments
        categories.extend(['Emergency Fund', 'Investments'])
        amounts.extend([budget_plan.emergency_fund_target, budget_plan.investment_allocation])
        
        return {'categories': categories, 'amounts': amounts}
    
    def _calculate_market_trends(self, market_data: pd.DataFrame) -> Dict[str, str]:
        """Calculate simple market trends."""
        trends = {}
        
        for asset in market_data.columns:
            prices = market_data[asset].dropna()
            if len(prices) > 1:
                recent_return = (prices.iloc[-1] - prices.iloc[-20]) / prices.iloc[-20]
                if recent_return > 0.05:
                    trends[asset] = "Strong Uptrend"
                elif recent_return > 0.02:
                    trends[asset] = "Uptrend"
                elif recent_return > -0.02:
                    trends[asset] = "Sideways"
                elif recent_return > -0.05:
                    trends[asset] = "Downtrend"
                else:
                    trends[asset] = "Strong Downtrend"
        
        return trends

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Financial Advisor Agent",
        page_icon="üí∞",
        layout="wide"
    )
    
    st.title("üí∞ AI Financial Advisor Agent")
    st.markdown("Intelligent financial planning with LLM-powered insights and optimization")
    
    # Initialize session state
    if 'advisor' not in st.session_state:
        st.session_state['advisor'] = None
    if 'user_profile' not in st.session_state:
        st.session_state['user_profile'] = None
    if 'investment_recommendation' not in st.session_state:
        st.session_state['investment_recommendation'] = None
    
    # Sidebar for configuration
    with st.sidebar:
        st.header("üîß Configuration")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Advisor") or st.session_state['advisor'] is None:
            with st.spinner("Initializing financial advisor..."):
                st.session_state['advisor'] = FinancialAdvisorAgent(openai_key)
                st.success("Financial advisor ready!")
        
        st.header("üë§ Financial Profile")
        
        if st.session_state['user_profile'] is None:
            # Profile creation form
            name = st.text_input("Name")
            age = st.number_input("Age", min_value=18, max_value=100, value=35)
            annual_income = st.number_input("Annual Income ($)", min_value=0, value=75000)
            monthly_expenses = st.number_input("Monthly Expenses ($)", min_value=0, value=4000)
            current_savings = st.number_input("Current Savings ($)", min_value=0, value=25000)
            
            risk_tolerance = st.selectbox("Risk Tolerance", [
                "Conservative", "Moderate", "Aggressive"
            ])
            
            investment_goals = st.multiselect("Investment Goals", [
                "Retirement", "Education", "Home Purchase", "Wealth Building", "Income Generation"
            ])
            
            time_horizon = st.slider("Investment Time Horizon (years)", 1, 40, 15)
            
            if st.button("Create Profile") and name:
                # Map selections to enums
                risk_map = {
                    "Conservative": RiskTolerance.CONSERVATIVE,
                    "Moderate": RiskTolerance.MODERATE,
                    "Aggressive": RiskTolerance.AGGRESSIVE
                }
                
                goal_map = {
                    "Retirement": InvestmentGoal.RETIREMENT,
                    "Education": InvestmentGoal.EDUCATION,
                    "Home Purchase": InvestmentGoal.HOME_PURCHASE,
                    "Wealth Building": InvestmentGoal.WEALTH_BUILDING,
                    "Income Generation": InvestmentGoal.INCOME_GENERATION
                }
                
                profile = FinancialProfile(
                    profile_id=f"profile_{hash(name)}",
                    age=age,
                    annual_income=annual_income,
                    monthly_expenses=monthly_expenses,
                    current_savings=current_savings,
                    investment_experience="intermediate",
                    risk_tolerance=risk_map[risk_tolerance],
                    investment_goals=[goal_map[g] for g in investment_goals if g in goal_map],
                    time_horizon=time_horizon,
                    liquidity_needs=monthly_expenses * 3
                )
                
                st.session_state['user_profile'] = profile
                st.success("Profile created!")
                st.rerun()
        else:
            profile = st.session_state['user_profile']
            st.write(f"**Name:** Profile User")
            st.write(f"**Age:** {profile.age}")
            st.write(f"**Income:** ${profile.annual_income:,.0f}")
            st.write(f"**Risk Tolerance:** {profile.risk_tolerance.value}")
            
            if st.button("Reset Profile"):
                st.session_state['user_profile'] = None
                st.session_state['investment_recommendation'] = None
                st.rerun()
    
    if not st.session_state['advisor']:
        st.info("üëà Please initialize the financial advisor")
        return
    
    if not st.session_state['user_profile']:
        st.info("üëà Please create your financial profile")
        return
    
    advisor = st.session_state['advisor']
    profile = st.session_state['user_profile']
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üéØ Investment Advice", "üí≥ Budget Planning", "üìä Market Analysis", "‚ö†Ô∏è Risk Assessment", "üí¨ Ask Advisor"])
    
    with tab1:
        st.header("üéØ Investment Recommendations")
        
        if st.button("Generate Investment Recommendation"):
            with st.spinner("Analyzing portfolio optimization..."):
                recommendation = advisor.create_investment_recommendation(profile)
                st.session_state['investment_recommendation'] = recommendation
        
        recommendation = st.session_state['investment_recommendation']
        
        if recommendation and 'error' not in recommendation:
            portfolio = recommendation['portfolio']
            metrics = recommendation['portfolio_metrics']
            
            # Portfolio summary
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Expected Return", f"{metrics.get('annual_return', 0):.1%}")
            with col2:
                st.metric("Risk (Volatility)", f"{metrics.get('annual_volatility', 0):.1%}")
            with col3:
                st.metric("Sharpe Ratio", f"{metrics.get('sharpe_ratio', 0):.2f}")
            with col4:
                st.metric("Max Drawdown", f"{metrics.get('max_drawdown', 0):.1%}")
            
            # Portfolio allocation chart
            st.subheader("üìä Recommended Portfolio Allocation")
            
            allocation_data = recommendation['allocation_chart_data']
            fig_allocation = px.pie(
                values=allocation_data['values'],
                names=allocation_data['assets'],
                title="Asset Allocation"
            )
            st.plotly_chart(fig_allocation, use_container_width=True)
            
            # Detailed allocation table
            st.subheader("üìã Detailed Allocation")
            allocation_df = pd.DataFrame([
                {"Asset": asset, "Allocation": f"{weight:.1%}", "Value": f"${portfolio.total_value * weight:,.2f}"}
                for asset, weight in portfolio.assets.items()
            ])
            st.dataframe(allocation_df, use_container_width=True)
            
            # AI-generated advice
            st.subheader("ü§ñ AI Financial Advice")
            st.write(recommendation['advice'])
            
        elif recommendation and 'error' in recommendation:
            st.error(f"Error generating recommendation: {recommendation['error']}")
        else:
            st.info("Click the button above to generate your personalized investment recommendation.")
    
    with tab2:
        st.header("üí≥ Budget Optimization")
        
        # Input current expenses
        st.subheader("üìù Current Monthly Expenses")
        
        if 'expense_items' not in st.session_state:
            st.session_state['expense_items'] = [
                BudgetItem("Housing", profile.monthly_expenses * 0.3, True, 1),
                BudgetItem("Food", profile.monthly_expenses * 0.15, False, 2),
                BudgetItem("Transportation", profile.monthly_expenses * 0.15, False, 3),
                BudgetItem("Utilities", profile.monthly_expenses * 0.1, True, 2),
                BudgetItem("Entertainment", profile.monthly_expenses * 0.1, False, 4),
                BudgetItem("Healthcare", profile.monthly_expenses * 0.1, False, 2),
                BudgetItem("Miscellaneous", profile.monthly_expenses * 0.1, False, 5)
            ]
        
        # Display and edit expenses
        expense_data = []
        for i, item in enumerate(st.session_state['expense_items']):
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                category = st.text_input(f"Category {i+1}", value=item.category, key=f"cat_{i}")
            with col2:
                amount = st.number_input(f"Amount {i+1}", value=item.amount, min_value=0.0, key=f"amt_{i}")
            with col3:
                is_fixed = st.checkbox(f"Fixed {i+1}", value=item.is_fixed, key=f"fix_{i}")
            with col4:
                priority = st.selectbox(f"Priority {i+1}", [1, 2, 3, 4, 5], index=item.priority-1, key=f"pri_{i}")
            
            expense_data.append(BudgetItem(category, amount, is_fixed, priority))
        
        st.session_state['expense_items'] = expense_data
        
        if st.button("Optimize Budget"):
            with st.spinner("Optimizing budget allocation..."):
                budget_result = advisor.create_budget_plan(profile, st.session_state['expense_items'])
                st.session_state['budget_result'] = budget_result
        
        # Display budget optimization results
        if 'budget_result' in st.session_state:
            budget_result = st.session_state['budget_result']
            
            if 'error' not in budget_result:
                budget_plan = budget_result['budget_plan']
                
                # Budget summary
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Monthly Income", f"${budget_plan.monthly_income:,.2f}")
                with col2:
                    st.metric("Total Savings", f"${budget_plan.savings_target:,.2f}")
                with col3:
                    st.metric("Savings Rate", f"{budget_result['savings_rate']:.1%}")
                with col4:
                    st.metric("Emergency Fund", f"${budget_plan.emergency_fund_target:,.2f}")
                
                # Budget breakdown chart
                st.subheader("üí∞ Optimized Budget Breakdown")
                
                breakdown_data = budget_result['expense_breakdown']
                fig_budget = px.pie(
                    values=breakdown_data['amounts'],
                    names=breakdown_data['categories'],
                    title="Monthly Budget Allocation"
                )
                st.plotly_chart(fig_budget, use_container_width=True)
                
                # Budget advice
                st.subheader("üí° Budget Optimization Advice")
                st.write(budget_result['advice'])
            else:
                st.error(f"Budget optimization error: {budget_result['error']}")
    
    with tab3:
        st.header("üìä Market Analysis")
        
        if st.button("Analyze Current Market"):
            with st.spinner("Analyzing market conditions..."):
                market_analysis = advisor.analyze_market_outlook()
                st.session_state['market_analysis'] = market_analysis
        
        if 'market_analysis' in st.session_state:
            analysis = st.session_state['market_analysis']
            
            if 'error' not in analysis:
                # Economic indicators
                st.subheader("üìà Economic Indicators")
                
                indicators = analysis['economic_indicators']
                indicator_cols = st.columns(3)
                
                for i, (key, value) in enumerate(indicators.items()):
                    with indicator_cols[i % 3]:
                        st.metric(key.replace('_', ' ').title(), f"{value}%")
                
                # Sector performance
                st.subheader("üè≠ Sector Performance (YTD)")
                
                sector_data = analysis['sector_performance']
                sector_df = pd.DataFrame([
                    {"Sector": sector, "Return": f"{return_val:.1%}"}
                    for sector, return_val in sorted(sector_data.items(), key=lambda x: x[1], reverse=True)
                ])
                
                # Sector performance chart
                fig_sectors = px.bar(
                    x=list(sector_data.keys()),
                    y=[v * 100 for v in sector_data.values()],
                    title="Sector Performance (YTD %)",
                    labels={'x': 'Sector', 'y': 'Return (%)'}
                )
                st.plotly_chart(fig_sectors, use_container_width=True)
                
                # Market trends
                st.subheader("üìä Market Trends")
                trends = analysis['market_trends']
                for asset, trend in trends.items():
                    st.write(f"**{asset}:** {trend}")
                
                # AI market analysis
                st.subheader("ü§ñ AI Market Analysis")
                st.write(analysis['analysis'])
            else:
                st.error(f"Market analysis error: {analysis['error']}")
        else:
            st.info("Click the button above to get current market analysis.")
    
    with tab4:
        st.header("‚ö†Ô∏è Risk Assessment")
        
        if st.session_state['investment_recommendation']:
            recommendation = st.session_state['investment_recommendation']
            
            if 'risk_analysis' in recommendation:
                risk_data = recommendation['risk_analysis']
                
                if 'error' not in risk_data:
                    # Risk metrics
                    st.subheader("üìä Portfolio Risk Metrics")
                    
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.metric("Value at Risk (95%)", f"{risk_data.get('value_at_risk_95', 0):.2%}")
                        st.metric("Beta", f"{risk_data.get('beta', 0):.2f}")
                    
                    with col2:
                        st.metric("Expected Shortfall", f"{risk_data.get('expected_shortfall_95', 0):.2%}")
                        st.metric("Volatility", f"{risk_data.get('volatility', 0):.2%}")
                    
                    with col3:
                        st.metric("Concentration Risk", f"{risk_data.get('concentration_risk', 0):.2%}")
                        st.metric("Diversification Ratio", f"{risk_data.get('diversification_ratio', 0):.2f}")
                    
                    # Risk interpretation
                    st.subheader("üéØ Risk Analysis")
                    
                    var_95 = risk_data.get('value_at_risk_95', 0)
                    if var_95 < -0.1:
                        st.error("‚ö†Ô∏è High risk portfolio - potential for significant losses")
                    elif var_95 < -0.05:
                        st.warning("‚ö†Ô∏è Moderate risk - consider diversification")
                    else:
                        st.success("‚úÖ Conservative risk profile")
                    
                    concentration = risk_data.get('concentration_risk', 0)
                    if concentration > 0.4:
                        st.warning("‚ö†Ô∏è High concentration risk - consider diversifying")
                    
                    # Risk recommendations
                    st.subheader("üí° Risk Management Recommendations")
                    
                    recommendations = []
                    
                    if risk_data.get('concentration_risk', 0) > 0.3:
                        recommendations.append("‚Ä¢ Consider reducing concentration in top holdings")
                    
                    if risk_data.get('diversification_ratio', 0) < 1.2:
                        recommendations.append("‚Ä¢ Improve diversification across asset classes")
                    
                    if risk_data.get('beta', 0) > 1.5:
                        recommendations.append("‚Ä¢ Portfolio is highly sensitive to market movements")
                    
                    if risk_data.get('average_correlation', 0) > 0.7:
                        recommendations.append("‚Ä¢ Consider adding uncorrelated assets")
                    
                    if not recommendations:
                        recommendations.append("‚Ä¢ Portfolio shows good risk characteristics")
                    
                    for rec in recommendations:
                        st.write(rec)
                else:
                    st.error(f"Risk analysis error: {risk_data['error']}")
        else:
            st.info("Generate an investment recommendation first to see risk analysis.")
    
    with tab5:
        st.header("üí¨ Ask Your Financial Advisor")
        
        # Chat interface
        if 'chat_history' not in st.session_state:
            st.session_state['chat_history'] = []
        
        # Display chat history
        for message in st.session_state['chat_history']:
            with st.chat_message(message['role']):
                st.write(message['content'])
        
        # Chat input
        user_question = st.chat_input("Ask your financial advisor anything...")
        
        if user_question:
            # Add user message to history
            st.session_state['chat_history'].append({
                'role': 'user',
                'content': user_question
            })
            
            # Generate response
            with st.spinner("Generating advice..."):
                # Get current market context
                market_data = {
                    'economic_indicators': advisor.data_provider.get_economic_indicators(),
                    'sector_performance': advisor.data_provider.get_sector_performance()
                }
                
                # Get portfolio context if available
                portfolio = None
                if st.session_state['investment_recommendation']:
                    portfolio = st.session_state['investment_recommendation'].get('portfolio')
                
                # Generate advice
                advice = advisor.llm_advisor.get_financial_advice(
                    profile, portfolio, market_data, user_question
                )
                
                # Add advisor response to history
                st.session_state['chat_history'].append({
                    'role': 'assistant',
                    'content': advice
                })
            
            st.rerun()
        
        # Clear chat button
        if st.button("Clear Chat History"):
            st.session_state['chat_history'] = []
            st.rerun()

if __name__ == "__main__":
    main()
````

## Project Summary

The Financial Advisor Agent represents a comprehensive AI-powered financial planning system that integrates LLM capabilities with quantitative analysis, real-time market data through OpenBB, and advanced optimization algorithms to deliver personalized financial advice, portfolio management, and budget optimization services.

### Key Value Propositions:
- **Intelligent Financial Advisory**: LLM-powered personalized advice generation with market context and quantitative analysis
- **Real-time Market Integration**: OpenBB integration for live financial data, economic indicators, and market analysis
- **Advanced Portfolio Optimization**: Modern portfolio theory implementation with risk-adjusted optimization algorithms
- **Comprehensive Budget Planning**: Automated budget optimization with goal-based constraints and savings maximization

### Technical Architecture:
The system combines LangChain for conversational AI, OpenBB Terminal for financial data access, CVXPY for portfolio optimization, and comprehensive risk analysis frameworks, creating a scalable platform for financial advisory services that can handle both individual and institutional investment planning needs with regulatory compliance considerations.