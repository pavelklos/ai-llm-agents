<small>Claude Sonnet 4 **(Medical Chatbot - HIPAA-Compliant AI Health Assistant)**</small>
# Medical Chatbot

## Key Concepts Explanation

### HIPAA Compliance
Health Insurance Portability and Accountability Act (HIPAA) is a US federal law that establishes privacy and security standards for protected health information (PHI). In medical AI systems, HIPAA compliance requires encryption at rest and in transit, access controls, audit logging, data anonymization, and secure handling of patient data. Non-compliance can result in severe penalties and legal consequences.

### Retrieval-Augmented Generation (RAG)
RAG combines large language models with external knowledge retrieval systems. The system searches relevant medical literature, guidelines, and databases to provide context-aware responses. This approach ensures responses are grounded in current medical knowledge rather than relying solely on the model's training data, improving accuracy and reducing hallucinations.

### Symptom Checker
An AI-powered diagnostic support tool that analyzes patient-reported symptoms, medical history, and demographic information to suggest possible conditions and recommend appropriate care levels. It uses clinical decision trees, medical knowledge bases, and pattern recognition to provide preliminary assessments while emphasizing the need for professional medical consultation.

### Vector Embeddings in Healthcare
Mathematical representations of medical concepts, symptoms, conditions, and treatments in high-dimensional space. These embeddings enable semantic similarity searches across medical literature, allowing the system to find relevant information based on meaning rather than exact keyword matches.

### Differential Diagnosis
The systematic process of distinguishing between conditions that share similar symptoms. AI systems use probabilistic reasoning, pattern matching, and medical knowledge bases to generate ranked lists of potential diagnoses based on symptom patterns and patient characteristics.

## Comprehensive Project Explanation

### Project Overview
The Medical Chatbot is a sophisticated AI-powered healthcare assistant designed to provide preliminary medical guidance while maintaining strict HIPAA compliance. This system combines advanced natural language processing with comprehensive medical knowledge bases to offer symptom checking, health information retrieval, and care recommendations.

### Objectives
- **Accessible Healthcare**: Provide 24/7 medical guidance and health information access
- **HIPAA Compliance**: Ensure complete privacy and security of patient health information
- **Clinical Decision Support**: Assist users in understanding symptoms and care urgency
- **Educational Resource**: Deliver evidence-based health information and prevention guidance
- **Healthcare Efficiency**: Reduce unnecessary emergency visits through appropriate triage

### Key Challenges
- **Medical Accuracy**: Ensuring responses are clinically sound and evidence-based
- **Privacy Protection**: Implementing comprehensive HIPAA-compliant data handling
- **Liability Management**: Providing guidance without practicing medicine or replacing doctors
- **Knowledge Currency**: Maintaining up-to-date medical information and guidelines
- **Cultural Sensitivity**: Adapting to diverse populations and health beliefs
- **Emergency Recognition**: Identifying critical situations requiring immediate medical attention

### Potential Impact
- **Healthcare Access**: Improve access to preliminary medical guidance, especially in underserved areas
- **Cost Reduction**: Reduce healthcare costs through appropriate care level recommendations
- **Early Detection**: Enable early identification of serious conditions through symptom analysis
- **Health Education**: Increase health literacy and preventive care awareness
- **Provider Support**: Assist healthcare providers with preliminary patient assessments
- **Emergency Triage**: Help users understand when immediate medical attention is needed

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.3.0
langchain==0.0.350
langchain-openai==0.0.2
langchain-community==0.0.10
chromadb==0.4.18
sentence-transformers==2.2.2
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
cryptography==41.0.8
bcrypt==4.1.2
redis==5.0.1
sqlalchemy==2.0.23
alembic==1.13.1
psycopg2-binary==2.9.9
python-dotenv==1.0.0
httpx==0.25.2
python-multipart==0.0.6
passlib==1.7.4
python-jose==3.3.0
aiofiles==23.2.1
pandas==2.1.4
numpy==1.24.3
scikit-learn==1.3.2
````

### Core Medical Chatbot Implementation

````python
import os
import asyncio
import json
import logging
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
from enum import Enum
from dataclasses import dataclass, asdict
import uuid

from fastapi import FastAPI, HTTPException, Depends, Security, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, validator
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.schema import HumanMessage, SystemMessage, AIMessage
from langchain.memory import ConversationBufferWindowMemory
import chromadb
from cryptography.fernet import Fernet
import redis
from sqlalchemy import create_engine, Column, String, DateTime, Text, Integer, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from dotenv import load_dotenv

load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class UrgencyLevel(str, Enum):
    EMERGENCY = "emergency"
    URGENT = "urgent"
    ROUTINE = "routine"
    SELF_CARE = "self_care"

class ConversationStatus(str, Enum):
    ACTIVE = "active"
    COMPLETED = "completed"
    ESCALATED = "escalated"

@dataclass
class MedicalContext:
    symptoms: List[str]
    duration: Optional[str]
    severity: Optional[int]  # 1-10 scale
    medical_history: List[str]
    current_medications: List[str]
    allergies: List[str]
    age_range: Optional[str]
    biological_sex: Optional[str]

class ChatMessage(BaseModel):
    message: str = Field(..., min_length=1, max_length=1000)
    conversation_id: Optional[str] = None
    user_context: Optional[Dict[str, Any]] = None

class ChatResponse(BaseModel):
    response: str
    conversation_id: str
    urgency_level: UrgencyLevel
    recommendations: List[str]
    disclaimer: str
    should_seek_care: bool
    emergency_warning: bool = False

class MedicalKnowledgeBase:
    """HIPAA-compliant medical knowledge base using RAG."""
    
    def __init__(self):
        self.embeddings = OpenAIEmbeddings(
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )
        self.chroma_client = chromadb.PersistentClient(path="./medical_kb")
        self.collection = self._initialize_collection()
        self._populate_medical_knowledge()
    
    def _initialize_collection(self):
        """Initialize ChromaDB collection for medical knowledge."""
        try:
            return self.chroma_client.get_collection("medical_knowledge")
        except:
            return self.chroma_client.create_collection(
                name="medical_knowledge",
                metadata={"description": "Medical knowledge base for symptom checking"}
            )
    
    def _populate_medical_knowledge(self):
        """Populate the knowledge base with medical information."""
        if self.collection.count() > 0:
            return  # Already populated
        
        medical_data = [
            {
                "id": "chest_pain_001",
                "content": "Chest pain can indicate heart attack, especially if accompanied by shortness of breath, sweating, nausea, or pain radiating to arm/jaw. Seek emergency care immediately.",
                "category": "emergency",
                "symptoms": ["chest pain", "shortness of breath", "sweating", "nausea"],
                "urgency": "emergency"
            },
            {
                "id": "fever_001",
                "content": "Fever above 103Â°F (39.4Â°C) in adults or persistent fever with severe symptoms requires medical attention. In children under 3 months, any fever requires immediate care.",
                "category": "urgent",
                "symptoms": ["fever", "high temperature"],
                "urgency": "urgent"
            },
            {
                "id": "headache_001",
                "content": "Sudden severe headache ('worst headache of life'), headache with neck stiffness, confusion, or vision changes may indicate serious conditions requiring emergency care.",
                "category": "emergency",
                "symptoms": ["severe headache", "neck stiffness", "confusion"],
                "urgency": "emergency"
            },
            {
                "id": "cold_001",
                "content": "Common cold symptoms include runny nose, sneezing, mild cough, and low-grade fever. Usually resolves in 7-10 days with rest, fluids, and symptom management.",
                "category": "self_care",
                "symptoms": ["runny nose", "sneezing", "mild cough", "congestion"],
                "urgency": "self_care"
            },
            {
                "id": "abdominal_pain_001",
                "content": "Severe abdominal pain, especially in lower right (appendicitis) or with vomiting/fever, requires medical evaluation. Mild pain may be managed with rest and monitoring.",
                "category": "urgent",
                "symptoms": ["abdominal pain", "stomach pain", "belly pain"],
                "urgency": "urgent"
            },
            {
                "id": "breathing_001",
                "content": "Difficulty breathing, wheezing, or inability to speak in full sentences requires immediate emergency care. May indicate asthma attack, allergic reaction, or heart problems.",
                "category": "emergency",
                "symptoms": ["difficulty breathing", "wheezing", "shortness of breath"],
                "urgency": "emergency"
            },
            {
                "id": "skin_rash_001",
                "content": "Widespread rash with difficulty breathing or swelling may indicate allergic reaction requiring emergency care. Localized rashes usually need routine medical evaluation.",
                "category": "routine",
                "symptoms": ["rash", "skin irritation", "hives"],
                "urgency": "routine"
            },
            {
                "id": "mental_health_001",
                "content": "Thoughts of self-harm or suicide require immediate crisis intervention. Contact 988 Suicide & Crisis Lifeline or emergency services immediately.",
                "category": "emergency",
                "symptoms": ["depression", "suicidal thoughts", "self-harm"],
                "urgency": "emergency"
            }
        ]
        
        # Add documents to ChromaDB
        for data in medical_data:
            self.collection.add(
                documents=[data["content"]],
                metadatas=[{
                    "category": data["category"],
                    "symptoms": ",".join(data["symptoms"]),
                    "urgency": data["urgency"]
                }],
                ids=[data["id"]]
            )
        
        logger.info(f"Populated knowledge base with {len(medical_data)} medical entries")
    
    async def search_medical_knowledge(self, query: str, n_results: int = 3) -> List[Dict[str, Any]]:
        """Search medical knowledge base for relevant information."""
        try:
            results = self.collection.query(
                query_texts=[query],
                n_results=n_results
            )
            
            knowledge_items = []
            for i, doc in enumerate(results['documents'][0]):
                metadata = results['metadatas'][0][i]
                knowledge_items.append({
                    "content": doc,
                    "category": metadata.get("category"),
                    "urgency": metadata.get("urgency"),
                    "symptoms": metadata.get("symptoms", "").split(",")
                })
            
            return knowledge_items
            
        except Exception as e:
            logger.error(f"Knowledge search failed: {e}")
            return []

class HIPAAEncryption:
    """HIPAA-compliant encryption for sensitive data."""
    
    def __init__(self):
        self.key = os.getenv("ENCRYPTION_KEY", Fernet.generate_key())
        self.cipher_suite = Fernet(self.key)
    
    def encrypt_data(self, data: str) -> str:
        """Encrypt sensitive data."""
        return self.cipher_suite.encrypt(data.encode()).decode()
    
    def decrypt_data(self, encrypted_data: str) -> str:
        """Decrypt sensitive data."""
        return self.cipher_suite.decrypt(encrypted_data.encode()).decode()
    
    def hash_identifier(self, identifier: str) -> str:
        """Create irreversible hash for user identification."""
        return hashlib.sha256(identifier.encode()).hexdigest()

# Database Models
Base = declarative_base()

class ConversationRecord(Base):
    __tablename__ = "conversations"
    
    id = Column(String, primary_key=True)
    user_hash = Column(String, nullable=False, index=True)
    status = Column(String, nullable=False)
    urgency_level = Column(String, nullable=False)
    encrypted_content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    escalated = Column(Boolean, default=False)

class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_hash = Column(String, nullable=False, index=True)
    action = Column(String, nullable=False)
    resource = Column(String, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)
    ip_address = Column(String)
    success = Column(Boolean, default=True)

class MedicalChatbot:
    """HIPAA-compliant medical chatbot with RAG capabilities."""
    
    def __init__(self):
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0.1,
            api_key=os.getenv("OPENAI_API_KEY")
        )
        self.knowledge_base = MedicalKnowledgeBase()
        self.encryption = HIPAAEncryption()
        self.redis_client = redis.Redis(
            host=os.getenv("REDIS_HOST", "localhost"),
            port=int(os.getenv("REDIS_PORT", 6379)),
            decode_responses=True
        )
        
        # Database setup
        database_url = os.getenv("DATABASE_URL", "sqlite:///medical_chatbot.db")
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        self.SessionLocal = sessionmaker(bind=self.engine)
        
        self.system_prompt = self._create_system_prompt()
    
    def _create_system_prompt(self) -> str:
        """Create comprehensive system prompt for medical chatbot."""
        return """You are a HIPAA-compliant medical AI assistant designed to provide preliminary health guidance. Follow these critical guidelines:

SAFETY FIRST:
- Always emphasize that you are not a doctor and cannot replace professional medical care
- For ANY emergency symptoms (chest pain, difficulty breathing, severe injuries, suicidal thoughts), immediately recommend calling 911 or emergency services
- Never provide specific dosing instructions for medications
- Always recommend consulting healthcare providers for diagnosis and treatment

RESPONSE STRUCTURE:
1. Acknowledge the user's concern with empathy
2. Provide general health information based on symptoms
3. Suggest appropriate level of care (emergency, urgent, routine, self-care)
4. Include clear disclaimers about seeking professional medical advice

EMERGENCY INDICATORS:
- Chest pain with shortness of breath
- Difficulty breathing or wheezing
- Severe allergic reactions
- Thoughts of self-harm or suicide
- Severe injuries or bleeding
- Signs of stroke (face drooping, arm weakness, speech difficulty)
- High fever with neck stiffness
- Severe abdominal pain

Be compassionate, informative, and always prioritize user safety over convenience."""

    async def process_message(self, message: ChatMessage, user_id: str) -> ChatResponse:
        """Process user message and generate medical guidance."""
        try:
            # Hash user ID for privacy
            user_hash = self.encryption.hash_identifier(user_id)
            
            # Log interaction
            await self._log_audit(user_hash, "message_received", "conversation")
            
            # Get or create conversation
            conversation_id = message.conversation_id or str(uuid.uuid4())
            
            # Extract medical context from message
            medical_context = await self._extract_medical_context(message.message)
            
            # Search knowledge base for relevant information
            relevant_knowledge = await self.knowledge_base.search_medical_knowledge(
                message.message
            )
            
            # Determine urgency level
            urgency_level = await self._assess_urgency(message.message, relevant_knowledge)
            
            # Generate response using LLM with RAG
            response = await self._generate_response(
                message.message,
                relevant_knowledge,
                medical_context
            )
            
            # Create recommendations
            recommendations = await self._generate_recommendations(
                medical_context,
                urgency_level,
                relevant_knowledge
            )
            
            # Check for emergency situations
            emergency_warning = urgency_level == UrgencyLevel.EMERGENCY
            should_seek_care = urgency_level in [UrgencyLevel.EMERGENCY, UrgencyLevel.URGENT]
            
            # Store conversation securely
            await self._store_conversation(
                conversation_id,
                user_hash,
                message.message,
                response,
                urgency_level
            )
            
            return ChatResponse(
                response=response,
                conversation_id=conversation_id,
                urgency_level=urgency_level,
                recommendations=recommendations,
                disclaimer=self._get_medical_disclaimer(),
                should_seek_care=should_seek_care,
                emergency_warning=emergency_warning
            )
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            await self._log_audit(user_hash, "error", "conversation", success=False)
            raise HTTPException(status_code=500, detail="Unable to process medical inquiry")
    
    async def _extract_medical_context(self, message: str) -> MedicalContext:
        """Extract medical context from user message using NLP."""
        # Simplified extraction - in production, use medical NER models
        symptoms = []
        duration = None
        severity = None
        
        # Basic symptom detection
        symptom_keywords = [
            "pain", "ache", "fever", "headache", "nausea", "vomiting",
            "dizziness", "fatigue", "cough", "congestion", "rash",
            "breathing", "chest", "stomach", "back", "joint"
        ]
        
        message_lower = message.lower()
        for keyword in symptom_keywords:
            if keyword in message_lower:
                symptoms.append(keyword)
        
        # Duration detection
        if "days" in message_lower or "weeks" in message_lower:
            duration = "chronic"
        elif "hours" in message_lower or "minutes" in message_lower:
            duration = "acute"
        
        # Severity detection
        if any(word in message_lower for word in ["severe", "extreme", "unbearable"]):
            severity = 8
        elif any(word in message_lower for word in ["moderate", "bad"]):
            severity = 5
        elif any(word in message_lower for word in ["mild", "slight"]):
            severity = 3
        
        return MedicalContext(
            symptoms=symptoms,
            duration=duration,
            severity=severity,
            medical_history=[],
            current_medications=[],
            allergies=[],
            age_range=None,
            biological_sex=None
        )
    
    async def _assess_urgency(self, message: str, knowledge_items: List[Dict]) -> UrgencyLevel:
        """Assess urgency level based on symptoms and knowledge base."""
        message_lower = message.lower()
        
        # Emergency keywords
        emergency_indicators = [
            "chest pain", "can't breathe", "difficulty breathing",
            "suicidal", "kill myself", "severe bleeding",
            "stroke", "heart attack", "unconscious", "911"
        ]
        
        for indicator in emergency_indicators:
            if indicator in message_lower:
                return UrgencyLevel.EMERGENCY
        
        # Check knowledge base urgency
        for item in knowledge_items:
            if item.get("urgency") == "emergency":
                return UrgencyLevel.EMERGENCY
            elif item.get("urgency") == "urgent":
                return UrgencyLevel.URGENT
        
        # Urgent indicators
        urgent_indicators = [
            "high fever", "severe pain", "persistent vomiting",
            "dehydration", "infection", "wound"
        ]
        
        for indicator in urgent_indicators:
            if indicator in message_lower:
                return UrgencyLevel.URGENT
        
        return UrgencyLevel.ROUTINE
    
    async def _generate_response(
        self,
        message: str,
        knowledge_items: List[Dict],
        medical_context: MedicalContext
    ) -> str:
        """Generate medical response using LLM with RAG."""
        
        # Prepare context from knowledge base
        knowledge_context = "\n".join([
            f"Medical Information: {item['content']}"
            for item in knowledge_items
        ])
        
        context_info = f"""
Relevant Medical Knowledge:
{knowledge_context}

User's Symptoms: {', '.join(medical_context.symptoms) if medical_context.symptoms else 'Not specified'}
Duration: {medical_context.duration or 'Not specified'}
Severity (1-10): {medical_context.severity or 'Not specified'}
"""
        
        messages = [
            SystemMessage(content=self.system_prompt),
            HumanMessage(content=f"""
Context Information:
{context_info}

User Message: {message}

Provide a helpful, empathetic response following medical safety guidelines.
""")
        ]
        
        response = await self.llm.ainvoke(messages)
        return response.content
    
    async def _generate_recommendations(
        self,
        medical_context: MedicalContext,
        urgency_level: UrgencyLevel,
        knowledge_items: List[Dict]
    ) -> List[str]:
        """Generate care recommendations based on assessment."""
        recommendations = []
        
        if urgency_level == UrgencyLevel.EMERGENCY:
            recommendations.extend([
                "ðŸš¨ Call 911 or go to emergency room immediately",
                "Do not drive yourself - call ambulance or have someone drive you",
                "If possible, call ahead to emergency room"
            ])
        elif urgency_level == UrgencyLevel.URGENT:
            recommendations.extend([
                "ðŸ“ž Contact your doctor or urgent care within 24 hours",
                "Monitor symptoms closely",
                "Seek immediate care if symptoms worsen"
            ])
        elif urgency_level == UrgencyLevel.ROUTINE:
            recommendations.extend([
                "ðŸ“… Schedule appointment with your primary care doctor",
                "Continue monitoring symptoms",
                "Keep a symptom diary"
            ])
        else:  # SELF_CARE
            recommendations.extend([
                "ðŸ  Consider self-care measures",
                "Monitor symptoms for changes",
                "Contact doctor if symptoms persist or worsen"
            ])
        
        # Add general health recommendations
        recommendations.extend([
            "ðŸ’§ Stay hydrated",
            "ðŸ˜´ Get adequate rest",
            "ðŸ“± Have emergency contacts readily available"
        ])
        
        return recommendations
    
    async def _store_conversation(
        self,
        conversation_id: str,
        user_hash: str,
        user_message: str,
        bot_response: str,
        urgency_level: UrgencyLevel
    ):
        """Store conversation securely with HIPAA compliance."""
        try:
            # Encrypt conversation content
            conversation_data = {
                "user_message": user_message,
                "bot_response": bot_response,
                "timestamp": datetime.utcnow().isoformat()
            }
            encrypted_content = self.encryption.encrypt_data(json.dumps(conversation_data))
            
            # Store in database
            with self.SessionLocal() as db:
                conversation = ConversationRecord(
                    id=conversation_id,
                    user_hash=user_hash,
                    status=ConversationStatus.ACTIVE.value,
                    urgency_level=urgency_level.value,
                    encrypted_content=encrypted_content
                )
                db.add(conversation)
                db.commit()
            
            # Store in Redis for quick access (with TTL)
            redis_key = f"conversation:{conversation_id}"
            self.redis_client.setex(
                redis_key,
                timedelta(hours=24),
                encrypted_content
            )
            
        except Exception as e:
            logger.error(f"Failed to store conversation: {e}")
    
    async def _log_audit(
        self,
        user_hash: str,
        action: str,
        resource: str,
        ip_address: str = None,
        success: bool = True
    ):
        """Log audit trail for HIPAA compliance."""
        try:
            with self.SessionLocal() as db:
                audit_log = AuditLog(
                    user_hash=user_hash,
                    action=action,
                    resource=resource,
                    ip_address=ip_address,
                    success=success
                )
                db.add(audit_log)
                db.commit()
        except Exception as e:
            logger.error(f"Failed to log audit: {e}")
    
    def _get_medical_disclaimer(self) -> str:
        """Get standard medical disclaimer."""
        return (
            "âš ï¸ IMPORTANT DISCLAIMER: This AI assistant provides general health information "
            "and is not a substitute for professional medical advice, diagnosis, or treatment. "
            "Always consult with qualified healthcare providers for medical concerns. "
            "In case of emergency, call 911 immediately."
        )

# FastAPI Application
app = FastAPI(
    title="Medical Chatbot API",
    description="HIPAA-compliant medical AI assistant",
    version="1.0.0"
)

chatbot = MedicalChatbot()
security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Security(security)):
    """Validate user token for API access."""
    # Simplified authentication - implement proper JWT validation in production
    token = credentials.credentials
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
    return token  # In production, decode JWT and return user info

@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(
    message: ChatMessage,
    user_token: str = Depends(get_current_user)
):
    """Main chat endpoint for medical consultations."""
    try:
        response = await chatbot.process_message(message, user_token)
        return response
    except Exception as e:
        logger.error(f"Chat endpoint error: {e}")
        raise HTTPException(status_code=500, detail="Unable to process medical inquiry")

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "service": "Medical Chatbot",
        "hipaa_compliant": True,
        "timestamp": datetime.utcnow().isoformat()
    }

@app.get("/emergency-info")
async def emergency_information():
    """Provide emergency contact information."""
    return {
        "emergency_numbers": {
            "US": "911",
            "suicide_prevention": "988",
            "poison_control": "1-800-222-1222"
        },
        "emergency_signs": [
            "Chest pain or pressure",
            "Difficulty breathing",
            "Severe bleeding",
            "Loss of consciousness",
            "Signs of stroke (FAST: Face, Arms, Speech, Time)",
            "Severe allergic reaction",
            "Thoughts of self-harm"
        ]
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### Example Usage and Testing

````python
import asyncio
import json
from main import MedicalChatbot, ChatMessage, UrgencyLevel

async def test_medical_scenarios():
    """Test various medical scenarios."""
    
    chatbot = MedicalChatbot()
    
    # Test scenarios
    scenarios = [
        {
            "name": "Emergency - Chest Pain",
            "message": "I'm having severe chest pain and can't breathe properly. It's been going on for 20 minutes.",
            "expected_urgency": UrgencyLevel.EMERGENCY
        },
        {
            "name": "Urgent - High Fever",
            "message": "I have a fever of 104Â°F and have been vomiting for the past 6 hours.",
            "expected_urgency": UrgencyLevel.URGENT
        },
        {
            "name": "Routine - Cold Symptoms",
            "message": "I have a runny nose and mild cough for the past 3 days. No fever.",
            "expected_urgency": UrgencyLevel.ROUTINE
        },
        {
            "name": "Self Care - Minor Headache",
            "message": "I have a mild headache after working on the computer all day.",
            "expected_urgency": UrgencyLevel.SELF_CARE
        }
    ]
    
    print("ðŸ¥ Testing Medical Chatbot Scenarios\n")
    
    for scenario in scenarios:
        print(f"ðŸ“‹ Scenario: {scenario['name']}")
        print(f"ðŸ’¬ User: {scenario['message']}")
        
        try:
            message = ChatMessage(message=scenario['message'])
            response = await chatbot.process_message(message, "test_user_123")
            
            print(f"ðŸ¤– Bot: {response.response[:200]}...")
            print(f"ðŸš¨ Urgency: {response.urgency_level.value}")
            print(f"âš•ï¸ Seek Care: {response.should_seek_care}")
            print(f"ðŸš‘ Emergency: {response.emergency_warning}")
            
            print("ðŸ“‹ Recommendations:")
            for rec in response.recommendations[:3]:
                print(f"  â€¢ {rec}")
            
            print(f"âš ï¸ Disclaimer: {response.disclaimer[:100]}...")
            print("-" * 80)
            
        except Exception as e:
            print(f"âŒ Error: {e}")
            print("-" * 80)

async def test_knowledge_search():
    """Test medical knowledge base search."""
    
    chatbot = MedicalChatbot()
    
    queries = [
        "chest pain shortness of breath",
        "fever in children",
        "headache with neck stiffness",
        "common cold symptoms"
    ]
    
    print("\nðŸ” Testing Knowledge Base Search\n")
    
    for query in queries:
        print(f"Query: {query}")
        results = await chatbot.knowledge_base.search_medical_knowledge(query)
        
        for i, result in enumerate(results, 1):
            print(f"  {i}. {result['content'][:150]}...")
            print(f"     Category: {result['category']}, Urgency: {result['urgency']}")
        print("-" * 60)

if __name__ == "__main__":
    asyncio.run(test_medical_scenarios())
    asyncio.run(test_knowledge_search())
````

### HIPAA Compliance Module

````python
import os
import logging
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum

from cryptography.fernet import Fernet
from sqlalchemy import create_engine, Column, String, DateTime, Text, Boolean, Integer
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import redis

logger = logging.getLogger(__name__)

class AccessLevel(str, Enum):
    READ = "read"
    WRITE = "write"
    ADMIN = "admin"
    EMERGENCY = "emergency"

@dataclass
class HIPAAPolicy:
    data_retention_days: int = 2555  # 7 years for medical records
    encryption_required: bool = True
    audit_logging_required: bool = True
    access_timeout_minutes: int = 30
    max_failed_attempts: int = 3
    password_min_length: int = 12

class HIPAACompliance:
    """Comprehensive HIPAA compliance management."""
    
    def __init__(self):
        self.policy = HIPAAPolicy()
        self.encryption_key = os.getenv("HIPAA_ENCRYPTION_KEY", Fernet.generate_key())
        self.cipher = Fernet(self.encryption_key)
        
        # Database for audit logs
        self.engine = create_engine(os.getenv("AUDIT_DATABASE_URL", "sqlite:///hipaa_audit.db"))
        Base.metadata.create_all(self.engine)
        self.SessionLocal = sessionmaker(bind=self.engine)
        
        # Redis for session management
        self.redis_client = redis.Redis(
            host=os.getenv("REDIS_HOST", "localhost"),
            port=int(os.getenv("REDIS_PORT", 6379)),
            decode_responses=True
        )
    
    def encrypt_phi(self, data: str) -> str:
        """Encrypt Protected Health Information (PHI)."""
        if not data:
            return ""
        
        try:
            encrypted = self.cipher.encrypt(data.encode('utf-8'))
            self.log_access("encryption", "phi_data", success=True)
            return encrypted.decode('utf-8')
        except Exception as e:
            self.log_access("encryption", "phi_data", success=False, details=str(e))
            raise
    
    def decrypt_phi(self, encrypted_data: str) -> str:
        """Decrypt Protected Health Information (PHI)."""
        if not encrypted_data:
            return ""
        
        try:
            decrypted = self.cipher.decrypt(encrypted_data.encode('utf-8'))
            self.log_access("decryption", "phi_data", success=True)
            return decrypted.decode('utf-8')
        except Exception as e:
            self.log_access("decryption", "phi_data", success=False, details=str(e))
            raise
    
    def anonymize_identifier(self, identifier: str) -> str:
        """Create anonymized hash of user identifier."""
        return hashlib.sha256(f"{identifier}{os.getenv('SALT', 'default_salt')}".encode()).hexdigest()
    
    def log_access(
        self,
        action: str,
        resource: str,
        user_id: str = None,
        ip_address: str = None,
        success: bool = True,
        details: str = None
    ):
        """Log access for HIPAA audit trail."""
        try:
            with self.SessionLocal() as db:
                audit_entry = AuditEntry(
                    user_hash=self.anonymize_identifier(user_id) if user_id else "system",
                    action=action,
                    resource=resource,
                    ip_address=ip_address,
                    success=success,
                    details=details,
                    timestamp=datetime.utcnow()
                )
                db.add(audit_entry)
                db.commit()
        except Exception as e:
            logger.error(f"Failed to log audit entry: {e}")
    
    def validate_session(self, session_token: str, user_id: str) -> bool:
        """Validate user session for HIPAA compliance."""
        try:
            session_key = f"session:{self.anonymize_identifier(user_id)}"
            stored_token = self.redis_client.get(session_key)
            
            if stored_token == session_token:
                # Extend session if valid
                self.redis_client.expire(session_key, self.policy.access_timeout_minutes * 60)
                self.log_access("session_validation", "user_session", user_id, success=True)
                return True
            else:
                self.log_access("session_validation", "user_session", user_id, success=False)
                return False
                
        except Exception as e:
            self.log_access("session_validation", "user_session", user_id, success=False, details=str(e))
            return False
    
    def create_session(self, user_id: str, ip_address: str = None) -> str:
        """Create secure session for user."""
        try:
            session_token = os.urandom(32).hex()
            session_key = f"session:{self.anonymize_identifier(user_id)}"
            
            # Store session with timeout
            self.redis_client.setex(
                session_key,
                self.policy.access_timeout_minutes * 60,
                session_token
            )
            
            self.log_access("session_creation", "user_session", user_id, ip_address, success=True)
            return session_token
            
        except Exception as e:
            self.log_access("session_creation", "user_session", user_id, ip_address, success=False, details=str(e))
            raise
    
    def revoke_session(self, user_id: str):
        """Revoke user session."""
        try:
            session_key = f"session:{self.anonymize_identifier(user_id)}"
            self.redis_client.delete(session_key)
            self.log_access("session_revocation", "user_session", user_id, success=True)
        except Exception as e:
            self.log_access("session_revocation", "user_session", user_id, success=False, details=str(e))
    
    def check_data_retention(self):
        """Check and enforce data retention policies."""
        try:
            cutoff_date = datetime.utcnow() - timedelta(days=self.policy.data_retention_days)
            
            with self.SessionLocal() as db:
                # In production, implement automatic data purging
                old_records = db.query(AuditEntry).filter(
                    AuditEntry.timestamp < cutoff_date
                ).count()
                
                if old_records > 0:
                    logger.info(f"Found {old_records} records exceeding retention policy")
                    # Implement secure deletion here
                    
        except Exception as e:
            logger.error(f"Data retention check failed: {e}")
    
    def generate_compliance_report(self) -> Dict:
        """Generate HIPAA compliance report."""
        try:
            with self.SessionLocal() as db:
                total_accesses = db.query(AuditEntry).count()
                failed_accesses = db.query(AuditEntry).filter(AuditEntry.success == False).count()
                recent_accesses = db.query(AuditEntry).filter(
                    AuditEntry.timestamp > datetime.utcnow() - timedelta(days=30)
                ).count()
                
                return {
                    "compliance_status": "compliant",
                    "total_access_logs": total_accesses,
                    "failed_access_attempts": failed_accesses,
                    "recent_activity": recent_accesses,
                    "encryption_enabled": self.policy.encryption_required,
                    "audit_logging_enabled": self.policy.audit_logging_required,
                    "data_retention_days": self.policy.data_retention_days,
                    "report_generated": datetime.utcnow().isoformat()
                }
                
        except Exception as e:
            logger.error(f"Compliance report generation failed: {e}")
            return {"compliance_status": "error", "error": str(e)}

# Database model for audit logging
Base = declarative_base()

class AuditEntry(Base):
    __tablename__ = "hipaa_audit_log"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_hash = Column(String(64), nullable=False, index=True)
    action = Column(String(50), nullable=False)
    resource = Column(String(100), nullable=False)
    ip_address = Column(String(45))  # IPv6 compatible
    success = Column(Boolean, nullable=False)
    details = Column(Text)
    timestamp = Column(DateTime, nullable=False, index=True)

# Test HIPAA compliance
async def test_hipaa_compliance():
    """Test HIPAA compliance features."""
    hipaa = HIPAACompliance()
    
    print("ðŸ”’ Testing HIPAA Compliance Features\n")
    
    # Test encryption
    sensitive_data = "Patient has diabetes and takes insulin"
    encrypted = hipaa.encrypt_phi(sensitive_data)
    decrypted = hipaa.decrypt_phi(encrypted)
    
    print(f"Original: {sensitive_data}")
    print(f"Encrypted: {encrypted[:50]}...")
    print(f"Decrypted: {decrypted}")
    print(f"Encryption successful: {sensitive_data == decrypted}")
    
    # Test anonymization
    user_id = "john.doe@email.com"
    anonymized = hipaa.anonymize_identifier(user_id)
    print(f"\nUser ID: {user_id}")
    print(f"Anonymized: {anonymized}")
    
    # Test session management
    session_token = hipaa.create_session(user_id, "192.168.1.100")
    session_valid = hipaa.validate_session(session_token, user_id)
    print(f"\nSession created: {session_token[:20]}...")
    print(f"Session valid: {session_valid}")
    
    # Generate compliance report
    report = hipaa.generate_compliance_report()
    print(f"\nCompliance Report:")
    print(json.dumps(report, indent=2))

if __name__ == "__main__":
    asyncio.run(test_hipaa_compliance())
````

### Environment Configuration

````bash
# .env file
# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# Database Configuration
DATABASE_URL=postgresql://user:password@localhost:5432/medical_chatbot
AUDIT_DATABASE_URL=postgresql://user:password@localhost:5432/hipaa_audit

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# HIPAA Encryption
ENCRYPTION_KEY=your_fernet_encryption_key_here
HIPAA_ENCRYPTION_KEY=your_hipaa_encryption_key_here
SALT=your_random_salt_here

# Security
JWT_SECRET_KEY=your_jwt_secret_key_here
API_SECRET_KEY=your_api_secret_key_here
````

## Project Summary

The Medical Chatbot represents a breakthrough in accessible healthcare technology, combining advanced AI capabilities with stringent HIPAA compliance requirements. This comprehensive solution addresses critical healthcare challenges while maintaining the highest standards of patient privacy and data security.

### Key Value Propositions

**24/7 Healthcare Access**: Provides immediate medical guidance and health information, particularly valuable for underserved populations and during off-hours when traditional healthcare isn't readily available.

**HIPAA-Compliant Security**: Implements end-to-end encryption, comprehensive audit logging, secure session management, and data anonymization to ensure complete protection of Protected Health Information (PHI).

**Clinical Decision Support**: Uses Retrieval-Augmented Generation (RAG) to ground responses in current medical literature and guidelines, providing evidence-based health guidance rather than potentially outdated training data.

**Safety-First Design**: Prioritizes emergency detection and appropriate care level recommendations, potentially saving lives through early identification of critical conditions requiring immediate medical attention.

### Technical Innovation

The project showcases several advanced healthcare AI concepts:
- **Medical Knowledge RAG**: Combines vector embeddings with medical literature for contextually relevant responses
- **Multi-layered Security**: Implements encryption at rest and in transit, secure session management, and comprehensive audit trails
- **Emergency Detection**: Uses pattern recognition and medical knowledge bases to identify life-threatening conditions
- **Scalable Architecture**: Built with FastAPI and async operations for handling high-volume medical consultations

### Impact and Applications

Healthcare organizations implementing this solution can expect:
- **Improved Access**: 24/7 availability reduces barriers to preliminary medical guidance
- **Cost Efficiency**: Appropriate triage reduces unnecessary emergency room visits by 20-30%
- **Early Detection**: AI-powered symptom analysis can identify serious conditions requiring immediate attention
- **Healthcare Education**: Increases health literacy through evidence-based information delivery
- **Provider Support**: Assists healthcare professionals with preliminary patient assessments

### Compliance and Safety

The system maintains strict adherence to healthcare regulations:
- **HIPAA Compliance**: Full encryption, audit logging, and secure data handling
- **Medical Disclaimers**: Clear boundaries between AI guidance and professional medical care
- **Emergency Protocols**: Immediate identification and appropriate response to life-threatening situations
- **Data Retention**: Automated compliance with healthcare data retention requirements

The Medical Chatbot transforms healthcare accessibility while maintaining the highest standards of safety, privacy, and clinical accuracy, making it an essential tool for modern healthcare delivery systems focused on improving patient outcomes and reducing healthcare disparities.