<small>Claude Sonnet 4 **(PersonalizovanÃ½ SystÃ©m Å˜Ã­zenÃ­ UÄenÃ­)**</small>
# Personalized Learning Management System

## 1. NÃ¡zev Projektu

**PersonalizovanÃ½ SystÃ©m Å˜Ã­zenÃ­ UÄenÃ­ (PSÅ˜U)** - InteligentnÃ­ multi-agentnÃ­ systÃ©m pro adaptivnÃ­ vzdÄ›lÃ¡vÃ¡nÃ­ s automatizovanou kurÃ¡torovÃ¡nÃ­m obsahu, hodnocenÃ­m studentÅ¯ a sledovÃ¡nÃ­m pokroku.

## 2. VysvÄ›tlenÃ­ KlÃ­ÄovÃ½ch KonceptÅ¯

### AdaptivnÃ­ UÄenÃ­
SystÃ©m, kterÃ½ dynamicky pÅ™izpÅ¯sobuje obsah, tempo a metody vÃ½uky individuÃ¡lnÃ­m potÅ™ebÃ¡m a schopnostem kaÅ¾dÃ©ho studenta na zÃ¡kladÄ› jejich vÃ½konu a uÄebnÃ­ch vzorcÅ¯.

### KurÃ¡torovÃ¡nÃ­ Obsahu
AutomatizovanÃ½ proces vÃ½bÄ›ru, organizace a personalizace vzdÄ›lÃ¡vacÃ­ho materiÃ¡lu pomocÃ­ AI algoritmÅ¯, kterÃ½ zajiÅ¡Å¥uje relevantnost a kvalitu uÄebnÃ­ch zdrojÅ¯.

### HodnocenÃ­ StudentÅ¯
KontinuÃ¡lnÃ­ a multidimenzionÃ¡lnÃ­ evaluace znalostÃ­, dovednostÃ­ a pokroku studentÅ¯ pomocÃ­ rÅ¯znÃ½ch metrik a AI-powered analytiky.

### SledovÃ¡nÃ­ Pokroku
KomplexnÃ­ monitoring uÄebnÃ­ho procesu zahrnujÃ­cÃ­ analÃ½zu vÃ½konu, identifikaci slabÃ½ch mÃ­st a predikci budoucÃ­ch vÃ½sledkÅ¯.

### Koordinace VzdÄ›lÃ¡vacÃ­ch ZdrojÅ¯
InteligentnÃ­ sprÃ¡va a distribuce uÄebnÃ­ch materiÃ¡lÅ¯, nÃ¡strojÅ¯ a aktivit napÅ™Ã­Ä platformou pro optimÃ¡lnÃ­ uÄebnÃ­ zÃ¡Å¾itek.

## 3. KomplexnÃ­ VysvÄ›tlenÃ­ Projektu

### CÃ­le Projektu
PersonalizovanÃ½ SystÃ©m Å˜Ã­zenÃ­ UÄenÃ­ pÅ™edstavuje revoluÄnÃ­ pÅ™Ã­stup k vzdÄ›lÃ¡vÃ¡nÃ­, kterÃ½ vyuÅ¾Ã­vÃ¡ sÃ­lu multi-agentnÃ­ch systÃ©mÅ¯ a umÄ›lÃ© inteligence k vytvoÅ™enÃ­ plnÄ› adaptivnÃ­ho vzdÄ›lÃ¡vacÃ­ho prostÅ™edÃ­. HlavnÃ­mi cÃ­li jsou:

- **Individualizace uÄenÃ­**: KaÅ¾dÃ½ student obdrÅ¾Ã­ personalizovanÃ½ uÄebnÃ­ plÃ¡n
- **Optimalizace vÃ½konu**: Maximalizace uÄebnÃ­ch vÃ½sledkÅ¯ prostÅ™ednictvÃ­m dat-driven pÅ™Ã­stupÅ¯
- **Automatizace administrace**: SnÃ­Å¾enÃ­ zÃ¡tÄ›Å¾e uÄitelÅ¯ automatizacÃ­ rutinnÃ­ch ÃºkolÅ¯
- **PrediktivnÃ­ analytika**: VÄasnÃ¡ identifikace rizikovÃ½ch studentÅ¯ a preventivnÃ­ opatÅ™enÃ­

### VÃ½zvy a ProblÃ©my
- **Komplexnost personalizace**: ZpracovÃ¡nÃ­ velkÃ©ho mnoÅ¾stvÃ­ individuÃ¡lnÃ­ch profilÅ¯
- **Kvalita dat**: ZajiÅ¡tÄ›nÃ­ pÅ™esnosti a relevantnosti vzdÄ›lÃ¡vacÃ­ho obsahu
- **Å kÃ¡lovatelnost**: Podpora tisÃ­cÅ¯ souÄasnÃ½ch uÅ¾ivatelÅ¯
- **EtickÃ© aspekty**: Ochrana soukromÃ­ a spravedlivÃ© hodnocenÃ­

### PotenciÃ¡lnÃ­ Dopad
SystÃ©m mÅ¯Å¾e transformovat zpÅ¯sob, jakÃ½m se uÄÃ­me a vyuÄujeme, zvÃ½Å¡it efektivitu vzdÄ›lÃ¡vÃ¡nÃ­ a demokratizovat pÅ™Ã­stup k kvalitnÃ­mu vzdÄ›lÃ¡nÃ­.

## 4. KomplexnÃ­ PÅ™Ã­klad s Python ImplementacÃ­

````python
langchain==0.1.0
openai==1.12.0
chromadb==0.4.22
pydantic==2.5.0
fastapi==0.108.0
uvicorn==0.25.0
pandas==2.1.4
numpy==1.24.3
scikit-learn==1.3.2
matplotlib==3.8.2
````

````python
import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt

from langchain.llms import OpenAI
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.schema import Document
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class LearningStyle(Enum):
    VISUAL = "vizuÃ¡lnÃ­"
    AUDITORY = "sluchovÃ½"
    KINESTHETIC = "kinestetickÃ½"
    READING = "ÄtecÃ­"

class DifficultyLevel(Enum):
    BEGINNER = "zaÄÃ¡teÄnÃ­k"
    INTERMEDIATE = "pokroÄilÃ½"
    ADVANCED = "expert"

@dataclass
class StudentProfile:
    student_id: str
    name: str
    learning_style: LearningStyle
    current_level: DifficultyLevel
    strengths: List[str]
    weaknesses: List[str]
    interests: List[str]
    performance_history: Dict[str, float]
    learning_pace: float  # 0.1 - 2.0 (pomalÃ½ - rychlÃ½)

@dataclass
class LearningContent:
    content_id: str
    title: str
    description: str
    content_type: str  # "text", "video", "quiz", "exercise"
    difficulty: DifficultyLevel
    topic: str
    estimated_duration: int  # v minutÃ¡ch
    prerequisites: List[str]
    learning_objectives: List[str]

@dataclass
class Assessment:
    assessment_id: str
    student_id: str
    content_id: str
    score: float  # 0.0 - 1.0
    completion_time: int  # v minutÃ¡ch
    timestamp: datetime
    feedback: str

class ContentCuratorAgent:
    """Agent pro kurÃ¡torovÃ¡nÃ­ a personalizaci obsahu"""
    
    def __init__(self, llm, embeddings, vectorstore):
        self.llm = llm
        self.embeddings = embeddings
        self.vectorstore = vectorstore
        self.content_database = self._initialize_content_database()
        
    def _initialize_content_database(self) -> List[LearningContent]:
        """Inicializace ukÃ¡zkovÃ© databÃ¡ze obsahu"""
        return [
            LearningContent(
                content_id="py_basics_001",
                title="Ãšvod do Pythonu",
                description="ZÃ¡kladnÃ­ syntaxe a koncepty programovÃ¡nÃ­ v Pythonu",
                content_type="text",
                difficulty=DifficultyLevel.BEGINNER,
                topic="programovÃ¡nÃ­",
                estimated_duration=45,
                prerequisites=[],
                learning_objectives=["PorozumÄ›nÃ­ zÃ¡kladnÃ­ syntaxi", "PrÃ¡ce s promÄ›nnÃ½mi"]
            ),
            LearningContent(
                content_id="py_loops_001",
                title="Cykly v Pythonu",
                description="For a while cykly s praktickÃ½mi pÅ™Ã­klady",
                content_type="video",
                difficulty=DifficultyLevel.INTERMEDIATE,
                topic="programovÃ¡nÃ­",
                estimated_duration=60,
                prerequisites=["py_basics_001"],
                learning_objectives=["OvlÃ¡dÃ¡nÃ­ cyklÅ¯", "Optimalizace kÃ³du"]
            ),
            LearningContent(
                content_id="py_oop_001",
                title="ObjektovÄ› orientovanÃ© programovÃ¡nÃ­",
                description="TÅ™Ã­dy, objekty a dÄ›diÄnost v Pythonu",
                content_type="exercise",
                difficulty=DifficultyLevel.ADVANCED,
                topic="programovÃ¡nÃ­",
                estimated_duration=90,
                prerequisites=["py_basics_001", "py_loops_001"],
                learning_objectives=["OOP principy", "NÃ¡vrh tÅ™Ã­d"]
            )
        ]
    
    async def curate_content_for_student(self, student: StudentProfile) -> List[LearningContent]:
        """Vybere personalizovanÃ½ obsah pro studenta"""
        try:
            # FiltrovÃ¡nÃ­ podle aktuÃ¡lnÃ­ ÃºrovnÄ›
            suitable_content = [
                content for content in self.content_database
                if self._is_content_suitable(content, student)
            ]
            
            # Personalizace podle uÄebnÃ­ho stylu
            personalized_content = await self._personalize_by_learning_style(
                suitable_content, student
            )
            
            # Å˜azenÃ­ podle relevance
            ranked_content = self._rank_content_by_relevance(personalized_content, student)
            
            logger.info(f"KurÃ¡torovÃ¡no {len(ranked_content)} obsahÅ¯ pro studenta {student.name}")
            return ranked_content[:5]  # Top 5 doporuÄenÃ­
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i kurÃ¡torovÃ¡nÃ­ obsahu: {e}")
            return []
    
    def _is_content_suitable(self, content: LearningContent, student: StudentProfile) -> bool:
        """Kontroluje vhodnost obsahu pro studenta"""
        # Kontrola ÃºrovnÄ› obtÃ­Å¾nosti
        level_mapping = {
            DifficultyLevel.BEGINNER: 1,
            DifficultyLevel.INTERMEDIATE: 2,
            DifficultyLevel.ADVANCED: 3
        }
        
        student_level = level_mapping[student.current_level]
        content_level = level_mapping[content.difficulty]
        
        # Obsah mÅ¯Å¾e bÃ½t maximÃ¡lnÄ› o 1 ÃºroveÅˆ tÄ›Å¾Å¡Ã­
        return content_level <= student_level + 1
    
    async def _personalize_by_learning_style(self, content_list: List[LearningContent], 
                                           student: StudentProfile) -> List[LearningContent]:
        """Personalizuje obsah podle uÄebnÃ­ho stylu"""
        style_preferences = {
            LearningStyle.VISUAL: ["video", "infographic"],
            LearningStyle.AUDITORY: ["audio", "podcast"],
            LearningStyle.KINESTHETIC: ["exercise", "simulation"],
            LearningStyle.READING: ["text", "article"]
        }
        
        preferred_types = style_preferences.get(student.learning_style, ["text"])
        
        # UpÅ™ednostnÃ­ obsah odpovÃ­dajÃ­cÃ­ uÄebnÃ­mu stylu
        prioritized = []
        other_content = []
        
        for content in content_list:
            if content.content_type in preferred_types:
                prioritized.append(content)
            else:
                other_content.append(content)
        
        return prioritized + other_content
    
    def _rank_content_by_relevance(self, content_list: List[LearningContent], 
                                 student: StudentProfile) -> List[LearningContent]:
        """Å˜adÃ­ obsah podle relevance pro studenta"""
        scored_content = []
        
        for content in content_list:
            score = 0.0
            
            # SkÃ³re na zÃ¡kladÄ› zÃ¡jmÅ¯ studenta
            if content.topic in student.interests:
                score += 0.3
            
            # SkÃ³re na zÃ¡kladÄ› slabÃ½ch mÃ­st
            for weakness in student.weaknesses:
                if weakness.lower() in content.description.lower():
                    score += 0.4
            
            # SkÃ³re na zÃ¡kladÄ› uÄebnÃ­ho tempa
            duration_factor = min(content.estimated_duration / 60.0, 2.0)
            if student.learning_pace > 1.0:  # RychlÃ½ student
                score += 0.2 if duration_factor > 1.0 else 0.1
            else:  # PomalÃ½ student
                score += 0.2 if duration_factor < 1.0 else 0.1
            
            scored_content.append((content, score))
        
        # Å˜azenÃ­ podle skÃ³re (sestupnÄ›)
        scored_content.sort(key=lambda x: x[1], reverse=True)
        return [content for content, _ in scored_content]

class StudentAssessmentAgent:
    """Agent pro hodnocenÃ­ studentÅ¯"""
    
    def __init__(self, llm):
        self.llm = llm
        self.assessments = []
        
    async def assess_student_performance(self, student: StudentProfile, 
                                       content: LearningContent, 
                                       completion_time: int,
                                       answers: Dict[str, Any]) -> Assessment:
        """HodnotÃ­ vÃ½kon studenta"""
        try:
            # VÃ½poÄet zÃ¡kladnÃ­ho skÃ³re
            base_score = self._calculate_base_score(answers)
            
            # Ãšprava skÃ³re podle Äasu dokonÄenÃ­
            time_adjusted_score = self._adjust_score_by_time(
                base_score, completion_time, content.estimated_duration
            )
            
            # GenerovÃ¡nÃ­ AI feedback
            feedback = await self._generate_feedback(student, content, time_adjusted_score)
            
            assessment = Assessment(
                assessment_id=f"assess_{len(self.assessments) + 1}",
                student_id=student.student_id,
                content_id=content.content_id,
                score=time_adjusted_score,
                completion_time=completion_time,
                timestamp=datetime.now(),
                feedback=feedback
            )
            
            self.assessments.append(assessment)
            logger.info(f"HodnocenÃ­ dokonÄeno pro studenta {student.name}: {time_adjusted_score:.2f}")
            
            return assessment
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i hodnocenÃ­: {e}")
            raise
    
    def _calculate_base_score(self, answers: Dict[str, Any]) -> float:
        """VypoÄÃ­tÃ¡ zÃ¡kladnÃ­ skÃ³re na zÃ¡kladÄ› odpovÄ›dÃ­"""
        # Simulace hodnocenÃ­ odpovÄ›dÃ­
        correct_answers = 0
        total_questions = len(answers)
        
        for question, answer in answers.items():
            # Simulace kontroly sprÃ¡vnosti (v reÃ¡lnÃ©m systÃ©mu by bylo sloÅ¾itÄ›jÅ¡Ã­)
            if isinstance(answer, bool) and answer:
                correct_answers += 1
            elif isinstance(answer, str) and len(answer) > 10:
                correct_answers += 0.8
        
        return correct_answers / total_questions if total_questions > 0 else 0.0
    
    def _adjust_score_by_time(self, base_score: float, actual_time: int, 
                            estimated_time: int) -> float:
        """UpravÃ­ skÃ³re podle Äasu dokonÄenÃ­"""
        time_ratio = actual_time / estimated_time if estimated_time > 0 else 1.0
        
        # Bonus za rychlÃ© dokonÄenÃ­, malÃ¡ penalizace za pomalÃ©
        if time_ratio < 0.8:  # DokonÄeno rychle
            return min(base_score * 1.1, 1.0)
        elif time_ratio > 1.5:  # DokonÄeno pomalu
            return base_score * 0.95
        else:
            return base_score
    
    async def _generate_feedback(self, student: StudentProfile, 
                               content: LearningContent, score: float) -> str:
        """Generuje personalizovanÃ½ feedback pomocÃ­ LLM"""
        prompt = PromptTemplate(
            input_variables=["student_name", "content_title", "score", "learning_style"],
            template="""
            VytvoÅ™ personalizovanÃ½ feedback pro studenta {student_name}, kterÃ½ dokonÄil "{content_title}" 
            se skÃ³re {score}. Student mÃ¡ {learning_style} uÄebnÃ­ styl.
            
            Feedback by mÄ›l bÃ½t:
            - PozitivnÃ­ a motivaÄnÃ­
            - Obsahovat konkrÃ©tnÃ­ doporuÄenÃ­ pro zlepÅ¡enÃ­
            - PÅ™izpÅ¯sobenÃ½ uÄebnÃ­mu stylu studenta
            - V ÄeskÃ©m jazyce
            - MaximÃ¡lnÄ› 150 slov
            """
        )
        
        chain = LLMChain(llm=self.llm, prompt=prompt)
        
        try:
            feedback = await chain.arun(
                student_name=student.name,
                content_title=content.title,
                score=f"{score:.0%}",
                learning_style=student.learning_style.value
            )
            return feedback.strip()
        except Exception as e:
            logger.error(f"Chyba pÅ™i generovÃ¡nÃ­ feedbacku: {e}")
            return f"VÃ½bornÃ¡ prÃ¡ce! DosÃ¡hl jsi {score:.0%} ÃºspÄ›Å¡nosti."

class ProgressTrackingAgent:
    """Agent pro sledovÃ¡nÃ­ pokroku"""
    
    def __init__(self):
        self.progress_data = {}
        
    def update_student_progress(self, student: StudentProfile, assessment: Assessment):
        """Aktualizuje pokrok studenta"""
        if student.student_id not in self.progress_data:
            self.progress_data[student.student_id] = {
                'assessments': [],
                'learning_path': [],
                'skill_levels': {},
                'time_spent': 0
            }
        
        self.progress_data[student.student_id]['assessments'].append(assessment)
        self.progress_data[student.student_id]['time_spent'] += assessment.completion_time
        
        # Aktualizace ÃºrovnÃ­ dovednostÃ­
        self._update_skill_levels(student.student_id, assessment)
        
        logger.info(f"Pokrok aktualizovÃ¡n pro studenta {student.student_id}")
    
    def _update_skill_levels(self, student_id: str, assessment: Assessment):
        """Aktualizuje ÃºrovnÄ› dovednostÃ­ na zÃ¡kladÄ› hodnocenÃ­"""
        progress = self.progress_data[student_id]
        
        # Simulace extrakce dovednostÃ­ z obsahu
        skill_mapping = {
            "py_basics": "python_basics",
            "py_loops": "loops_control",
            "py_oop": "object_oriented"
        }
        
        for content_key, skill in skill_mapping.items():
            if content_key in assessment.content_id:
                current_level = progress['skill_levels'].get(skill, 0.0)
                new_level = (current_level * 0.7) + (assessment.score * 0.3)
                progress['skill_levels'][skill] = min(new_level, 1.0)
    
    def generate_progress_report(self, student_id: str) -> Dict[str, Any]:
        """Generuje report pokroku studenta"""
        if student_id not in self.progress_data:
            return {"error": "Student nenalezen"}
        
        data = self.progress_data[student_id]
        assessments = data['assessments']
        
        if not assessments:
            return {"error": "Å½Ã¡dnÃ¡ data pro analÃ½zu"}
        
        # ZÃ¡kladnÃ­ statistiky
        scores = [a.score for a in assessments]
        avg_score = np.mean(scores)
        score_trend = self._calculate_trend(scores)
        
        # AnalÃ½za Äasu
        total_time = data['time_spent']
        avg_time_per_session = np.mean([a.completion_time for a in assessments])
        
        # DoporuÄenÃ­
        recommendations = self._generate_recommendations(data, avg_score, score_trend)
        
        report = {
            'student_id': student_id,
            'total_assessments': len(assessments),
            'average_score': avg_score,
            'score_trend': score_trend,
            'total_time_spent': total_time,
            'average_session_time': avg_time_per_session,
            'skill_levels': data['skill_levels'],
            'recommendations': recommendations,
            'last_activity': max([a.timestamp for a in assessments]) if assessments else None
        }
        
        return report
    
    def _calculate_trend(self, scores: List[float]) -> str:
        """VypoÄÃ­tÃ¡ trend skÃ³re"""
        if len(scores) < 2:
            return "nedostatek_dat"
        
        # JednoduchÃ¡ lineÃ¡rnÃ­ regrese
        x = np.arange(len(scores))
        slope = np.polyfit(x, scores, 1)[0]
        
        if slope > 0.05:
            return "zlepÅ¡ujÃ­cÃ­_se"
        elif slope < -0.05:
            return "zhorÅ¡ujÃ­cÃ­_se"
        else:
            return "stabilnÃ­"
    
    def _generate_recommendations(self, data: Dict, avg_score: float, 
                                trend: str) -> List[str]:
        """Generuje doporuÄenÃ­ na zÃ¡kladÄ› pokroku"""
        recommendations = []
        
        if avg_score < 0.6:
            recommendations.append("ZamÄ›Å™ se na opakovÃ¡nÃ­ zÃ¡kladnÃ­ch konceptÅ¯")
        
        if trend == "zhorÅ¡ujÃ­cÃ­_se":
            recommendations.append("Zkus zmÄ›nit uÄebnÃ­ strategii nebo tempo")
        elif trend == "zlepÅ¡ujÃ­cÃ­_se":
            recommendations.append("VÃ½bornÃ© tempo! MÅ¯Å¾eÅ¡ zkusit pokroÄilejÅ¡Ã­ obsah")
        
        # DoporuÄenÃ­ podle dovednostÃ­
        skill_levels = data['skill_levels']
        weak_skills = [skill for skill, level in skill_levels.items() if level < 0.5]
        
        if weak_skills:
            recommendations.append(f"ProcviÄ tyto oblasti: {', '.join(weak_skills)}")
        
        return recommendations

class LearningResourceCoordinator:
    """KoordinÃ¡tor vzdÄ›lÃ¡vacÃ­ch zdrojÅ¯"""
    
    def __init__(self, content_agent: ContentCuratorAgent, 
                 assessment_agent: StudentAssessmentAgent,
                 progress_agent: ProgressTrackingAgent):
        self.content_agent = content_agent
        self.assessment_agent = assessment_agent
        self.progress_agent = progress_agent
        
    async def create_personalized_learning_path(self, student: StudentProfile) -> Dict[str, Any]:
        """VytvoÅ™Ã­ personalizovanou uÄebnÃ­ cestu"""
        try:
            # ZÃ­skÃ¡nÃ­ doporuÄenÃ©ho obsahu
            recommended_content = await self.content_agent.curate_content_for_student(student)
            
            # ZÃ­skÃ¡nÃ­ aktuÃ¡lnÃ­ho pokroku
            progress_report = self.progress_agent.generate_progress_report(student.student_id)
            
            # VytvoÅ™enÃ­ uÄebnÃ­ cesty
            learning_path = {
                'student_id': student.student_id,
                'recommended_content': [asdict(content) for content in recommended_content],
                'current_progress': progress_report,
                'estimated_completion_time': sum(c.estimated_duration for c in recommended_content),
                'adaptive_parameters': {
                    'difficulty_adjustment': self._calculate_difficulty_adjustment(student, progress_report),
                    'pace_recommendation': self._recommend_learning_pace(student, progress_report),
                    'content_type_preference': student.learning_style.value
                }
            }
            
            logger.info(f"UÄebnÃ­ cesta vytvoÅ™ena pro studenta {student.name}")
            return learning_path
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i vytvÃ¡Å™enÃ­ uÄebnÃ­ cesty: {e}")
            return {"error": str(e)}
    
    def _calculate_difficulty_adjustment(self, student: StudentProfile, 
                                       progress_report: Dict) -> str:
        """VypoÄÃ­tÃ¡ doporuÄenou Ãºpravu obtÃ­Å¾nosti"""
        if 'average_score' not in progress_report:
            return "standard"
        
        avg_score = progress_report['average_score']
        trend = progress_report.get('score_trend', 'stabilnÃ­')
        
        if avg_score > 0.8 and trend == "zlepÅ¡ujÃ­cÃ­_se":
            return "zvÃ½Å¡it_obtÃ­Å¾nost"
        elif avg_score < 0.5 or trend == "zhorÅ¡ujÃ­cÃ­_se":
            return "snÃ­Å¾it_obtÃ­Å¾nost"
        else:
            return "zachovat_obtÃ­Å¾nost"
    
    def _recommend_learning_pace(self, student: StudentProfile, 
                               progress_report: Dict) -> str:
        """DoporuÄÃ­ tempo uÄenÃ­"""
        base_pace = student.learning_pace
        
        if 'average_session_time' in progress_report:
            avg_time = progress_report['average_session_time']
            
            if avg_time > 80 and base_pace < 1.0:  # DlouhÃ© sezenÃ­, pomalÃ½ student
                return "zkrÃ¡tit_session"
            elif avg_time < 20 and base_pace > 1.5:  # KrÃ¡tkÃ© sezenÃ­, rychlÃ½ student
                return "prodlouÅ¾it_session"
        
        return "zachovat_tempo"

class PersonalizedLearningSystem:
    """HlavnÃ­ tÅ™Ã­da systÃ©mu personalizovanÃ©ho uÄenÃ­"""
    
    def __init__(self, openai_api_key: str):
        # Inicializace komponent
        self.llm = OpenAI(openai_api_key=openai_api_key, temperature=0.7)
        self.embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)
        self.vectorstore = Chroma(embedding_function=self.embeddings)
        
        # Inicializace agentÅ¯
        self.content_agent = ContentCuratorAgent(self.llm, self.embeddings, self.vectorstore)
        self.assessment_agent = StudentAssessmentAgent(self.llm)
        self.progress_agent = ProgressTrackingAgent()
        self.coordinator = LearningResourceCoordinator(
            self.content_agent, self.assessment_agent, self.progress_agent
        )
        
        # UkÃ¡zkovÃ¡ data studentÅ¯
        self.students = self._initialize_students()
        
    def _initialize_students(self) -> List[StudentProfile]:
        """Inicializace ukÃ¡zkovÃ½ch studentÅ¯"""
        return [
            StudentProfile(
                student_id="student_001",
                name="Anna NovÃ¡kovÃ¡",
                learning_style=LearningStyle.VISUAL,
                current_level=DifficultyLevel.BEGINNER,
                strengths=["logickÃ© myÅ¡lenÃ­", "matematika"],
                weaknesses=["syntaxe", "debugging"],
                interests=["programovÃ¡nÃ­", "webovÃ½ vÃ½voj"],
                performance_history={"python_basics": 0.7, "html_css": 0.8},
                learning_pace=1.2
            ),
            StudentProfile(
                student_id="student_002",
                name="Petr Svoboda",
                learning_style=LearningStyle.KINESTHETIC,
                current_level=DifficultyLevel.INTERMEDIATE,
                strengths=["praktickÃ© Ãºkoly", "problem solving"],
                weaknesses=["teorie", "dokumentace"],
                interests=["data science", "machine learning"],
                performance_history={"python_basics": 0.9, "statistics": 0.6},
                learning_pace=0.8
            )
        ]
    
    async def run_learning_session(self, student_id: str) -> Dict[str, Any]:
        """SpustÃ­ kompletnÃ­ uÄebnÃ­ sezenÃ­ pro studenta"""
        try:
            # NajdenÃ­ studenta
            student = next((s for s in self.students if s.student_id == student_id), None)
            if not student:
                return {"error": "Student nenalezen"}
            
            logger.info(f"SpouÅ¡tÃ­m uÄebnÃ­ sezenÃ­ pro {student.name}")
            
            # 1. VytvoÅ™enÃ­ personalizovanÃ© uÄebnÃ­ cesty
            learning_path = await self.coordinator.create_personalized_learning_path(student)
            
            # 2. Simulace studia (vÃ½bÄ›r prvnÃ­ho doporuÄenÃ©ho obsahu)
            if learning_path.get('recommended_content'):
                content_data = learning_path['recommended_content'][0]
                content = LearningContent(**content_data)
                
                # 3. Simulace dokonÄenÃ­ obsahu
                completion_time = int(content.estimated_duration * (0.8 + 0.4 * np.random.random()))
                simulated_answers = self._simulate_student_answers(student, content)
                
                # 4. HodnocenÃ­ vÃ½konu
                assessment = await self.assessment_agent.assess_student_performance(
                    student, content, completion_time, simulated_answers
                )
                
                # 5. Aktualizace pokroku
                self.progress_agent.update_student_progress(student, assessment)
                
                # 6. GenerovÃ¡nÃ­ vÃ½sledkÅ¯ sezenÃ­
                session_results = {
                    'student': asdict(student),
                    'completed_content': asdict(content),
                    'assessment': asdict(assessment),
                    'learning_path': learning_path,
                    'session_duration': completion_time,
                    'next_recommendations': await self._get_next_recommendations(student)
                }
                
                logger.info(f"SezenÃ­ dokonÄeno pro {student.name} se skÃ³re {assessment.score:.2f}")
                return session_results
            
            else:
                return {"error": "Å½Ã¡dnÃ½ doporuÄenÃ½ obsah nenalezen"}
                
        except Exception as e:
            logger.error(f"Chyba bÄ›hem uÄebnÃ­ho sezenÃ­: {e}")
            return {"error": str(e)}
    
    def _simulate_student_answers(self, student: StudentProfile, 
                                content: LearningContent) -> Dict[str, Any]:
        """Simuluje odpovÄ›di studenta na zÃ¡kladÄ› jeho profilu"""
        # Simulace rÅ¯znÃ½ch typÅ¯ otÃ¡zek
        base_performance = 0.7 + 0.3 * np.random.random()
        
        # Ãšprava podle silnÃ½ch/slabÃ½ch strÃ¡nek
        if any(strength in content.description.lower() for strength in student.strengths):
            base_performance += 0.1
        
        if any(weakness in content.description.lower() for weakness in student.weaknesses):
            base_performance -= 0.1
        
        base_performance = max(0.0, min(1.0, base_performance))
        
        # GenerovÃ¡nÃ­ simulovanÃ½ch odpovÄ›dÃ­
        answers = {}
        for i in range(5):  # 5 otÃ¡zek
            if np.random.random() < base_performance:
                answers[f"question_{i+1}"] = True  # SprÃ¡vnÃ¡ odpovÄ›Ä
            else:
                answers[f"question_{i+1}"] = False  # NesprÃ¡vnÃ¡ odpovÄ›Ä
        
        return answers
    
    async def _get_next_recommendations(self, student: StudentProfile) -> List[str]:
        """ZÃ­skÃ¡ doporuÄenÃ­ pro dalÅ¡Ã­ uÄenÃ­"""
        try:
            progress_report = self.progress_agent.generate_progress_report(student.student_id)
            recommendations = progress_report.get('recommendations', [])
            
            # PÅ™idÃ¡nÃ­ obecnÃ½ch doporuÄenÃ­
            if not recommendations:
                recommendations = [
                    "PokraÄuj v pravidelnÃ©m uÄenÃ­",
                    "Zkus praktickÃ© projekty",
                    "Opakuj si obtÃ­Å¾nÄ›jÅ¡Ã­ koncepty"
                ]
            
            return recommendations[:3]  # Top 3 doporuÄenÃ­
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i zÃ­skÃ¡vÃ¡nÃ­ doporuÄenÃ­: {e}")
            return ["PokraÄuj v uÄenÃ­ podle svÃ©ho tempa"]
    
    def generate_system_analytics(self) -> Dict[str, Any]:
        """Generuje analytiku celÃ©ho systÃ©mu"""
        total_students = len(self.students)
        total_assessments = len(self.assessment_agent.assessments)
        
        if total_assessments > 0:
            avg_system_score = np.mean([a.score for a in self.assessment_agent.assessments])
            completion_times = [a.completion_time for a in self.assessment_agent.assessments]
            avg_completion_time = np.mean(completion_times)
        else:
            avg_system_score = 0.0
            avg_completion_time = 0.0
        
        analytics = {
            'system_stats': {
                'total_students': total_students,
                'total_assessments': total_assessments,
                'average_score': avg_system_score,
                'average_completion_time': avg_completion_time
            },
            'student_distribution': {
                style.value: sum(1 for s in self.students if s.learning_style == style)
                for style in LearningStyle
            },
            'content_effectiveness': self._analyze_content_effectiveness(),
            'system_recommendations': self._generate_system_recommendations()
        }
        
        return analytics
    
    def _analyze_content_effectiveness(self) -> Dict[str, float]:
        """Analyzuje efektivnost jednotlivÃ½ch obsahÅ¯"""
        content_scores = {}
        
        for assessment in self.assessment_agent.assessments:
            content_id = assessment.content_id
            if content_id not in content_scores:
                content_scores[content_id] = []
            content_scores[content_id].append(assessment.score)
        
        # PrÅ¯mÄ›rnÃ© skÃ³re pro kaÅ¾dÃ½ obsah
        effectiveness = {
            content_id: np.mean(scores)
            for content_id, scores in content_scores.items()
            if scores
        }
        
        return effectiveness
    
    def _generate_system_recommendations(self) -> List[str]:
        """Generuje doporuÄenÃ­ pro zlepÅ¡enÃ­ systÃ©mu"""
        recommendations = []
        
        if len(self.assessment_agent.assessments) > 0:
            avg_score = np.mean([a.score for a in self.assessment_agent.assessments])
            
            if avg_score < 0.6:
                recommendations.append("ZvÃ¡Å¾it snÃ­Å¾enÃ­ obtÃ­Å¾nosti obsahÅ¯")
            elif avg_score > 0.9:
                recommendations.append("PÅ™idat pokroÄilejÅ¡Ã­ obsah")
            
            # AnalÃ½za ÄasÅ¯ dokonÄenÃ­
            times = [a.completion_time for a in self.assessment_agent.assessments]
            avg_time = np.mean(times)
            
            if avg_time > 90:
                recommendations.append("RozdÄ›lit dlouhÃ© obsahy na kratÅ¡Ã­ sekce")
        
        if not recommendations:
            recommendations = ["SystÃ©m funguje dobÅ™e, pokraÄujte v souÄasnÃ© strategii"]
        
        return recommendations

# HlavnÃ­ spouÅ¡tÄ›cÃ­ funkce
async def main():
    """HlavnÃ­ demonstraÄnÃ­ funkce"""
    print("ğŸ“ PersonalizovanÃ½ SystÃ©m Å˜Ã­zenÃ­ UÄenÃ­ - Demonstrace")
    print("=" * 60)
    
    # Inicializace systÃ©mu (v produkci pouÅ¾ijte skuteÄnÃ½ API klÃ­Ä)
    system = PersonalizedLearningSystem("your-openai-api-key-here")
    
    try:
        # Demonstrace uÄebnÃ­ho sezenÃ­ pro kaÅ¾dÃ©ho studenta
        for student in system.students:
            print(f"\nğŸ“š SpouÅ¡tÃ­m sezenÃ­ pro {student.name}")
            print("-" * 40)
            
            session_results = await system.run_learning_session(student.student_id)
            
            if 'error' not in session_results:
                assessment = session_results['assessment']
                print(f"âœ… DokonÄenÃ½ obsah: {session_results['completed_content']['title']}")
                print(f"ğŸ“Š SkÃ³re: {assessment['score']:.1%}")
                print(f"â±ï¸  ÄŒas: {assessment['completion_time']} minut")
                print(f"ğŸ’¬ Feedback: {assessment['feedback'][:100]}...")
                
                # ZobrazenÃ­ doporuÄenÃ­
                recommendations = session_results.get('next_recommendations', [])
                if recommendations:
                    print(f"ğŸ¯ DoporuÄenÃ­: {recommendations[0]}")
            else:
                print(f"âŒ Chyba: {session_results['error']}")
        
        # SystÃ©movÃ¡ analytika
        print(f"\nğŸ“ˆ SystÃ©movÃ¡ Analytika")
        print("-" * 40)
        analytics = system.generate_system_analytics()
        
        stats = analytics['system_stats']
        print(f"ğŸ‘¥ Celkem studentÅ¯: {stats['total_students']}")
        print(f"ğŸ“‹ Celkem hodnocenÃ­: {stats['total_assessments']}")
        print(f"ğŸ“Š PrÅ¯mÄ›rnÃ© skÃ³re: {stats['average_score']:.1%}")
        print(f"â±ï¸  PrÅ¯mÄ›rnÃ½ Äas: {stats['average_completion_time']:.0f} minut")
        
        # DoporuÄenÃ­ systÃ©mu
        sys_recommendations = analytics.get('system_recommendations', [])
        if sys_recommendations:
            print(f"ğŸ’¡ SystÃ©movÃ¡ doporuÄenÃ­: {sys_recommendations[0]}")
            
    except Exception as e:
        print(f"âŒ Chyba bÄ›hem demonstrace: {e}")
        logger.error(f"Chyba v main: {e}")

if __name__ == "__main__":
    asyncio.run(main())
````

## 5. ShrnutÃ­ Projektu

### Hodnota Projektu
PersonalizovanÃ½ SystÃ©m Å˜Ã­zenÃ­ UÄenÃ­ pÅ™edstavuje komplexnÃ­ Å™eÅ¡enÃ­ pro modernÃ­ vzdÄ›lÃ¡vÃ¡nÃ­, kterÃ©:

- **Maximalizuje efektivitu uÄenÃ­** prostÅ™ednictvÃ­m AI-driven personalizace
- **SniÅ¾uje zÃ¡tÄ›Å¾ uÄitelÅ¯** automatizacÃ­ rutinnÃ­ch ÃºkolÅ¯
- **ZlepÅ¡uje vÃ½sledky studentÅ¯** pomocÃ­ adaptivnÃ­ch metod
- **Poskytuje datovÃ© poznatky** pro kontinuÃ¡lnÃ­ zlepÅ¡ovÃ¡nÃ­

### KlÃ­ÄovÃ© Technologie
- **LangChain** pro orchestraci AI komponent
- **OpenAI GPT** pro generovÃ¡nÃ­ personalizovanÃ©ho feedbacku
- **ChromaDB** pro uklÃ¡dÃ¡nÃ­ a vyhledÃ¡vÃ¡nÃ­ obsahu
- **Scikit-learn** pro prediktivnÃ­ analytiku
- **FastAPI** pro Å¡kÃ¡lovatelnÃ© webovÃ© rozhranÃ­

### ArchitektonickÃ¡ RozhodnutÃ­
- **Multi-agentnÃ­ architektura** umoÅ¾Åˆuje modulÃ¡rnÃ­ vÃ½voj a ÃºdrÅ¾bu
- **AsynchronnÃ­ zpracovÃ¡nÃ­** zajiÅ¡Å¥uje vysokÃ½ vÃ½kon
- **VektorovÃ© vyhledÃ¡vÃ¡nÃ­** pro efektivnÃ­ kurÃ¡torovÃ¡nÃ­ obsahu
- **RobustnÃ­ error handling** pro spolehlivost systÃ©mu

### Å kÃ¡lovatelnost a ÃšdrÅ¾ba
SystÃ©m je navrÅ¾en pro snadnÃ© rozÅ¡iÅ™ovÃ¡nÃ­ o novÃ© agenty, podporu tisÃ­cÅ¯ souÄasnÃ½ch uÅ¾ivatelÅ¯ a jednoduchou integraci s existujÃ­cÃ­mi LMS platformami. ModulÃ¡rnÃ­ architektura umoÅ¾Åˆuje nezÃ¡vislÃ© aktualizace jednotlivÃ½ch komponent.

Tento systÃ©m mÃ¡ potenciÃ¡l revolutionalizovat zpÅ¯sob, jakÃ½m se uÄÃ­me a vyuÄujeme, a poskytnout zÃ¡klady pro budoucnost personalizovanÃ©ho vzdÄ›lÃ¡vÃ¡nÃ­.