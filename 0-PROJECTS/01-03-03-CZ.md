<small>Claude Sonnet 4 **(PersonalizovanÃ½ Asistent pro UÄenÃ­ s MCP)**</small>
# Personalized Learning Assistant Using MCP

## KlÃ­ÄovÃ© Koncepty

### Model Context Protocol (MCP)
MCP je protokol vyvinutÃ½ spoleÄnostÃ­ Anthropic pro standardizaci zpÅ¯sobu, jakÃ½m AI asistenti pÅ™istupujÃ­ k externÃ­m zdrojÅ¯m dat a nÃ¡strojÅ¯m. UmoÅ¾Åˆuje bezpeÄnÃ© a strukturovanÃ© propojenÃ­ mezi jazykovÃ½mi modely a rÅ¯znÃ½mi systÃ©my.

### AdaptivnÃ­ VzdÄ›lÃ¡vÃ¡nÃ­
VzdÄ›lÃ¡vacÃ­ pÅ™Ã­stup, kterÃ½ se pÅ™izpÅ¯sobuje individuÃ¡lnÃ­m potÅ™ebÃ¡m, tempu uÄenÃ­ a stylu kaÅ¾dÃ©ho studenta. VyuÅ¾Ã­vÃ¡ data o vÃ½konu studenta k optimalizaci vzdÄ›lÃ¡vacÃ­ho procesu.

### Knowledge Graphs (ZnalostnÃ­ Grafy)
StrukturovanÃ© reprezentace znalostÃ­ ve formÄ› grafÅ¯, kde uzly pÅ™edstavujÃ­ entity a hrany vztahy mezi nimi. UmoÅ¾ÅˆujÃ­ efektivnÃ­ organizaci a propojovÃ¡nÃ­ vzdÄ›lÃ¡vacÃ­ch konceptÅ¯.

### GPT-4 Integrace
VyuÅ¾itÃ­ pokroÄilÃ©ho jazykovÃ©ho modelu GPT-4 pro generovÃ¡nÃ­ personalizovanÃ©ho obsahu, vysvÄ›tlenÃ­ a interaktivnÃ­ vÃ½uku.

### Feedback Loops (ZpÄ›tnovazebnÃ­ SmyÄky)
SystÃ©my kontinuÃ¡lnÃ­ho sledovÃ¡nÃ­ a vyhodnocovÃ¡nÃ­ pokroku studenta, kterÃ© umoÅ¾ÅˆujÃ­ prÅ¯bÄ›Å¾nÃ© pÅ™izpÅ¯sobovÃ¡nÃ­ vzdÄ›lÃ¡vacÃ­ho obsahu.

## KomplexnÃ­ VysvÄ›tlenÃ­ Projektu

PersonalizovanÃ½ Asistent pro UÄenÃ­ s MCP je pokroÄilÃ½ vzdÄ›lÃ¡vacÃ­ systÃ©m, kterÃ½ kombinuje sÃ­lu umÄ›lÃ© inteligence s personalizovanÃ½m pÅ™Ã­stupem k vÃ½uce. Projekt Å™eÅ¡Ã­ zÃ¡sadnÃ­ problÃ©m souÄasnÃ©ho vzdÄ›lÃ¡vÃ¡nÃ­ - jednotnÃ½ pÅ™Ã­stup ke vÅ¡em studentÅ¯m bez ohledu na jejich individuÃ¡lnÃ­ potÅ™eby.

### CÃ­le Projektu
- **Personalizace**: VytvoÅ™enÃ­ unikÃ¡tnÃ­ vzdÄ›lÃ¡vacÃ­ cesty pro kaÅ¾dÃ©ho studenta
- **Adaptabilita**: DynamickÃ© pÅ™izpÅ¯sobovÃ¡nÃ­ obsahu na zÃ¡kladÄ› pokroku
- **Efektivita**: Optimalizace Äasu strÃ¡venÃ©ho uÄenÃ­m
- **ZapojenÃ­**: ZvÃ½Å¡enÃ­ motivace studentÅ¯ prostÅ™ednictvÃ­m interaktivnÃ­ho pÅ™Ã­stupu

### VÃ½zvy
- **Komplexnost dat**: ZpracovÃ¡nÃ­ rÅ¯znorodÃ½ch vzdÄ›lÃ¡vacÃ­ch zdrojÅ¯
- **Personalizace v reÃ¡lnÃ©m Äase**: OkamÅ¾itÃ© pÅ™izpÅ¯sobovÃ¡nÃ­ obsahu
- **Scalabilita**: Podpora tisÃ­cÅ¯ studentÅ¯ souÄasnÄ›
- **Integrace**: PropojenÃ­ s existujÃ­cÃ­mi vzdÄ›lÃ¡vacÃ­mi systÃ©my

### Dopad
SystÃ©m mÅ¯Å¾e revolucionizovat zpÅ¯sob, jakÃ½m se uÄÃ­me, poskytnutÃ­m kaÅ¾dÃ©mu studentovi osobnÃ­ho tutora dostupnÃ©ho 24/7.

## KomplexnÃ­ PÅ™Ã­klad s Python ImplementacÃ­

````python
anthropic==0.7.8
openai==1.3.0
langchain==0.1.0
chromadb==0.4.18
networkx==3.2
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
numpy==1.25.2
pandas==2.1.3
scikit-learn==1.3.2
matplotlib==3.8.2
````

````python
import json
import asyncio
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import logging

@dataclass
class MCPMessage:
    """Struktura MCP zprÃ¡vy"""
    method: str
    params: Dict[str, Any]
    id: Optional[str] = None

class MCPClient:
    """Klient pro komunikaci s MCP servery"""
    
    def __init__(self):
        self.connections = {}
        self.logger = logging.getLogger(__name__)
    
    async def connect_to_server(self, server_name: str, server_url: str) -> bool:
        """PÅ™ipojenÃ­ k MCP serveru"""
        try:
            # Simulace pÅ™ipojenÃ­ k MCP serveru
            self.connections[server_name] = {
                'url': server_url,
                'status': 'connected',
                'capabilities': ['read', 'write', 'query']
            }
            self.logger.info(f"PÅ™ipojen k MCP serveru: {server_name}")
            return True
        except Exception as e:
            self.logger.error(f"Chyba pÅ™ipojenÃ­ k {server_name}: {e}")
            return False
    
    async def send_request(self, server_name: str, message: MCPMessage) -> Dict[str, Any]:
        """OdeslÃ¡nÃ­ poÅ¾adavku na MCP server"""
        if server_name not in self.connections:
            raise ValueError(f"Server {server_name} nenÃ­ pÅ™ipojen")
        
        # Simulace MCP komunikace
        if message.method == "get_student_progress":
            return await self._get_student_progress(message.params)
        elif message.method == "update_learning_path":
            return await self._update_learning_path(message.params)
        elif message.method == "get_recommendations":
            return await self._get_recommendations(message.params)
        
        return {"status": "success", "data": {}}
    
    async def _get_student_progress(self, params: Dict) -> Dict[str, Any]:
        """ZÃ­skÃ¡nÃ­ pokroku studenta"""
        student_id = params.get('student_id')
        return {
            "status": "success",
            "data": {
                "student_id": student_id,
                "completed_topics": 15,
                "total_topics": 25,
                "average_score": 85.5,
                "learning_style": "visual",
                "difficulty_preference": "medium"
            }
        }
    
    async def _update_learning_path(self, params: Dict) -> Dict[str, Any]:
        """Aktualizace vzdÄ›lÃ¡vacÃ­ cesty"""
        return {"status": "success", "message": "VzdÄ›lÃ¡vacÃ­ cesta aktualizovÃ¡na"}
    
    async def _get_recommendations(self, params: Dict) -> Dict[str, Any]:
        """ZÃ­skÃ¡nÃ­ doporuÄenÃ­"""
        return {
            "status": "success",
            "data": {
                "recommended_topics": ["Derivace", "IntegrÃ¡ly", "Limity"],
                "difficulty_adjustment": "increase",
                "estimated_time": "45 minut"
            }
        }
````

````python
import networkx as nx
import json
from typing import Dict, List, Set, Tuple
import matplotlib.pyplot as plt

class KnowledgeGraph:
    """ZnalostnÃ­ graf pro reprezentaci vzdÄ›lÃ¡vacÃ­ch konceptÅ¯"""
    
    def __init__(self):
        self.graph = nx.DiGraph()
        self.concept_metadata = {}
    
    def add_concept(self, concept_id: str, name: str, difficulty: int, 
                   prerequisites: List[str] = None, metadata: Dict = None):
        """PÅ™idÃ¡nÃ­ konceptu do grafu"""
        self.graph.add_node(concept_id, name=name, difficulty=difficulty)
        
        self.concept_metadata[concept_id] = {
            'name': name,
            'difficulty': difficulty,
            'prerequisites': prerequisites or [],
            'metadata': metadata or {}
        }
        
        # PÅ™idÃ¡nÃ­ zÃ¡vislostÃ­
        if prerequisites:
            for prereq in prerequisites:
                if prereq in self.graph:
                    self.graph.add_edge(prereq, concept_id, relationship='prerequisite')
    
    def get_learning_path(self, target_concept: str, 
                         completed_concepts: Set[str] = None) -> List[str]:
        """ZÃ­skÃ¡nÃ­ optimÃ¡lnÃ­ vzdÄ›lÃ¡vacÃ­ cesty"""
        completed = completed_concepts or set()
        
        # TopologickÃ© seÅ™azenÃ­ pro urÄenÃ­ poÅ™adÃ­
        try:
            all_concepts = list(nx.topological_sort(self.graph))
            path = []
            
            # Najdeme cestu k cÃ­lovÃ©mu konceptu
            target_ancestors = nx.ancestors(self.graph, target_concept)
            target_ancestors.add(target_concept)
            
            for concept in all_concepts:
                if concept in target_ancestors and concept not in completed:
                    path.append(concept)
            
            return path
        except nx.NetworkXError:
            return [target_concept]
    
    def get_concept_recommendations(self, student_level: int, 
                                  completed_concepts: Set[str]) -> List[str]:
        """DoporuÄenÃ­ konceptÅ¯ na zÃ¡kladÄ› ÃºrovnÄ› studenta"""
        recommendations = []
        
        for concept_id, metadata in self.concept_metadata.items():
            if (concept_id not in completed_concepts and 
                metadata['difficulty'] <= student_level + 1):
                
                # Zkontrolovat prerequisites
                prereqs = set(metadata['prerequisites'])
                if prereqs.issubset(completed_concepts):
                    recommendations.append(concept_id)
        
        return recommendations[:5]  # Top 5 doporuÄenÃ­
    
    def visualize_graph(self, highlight_path: List[str] = None):
        """Vizualizace znalostnÃ­ho grafu"""
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(self.graph)
        
        # ZÃ¡kladnÃ­ uzly
        nx.draw_networkx_nodes(self.graph, pos, node_color='lightblue', 
                              node_size=1000)
        
        # ZvÃ½raznÄ›nÃ© uzly (cesta)
        if highlight_path:
            highlight_nodes = [node for node in highlight_path if node in self.graph]
            nx.draw_networkx_nodes(self.graph, pos, nodelist=highlight_nodes,
                                  node_color='orange', node_size=1200)
        
        # Hrany
        nx.draw_networkx_edges(self.graph, pos, edge_color='gray', arrows=True)
        
        # Popisky
        labels = {node: self.graph.nodes[node]['name'] for node in self.graph.nodes()}
        nx.draw_networkx_labels(self.graph, pos, labels, font_size=8)
        
        plt.title("ZnalostnÃ­ Graf - VzdÄ›lÃ¡vacÃ­ Koncepty")
        plt.axis('off')
        plt.tight_layout()
        plt.show()

def create_sample_knowledge_graph() -> KnowledgeGraph:
    """VytvoÅ™enÃ­ ukÃ¡zkovÃ©ho znalostnÃ­ho grafu pro matematiku"""
    kg = KnowledgeGraph()
    
    # ZÃ¡kladnÃ­ koncepty
    kg.add_concept("algebra_basic", "ZÃ¡kladnÃ­ Algebra", 1)
    kg.add_concept("equations", "Rovnice", 2, ["algebra_basic"])
    kg.add_concept("functions", "Funkce", 3, ["equations"])
    kg.add_concept("derivatives", "Derivace", 4, ["functions"])
    kg.add_concept("integrals", "IntegrÃ¡ly", 5, ["derivatives"])
    kg.add_concept("limits", "Limity", 4, ["functions"])
    kg.add_concept("differential_eq", "DiferenciÃ¡lnÃ­ rovnice", 6, ["derivatives", "integrals"])
    
    return kg
````

````python
import numpy as np
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
import json

@dataclass
class StudentProfile:
    """Profil studenta"""
    student_id: str
    learning_style: str  # visual, auditory, kinesthetic
    difficulty_preference: str  # easy, medium, hard
    completed_concepts: set
    performance_history: List[Dict]
    current_level: int
    strengths: List[str]
    weaknesses: List[str]

@dataclass
class LearningSession:
    """VzdÄ›lÃ¡vacÃ­ session"""
    concept_id: str
    duration_minutes: int
    score: float
    difficulty: int
    completion_time: float
    attempts: int

class AdaptiveLearningEngine:
    """Engine pro adaptivnÃ­ uÄenÃ­"""
    
    def __init__(self):
        self.performance_predictor = LinearRegression()
        self.scaler = StandardScaler()
        self.is_trained = False
    
    def create_student_profile(self, student_id: str, 
                             initial_assessment: Dict) -> StudentProfile:
        """VytvoÅ™enÃ­ profilu studenta"""
        return StudentProfile(
            student_id=student_id,
            learning_style=initial_assessment.get('learning_style', 'visual'),
            difficulty_preference=initial_assessment.get('difficulty', 'medium'),
            completed_concepts=set(),
            performance_history=[],
            current_level=initial_assessment.get('level', 1),
            strengths=initial_assessment.get('strengths', []),
            weaknesses=initial_assessment.get('weaknesses', [])
        )
    
    def update_student_profile(self, profile: StudentProfile, 
                             session: LearningSession) -> StudentProfile:
        """Aktualizace profilu studenta po session"""
        # PÅ™idÃ¡nÃ­ session do historie
        session_data = {
            'concept_id': session.concept_id,
            'score': session.score,
            'duration': session.duration_minutes,
            'difficulty': session.difficulty,
            'timestamp': np.datetime64('now')
        }
        profile.performance_history.append(session_data)
        
        # OznaÄenÃ­ konceptu jako dokonÄenÃ©ho (pÅ™i skÃ³re > 70%)
        if session.score >= 0.7:
            profile.completed_concepts.add(session.concept_id)
        
        # Aktualizace ÃºrovnÄ› na zÃ¡kladÄ› vÃ½konu
        recent_scores = [s['score'] for s in profile.performance_history[-5:]]
        avg_recent_score = np.mean(recent_scores)
        
        if avg_recent_score >= 0.85 and len(recent_scores) >= 3:
            profile.current_level = min(profile.current_level + 1, 10)
        elif avg_recent_score < 0.6 and len(recent_scores) >= 3:
            profile.current_level = max(profile.current_level - 1, 1)
        
        return profile
    
    def predict_performance(self, profile: StudentProfile, 
                          concept_difficulty: int) -> float:
        """Predikce vÃ½konu studenta pro danÃ½ koncept"""
        if not self.is_trained or len(profile.performance_history) < 3:
            # ZÃ¡kladnÃ­ odhad pro novÃ© studenty
            level_factor = profile.current_level / 10.0
            difficulty_factor = max(0.1, 1.0 - (concept_difficulty - profile.current_level) * 0.2)
            return min(1.0, level_factor * difficulty_factor)
        
        # PouÅ¾itÃ­ ML modelu pro pokroÄilejÅ¡Ã­ predikci
        features = self._extract_features(profile, concept_difficulty)
        features_scaled = self.scaler.transform([features])
        prediction = self.performance_predictor.predict(features_scaled)[0]
        
        return max(0.0, min(1.0, prediction))
    
    def recommend_difficulty(self, profile: StudentProfile, 
                           base_difficulty: int) -> int:
        """DoporuÄenÃ­ obtÃ­Å¾nosti pro studenta"""
        predicted_performance = self.predict_performance(profile, base_difficulty)
        
        if predicted_performance > 0.9:
            return min(base_difficulty + 1, 10)
        elif predicted_performance < 0.6:
            return max(base_difficulty - 1, 1)
        else:
            return base_difficulty
    
    def _extract_features(self, profile: StudentProfile, 
                         concept_difficulty: int) -> List[float]:
        """Extrakce features pro ML model"""
        recent_scores = [s['score'] for s in profile.performance_history[-10:]]
        
        features = [
            profile.current_level,
            concept_difficulty,
            len(profile.completed_concepts),
            np.mean(recent_scores) if recent_scores else 0.5,
            np.std(recent_scores) if len(recent_scores) > 1 else 0.0,
            1.0 if profile.learning_style == 'visual' else 0.0,
            1.0 if profile.learning_style == 'auditory' else 0.0,
            1.0 if profile.difficulty_preference == 'hard' else 0.0
        ]
        
        return features
    
    def train_performance_model(self, training_data: List[Dict]):
        """TrÃ©novÃ¡nÃ­ modelu pro predikci vÃ½konu"""
        if len(training_data) < 10:
            return
        
        features = []
        targets = []
        
        for data in training_data:
            feature_vector = [
                data['student_level'],
                data['concept_difficulty'],
                data['completed_concepts_count'],
                data['avg_recent_score'],
                data['score_variance'],
                1.0 if data['learning_style'] == 'visual' else 0.0,
                1.0 if data['learning_style'] == 'auditory' else 0.0,
                1.0 if data['difficulty_preference'] == 'hard' else 0.0
            ]
            features.append(feature_vector)
            targets.append(data['actual_score'])
        
        features_scaled = self.scaler.fit_transform(features)
        self.performance_predictor.fit(features_scaled, targets)
        self.is_trained = True
````

````python
import openai
from typing import Dict, List, Optional
import json
import asyncio
from dataclasses import dataclass

@dataclass
class LearningContent:
    """VzdÄ›lÃ¡vacÃ­ obsah"""
    concept_id: str
    title: str
    explanation: str
    examples: List[str]
    exercises: List[Dict]
    difficulty_level: int
    learning_style: str

class ContentGenerator:
    """GenerÃ¡tor personalizovanÃ©ho vzdÄ›lÃ¡vacÃ­ho obsahu"""
    
    def __init__(self, api_key: str):
        self.client = openai.OpenAI(api_key=api_key)
    
    async def generate_personalized_content(self, 
                                          concept_id: str,
                                          concept_name: str,
                                          student_profile: 'StudentProfile',
                                          difficulty_level: int) -> LearningContent:
        """GenerovÃ¡nÃ­ personalizovanÃ©ho obsahu"""
        
        # PÅ™Ã­prava kontextu pro GPT-4
        context = self._prepare_context(concept_name, student_profile, difficulty_level)
        
        # GenerovÃ¡nÃ­ vysvÄ›tlenÃ­
        explanation = await self._generate_explanation(context, concept_name)
        
        # GenerovÃ¡nÃ­ pÅ™Ã­kladÅ¯
        examples = await self._generate_examples(context, concept_name)
        
        # GenerovÃ¡nÃ­ cviÄenÃ­
        exercises = await self._generate_exercises(context, concept_name)
        
        return LearningContent(
            concept_id=concept_id,
            title=f"{concept_name} - ÃšroveÅˆ {difficulty_level}",
            explanation=explanation,
            examples=examples,
            exercises=exercises,
            difficulty_level=difficulty_level,
            learning_style=student_profile.learning_style
        )
    
    def _prepare_context(self, concept_name: str, 
                        student_profile: 'StudentProfile', 
                        difficulty_level: int) -> str:
        """PÅ™Ã­prava kontextu pro generovÃ¡nÃ­ obsahu"""
        
        learning_style_prompt = {
            'visual': 'PouÅ¾ij diagramy, grafy a vizuÃ¡lnÃ­ pomÅ¯cky.',
            'auditory': 'ZamÄ›Å™ se na slovnÃ­ vysvÄ›tlenÃ­ a analogie.',
            'kinesthetic': 'Zahrnuj praktickÃ© pÅ™Ã­klady a hands-on aktivity.'
        }
        
        context = f"""
        Koncept: {concept_name}
        ÃšroveÅˆ obtÃ­Å¾nosti: {difficulty_level}/10
        Styl uÄenÃ­ studenta: {student_profile.learning_style}
        Pokyny pro styl uÄenÃ­: {learning_style_prompt.get(student_profile.learning_style, '')}
        DokonÄenÃ© koncepty: {', '.join(list(student_profile.completed_concepts)[:5])}
        SouÄasnÃ¡ ÃºroveÅˆ studenta: {student_profile.current_level}
        
        VytvoÅ™ obsah v ÄeÅ¡tinÄ›, kterÃ½ je:
        - PÅ™izpÅ¯sobenÃ½ Ãºrovni obtÃ­Å¾nosti
        - OrientovanÃ½ na preferovanÃ½ styl uÄenÃ­
        - NavazujÃ­cÃ­ na jiÅ¾ dokonÄenÃ© koncepty
        - Prakticky zamÄ›Å™enÃ½ s reÃ¡lnÃ½mi pÅ™Ã­klady
        """
        
        return context
    
    async def _generate_explanation(self, context: str, concept_name: str) -> str:
        """GenerovÃ¡nÃ­ vysvÄ›tlenÃ­ konceptu"""
        
        prompt = f"""
        {context}
        
        VytvoÅ™ jasnÃ© a srozumitelnÃ© vysvÄ›tlenÃ­ konceptu "{concept_name}".
        VysvÄ›tlenÃ­ by mÄ›lo bÃ½t:
        - StrukturovanÃ© a logickÃ©
        - Obsahovat definici
        - VysvÄ›tlit praktickÃ© vyuÅ¾itÃ­
        - BÃ½t pÅ™izpÅ¯sobenÃ© uvedenÃ© Ãºrovni obtÃ­Å¾nosti
        
        MaximÃ¡lnÃ­ dÃ©lka: 300 slov.
        """
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=500,
                temperature=0.7
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            return f"VysvÄ›tlenÃ­ konceptu {concept_name} - ZÃ¡kladnÃ­ informace a definice."
    
    async def _generate_examples(self, context: str, concept_name: str) -> List[str]:
        """GenerovÃ¡nÃ­ pÅ™Ã­kladÅ¯"""
        
        prompt = f"""
        {context}
        
        VytvoÅ™ 3 praktickÃ© pÅ™Ã­klady pro koncept "{concept_name}".
        KaÅ¾dÃ½ pÅ™Ã­klad by mÄ›l:
        - BÃ½t reÃ¡lnÃ½ a relatable
        - Ilustrovat klÃ­ÄovÃ© principy konceptu
        - BÃ½t vhodnÃ½ pro uvedenou ÃºroveÅˆ obtÃ­Å¾nosti
        
        FormÃ¡t: Jeden pÅ™Ã­klad na Å™Ã¡dek, zaÄÃ­najÃ­cÃ­ ÄÃ­slem.
        """
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=400,
                temperature=0.7
            )
            
            examples_text = response.choices[0].message.content.strip()
            examples = [ex.strip() for ex in examples_text.split('\n') if ex.strip()]
            return examples[:3]
        except Exception as e:
            return [
                f"ZÃ¡kladnÃ­ pÅ™Ã­klad pro {concept_name}",
                f"PraktickÃ¡ aplikace {concept_name}",
                f"PokroÄilÃ½ pÅ™Ã­klad {concept_name}"
            ]
    
    async def _generate_exercises(self, context: str, concept_name: str) -> List[Dict]:
        """GenerovÃ¡nÃ­ cviÄenÃ­"""
        
        prompt = f"""
        {context}
        
        VytvoÅ™ 3 cviÄenÃ­ pro koncept "{concept_name}".
        Pro kaÅ¾dÃ© cviÄenÃ­ poskytni:
        - OtÃ¡zku/zadÃ¡nÃ­
        - SprÃ¡vnou odpovÄ›Ä
        - KrÃ¡tkÃ© vysvÄ›tlenÃ­ Å™eÅ¡enÃ­
        
        FormÃ¡t JSON:
        [
            {{
                "question": "text otÃ¡zky",
                "answer": "sprÃ¡vnÃ¡ odpovÄ›Ä",
                "explanation": "vysvÄ›tlenÃ­ Å™eÅ¡enÃ­"
            }}
        ]
        """
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=600,
                temperature=0.7
            )
            
            # Pokus o parsovÃ¡nÃ­ JSON
            content = response.choices[0].message.content.strip()
            
            # OdstranÄ›nÃ­ markdown formÃ¡tovÃ¡nÃ­ pokud existuje
            if content.startswith('```json'):
                content = content[7:-3]
            elif content.startswith('```'):
                content = content[3:-3]
            
            exercises = json.loads(content)
            return exercises[:3]
            
        except Exception as e:
            # Fallback cviÄenÃ­
            return [
                {
                    "question": f"ZÃ¡kladnÃ­ otÃ¡zka o konceptu {concept_name}",
                    "answer": "OdpovÄ›Ä bude generovÃ¡na",
                    "explanation": "VysvÄ›tlenÃ­ bude doplnÄ›no"
                }
            ]

def create_sample_content() -> LearningContent:
    """VytvoÅ™enÃ­ ukÃ¡zkovÃ©ho obsahu"""
    return LearningContent(
        concept_id="derivatives",
        title="Derivace - ÃšroveÅˆ 4",
        explanation="""
        Derivace je zÃ¡kladnÃ­ pojem diferenciÃ¡lnÃ­ho poÄtu, kterÃ½ mÄ›Å™Ã­ rychlost zmÄ›ny funkce.
        Geometricky pÅ™edstavuje derivace sklon teÄny ke grafu funkce v danÃ©m bodÄ›.
        
        PraktickÃ© vyuÅ¾itÃ­ derivacÃ­:
        - VÃ½poÄet rychlosti a zrychlenÃ­ ve fyzice
        - Optimalizace v ekonomii a inÅ¾enÃ½rstvÃ­
        - AnalÃ½za trendÅ¯ v datech
        """,
        examples=[
            "Rychlost automobilu jako derivace polohy podle Äasu",
            "Optimalizace zisku firmy pomocÃ­ derivace nÃ¡kladovÃ© funkce",
            "RÅ¯st populace modelovanÃ½ exponenciÃ¡lnÃ­ funkcÃ­ a jejÃ­ derivacÃ­"
        ],
        exercises=[
            {
                "question": "VypoÄÃ­tejte derivaci funkce f(x) = 3xÂ² + 2x - 1",
                "answer": "f'(x) = 6x + 2",
                "explanation": "PouÅ¾ijeme pravidlo mocniny: derivace xâ¿ je nâ‹…xâ¿â»Â¹"
            }
        ],
        difficulty_level=4,
        learning_style="visual"
    )
````

````python
import asyncio
import logging
from typing import Dict, List
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn

from mcp_client import MCPClient, MCPMessage
from knowledge_graph import KnowledgeGraph, create_sample_knowledge_graph
from adaptive_learning_engine import AdaptiveLearningEngine, StudentProfile, LearningSession
from content_generator import ContentGenerator, create_sample_content

# Konfigurace logovÃ¡nÃ­
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# FastAPI aplikace
app = FastAPI(title="PersonalizovanÃ½ Asistent pro UÄenÃ­", version="1.0.0")

# Pydantic modely pro API
class StudentAssessment(BaseModel):
    learning_style: str
    difficulty: str
    level: int
    strengths: List[str]
    weaknesses: List[str]

class SessionData(BaseModel):
    concept_id: str
    duration_minutes: int
    score: float
    difficulty: int
    completion_time: float
    attempts: int

class LearningSystem:
    """HlavnÃ­ tÅ™Ã­da vzdÄ›lÃ¡vacÃ­ho systÃ©mu"""
    
    def __init__(self):
        self.mcp_client = MCPClient()
        self.knowledge_graph = create_sample_knowledge_graph()
        self.adaptive_engine = AdaptiveLearningEngine()
        self.content_generator = None  # Bude inicializovÃ¡n s API klÃ­Äem
        self.student_profiles: Dict[str, StudentProfile] = {}
        
    async def initialize(self):
        """Inicializace systÃ©mu"""
        # PÅ™ipojenÃ­ k MCP serverÅ¯m
        await self.mcp_client.connect_to_server("student_data", "http://localhost:8001")
        await self.mcp_client.connect_to_server("content_repository", "http://localhost:8002")
        
        # NaÄtenÃ­ existujÃ­cÃ­ch profilÅ¯ studentÅ¯
        await self._load_student_profiles()
        
        logger.info("VzdÄ›lÃ¡vacÃ­ systÃ©m inicializovÃ¡n")
    
    async def create_student(self, student_id: str, assessment: StudentAssessment) -> StudentProfile:
        """VytvoÅ™enÃ­ novÃ©ho studenta"""
        profile = self.adaptive_engine.create_student_profile(
            student_id, assessment.dict()
        )
        
        self.student_profiles[student_id] = profile
        
        # UloÅ¾enÃ­ profilu pÅ™es MCP
        message = MCPMessage(
            method="save_student_profile",
            params={"student_id": student_id, "profile": profile.__dict__}
        )
        await self.mcp_client.send_request("student_data", message)
        
        logger.info(f"VytvoÅ™en novÃ½ student: {student_id}")
        return profile
    
    async def get_personalized_learning_path(self, student_id: str, 
                                           target_concept: str) -> List[str]:
        """ZÃ­skÃ¡nÃ­ personalizovanÃ© vzdÄ›lÃ¡vacÃ­ cesty"""
        if student_id not in self.student_profiles:
            raise ValueError(f"Student {student_id} neexistuje")
        
        profile = self.student_profiles[student_id]
        
        # ZÃ­skÃ¡nÃ­ optimÃ¡lnÃ­ cesty z knowledge graph
        learning_path = self.knowledge_graph.get_learning_path(
            target_concept, profile.completed_concepts
        )
        
        # Personalizace cesty na zÃ¡kladÄ› profilu studenta
        personalized_path = []
        for concept in learning_path:
            # ZjiÅ¡tÄ›nÃ­ doporuÄenÃ© obtÃ­Å¾nosti
            base_difficulty = self.knowledge_graph.concept_metadata[concept]['difficulty']
            recommended_difficulty = self.adaptive_engine.recommend_difficulty(
                profile, base_difficulty
            )
            
            personalized_path.append({
                'concept_id': concept,
                'concept_name': self.knowledge_graph.concept_metadata[concept]['name'],
                'recommended_difficulty': recommended_difficulty,
                'estimated_performance': self.adaptive_engine.predict_performance(
                    profile, recommended_difficulty
                )
            })
        
        return personalized_path
    
    async def generate_learning_content(self, student_id: str, 
                                      concept_id: str) -> Dict:
        """GenerovÃ¡nÃ­ personalizovanÃ©ho obsahu"""
        if student_id not in self.student_profiles:
            raise ValueError(f"Student {student_id} neexistuje")
        
        profile = self.student_profiles[student_id]
        concept_metadata = self.knowledge_graph.concept_metadata[concept_id]
        
        # Pro demo ÃºÄely vrÃ¡tÃ­me ukÃ¡zkovÃ½ obsah
        # V reÃ¡lnÃ© implementaci by se pouÅ¾il ContentGenerator s OpenAI API
        content = create_sample_content()
        content.concept_id = concept_id
        content.title = f"{concept_metadata['name']} - ÃšroveÅˆ {concept_metadata['difficulty']}"
        content.learning_style = profile.learning_style
        
        return {
            "concept_id": content.concept_id,
            "title": content.title,
            "explanation": content.explanation,
            "examples": content.examples,
            "exercises": content.exercises,
            "difficulty_level": content.difficulty_level,
            "learning_style": content.learning_style
        }
    
    async def record_learning_session(self, student_id: str, 
                                    session_data: SessionData) -> Dict:
        """ZaznamenÃ¡nÃ­ vzdÄ›lÃ¡vacÃ­ session"""
        if student_id not in self.student_profiles:
            raise ValueError(f"Student {student_id} neexistuje")
        
        profile = self.student_profiles[student_id]
        
        # VytvoÅ™enÃ­ session objektu
        session = LearningSession(**session_data.dict())
        
        # Aktualizace profilu studenta
        updated_profile = self.adaptive_engine.update_student_profile(profile, session)
        self.student_profiles[student_id] = updated_profile
        
        # UloÅ¾enÃ­ pÅ™es MCP
        message = MCPMessage(
            method="save_learning_session",
            params={
                "student_id": student_id,
                "session": session.__dict__,
                "updated_profile": updated_profile.__dict__
            }
        )
        await self.mcp_client.send_request("student_data", message)
        
        # ZÃ­skÃ¡nÃ­ doporuÄenÃ­ pro dalÅ¡Ã­ uÄenÃ­
        recommendations = self.knowledge_graph.get_concept_recommendations(
            updated_profile.current_level, updated_profile.completed_concepts
        )
        
        return {
            "session_recorded": True,
            "updated_level": updated_profile.current_level,
            "progress": len(updated_profile.completed_concepts),
            "recommendations": recommendations[:3]
        }
    
    async def get_student_analytics(self, student_id: str) -> Dict:
        """ZÃ­skÃ¡nÃ­ analytiky studenta"""
        if student_id not in self.student_profiles:
            raise ValueError(f"Student {student_id} neexistuje")
        
        profile = self.student_profiles[student_id]
        
        # VÃ½poÄet statistik
        recent_sessions = profile.performance_history[-10:]
        avg_score = sum(s['score'] for s in recent_sessions) / len(recent_sessions) if recent_sessions else 0
        
        total_concepts = len(self.knowledge_graph.concept_metadata)
        completion_rate = len(profile.completed_concepts) / total_concepts * 100
        
        return {
            "student_id": student_id,
            "current_level": profile.current_level,
            "completed_concepts": len(profile.completed_concepts),
            "total_concepts": total_concepts,
            "completion_rate": round(completion_rate, 2),
            "average_score": round(avg_score, 2),
            "learning_style": profile.learning_style,
            "total_sessions": len(profile.performance_history),
            "strengths": profile.strengths,
            "weaknesses": profile.weaknesses
        }
    
    async def _load_student_profiles(self):
        """NaÄtenÃ­ existujÃ­cÃ­ch profilÅ¯ studentÅ¯"""
        # Simulace naÄtenÃ­ z MCP serveru
        message = MCPMessage(method="get_all_student_profiles", params={})
        try:
            response = await self.mcp_client.send_request("student_data", message)
            # V reÃ¡lnÃ© implementaci by se zde naÄetly skuteÄnÃ© profily
            logger.info("Profily studentÅ¯ naÄteny")
        except Exception as e:
            logger.warning(f"NepodaÅ™ilo se naÄÃ­st profily studentÅ¯: {e}")

# GlobÃ¡lnÃ­ instance systÃ©mu
learning_system = LearningSystem()

# API Endpoints
@app.on_event("startup")
async def startup_event():
    """Inicializace pÅ™i startu aplikace"""
    await learning_system.initialize()

@app.post("/students/{student_id}/create")
async def create_student(student_id: str, assessment: StudentAssessment):
    """VytvoÅ™enÃ­ novÃ©ho studenta"""
    try:
        profile = await learning_system.create_student(student_id, assessment)
        return {"message": "Student vytvoÅ™en", "student_id": student_id}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/students/{student_id}/learning-path/{target_concept}")
async def get_learning_path(student_id: str, target_concept: str):
    """ZÃ­skÃ¡nÃ­ vzdÄ›lÃ¡vacÃ­ cesty"""
    try:
        path = await learning_system.get_personalized_learning_path(student_id, target_concept)
        return {"learning_path": path}
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

@app.get("/students/{student_id}/content/{concept_id}")
async def get_content(student_id: str, concept_id: str):
    """ZÃ­skÃ¡nÃ­ personalizovanÃ©ho obsahu"""
    try:
        content = await learning_system.generate_learning_content(student_id, concept_id)
        return content
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

@app.post("/students/{student_id}/sessions")
async def record_session(student_id: str, session: SessionData):
    """ZaznamenÃ¡nÃ­ vzdÄ›lÃ¡vacÃ­ session"""
    try:
        result = await learning_system.record_learning_session(student_id, session)
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/students/{student_id}/analytics")
async def get_analytics(student_id: str):
    """ZÃ­skÃ¡nÃ­ analytiky studenta"""
    try:
        analytics = await learning_system.get_student_analytics(student_id)
        return analytics
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

@app.get("/concepts")
async def get_all_concepts():
    """ZÃ­skÃ¡nÃ­ vÅ¡ech dostupnÃ½ch konceptÅ¯"""
    concepts = []
    for concept_id, metadata in learning_system.knowledge_graph.concept_metadata.items():
        concepts.append({
            "concept_id": concept_id,
            "name": metadata['name'],
            "difficulty": metadata['difficulty'],
            "prerequisites": metadata['prerequisites']
        })
    return {"concepts": concepts}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````python
import asyncio
import json
from src.main_application import LearningSystem, StudentAssessment, SessionData

async def demo_learning_system():
    """Demonstrace funkcÃ­ vzdÄ›lÃ¡vacÃ­ho systÃ©mu"""
    
    # Inicializace systÃ©mu
    system = LearningSystem()
    await system.initialize()
    
    # VytvoÅ™enÃ­ studenta
    assessment = StudentAssessment(
        learning_style="visual",
        difficulty="medium",
        level=3,
        strengths=["algebra", "geometry"],
        weaknesses=["calculus"]
    )
    
    student_id = "student_001"
    await system.create_student(student_id, assessment)
    print(f"âœ… Student {student_id} vytvoÅ™en")
    
    # ZÃ­skÃ¡nÃ­ vzdÄ›lÃ¡vacÃ­ cesty
    target_concept = "integrals"
    learning_path = await system.get_personalized_learning_path(student_id, target_concept)
    print(f"\nğŸ“š VzdÄ›lÃ¡vacÃ­ cesta pro {target_concept}:")
    for i, step in enumerate(learning_path, 1):
        print(f"  {i}. {step['concept_name']} (obtÃ­Å¾nost: {step['recommended_difficulty']})")
    
    # GenerovÃ¡nÃ­ obsahu pro prvnÃ­ koncept
    if learning_path:
        first_concept = learning_path[0]['concept_id']
        content = await system.generate_learning_content(student_id, first_concept)
        print(f"\nğŸ“– Obsah pro {content['title']}:")
        print(f"VysvÄ›tlenÃ­: {content['explanation'][:150]}...")
        print(f"PoÄet pÅ™Ã­kladÅ¯: {len(content['examples'])}")
        print(f"PoÄet cviÄenÃ­: {len(content['exercises'])}")
    
    # Simulace vzdÄ›lÃ¡vacÃ­ session
    session_data = SessionData(
        concept_id=first_concept,
        duration_minutes=25,
        score=0.85,
        difficulty=3,
        completion_time=22.5,
        attempts=2
    )
    
    session_result = await system.record_learning_session(student_id, session_data)
    print(f"\nğŸ“Š Session zaznamenÃ¡na:")
    print(f"  NovÃ¡ ÃºroveÅˆ: {session_result['updated_level']}")
    print(f"  Pokrok: {session_result['progress']} dokonÄenÃ½ch konceptÅ¯")
    print(f"  DoporuÄenÃ­: {session_result['recommendations']}")
    
    # ZÃ­skÃ¡nÃ­ analytiky
    analytics = await system.get_student_analytics(student_id)
    print(f"\nğŸ“ˆ Analytika studenta:")
    print(f"  ÃšroveÅˆ: {analytics['current_level']}")
    print(f"  DokonÄeno: {analytics['completion_rate']}%")
    print(f"  PrÅ¯mÄ›rnÃ© skÃ³re: {analytics['average_score']}")
    print(f"  Celkem sessions: {analytics['total_sessions']}")

if __name__ == "__main__":
    asyncio.run(demo_learning_system())
````

## ShrnutÃ­ Projektu

PersonalizovanÃ½ Asistent pro UÄenÃ­ s MCP pÅ™edstavuje revoluÄnÃ­ pÅ™Ã­stup k vzdÄ›lÃ¡vÃ¡nÃ­, kterÃ½ kombinuje nejnovÄ›jÅ¡Ã­ technologie umÄ›lÃ© inteligence s individualizovanÃ½m pÅ™Ã­stupem k uÄenÃ­.

### KlÃ­ÄovÃ© VÃ½hody

**Personalizace**: SystÃ©m se pÅ™izpÅ¯sobuje kaÅ¾dÃ©mu studentovi na zÃ¡kladÄ› jeho stylu uÄenÃ­, ÃºrovnÄ› znalostÃ­ a vÃ½konu.

**Adaptabilita**: KontinuÃ¡lnÃ­ uÄenÃ­ ze zpÄ›tnÃ© vazby umoÅ¾Åˆuje dynamickÃ© pÅ™izpÅ¯sobovÃ¡nÃ­ obsahu a obtÃ­Å¾nosti.

**Scalabilita**: Architektura zaloÅ¾enÃ¡ na MCP a mikrosluÅ¾bÃ¡ch umoÅ¾Åˆuje podporu tisÃ­cÅ¯ studentÅ¯ souÄasnÄ›.

**Integrace**: StandardizovanÃ© MCP rozhranÃ­ facilituje snadnou integraci s existujÃ­cÃ­mi vzdÄ›lÃ¡vacÃ­mi systÃ©my.

### TechnologickÃ¡ Inovace

Projekt vyuÅ¾Ã­vÃ¡ cutting-edge technologie vÄetnÄ› GPT-4 pro generovÃ¡nÃ­ obsahu, znalostnÃ­ch grafÅ¯ pro strukturovanou reprezentaci konceptÅ¯, machine learning pro predikci vÃ½konu a MCP protokol pro bezpeÄnou komunikaci mezi komponenty.

### BudoucÃ­ PotenciÃ¡l

SystÃ©m mÅ¯Å¾e bÃ½t rozÅ¡Ã­Å™en o pokroÄilÃ© funkce jako rozpoznÃ¡vÃ¡nÃ­ emocÃ­, podporu virtuÃ¡lnÃ­ reality pro immersivnÃ­ uÄenÃ­, nebo integraci s IoT zaÅ™Ã­zenÃ­mi pro contextual learning. MoÅ¾nosti jsou prakticky neomezenÃ©, coÅ¾ ÄinÃ­ z tohoto projektu ideÃ¡lnÃ­ zÃ¡klad pro budoucÃ­ vzdÄ›lÃ¡vacÃ­ platformy.