<small>Claude Sonnet 4 **(AI-LLM Multi-Agent Syst√©m pro Anal√Ωzu Realitn√≠ho Trhu a Doporuƒçovac√≠ Engine)**</small>
# Real Estate Market Analysis and Recommendation Engine

## 1. N√°zev Projektu

**Inteligentn√≠ Multi-Agent Syst√©m pro Komplexn√≠ Anal√Ωzu Realitn√≠ho Trhu**

## 2. Vysvƒõtlen√≠ Kl√≠ƒçov√Ωch Koncept≈Ø

### Property Valuation (Ocenƒõn√≠ Nemovitost√≠)
Automatizovan√© hodnocen√≠ tr≈æn√≠ hodnoty nemovitost√≠ na z√°kladƒõ lokace, velikosti, stavu, tr≈æn√≠ch trend≈Ø a srovnateln√Ωch prodej≈Ø. Vyu≈æ√≠v√° regresn√≠ modely a data z realitn√≠ho trhu.

### Market Trend Analysis (Anal√Ωza Tr≈æn√≠ch Trend≈Ø)
Sledov√°n√≠ a predikce v√Ωvoje cen nemovitost√≠ v ƒçase. Zahrnuje anal√Ωzu historick√Ωch dat, ekonomick√Ωch indik√°tor≈Ø a extern√≠ch faktor≈Ø ovliv≈àuj√≠c√≠ch trh.

### Investment Advisory (Investiƒçn√≠ Poradenstv√≠)
Poskytov√°n√≠ personalizovan√Ωch doporuƒçen√≠ pro investice do nemovitost√≠ na z√°kladƒõ rizikov√©ho profilu klienta, rozpoƒçtu a investiƒçn√≠ch c√≠l≈Ø.

### Neighborhood Assessment (Hodnocen√≠ Lokalit)
Komplexn√≠ anal√Ωza kvality a atraktivity konkr√©tn√≠ch ƒçtvrt√≠ vƒçetnƒõ infrastruktury, bezpeƒçnosti, dostupnosti slu≈æeb a budouc√≠ho potenci√°lu.

### Client Matching (P√°rov√°n√≠ Klient≈Ø)
Inteligentn√≠ spojov√°n√≠ kupuj√≠c√≠ch s vhodn√Ωmi nemovitostmi nebo prod√°vaj√≠c√≠ch s potenci√°ln√≠mi kupci na z√°kladƒõ preferenc√≠ a po≈æadavk≈Ø.

## 3. Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Vytvo≈ôen√≠ sofistikovan√©ho AI syst√©mu, kter√Ω revolucionizuje realitn√≠ trh prost≈ôednictv√≠m:
- Automatick√©ho oce≈àov√°n√≠ nemovitost√≠ s vysokou p≈ôesnost√≠
- Prediktivn√≠ anal√Ωzy tr≈æn√≠ch trend≈Ø
- Personalizovan√©ho investiƒçn√≠ho poradenstv√≠
- Inteligentn√≠ho p√°rov√°n√≠ klient≈Ø s nemovitostmi

### V√Ωzvy
- **Komplexita dat**: Integrace heterogenn√≠ch datov√Ωch zdroj≈Ø (ceny, lokace, demografie)
- **Tr≈æn√≠ volatilita**: Zachycen√≠ rychl√Ωch zmƒõn na realitn√≠m trhu
- **Region√°ln√≠ specifika**: P≈ôizp≈Øsoben√≠ m√≠stn√≠m tr≈æn√≠m podm√≠nk√°m
- **P≈ôesnost ocenƒõn√≠**: Minimalizace chyb v hodnocen√≠ nemovitost√≠

### Potenci√°ln√≠ Dopad
- Demokratizace p≈ô√≠stupu k profesion√°ln√≠m realitn√≠m anal√Ωz√°m
- Zv√Ω≈°en√≠ transparentnosti realitn√≠ho trhu
- Optimalizace investiƒçn√≠ch rozhodnut√≠
- Sn√≠≈æen√≠ transakƒçn√≠ch n√°klad≈Ø a ƒçasu

## 4. Komplexn√≠ Implementace v Pythonu

### Instalace Z√°vislost√≠

````bash
pip install langchain openai pandas numpy scikit-learn plotly streamlit chromadb python-dotenv requests beautifulsoup4 folium geopy
````

### Hlavn√≠ Implementace

````python
import os
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import json

from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain.tools import Tool
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.memory import ConversationBufferMemory
from langchain.schema import HumanMessage, SystemMessage

from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, r2_score

import chromadb
from chromadb.config import Settings
import plotly.graph_objects as go
import plotly.express as px

@dataclass
class Property:
    """Datov√° struktura pro nemovitost"""
    id: str
    address: str
    price: float
    size: int  # m¬≤
    rooms: int
    year_built: int
    property_type: str
    neighborhood: str
    lat: float
    lon: float
    features: List[str]

@dataclass
class Client:
    """Datov√° struktura pro klienta"""
    id: str
    name: str
    budget_min: float
    budget_max: float
    preferred_areas: List[str]
    property_type: str
    min_rooms: int
    investment_type: str  # "buy_to_live", "investment", "flip"
    risk_tolerance: str  # "low", "medium", "high"

class PropertyDataGenerator:
    """Gener√°tor testovac√≠ch dat pro nemovitosti"""
    
    def __init__(self):
        self.neighborhoods = [
            "Vinohrady", "Karl√≠n", "Sm√≠chov", "Vr≈°ovice", "Nov√© Mƒõsto",
            "Hole≈°ovice", "Dejvice", "B≈ôevnov", "Andƒõl", "Wenceslas Square"
        ]
        
        self.property_types = ["apartment", "house", "studio", "penthouse"]
        
    def generate_properties(self, count: int = 1000) -> List[Property]:
        """Generuje testovac√≠ data nemovitost√≠"""
        properties = []
        
        for i in range(count):
            neighborhood = np.random.choice(self.neighborhoods)
            property_type = np.random.choice(self.property_types)
            
            # Simulace cen podle lokality a typu
            base_price = self._get_base_price(neighborhood, property_type)
            size = np.random.randint(30, 200)
            rooms = max(1, size // 25)
            year_built = np.random.randint(1950, 2024)
            
            # Cenov√° kalkulace
            price = base_price * size * self._get_year_multiplier(year_built)
            price += np.random.normal(0, price * 0.1)  # Variabilita
            
            property_obj = Property(
                id=f"prop_{i:05d}",
                address=f"{neighborhood} {i+1}",
                price=max(price, 1000000),  # Min 1M CZK
                size=size,
                rooms=rooms,
                year_built=year_built,
                property_type=property_type,
                neighborhood=neighborhood,
                lat=50.0755 + np.random.normal(0, 0.05),
                lon=14.4378 + np.random.normal(0, 0.05),
                features=self._generate_features()
            )
            properties.append(property_obj)
            
        return properties
    
    def _get_base_price(self, neighborhood: str, property_type: str) -> float:
        """Z√°kladn√≠ cena podle lokality a typu"""
        neighborhood_multipliers = {
            "Vinohrady": 120000, "Karl√≠n": 110000, "Sm√≠chov": 95000,
            "Vr≈°ovice": 85000, "Nov√© Mƒõsto": 115000, "Hole≈°ovice": 90000,
            "Dejvice": 105000, "B≈ôevnov": 80000, "Andƒõl": 100000,
            "Wenceslas Square": 130000
        }
        
        type_multipliers = {
            "apartment": 1.0, "house": 1.2, "studio": 0.8, "penthouse": 1.5
        }
        
        return neighborhood_multipliers.get(neighborhood, 90000) * type_multipliers.get(property_type, 1.0)
    
    def _get_year_multiplier(self, year: int) -> float:
        """Multiplik√°tor podle roku v√Ωstavby"""
        if year >= 2010:
            return 1.2
        elif year >= 2000:
            return 1.1
        elif year >= 1990:
            return 1.0
        else:
            return 0.9
    
    def _generate_features(self) -> List[str]:
        """Generuje n√°hodn√© vlastnosti nemovitosti"""
        all_features = [
            "parking", "balcony", "terrace", "garden", "elevator",
            "air_conditioning", "fireplace", "swimming_pool", "gym",
            "security", "storage", "furnished"
        ]
        return np.random.choice(all_features, size=np.random.randint(1, 6), replace=False).tolist()

class PropertyValuationAgent:
    """Agent pro oce≈àov√°n√≠ nemovitost√≠"""
    
    def __init__(self, llm: ChatOpenAI, properties: List[Property]):
        self.llm = llm
        self.properties = properties
        self.scaler = StandardScaler()
        self.model = None
        self._train_model()
        
    def _train_model(self):
        """Tr√©nov√°n√≠ modelu pro oce≈àov√°n√≠"""
        if not self.properties:
            return
            
        # P≈ô√≠prava dat
        features = []
        prices = []
        
        for prop in self.properties:
            feature_vector = [
                prop.size,
                prop.rooms,
                2024 - prop.year_built,  # vƒõk
                len(prop.features),
                hash(prop.neighborhood) % 1000,  # k√≥dov√°n√≠ lokality
                hash(prop.property_type) % 100   # k√≥dov√°n√≠ typu
            ]
            features.append(feature_vector)
            prices.append(prop.price)
        
        X = np.array(features)
        y = np.array(prices)
        
        # Normalizace a tr√©nov√°n√≠
        X_scaled = self.scaler.fit_transform(X)
        X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)
        
        self.model = GradientBoostingRegressor(n_estimators=100, random_state=42)
        self.model.fit(X_train, y_train)
        
        # Evaluace
        y_pred = self.model.predict(X_test)
        mae = mean_absolute_error(y_test, y_pred)
        r2 = r2_score(y_test, y_pred)
        
        print(f"Model tr√©nov√°n - MAE: {mae:,.0f} CZK, R¬≤: {r2:.3f}")
    
    def valuate_property(self, property_details: Dict) -> Dict:
        """Oce≈àuje nemovitost"""
        try:
            if not self.model:
                return {"error": "Model nen√≠ natr√©nov√°n"}
            
            # P≈ô√≠prava features
            feature_vector = np.array([[
                property_details.get('size', 70),
                property_details.get('rooms', 2),
                2024 - property_details.get('year_built', 2000),
                len(property_details.get('features', [])),
                hash(property_details.get('neighborhood', 'Unknown')) % 1000,
                hash(property_details.get('property_type', 'apartment')) % 100
            ]])
            
            feature_vector_scaled = self.scaler.transform(feature_vector)
            predicted_price = self.model.predict(feature_vector_scaled)[0]
            
            # Z√≠sk√°n√≠ dodateƒçn√© anal√Ωzy od LLM
            prompt = f"""
            Analyzuj oce≈àov√°n√≠ nemovitosti s n√°sleduj√≠c√≠mi parametry:
            - Velikost: {property_details.get('size')} m¬≤
            - Pokoje: {property_details.get('rooms')}
            - Rok v√Ωstavby: {property_details.get('year_built')}
            - Lokalita: {property_details.get('neighborhood')}
            - Typ: {property_details.get('property_type')}
            - Vlastnosti: {property_details.get('features', [])}
            
            Predikovan√° cena: {predicted_price:,.0f} CZK
            
            Poskytni anal√Ωzu faktor≈Ø ovliv≈àuj√≠c√≠ch cenu a doporuƒçen√≠.
            """
            
            response = self.llm.invoke([HumanMessage(content=prompt)])
            
            return {
                "predicted_price": predicted_price,
                "price_per_sqm": predicted_price / property_details.get('size', 1),
                "analysis": response.content,
                "confidence": "vysok√°" if self.model else "n√≠zk√°"
            }
            
        except Exception as e:
            return {"error": f"Chyba p≈ôi oce≈àov√°n√≠: {str(e)}"}

class MarketTrendAgent:
    """Agent pro anal√Ωzu tr≈æn√≠ch trend≈Ø"""
    
    def __init__(self, llm: ChatOpenAI, properties: List[Property]):
        self.llm = llm
        self.properties = properties
        
    def analyze_trends(self, neighborhood: Optional[str] = None) -> Dict:
        """Analyzuje tr≈æn√≠ trendy"""
        try:
            # Simulace historick√Ωch dat
            trends_data = self._generate_trend_data(neighborhood)
            
            prompt = f"""
            Analyzuj tr≈æn√≠ trendy na z√°kladƒõ n√°sleduj√≠c√≠ch dat:
            
            Lokalita: {neighborhood or 'Cel√° Praha'}
            Pr≈Ømƒõrn√° cena za m¬≤: {trends_data['avg_price_per_sqm']:,.0f} CZK
            R≈Øst YoY: {trends_data['yoy_growth']:.1f}%
            Poƒçet transakc√≠: {trends_data['transaction_count']}
            Pr≈Ømƒõrn√° doba prodeje: {trends_data['avg_days_on_market']} dn≈Ø
            
            Poskytni komprehensivn√≠ anal√Ωzu trend≈Ø a predikci v√Ωvoje.
            """
            
            response = self.llm.invoke([HumanMessage(content=prompt)])
            
            return {
                "trend_data": trends_data,
                "analysis": response.content,
                "prediction": self._generate_prediction(trends_data)
            }
            
        except Exception as e:
            return {"error": f"Chyba p≈ôi anal√Ωze trend≈Ø: {str(e)}"}
    
    def _generate_trend_data(self, neighborhood: str = None) -> Dict:
        """Generuje trendov√° data"""
        filtered_props = self.properties
        if neighborhood:
            filtered_props = [p for p in self.properties if p.neighborhood == neighborhood]
        
        if not filtered_props:
            return {"error": "≈Ω√°dn√° data pro lokalitu"}
        
        prices_per_sqm = [p.price / p.size for p in filtered_props]
        
        return {
            "avg_price_per_sqm": np.mean(prices_per_sqm),
            "median_price_per_sqm": np.median(prices_per_sqm),
            "yoy_growth": np.random.normal(5, 3),  # Simulace r≈Østu
            "transaction_count": len(filtered_props),
            "avg_days_on_market": np.random.randint(30, 90),
            "price_range": (min(prices_per_sqm), max(prices_per_sqm))
        }
    
    def _generate_prediction(self, trends_data: Dict) -> Dict:
        """Generuje predikci v√Ωvoje"""
        current_growth = trends_data.get('yoy_growth', 0)
        
        return {
            "short_term_outlook": "pozitivn√≠" if current_growth > 3 else "stabiln√≠",
            "predicted_growth_6m": max(-5, min(15, current_growth + np.random.normal(0, 2))),
            "predicted_growth_1y": max(-10, min(20, current_growth + np.random.normal(0, 4))),
            "risk_factors": ["√∫rokov√© sazby", "ekonomick√° situace", "regulace"]
        }

class InvestmentAdvisoryAgent:
    """Agent pro investiƒçn√≠ poradenstv√≠"""
    
    def __init__(self, llm: ChatOpenAI, properties: List[Property]):
        self.llm = llm
        self.properties = properties
        
    def get_investment_advice(self, client: Client, target_properties: List[Property] = None) -> Dict:
        """Poskytuje investiƒçn√≠ poradenstv√≠"""
        try:
            if not target_properties:
                target_properties = self._find_suitable_properties(client)
            
            # Anal√Ωza investiƒçn√≠ch p≈ô√≠le≈æitost√≠
            analysis = self._analyze_investment_opportunities(client, target_properties)
            
            prompt = f"""
            Poskytni investiƒçn√≠ poradenstv√≠ pro klienta s profilem:
            - Rozpoƒçet: {client.budget_min:,.0f} - {client.budget_max:,.0f} CZK
            - Typ investice: {client.investment_type}
            - Rizikov√° tolerance: {client.risk_tolerance}
            - Preferovan√© lokality: {client.preferred_areas}
            
            Anal√Ωza nalezen√Ωch p≈ô√≠le≈æitost√≠:
            {json.dumps(analysis, indent=2, ensure_ascii=False)}
            
            Poskytni personalizovan√© doporuƒçen√≠ a strategii.
            """
            
            response = self.llm.invoke([HumanMessage(content=prompt)])
            
            return {
                "suitable_properties": target_properties[:5],  # Top 5
                "investment_analysis": analysis,
                "recommendations": response.content,
                "risk_assessment": self._assess_risk(client, target_properties)
            }
            
        except Exception as e:
            return {"error": f"Chyba p≈ôi poskytov√°n√≠ poradenstv√≠: {str(e)}"}
    
    def _find_suitable_properties(self, client: Client) -> List[Property]:
        """Najde vhodn√© nemovitosti pro klienta"""
        suitable = []
        
        for prop in self.properties:
            if (client.budget_min <= prop.price <= client.budget_max and
                prop.rooms >= client.min_rooms and
                (not client.preferred_areas or prop.neighborhood in client.preferred_areas) and
                prop.property_type == client.property_type):
                suitable.append(prop)
        
        # Se≈ôazen√≠ podle ROI potenci√°lu
        return sorted(suitable, key=lambda p: self._calculate_roi_score(p), reverse=True)
    
    def _calculate_roi_score(self, property: Property) -> float:
        """Kalkuluje ROI sk√≥re nemovitosti"""
        # Zjednodu≈°en√° kalkulace ROI
        base_score = 100
        
        # Bonus za nov√© nemovitosti
        if property.year_built >= 2010:
            base_score += 20
        
        # Bonus za lokality s potenci√°lem
        high_potential_areas = ["Karl√≠n", "Hole≈°ovice", "Sm√≠chov"]
        if property.neighborhood in high_potential_areas:
            base_score += 30
        
        # Bonus za vlastnosti
        premium_features = ["parking", "balcony", "elevator"]
        feature_bonus = sum(10 for f in premium_features if f in property.features)
        
        return base_score + feature_bonus + np.random.normal(0, 10)
    
    def _analyze_investment_opportunities(self, client: Client, properties: List[Property]) -> Dict:
        """Analyzuje investiƒçn√≠ p≈ô√≠le≈æitosti"""
        if not properties:
            return {"message": "≈Ω√°dn√© vhodn√© nemovitosti nenalezeny"}
        
        analysis = {
            "total_opportunities": len(properties),
            "avg_price": np.mean([p.price for p in properties]),
            "price_range": (min(p.price for p in properties), max(p.price for p in properties)),
            "neighborhoods": list(set(p.neighborhood for p in properties)),
            "avg_roi_score": np.mean([self._calculate_roi_score(p) for p in properties])
        }
        
        return analysis
    
    def _assess_risk(self, client: Client, properties: List[Property]) -> Dict:
        """Hodnot√≠ riziko investice"""
        risk_level = "n√≠zk√©"
        
        if client.risk_tolerance == "high":
            risk_level = "vysok√©"
        elif client.risk_tolerance == "medium":
            risk_level = "st≈ôedn√≠"
        
        return {
            "overall_risk": risk_level,
            "market_risk": "st≈ôedn√≠",
            "liquidity_risk": "n√≠zk√©",
            "diversification_score": min(10, len(set(p.neighborhood for p in properties))),
            "recommendations": [
                "Zva≈æte diverzifikaci portfolia",
                "Sledujte tr≈æn√≠ trendy",
                "Konzultujte s finanƒçn√≠m poradcem"
            ]
        }

class NeighborhoodAssessmentAgent:
    """Agent pro hodnocen√≠ lokalit"""
    
    def __init__(self, llm: ChatOpenAI):
        self.llm = llm
        
    def assess_neighborhood(self, neighborhood: str) -> Dict:
        """Hodnot√≠ kvalitu lokality"""
        try:
            # Simulace dat o lokalitƒõ
            assessment_data = self._generate_assessment_data(neighborhood)
            
            prompt = f"""
            Proveƒè komplexn√≠ hodnocen√≠ lokality {neighborhood} na z√°kladƒõ dat:
            
            Sk√≥re infrastruktury: {assessment_data['infrastructure_score']}/10
            Bezpeƒçnostn√≠ sk√≥re: {assessment_data['safety_score']}/10
            Dopravn√≠ dostupnost: {assessment_data['transport_score']}/10
            ≈†koly a vzdƒõl√°n√≠: {assessment_data['education_score']}/10
            Obchody a slu≈æby: {assessment_data['services_score']}/10
            Zelen√© plochy: {assessment_data['green_spaces_score']}/10
            Kulturn√≠ vy≈æit√≠: {assessment_data['culture_score']}/10
            
            Poskytni podrobn√© hodnocen√≠ a doporuƒçen√≠ pro r≈Øzn√© typy obyvatel.
            """
            
            response = self.llm.invoke([HumanMessage(content=prompt)])
            
            return {
                "neighborhood": neighborhood,
                "assessment_data": assessment_data,
                "overall_score": np.mean(list(assessment_data.values())),
                "detailed_analysis": response.content,
                "suitable_for": self._determine_suitability(assessment_data)
            }
            
        except Exception as e:
            return {"error": f"Chyba p≈ôi hodnocen√≠ lokality: {str(e)}"}
    
    def _generate_assessment_data(self, neighborhood: str) -> Dict:
        """Generuje data pro hodnocen√≠ lokality"""
        # Simulace sk√≥re pro r≈Øzn√© aspekty
        base_scores = {
            "Vinohrady": {"infrastructure": 9, "safety": 8, "transport": 9},
            "Karl√≠n": {"infrastructure": 8, "safety": 7, "transport": 8},
            "Sm√≠chov": {"infrastructure": 7, "safety": 6, "transport": 9},
            "Vr≈°ovice": {"infrastructure": 6, "safety": 7, "transport": 7},
        }
        
        base = base_scores.get(neighborhood, {"infrastructure": 6, "safety": 6, "transport": 6})
        
        return {
            "infrastructure_score": base["infrastructure"] + np.random.randint(-1, 2),
            "safety_score": base["safety"] + np.random.randint(-1, 2),
            "transport_score": base["transport"] + np.random.randint(-1, 2),
            "education_score": np.random.randint(5, 10),
            "services_score": np.random.randint(5, 10),
            "green_spaces_score": np.random.randint(4, 9),
            "culture_score": np.random.randint(4, 10)
        }
    
    def _determine_suitability(self, data: Dict) -> List[str]:
        """Urƒçuje vhodnost lokality pro r≈Øzn√© typy obyvatel"""
        suitable_for = []
        
        if data["education_score"] >= 8:
            suitable_for.append("rodiny s dƒõtmi")
        
        if data["culture_score"] >= 7:
            suitable_for.append("mlad√© profesion√°ly")
        
        if data["safety_score"] >= 8:
            suitable_for.append("seniory")
        
        if data["transport_score"] >= 8:
            suitable_for.append("doj√≠≈ædƒõj√≠c√≠")
        
        return suitable_for if suitable_for else ["obecn√© bydlen√≠"]

class ClientMatchingAgent:
    """Agent pro p√°rov√°n√≠ klient≈Ø"""
    
    def __init__(self, llm: ChatOpenAI, properties: List[Property]):
        self.llm = llm
        self.properties = properties
        self.vector_db = self._setup_vector_db()
        
    def _setup_vector_db(self):
        """Nastavuje vektorovou datab√°zi"""
        try:
            client = chromadb.Client()
            collection = client.create_collection(name="properties")
            return collection
        except:
            return None
    
    def match_client_to_properties(self, client: Client) -> Dict:
        """P√°ruje klienta s vhodn√Ωmi nemovitostmi"""
        try:
            # Nalezen√≠ vhodn√Ωch nemovitost√≠
            matches = self._find_matches(client)
            
            # Sk√≥rov√°n√≠ shody
            scored_matches = [(prop, self._calculate_match_score(client, prop)) for prop in matches]
            scored_matches.sort(key=lambda x: x[1], reverse=True)
            
            # LLM anal√Ωza
            prompt = f"""
            Analyzuj p√°rov√°n√≠ klienta s nemovitostmi:
            
            Profil klienta:
            - Rozpoƒçet: {client.budget_min:,.0f} - {client.budget_max:,.0f} CZK
            - Preferovan√© oblasti: {client.preferred_areas}
            - Typ nemovitosti: {client.property_type}
            - Minim√°lnƒõ pokoj≈Ø: {client.min_rooms}
            
            Nejlep≈°√≠ shody (top 3):
            {self._format_matches(scored_matches[:3])}
            
            Poskytni anal√Ωzu a doporuƒçen√≠ pro klienta.
            """
            
            response = self.llm.invoke([HumanMessage(content=prompt)])
            
            return {
                "total_matches": len(matches),
                "top_matches": [match[0] for match in scored_matches[:10]],
                "match_scores": [match[1] for match in scored_matches[:10]],
                "analysis": response.content,
                "recommendations": self._generate_recommendations(client, scored_matches)
            }
            
        except Exception as e:
            return {"error": f"Chyba p≈ôi p√°rov√°n√≠: {str(e)}"}
    
    def _find_matches(self, client: Client) -> List[Property]:
        """Najde potenci√°ln√≠ shody"""
        matches = []
        
        for prop in self.properties:
            # Z√°kladn√≠ filtry
            if (client.budget_min <= prop.price <= client.budget_max and
                prop.rooms >= client.min_rooms and
                prop.property_type == client.property_type):
                
                # Kontrola preferovan√Ωch oblast√≠
                if not client.preferred_areas or prop.neighborhood in client.preferred_areas:
                    matches.append(prop)
        
        return matches
    
    def _calculate_match_score(self, client: Client, property: Property) -> float:
        """Kalkuluje sk√≥re shody"""
        score = 0
        
        # Cenov√© sk√≥re (ƒç√≠m bl√≠≈æe k ide√°lu, t√≠m l√©pe)
        price_ideal = (client.budget_min + client.budget_max) / 2
        price_diff = abs(property.price - price_ideal) / price_ideal
        price_score = max(0, 100 - price_diff * 100)
        score += price_score * 0.4
        
        # Lokalita
        if property.neighborhood in client.preferred_areas:
            score += 30
        
        # Poƒçet pokoj≈Ø
        room_bonus = min(20, (property.rooms - client.min_rooms) * 5)
        score += room_bonus
        
        # Typ investice
        if client.investment_type == "investment":
            # Bonus za nov√© nemovitosti pro investory
            if property.year_built >= 2010:
                score += 15
        
        # N√°hodn√° variabilita
        score += np.random.normal(0, 5)
        
        return max(0, min(100, score))
    
    def _format_matches(self, matches: List[Tuple[Property, float]]) -> str:
        """Form√°tuje shody pro LLM"""
        formatted = []
        for prop, score in matches:
            formatted.append(
                f"- {prop.address}: {prop.price:,.0f} CZK, "
                f"{prop.size}m¬≤, {prop.rooms} pokoj≈Ø, "
                f"sk√≥re shody: {score:.1f}/100"
            )
        return "\n".join(formatted)
    
    def _generate_recommendations(self, client: Client, matches: List[Tuple[Property, float]]) -> List[str]:
        """Generuje doporuƒçen√≠"""
        recommendations = []
        
        if not matches:
            recommendations.append("Zva≈æte roz≈°√≠≈ôen√≠ krit√©ri√≠ vyhled√°v√°n√≠")
            return recommendations
        
        avg_score = np.mean([score for _, score in matches[:10]])
        
        if avg_score < 60:
            recommendations.append("Navrhujeme √∫pravu po≈æadavk≈Ø pro lep≈°√≠ v√Ωsledky")
        
        if client.investment_type == "investment":
            recommendations.append("Zamƒõ≈ôte se na lokality s r≈Østov√Ωm potenci√°lem")
        
        recommendations.append("Doporuƒçujeme osobn√≠ prohl√≠dku top kandid√°t≈Ø")
        
        return recommendations

class RealEstateMultiAgentSystem:
    """Hlavn√≠ koordin√°tor multi-agent syst√©mu"""
    
    def __init__(self, openai_api_key: str):
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0.1,
            openai_api_key=openai_api_key
        )
        
        # Generace testovac√≠ch dat
        self.data_generator = PropertyDataGenerator()
        self.properties = self.data_generator.generate_properties(1000)
        
        # Inicializace agent≈Ø
        self.valuation_agent = PropertyValuationAgent(self.llm, self.properties)
        self.trend_agent = MarketTrendAgent(self.llm, self.properties)
        self.advisory_agent = InvestmentAdvisoryAgent(self.llm, self.properties)
        self.neighborhood_agent = NeighborhoodAssessmentAgent(self.llm)
        self.matching_agent = ClientMatchingAgent(self.llm, self.properties)
        
        print(f"Multi-Agent syst√©m inicializov√°n s {len(self.properties)} nemovitostmi")
    
    def comprehensive_analysis(self, property_details: Dict, client: Client = None) -> Dict:
        """Komprehensivn√≠ anal√Ωza nemovitosti a trhu"""
        results = {}
        
        try:
            # 1. Ocenƒõn√≠ nemovitosti
            print("Prov√°d√≠m ocenƒõn√≠ nemovitosti...")
            results['valuation'] = self.valuation_agent.valuate_property(property_details)
            
            # 2. Anal√Ωza trend≈Ø
            print("Analyzuji tr≈æn√≠ trendy...")
            neighborhood = property_details.get('neighborhood')
            results['trends'] = self.trend_agent.analyze_trends(neighborhood)
            
            # 3. Hodnocen√≠ lokality
            print("Hodnot√≠m lokalitu...")
            if neighborhood:
                results['neighborhood'] = self.neighborhood_agent.assess_neighborhood(neighborhood)
            
            # 4. Investiƒçn√≠ poradenstv√≠ (pokud je klient)
            if client:
                print("Poskytuju investiƒçn√≠ poradenstv√≠...")
                results['investment_advice'] = self.advisory_agent.get_investment_advice(client)
                
                print("Hled√°m podobn√© nemovitosti...")
                results['matching'] = self.matching_agent.match_client_to_properties(client)
            
            # 5. Souhrnn√© doporuƒçen√≠
            results['summary'] = self._generate_summary(results)
            
            return results
            
        except Exception as e:
            return {"error": f"Chyba p≈ôi anal√Ωze: {str(e)}"}
    
    def _generate_summary(self, results: Dict) -> Dict:
        """Generuje souhrnn√© doporuƒçen√≠"""
        summary_prompt = f"""
        Na z√°kladƒõ kompletn√≠ anal√Ωzy poskytni souhrnn√© doporuƒçen√≠:
        
        Ocenƒõn√≠: {results.get('valuation', {}).get('predicted_price', 'N/A')}
        Tr≈æn√≠ trendy: {results.get('trends', {}).get('trend_data', {})}
        Hodnocen√≠ lokality: {results.get('neighborhood', {}).get('overall_score', 'N/A')}
        
        Poskytni struƒçn√©, ale komplexn√≠ shrnut√≠ a hlavn√≠ doporuƒçen√≠.
        """
        
        try:
            response = self.llm.invoke([HumanMessage(content=summary_prompt)])
            return {
                "recommendation": response.content,
                "confidence_level": "vysok√°",
                "key_factors": ["cena", "lokalita", "tr≈æn√≠ trendy", "investiƒçn√≠ potenci√°l"]
            }
        except:
            return {"recommendation": "Anal√Ωza dokonƒçena", "confidence_level": "st≈ôedn√≠"}

def demo_system():
    """Demonstrace syst√©mu"""
    # Nastaven√≠ API kl√≠ƒçe (v produkci pou≈æijte environment variable)
    api_key = os.getenv("OPENAI_API_KEY", "your-api-key-here")
    
    if api_key == "your-api-key-here":
        print("‚ö†Ô∏è  Nastavte OPENAI_API_KEY pro plnou funkcionalnost")
        return
    
    # Inicializace syst√©mu
    print("üöÄ Inicializuji Real Estate Multi-Agent syst√©m...")
    system = RealEstateMultiAgentSystem(api_key)
    
    # Testovac√≠ nemovitost
    test_property = {
        "size": 85,
        "rooms": 3,
        "year_built": 2015,
        "neighborhood": "Vinohrady",
        "property_type": "apartment",
        "features": ["parking", "balcony", "elevator"]
    }
    
    # Testovac√≠ klient
    test_client = Client(
        id="client_001",
        name="Jan Nov√°k",
        budget_min=4000000,
        budget_max=6000000,
        preferred_areas=["Vinohrady", "Karl√≠n"],
        property_type="apartment",
        min_rooms=2,
        investment_type="buy_to_live",
        risk_tolerance="medium"
    )
    
    print("\nüè† Prov√°d√≠m komprehensivn√≠ anal√Ωzu...")
    
    # Spu≈°tƒõn√≠ anal√Ωzy
    analysis = system.comprehensive_analysis(test_property, test_client)
    
    # V√Ωpis v√Ωsledk≈Ø
    print("\nüìä V√ùSLEDKY ANAL√ùZY")
    print("=" * 50)
    
    if "valuation" in analysis:
        val = analysis["valuation"]
        print(f"\nüí∞ OCENƒöN√ç NEMOVITOSTI:")
        print(f"Predikovan√° cena: {val.get('predicted_price', 0):,.0f} CZK")
        print(f"Cena za m¬≤: {val.get('price_per_sqm', 0):,.0f} CZK/m¬≤")
    
    if "trends" in analysis and "trend_data" in analysis["trends"]:
        trends = analysis["trends"]["trend_data"]
        print(f"\nüìà TR≈ΩN√ç TRENDY:")
        print(f"Pr≈Ømƒõrn√° cena za m¬≤: {trends.get('avg_price_per_sqm', 0):,.0f} CZK")
        print(f"R≈Øst YoY: {trends.get('yoy_growth', 0):.1f}%")
    
    if "neighborhood" in analysis:
        neighborhood = analysis["neighborhood"]
        print(f"\nüèòÔ∏è  HODNOCEN√ç LOKALITY:")
        print(f"Celkov√© sk√≥re: {neighborhood.get('overall_score', 0):.1f}/10")
    
    if "matching" in analysis:
        matching = analysis["matching"]
        print(f"\nüéØ P√ÅROV√ÅN√ç KLIENTA:")
        print(f"Nalezeno {matching.get('total_matches', 0)} vhodn√Ωch nemovitost√≠")
        
        top_matches = matching.get('top_matches', [])
        if top_matches:
            print("Top 3 doporuƒçen√≠:")
            for i, prop in enumerate(top_matches[:3], 1):
                print(f"  {i}. {prop.address} - {prop.price:,.0f} CZK")
    
    print(f"\n‚úÖ Anal√Ωza dokonƒçena √∫spƒõ≈°nƒõ!")

if __name__ == "__main__":
    demo_system()
````

### Streamlit Webov√© Rozhran√≠

````python
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from real_estate_agents import RealEstateMultiAgentSystem, Client
import os

st.set_page_config(
    page_title="AI Real Estate Analyzer",
    page_icon="üè†",
    layout="wide"
)

def main():
    st.title("üè† AI Multi-Agent Realitn√≠ Analyz√°tor")
    st.markdown("Komplexn√≠ anal√Ωza nemovitost√≠ pomoc√≠ umƒõl√© inteligence")
    
    # Sidebar pro nastaven√≠
    with st.sidebar:
        st.header("‚öôÔ∏è Nastaven√≠")
        
        # API kl√≠ƒç
        api_key = st.text_input("OpenAI API Key", type="password")
        
        if not api_key:
            st.warning("Zadejte OpenAI API kl√≠ƒç pro plnou funkcionalnost")
            return
    
    # Inicializace syst√©mu
    if 'system' not in st.session_state:
        with st.spinner("Inicializuji AI syst√©m..."):
            st.session_state.system = RealEstateMultiAgentSystem(api_key)
    
    # Hlavn√≠ rozhran√≠
    tab1, tab2, tab3 = st.tabs(["üè† Anal√Ωza Nemovitosti", "üë§ Profil Klienta", "üìä Dashboard"])
    
    with tab1:
        st.header("Anal√Ωza Nemovitosti")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Parametry nemovitosti")
            size = st.number_input("Velikost (m¬≤)", min_value=20, max_value=500, value=85)
            rooms = st.number_input("Poƒçet pokoj≈Ø", min_value=1, max_value=10, value=3)
            year_built = st.number_input("Rok v√Ωstavby", min_value=1900, max_value=2024, value=2015)
            
        with col2:
            neighborhood = st.selectbox("Lokalita", [
                "Vinohrady", "Karl√≠n", "Sm√≠chov", "Vr≈°ovice", "Nov√© Mƒõsto",
                "Hole≈°ovice", "Dejvice", "B≈ôevnov", "Andƒõl", "Wenceslas Square"
            ])
            property_type = st.selectbox("Typ nemovitosti", 
                ["apartment", "house", "studio", "penthouse"])
            features = st.multiselect("Vlastnosti", [
                "parking", "balcony", "terrace", "garden", "elevator",
                "air_conditioning", "fireplace", "swimming_pool"
            ])
        
        if st.button("üîç Analyzovat Nemovitost", type="primary"):
            property_details = {
                "size": size,
                "rooms": rooms,
                "year_built": year_built,
                "neighborhood": neighborhood,
                "property_type": property_type,
                "features": features
            }
            
            with st.spinner("Prov√°d√≠m anal√Ωzu..."):
                results = st.session_state.system.comprehensive_analysis(property_details)
            
            # Zobrazen√≠ v√Ωsledk≈Ø
            if "valuation" in results:
                st.success("‚úÖ Anal√Ωza dokonƒçena!")
                
                val = results["valuation"]
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("Predikovan√° cena", f"{val.get('predicted_price', 0):,.0f} CZK")
                
                with col2:
                    st.metric("Cena za m¬≤", f"{val.get('price_per_sqm', 0):,.0f} CZK/m¬≤")
                
                with col3:
                    st.metric("Spolehlivost", val.get('confidence', 'N/A'))
    
    with tab2:
        st.header("Profil Klienta")
        
        col1, col2 = st.columns(2)
        
        with col1:
            client_name = st.text_input("Jm√©no klienta", "Jan Nov√°k")
            budget_min = st.number_input("Min. rozpoƒçet (CZK)", min_value=1000000, value=4000000, step=100000)
            budget_max = st.number_input("Max. rozpoƒçet (CZK)", min_value=budget_min, value=6000000, step=100000)
            
        with col2:
            preferred_areas = st.multiselect("Preferovan√© lokality", [
                "Vinohrady", "Karl√≠n", "Sm√≠chov", "Vr≈°ovice", "Nov√© Mƒõsto",
                "Hole≈°ovice", "Dejvice", "B≈ôevnov", "Andƒõl", "Wenceslas Square"
            ], default=["Vinohrady", "Karl√≠n"])
            
            investment_type = st.selectbox("Typ koupƒõ", 
                ["buy_to_live", "investment", "flip"])
            risk_tolerance = st.selectbox("Rizikov√° tolerance", 
                ["low", "medium", "high"])
        
        if st.button("üéØ Naj√≠t Vhodn√© Nemovitosti", type="primary"):
            client = Client(
                id="web_client",
                name=client_name,
                budget_min=budget_min,
                budget_max=budget_max,
                preferred_areas=preferred_areas,
                property_type="apartment",
                min_rooms=2,
                investment_type=investment_type,
                risk_tolerance=risk_tolerance
            )
            
            with st.spinner("Hled√°m vhodn√© nemovitosti..."):
                matching = st.session_state.system.matching_agent.match_client_to_properties(client)
            
            if "top_matches" in matching:
                st.success(f"‚úÖ Nalezeno {matching['total_matches']} vhodn√Ωch nemovitost√≠")
                
                # Zobrazen√≠ top doporuƒçen√≠
                for i, prop in enumerate(matching['top_matches'][:5], 1):
                    with st.expander(f"#{i} {prop.address} - {prop.price:,.0f} CZK"):
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.write(f"**Velikost:** {prop.size} m¬≤")
                            st.write(f"**Pokoje:** {prop.rooms}")
                        with col2:
                            st.write(f"**Rok:** {prop.year_built}")
                            st.write(f"**Typ:** {prop.property_type}")
                        with col3:
                            st.write(f"**Lokalita:** {prop.neighborhood}")
                            st.write(f"**Vlastnosti:** {', '.join(prop.features[:3])}")
    
    with tab3:
        st.header("üìä Tr≈æn√≠ Dashboard")
        
        # Grafy a statistiky
        properties = st.session_state.system.properties
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Graf cen podle lokalit
            neighborhood_prices = {}
            for prop in properties:
                if prop.neighborhood not in neighborhood_prices:
                    neighborhood_prices[prop.neighborhood] = []
                neighborhood_prices[prop.neighborhood].append(prop.price / prop.size)
            
            avg_prices = {k: sum(v)/len(v) for k, v in neighborhood_prices.items()}
            
            fig = px.bar(
                x=list(avg_prices.keys()),
                y=list(avg_prices.values()),
                title="Pr≈Ømƒõrn√° cena za m¬≤ podle lokalit"
            )
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Graf distribuce cen
            prices = [prop.price for prop in properties]
            fig = px.histogram(x=prices, title="Distribuce cen nemovitost√≠", nbins=50)
            st.plotly_chart(fig, use_container_width=True)

if __name__ == "__main__":
    main()
````

## 5. Shrnut√≠ Projektu

### Kl√≠ƒçov√© V√Ωhody

**Technologick√° Inovace**
- Vyu≈æit√≠ pokroƒçil√Ωch LLM model≈Ø pro anal√Ωzu trhu
- Multi-agent architektura pro specializovan√© √∫lohy
- Integrace ML algoritm≈Ø pro predikci cen

**Obchodn√≠ Hodnota**
- Automatizace slo≈æit√Ωch realitn√≠ch anal√Ωz
- Personalizovan√© investiƒçn√≠ poradenstv√≠
- Zv√Ω≈°en√≠ efektivity realitn√≠ch transakc√≠
- Demokratizace p≈ô√≠stupu k profesion√°ln√≠m anal√Ωz√°m

**Technick√© Vlastnosti**
- ≈†k√°lovateln√° architektura s modul√°rn√≠mi agenty
- Robustn√≠ error handling a validace dat
- Modern√≠ technologick√Ω stack (LangChain, Streamlit, scikit-learn)
- P≈ôipravenost pro produkƒçn√≠ nasazen√≠

### Budouc√≠ Roz≈°√≠≈ôen√≠
- Integrace s re√°ln√Ωmi realitn√≠mi API
- Pokroƒçil√© geolokaƒçn√≠ anal√Ωzy
- Integrace s finanƒçn√≠mi slu≈æbami
- Mobiln√≠ aplikace pro klienty
- Blockchain integrace pro transparentn√≠ transakce

Tento syst√©m p≈ôedstavuje komplexn√≠ ≈ôe≈°en√≠ pro modern√≠ realitn√≠ trh, kombinuj√≠c√≠ s√≠lu umƒõl√© inteligence s praktick√Ωmi pot≈ôebami realitn√≠ch profesion√°l≈Ø a investor≈Ø.