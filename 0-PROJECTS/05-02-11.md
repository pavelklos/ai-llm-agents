<small>Claude Sonnet 4 **(Virtual Psychologist Agent)**</small>
# Virtual Psychologist Agent

## Key Concepts Explanation

### Empathetic Response Generation
Advanced AI system that understands emotional context, validates feelings, and provides compassionate responses using natural language processing to simulate therapeutic communication patterns while maintaining professional boundaries and ethical guidelines.

### Active Memory System
Persistent memory architecture that tracks patient history, emotional patterns, therapeutic progress, and session continuity across interactions to provide contextually aware and personalized psychological support over time.

### Sentiment Analysis Integration
Real-time emotional state assessment using multiple sentiment analysis models to detect mood patterns, emotional triggers, and psychological indicators for informed therapeutic response generation and crisis intervention.

### Therapeutic Communication Framework
Evidence-based conversational patterns incorporating cognitive behavioral therapy (CBT), active listening techniques, and psychological assessment methodologies to provide structured therapeutic interactions.

### Crisis Detection and Intervention
Automated monitoring system that identifies potential mental health crises, self-harm indicators, or emergency situations to provide appropriate resources and escalation protocols for user safety.

## Comprehensive Project Explanation

### Objectives
The Virtual Psychologist Agent provides accessible mental health support through AI-powered therapeutic conversations, emotional pattern tracking, and personalized coping strategies while maintaining ethical boundaries and user safety.

### Key Features
- **Empathetic AI Conversations**: Natural therapeutic dialogue with emotional validation
- **Memory-Persistent Sessions**: Continuous relationship building across interactions
- **Mood Pattern Analysis**: Long-term emotional state tracking and insights
- **Crisis Intervention**: Automated detection of mental health emergencies
- **Therapeutic Tool Integration**: CBT exercises, mindfulness, and coping strategies

### Challenges
- **Ethical Considerations**: Maintaining professional boundaries and user safety
- **Emotional Complexity**: Understanding nuanced human emotions and contexts
- **Crisis Management**: Identifying and responding to mental health emergencies
- **Privacy Protection**: Securing sensitive psychological and personal data

### Potential Impact
This system can increase mental health accessibility, provide 24/7 support, reduce stigma around therapy, and serve as a bridge to professional mental health services while supporting overall psychological wellbeing.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
transformers==4.35.0
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
textblob==0.17.1
vaderSentiment==3.3.2
chromadb==0.4.15
sentence-transformers==2.2.2
sklearn==1.3.2
datetime
logging
typing
dataclasses
enum
json
re
uuid
hashlib
````

### Core Implementation

````python
import pandas as pd
import numpy as np
import json
import re
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import uuid
import hashlib

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go

# NLP and sentiment analysis
from textblob import TextBlob
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from transformers import pipeline

# Vector database for memory
import chromadb
from sentence_transformers import SentenceTransformer

# LLM integration
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.memory import ConversationBufferWindowMemory

# Machine learning
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EmotionalState(Enum):
    VERY_POSITIVE = "very_positive"
    POSITIVE = "positive"
    NEUTRAL = "neutral"
    NEGATIVE = "negative"
    VERY_NEGATIVE = "very_negative"
    ANXIOUS = "anxious"
    DEPRESSED = "depressed"
    ANGRY = "angry"
    CONFUSED = "confused"

class CrisisLevel(Enum):
    NONE = "none"
    LOW = "low"
    MODERATE = "moderate"
    HIGH = "high"
    CRITICAL = "critical"

class TherapyTechnique(Enum):
    CBT = "cognitive_behavioral_therapy"
    MINDFULNESS = "mindfulness"
    ACTIVE_LISTENING = "active_listening"
    VALIDATION = "validation"
    REFRAMING = "cognitive_reframing"
    GROUNDING = "grounding_techniques"

@dataclass
class UserSession:
    session_id: str
    user_id: str
    timestamp: datetime
    emotional_state: EmotionalState
    sentiment_score: float
    crisis_level: CrisisLevel
    key_topics: List[str] = field(default_factory=list)
    user_message: str = ""
    agent_response: str = ""
    techniques_used: List[TherapyTechnique] = field(default_factory=list)

@dataclass
class UserProfile:
    user_id: str
    created_at: datetime
    total_sessions: int = 0
    emotional_patterns: Dict[str, float] = field(default_factory=dict)
    common_triggers: List[str] = field(default_factory=list)
    preferred_techniques: List[TherapyTechnique] = field(default_factory=list)
    crisis_history: List[datetime] = field(default_factory=list)
    progress_notes: List[str] = field(default_factory=list)

@dataclass
class CrisisIndicator:
    keyword: str
    weight: float
    category: str
    urgency_level: CrisisLevel

class SentimentAnalyzer:
    """Advanced sentiment analysis for psychological assessment."""
    
    def __init__(self):
        self.vader_analyzer = SentimentIntensityAnalyzer()
        
        # Load emotion detection model
        try:
            self.emotion_pipeline = pipeline(
                "text-classification",
                model="j-hartmann/emotion-english-distilroberta-base",
                return_all_scores=True
            )
            self.emotion_model_available = True
        except:
            self.emotion_pipeline = None
            self.emotion_model_available = False
            logger.warning("Emotion detection model not available")
        
        # Crisis keywords with weights
        self.crisis_indicators = [
            CrisisIndicator("suicide", 1.0, "self_harm", CrisisLevel.CRITICAL),
            CrisisIndicator("kill myself", 1.0, "self_harm", CrisisLevel.CRITICAL),
            CrisisIndicator("end it all", 0.8, "self_harm", CrisisLevel.HIGH),
            CrisisIndicator("worthless", 0.6, "depression", CrisisLevel.MODERATE),
            CrisisIndicator("hopeless", 0.7, "depression", CrisisLevel.MODERATE),
            CrisisIndicator("panic attack", 0.6, "anxiety", CrisisLevel.MODERATE),
            CrisisIndicator("can't cope", 0.5, "overwhelm", CrisisLevel.LOW),
            CrisisIndicator("self harm", 0.9, "self_harm", CrisisLevel.HIGH),
            CrisisIndicator("hurt myself", 0.9, "self_harm", CrisisLevel.HIGH),
        ]
    
    def analyze_emotional_state(self, text: str) -> Tuple[EmotionalState, float, Dict[str, float]]:
        """Comprehensive emotional state analysis."""
        try:
            # VADER sentiment analysis
            vader_scores = self.vader_analyzer.polarity_scores(text)
            
            # TextBlob sentiment
            blob = TextBlob(text)
            textblob_polarity = blob.sentiment.polarity
            
            # Emotion detection if available
            emotion_scores = {}
            if self.emotion_model_available and self.emotion_pipeline:
                try:
                    emotions = self.emotion_pipeline(text[:512])  # Limit text length
                    emotion_scores = {item['label']: item['score'] for item in emotions}
                except Exception as e:
                    logger.warning(f"Emotion detection error: {e}")
            
            # Combine sentiment scores
            combined_sentiment = (vader_scores['compound'] + textblob_polarity) / 2
            
            # Determine emotional state
            emotional_state = self._determine_emotional_state(
                combined_sentiment, emotion_scores, text
            )
            
            return emotional_state, combined_sentiment, emotion_scores
        
        except Exception as e:
            logger.error(f"Sentiment analysis error: {e}")
            return EmotionalState.NEUTRAL, 0.0, {}
    
    def _determine_emotional_state(self, sentiment: float, emotions: Dict[str, float], 
                                 text: str) -> EmotionalState:
        """Determine emotional state from sentiment and emotion scores."""
        text_lower = text.lower()
        
        # Check for specific emotional indicators
        if any(word in text_lower for word in ['anxious', 'anxiety', 'panic', 'worried']):
            return EmotionalState.ANXIOUS
        
        if any(word in text_lower for word in ['depressed', 'sad', 'hopeless', 'empty']):
            return EmotionalState.DEPRESSED
        
        if any(word in text_lower for word in ['angry', 'furious', 'rage', 'mad']):
            return EmotionalState.ANGRY
        
        if any(word in text_lower for word in ['confused', 'lost', 'uncertain']):
            return EmotionalState.CONFUSED
        
        # Use emotion scores if available
        if emotions:
            max_emotion = max(emotions.items(), key=lambda x: x[1])
            emotion_label, confidence = max_emotion
            
            if confidence > 0.7:
                emotion_mapping = {
                    'joy': EmotionalState.VERY_POSITIVE,
                    'happiness': EmotionalState.POSITIVE,
                    'sadness': EmotionalState.DEPRESSED,
                    'anger': EmotionalState.ANGRY,
                    'fear': EmotionalState.ANXIOUS,
                    'surprise': EmotionalState.NEUTRAL
                }
                
                if emotion_label in emotion_mapping:
                    return emotion_mapping[emotion_label]
        
        # Fall back to sentiment score
        if sentiment >= 0.6:
            return EmotionalState.VERY_POSITIVE
        elif sentiment >= 0.2:
            return EmotionalState.POSITIVE
        elif sentiment >= -0.2:
            return EmotionalState.NEUTRAL
        elif sentiment >= -0.6:
            return EmotionalState.NEGATIVE
        else:
            return EmotionalState.VERY_NEGATIVE
    
    def assess_crisis_level(self, text: str, emotional_state: EmotionalState) -> CrisisLevel:
        """Assess crisis level based on text content and emotional state."""
        text_lower = text.lower()
        crisis_score = 0.0
        
        # Check for crisis indicators
        for indicator in self.crisis_indicators:
            if indicator.keyword in text_lower:
                crisis_score += indicator.weight
        
        # Adjust based on emotional state
        if emotional_state in [EmotionalState.VERY_NEGATIVE, EmotionalState.DEPRESSED]:
            crisis_score += 0.3
        elif emotional_state == EmotionalState.ANXIOUS:
            crisis_score += 0.2
        
        # Determine crisis level
        if crisis_score >= 1.0:
            return CrisisLevel.CRITICAL
        elif crisis_score >= 0.7:
            return CrisisLevel.HIGH
        elif crisis_score >= 0.4:
            return CrisisLevel.MODERATE
        elif crisis_score >= 0.2:
            return CrisisLevel.LOW
        else:
            return CrisisLevel.NONE

class MemorySystem:
    """Advanced memory system for persistent user context."""
    
    def __init__(self):
        # Initialize ChromaDB for vector storage
        self.chroma_client = chromadb.Client()
        
        try:
            self.collection = self.chroma_client.create_collection(
                name="user_memories",
                metadata={"description": "User conversation memories and context"}
            )
        except:
            # Collection might already exist
            self.collection = self.chroma_client.get_collection("user_memories")
        
        # Sentence transformer for embeddings
        self.sentence_model = SentenceTransformer('all-MiniLM-L6-v2')
        
        # User profiles
        self.user_profiles = {}
        self.session_history = {}
    
    def store_session(self, session: UserSession) -> None:
        """Store session in memory system."""
        try:
            # Create memory text
            memory_text = f"User said: {session.user_message}\nEmotion: {session.emotional_state.value}\nTopics: {', '.join(session.key_topics)}"
            
            # Generate embedding
            embedding = self.sentence_model.encode(memory_text).tolist()
            
            # Store in vector database
            self.collection.add(
                documents=[memory_text],
                embeddings=[embedding],
                metadatas=[{
                    "user_id": session.user_id,
                    "session_id": session.session_id,
                    "timestamp": session.timestamp.isoformat(),
                    "emotional_state": session.emotional_state.value,
                    "crisis_level": session.crisis_level.value,
                    "sentiment_score": session.sentiment_score
                }],
                ids=[session.session_id]
            )
            
            # Update session history
            if session.user_id not in self.session_history:
                self.session_history[session.user_id] = []
            
            self.session_history[session.user_id].append(session)
            
            # Update user profile
            self._update_user_profile(session)
            
            logger.info(f"Stored session {session.session_id} for user {session.user_id}")
        
        except Exception as e:
            logger.error(f"Error storing session: {e}")
    
    def retrieve_relevant_memories(self, user_id: str, query: str, limit: int = 5) -> List[Dict]:
        """Retrieve relevant memories for context."""
        try:
            # Generate query embedding
            query_embedding = self.sentence_model.encode(query).tolist()
            
            # Search vector database
            results = self.collection.query(
                query_embeddings=[query_embedding],
                where={"user_id": user_id},
                n_results=limit
            )
            
            memories = []
            if results['documents']:
                for i, doc in enumerate(results['documents'][0]):
                    memory = {
                        'content': doc,
                        'metadata': results['metadatas'][0][i],
                        'distance': results['distances'][0][i] if 'distances' in results else 0
                    }
                    memories.append(memory)
            
            return memories
        
        except Exception as e:
            logger.error(f"Error retrieving memories: {e}")
            return []
    
    def get_user_profile(self, user_id: str) -> UserProfile:
        """Get or create user profile."""
        if user_id not in self.user_profiles:
            self.user_profiles[user_id] = UserProfile(
                user_id=user_id,
                created_at=datetime.now()
            )
        
        return self.user_profiles[user_id]
    
    def _update_user_profile(self, session: UserSession) -> None:
        """Update user profile based on session."""
        profile = self.get_user_profile(session.user_id)
        
        profile.total_sessions += 1
        
        # Update emotional patterns
        emotion_key = session.emotional_state.value
        if emotion_key not in profile.emotional_patterns:
            profile.emotional_patterns[emotion_key] = 0
        profile.emotional_patterns[emotion_key] += 1
        
        # Track crisis events
        if session.crisis_level != CrisisLevel.NONE:
            profile.crisis_history.append(session.timestamp)
        
        # Update common topics/triggers
        for topic in session.key_topics:
            if topic not in profile.common_triggers:
                profile.common_triggers.append(topic)
    
    def get_emotional_timeline(self, user_id: str, days: int = 30) -> List[Tuple[datetime, float]]:
        """Get emotional timeline for user."""
        sessions = self.session_history.get(user_id, [])
        cutoff_date = datetime.now() - timedelta(days=days)
        
        timeline = []
        for session in sessions:
            if session.timestamp >= cutoff_date:
                timeline.append((session.timestamp, session.sentiment_score))
        
        return sorted(timeline, key=lambda x: x[0])

class TherapeuticResponseGenerator:
    """Generate empathetic and therapeutic responses."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.llm = None
        
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.7,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self._initialize_prompts()
        self._load_therapeutic_frameworks()
    
    def _initialize_prompts(self):
        """Initialize therapeutic response prompts."""
        self.therapy_prompt = ChatPromptTemplate.from_template("""
        You are a compassionate virtual psychologist providing supportive therapy. 
        
        User Context:
        - Emotional State: {emotional_state}
        - Crisis Level: {crisis_level}
        - Previous Context: {memory_context}
        - Current Message: {user_message}
        
        Therapeutic Guidelines:
        1. Show empathy and validation
        2. Use active listening techniques
        3. Apply appropriate therapy techniques: {suggested_techniques}
        4. Maintain professional boundaries
        5. If crisis level is HIGH or CRITICAL, prioritize safety and provide resources
        
        Response Requirements:
        - Be warm, non-judgmental, and supportive
        - Acknowledge their feelings
        - Provide gentle guidance or coping strategies
        - Ask thoughtful follow-up questions
        - Keep responses conversational, not clinical
        
        Respond with empathy and therapeutic insight:
        """)
        
        self.crisis_prompt = ChatPromptTemplate.from_template("""
        CRISIS INTERVENTION RESPONSE NEEDED
        
        User is showing signs of: {crisis_level}
        Crisis indicators: {crisis_indicators}
        User message: {user_message}
        
        Provide immediate supportive response that:
        1. Validates their pain without judgment
        2. Expresses genuine concern for their wellbeing
        3. Gently guides toward safety and professional help
        4. Provides specific crisis resources
        5. Emphasizes that help is available and they matter
        
        Be direct but compassionate about the need for immediate support.
        """)
    
    def _load_therapeutic_frameworks(self):
        """Load therapeutic techniques and frameworks."""
        self.cbt_techniques = [
            "cognitive restructuring",
            "thought challenging",
            "behavioral activation",
            "problem-solving therapy"
        ]
        
        self.mindfulness_techniques = [
            "breathing exercises",
            "grounding techniques",
            "present moment awareness",
            "body scan meditation"
        ]
        
        self.validation_responses = [
            "It sounds like you're going through a really difficult time.",
            "Your feelings are completely valid and understandable.",
            "I can hear how much pain you're experiencing right now.",
            "Thank you for sharing something so personal with me."
        ]
    
    def generate_response(self, user_message: str, emotional_state: EmotionalState,
                         crisis_level: CrisisLevel, memory_context: str = "",
                         user_profile: Optional[UserProfile] = None) -> Tuple[str, List[TherapyTechnique]]:
        """Generate therapeutic response."""
        try:
            # Determine appropriate techniques
            suggested_techniques = self._select_techniques(emotional_state, crisis_level, user_profile)
            
            # Handle crisis situations
            if crisis_level in [CrisisLevel.HIGH, CrisisLevel.CRITICAL]:
                return self._generate_crisis_response(user_message, crisis_level)
            
            # Generate therapeutic response
            if self.llm:
                response = self.llm.invoke(
                    self.therapy_prompt.format(
                        emotional_state=emotional_state.value,
                        crisis_level=crisis_level.value,
                        memory_context=memory_context,
                        user_message=user_message,
                        suggested_techniques=", ".join([t.value for t in suggested_techniques])
                    )
                )
                
                therapeutic_response = response.content
            else:
                therapeutic_response = self._generate_fallback_response(
                    user_message, emotional_state, suggested_techniques
                )
            
            return therapeutic_response, suggested_techniques
        
        except Exception as e:
            logger.error(f"Error generating therapeutic response: {e}")
            return self._generate_fallback_response(user_message, emotional_state, [])
    
    def _select_techniques(self, emotional_state: EmotionalState, 
                          crisis_level: CrisisLevel, 
                          user_profile: Optional[UserProfile]) -> List[TherapyTechnique]:
        """Select appropriate therapeutic techniques."""
        techniques = []
        
        # Base techniques for emotional states
        if emotional_state in [EmotionalState.DEPRESSED, EmotionalState.VERY_NEGATIVE]:
            techniques.extend([TherapyTechnique.VALIDATION, TherapyTechnique.CBT])
        elif emotional_state == EmotionalState.ANXIOUS:
            techniques.extend([TherapyTechnique.GROUNDING, TherapyTechnique.MINDFULNESS])
        elif emotional_state == EmotionalState.ANGRY:
            techniques.extend([TherapyTechnique.VALIDATION, TherapyTechnique.REFRAMING])
        elif emotional_state == EmotionalState.CONFUSED:
            techniques.extend([TherapyTechnique.ACTIVE_LISTENING, TherapyTechnique.CBT])
        else:
            techniques.append(TherapyTechnique.ACTIVE_LISTENING)
        
        # Always include validation for empathy
        if TherapyTechnique.VALIDATION not in techniques:
            techniques.append(TherapyTechnique.VALIDATION)
        
        # Consider user preferences if available
        if user_profile and user_profile.preferred_techniques:
            for pref_technique in user_profile.preferred_techniques:
                if pref_technique not in techniques:
                    techniques.append(pref_technique)
        
        return techniques[:3]  # Limit to 3 techniques
    
    def _generate_crisis_response(self, user_message: str, 
                                crisis_level: CrisisLevel) -> Tuple[str, List[TherapyTechnique]]:
        """Generate crisis intervention response."""
        if self.llm:
            try:
                response = self.llm.invoke(
                    self.crisis_prompt.format(
                        crisis_level=crisis_level.value,
                        crisis_indicators="self-harm or suicide ideation detected",
                        user_message=user_message
                    )
                )
                
                crisis_response = response.content
            except Exception as e:
                logger.error(f"Error in crisis response generation: {e}")
                crisis_response = self._get_emergency_response(crisis_level)
        else:
            crisis_response = self._get_emergency_response(crisis_level)
        
        # Add crisis resources
        crisis_response += "\n\n" + self._get_crisis_resources()
        
        return crisis_response, [TherapyTechnique.VALIDATION]
    
    def _get_emergency_response(self, crisis_level: CrisisLevel) -> str:
        """Get emergency response for crisis situations."""
        if crisis_level == CrisisLevel.CRITICAL:
            return ("I'm very concerned about what you've shared with me. Your life has value and meaning, "
                   "and I want to make sure you get the immediate support you need. Please reach out to "
                   "a crisis counselor or emergency services right away.")
        else:
            return ("I can hear that you're struggling with some very difficult feelings right now. "
                   "It's important that you know you don't have to face this alone. Let's talk about "
                   "getting you some additional support.")
    
    def _get_crisis_resources(self) -> str:
        """Get crisis intervention resources."""
        return """
ğŸ†˜ **IMMEDIATE HELP AVAILABLE:**

**Crisis Lines:**
â€¢ National Suicide Prevention Lifeline: 988 or 1-800-273-8255
â€¢ Crisis Text Line: Text HOME to 741741
â€¢ International Association for Suicide Prevention: https://www.iasp.info/resources/Crisis_Centres/

**Emergency Services:**
â€¢ Call 911 (US) or your local emergency number
â€¢ Go to your nearest emergency room

**Online Support:**
â€¢ 7 Cups: Free emotional support chat
â€¢ BetterHelp: Professional counseling services

Remember: You matter, your life has value, and help is available. ğŸ’™
        """
    
    def _generate_fallback_response(self, user_message: str, 
                                  emotional_state: EmotionalState,
                                  techniques: List[TherapyTechnique]) -> Tuple[str, List[TherapyTechnique]]:
        """Generate fallback response without LLM."""
        validation = random.choice(self.validation_responses)
        
        # Basic response based on emotional state
        if emotional_state == EmotionalState.DEPRESSED:
            response = f"{validation} Depression can feel overwhelming, but you're taking a positive step by reaching out. What has been the most challenging part of your day?"
        elif emotional_state == EmotionalState.ANXIOUS:
            response = f"{validation} Anxiety can be really difficult to manage. Let's try a quick grounding exercise: Can you name 5 things you can see around you right now?"
        elif emotional_state == EmotionalState.ANGRY:
            response = f"{validation} It's okay to feel angry - emotions are information. What do you think might be underneath that anger?"
        else:
            response = f"{validation} I'm here to listen and support you. Can you tell me more about what's on your mind today?"
        
        return response, techniques if techniques else [TherapyTechnique.ACTIVE_LISTENING]

class VirtualPsychologist:
    """Main virtual psychologist agent."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.sentiment_analyzer = SentimentAnalyzer()
        self.memory_system = MemorySystem()
        self.response_generator = TherapeuticResponseGenerator(openai_api_key)
        
        # Session management
        self.active_sessions = {}
    
    def start_session(self, user_id: str) -> str:
        """Start a new therapy session."""
        session_id = str(uuid.uuid4())
        
        # Get user profile and context
        user_profile = self.memory_system.get_user_profile(user_id)
        
        # Welcome message
        if user_profile.total_sessions == 0:
            welcome_msg = ("Hello! I'm here to provide a safe, supportive space for you to share your thoughts and feelings. "
                          "Everything we discuss is confidential. How are you feeling today?")
        else:
            welcome_msg = f"Welcome back! It's good to see you again. How have you been since our last conversation?"
        
        return welcome_msg
    
    def process_message(self, user_id: str, message: str) -> Dict[str, Any]:
        """Process user message and generate therapeutic response."""
        try:
            # Analyze emotional state and sentiment
            emotional_state, sentiment_score, emotion_details = self.sentiment_analyzer.analyze_emotional_state(message)
            
            # Assess crisis level
            crisis_level = self.sentiment_analyzer.assess_crisis_level(message, emotional_state)
            
            # Extract key topics
            key_topics = self._extract_key_topics(message)
            
            # Retrieve relevant memories for context
            relevant_memories = self.memory_system.retrieve_relevant_memories(user_id, message)
            memory_context = "\n".join([mem['content'] for mem in relevant_memories[:3]])
            
            # Get user profile
            user_profile = self.memory_system.get_user_profile(user_id)
            
            # Generate therapeutic response
            response_text, techniques_used = self.response_generator.generate_response(
                message, emotional_state, crisis_level, memory_context, user_profile
            )
            
            # Create session record
            session = UserSession(
                session_id=str(uuid.uuid4()),
                user_id=user_id,
                timestamp=datetime.now(),
                emotional_state=emotional_state,
                sentiment_score=sentiment_score,
                crisis_level=crisis_level,
                key_topics=key_topics,
                user_message=message,
                agent_response=response_text,
                techniques_used=techniques_used
            )
            
            # Store session in memory
            self.memory_system.store_session(session)
            
            # Prepare response data
            response_data = {
                'response': response_text,
                'emotional_state': emotional_state.value,
                'sentiment_score': sentiment_score,
                'crisis_level': crisis_level.value,
                'techniques_used': [t.value for t in techniques_used],
                'key_topics': key_topics,
                'session_id': session.session_id,
                'is_crisis': crisis_level in [CrisisLevel.HIGH, CrisisLevel.CRITICAL]
            }
            
            # Add emotion details if available
            if emotion_details:
                response_data['emotion_details'] = emotion_details
            
            return response_data
        
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            return {
                'response': "I'm sorry, I'm having trouble processing that right now. Could you please try again?",
                'error': str(e)
            }
    
    def _extract_key_topics(self, message: str) -> List[str]:
        """Extract key topics from user message."""
        # Simple keyword extraction - could be enhanced with NER
        words = re.findall(r'\b\w+\b', message.lower())
        
        # Psychology-related keywords
        psych_keywords = [
            'depression', 'anxiety', 'stress', 'trauma', 'grief', 'loss', 'relationship',
            'family', 'work', 'school', 'fear', 'anger', 'loneliness', 'panic',
            'therapy', 'medication', 'sleep', 'eating', 'addiction', 'self-esteem'
        ]
        
        # Find relevant topics
        topics = [word for word in psych_keywords if word in words]
        
        # Add relationship keywords
        relationship_words = ['partner', 'spouse', 'boyfriend', 'girlfriend', 'marriage', 'divorce']
        if any(word in words for word in relationship_words):
            topics.append('relationships')
        
        # Add work/career keywords
        work_words = ['job', 'career', 'boss', 'colleague', 'unemployment', 'workplace']
        if any(word in words for word in work_words):
            topics.append('work_career')
        
        return list(set(topics))
    
    def get_user_insights(self, user_id: str) -> Dict[str, Any]:
        """Get psychological insights for user."""
        try:
            user_profile = self.memory_system.get_user_profile(user_id)
            emotional_timeline = self.memory_system.get_emotional_timeline(user_id)
            
            # Calculate insights
            insights = {
                'total_sessions': user_profile.total_sessions,
                'emotional_patterns': user_profile.emotional_patterns,
                'common_triggers': user_profile.common_triggers,
                'crisis_events': len(user_profile.crisis_history),
                'emotional_timeline': emotional_timeline,
                'overall_trend': self._calculate_emotional_trend(emotional_timeline),
                'recommendations': self._generate_recommendations(user_profile)
            }
            
            return insights
        
        except Exception as e:
            logger.error(f"Error getting user insights: {e}")
            return {'error': str(e)}
    
    def _calculate_emotional_trend(self, timeline: List[Tuple[datetime, float]]) -> str:
        """Calculate overall emotional trend."""
        if len(timeline) < 3:
            return "insufficient_data"
        
        # Simple trend calculation
        recent_scores = [score for _, score in timeline[-7:]]  # Last 7 sessions
        early_scores = [score for _, score in timeline[:7]]   # First 7 sessions
        
        if len(recent_scores) < 3 or len(early_scores) < 3:
            return "insufficient_data"
        
        recent_avg = np.mean(recent_scores)
        early_avg = np.mean(early_scores)
        
        if recent_avg > early_avg + 0.2:
            return "improving"
        elif recent_avg < early_avg - 0.2:
            return "declining"
        else:
            return "stable"
    
    def _generate_recommendations(self, user_profile: UserProfile) -> List[str]:
        """Generate therapeutic recommendations."""
        recommendations = []
        
        # Based on emotional patterns
        if 'depressed' in user_profile.emotional_patterns:
            recommendations.append("Consider exploring cognitive behavioral therapy techniques for depression")
        
        if 'anxious' in user_profile.emotional_patterns:
            recommendations.append("Mindfulness and grounding exercises may help manage anxiety")
        
        # Based on crisis history
        if len(user_profile.crisis_history) > 0:
            recommendations.append("Consider establishing a crisis management plan with professional support")
        
        # Based on common triggers
        if 'work_career' in user_profile.common_triggers:
            recommendations.append("Explore work-life balance and stress management strategies")
        
        if 'relationships' in user_profile.common_triggers:
            recommendations.append("Relationship counseling or communication skills training might be beneficial")
        
        # General recommendations
        if user_profile.total_sessions > 5:
            recommendations.append("You've been consistent with therapy - consider setting specific goals for continued growth")
        
        return recommendations

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Virtual Psychologist Agent",
        page_icon="ğŸ§ ",
        layout="wide"
    )
    
    st.title("ğŸ§  Virtual Psychologist Agent")
    st.markdown("**Confidential AI-powered mental health support**")
    
    # Disclaimer
    with st.expander("âš ï¸ Important Disclaimer - Please Read"):
        st.markdown("""
        **This is an AI assistant for educational/demonstration purposes only.**
        
        - This is NOT a replacement for professional mental health care
        - In crisis situations, please contact emergency services or crisis hotlines
        - All interactions are simulated and should not be considered medical advice
        - For real mental health concerns, please consult licensed professionals
        
        **Crisis Resources:**
        - National Suicide Prevention Lifeline: 988
        - Crisis Text Line: Text HOME to 741741
        - Emergency Services: 911
        """)
    
    # Initialize session state
    if 'psychologist' not in st.session_state:
        st.session_state['psychologist'] = None
    if 'user_id' not in st.session_state:
        st.session_state['user_id'] = str(uuid.uuid4())
    if 'conversation_history' not in st.session_state:
        st.session_state['conversation_history'] = []
    if 'session_started' not in st.session_state:
        st.session_state['session_started'] = False
    
    # Sidebar for configuration
    with st.sidebar:
        st.header("ğŸ”§ Configuration")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Agent") or st.session_state['psychologist'] is None:
            with st.spinner("Initializing Virtual Psychologist..."):
                st.session_state['psychologist'] = VirtualPsychologist(openai_key)
                st.success("Virtual Psychologist ready!")
        
        st.header("ğŸ“Š Session Info")
        if st.session_state['psychologist']:
            user_profile = st.session_state['psychologist'].memory_system.get_user_profile(st.session_state['user_id'])
            st.write(f"**Sessions:** {user_profile.total_sessions}")
            st.write(f"**User ID:** {st.session_state['user_id'][:8]}...")
        
        if st.button("New User Session"):
            st.session_state['user_id'] = str(uuid.uuid4())
            st.session_state['conversation_history'] = []
            st.session_state['session_started'] = False
            st.rerun()
    
    if not st.session_state['psychologist']:
        st.info("ğŸ‘ˆ Please initialize the Virtual Psychologist")
        return
    
    psychologist = st.session_state['psychologist']
    user_id = st.session_state['user_id']
    
    # Main interface tabs
    tab1, tab2, tab3 = st.tabs(["ğŸ’¬ Therapy Session", "ğŸ“Š Insights & Progress", "ğŸ†˜ Crisis Resources"])
    
    with tab1:
        st.header("ğŸ’¬ Therapy Session")
        
        # Start session if not started
        if not st.session_state['session_started']:
            with st.spinner("Starting session..."):
                welcome_message = psychologist.start_session(user_id)
                st.session_state['conversation_history'].append({
                    'role': 'assistant',
                    'content': welcome_message,
                    'timestamp': datetime.now()
                })
                st.session_state['session_started'] = True
        
        # Display conversation history
        for message in st.session_state['conversation_history']:
            with st.chat_message(message['role']):
                st.write(message['content'])
                
                # Show additional info for assistant messages
                if message['role'] == 'assistant' and 'metadata' in message:
                    with st.expander("Session Details"):
                        metadata = message['metadata']
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            st.write(f"**Emotion:** {metadata.get('emotional_state', 'N/A')}")
                        with col2:
                            st.write(f"**Sentiment:** {metadata.get('sentiment_score', 0):.2f}")
                        with col3:
                            crisis_level = metadata.get('crisis_level', 'none')
                            if crisis_level in ['high', 'critical']:
                                st.error(f"**Crisis Level:** {crisis_level}")
                            else:
                                st.write(f"**Crisis Level:** {crisis_level}")
        
        # Chat input
        user_input = st.chat_input("Share your thoughts and feelings...")
        
        if user_input:
            # Add user message to history
            st.session_state['conversation_history'].append({
                'role': 'user',
                'content': user_input,
                'timestamp': datetime.now()
            })
            
            # Process message
            with st.spinner("Processing and generating response..."):
                response_data = psychologist.process_message(user_id, user_input)
                
                if 'error' not in response_data:
                    # Add assistant response to history
                    st.session_state['conversation_history'].append({
                        'role': 'assistant',
                        'content': response_data['response'],
                        'timestamp': datetime.now(),
                        'metadata': response_data
                    })
                    
                    # Show crisis alert if needed
                    if response_data.get('is_crisis', False):
                        st.error("ğŸ†˜ Crisis situation detected. Please see crisis resources tab.")
                else:
                    st.error(f"Error: {response_data['error']}")
            
            st.rerun()
    
    with tab2:
        st.header("ğŸ“Š Insights & Progress")
        
        if st.button("Generate Insights"):
            with st.spinner("Analyzing your progress..."):
                insights = psychologist.get_user_insights(user_id)
                st.session_state['insights'] = insights
        
        if 'insights' in st.session_state:
            insights = st.session_state['insights']
            
            if 'error' not in insights:
                # Progress metrics
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Total Sessions", insights.get('total_sessions', 0))
                with col2:
                    st.metric("Crisis Events", insights.get('crisis_events', 0))
                with col3:
                    trend = insights.get('overall_trend', 'unknown')
                    trend_emoji = "ğŸ“ˆ" if trend == "improving" else "ğŸ“‰" if trend == "declining" else "â¡ï¸"
                    st.metric("Trend", f"{trend_emoji} {trend}")
                with col4:
                    triggers = len(insights.get('common_triggers', []))
                    st.metric("Common Triggers", triggers)
                
                # Emotional patterns
                if insights.get('emotional_patterns'):
                    st.subheader("ğŸ˜Š Emotional Patterns")
                    
                    patterns = insights['emotional_patterns']
                    emotions = list(patterns.keys())
                    counts = list(patterns.values())
                    
                    fig_emotions = px.pie(
                        values=counts,
                        names=emotions,
                        title="Distribution of Emotional States"
                    )
                    st.plotly_chart(fig_emotions, use_container_width=True)
                
                # Emotional timeline
                if insights.get('emotional_timeline'):
                    st.subheader("ğŸ“ˆ Emotional Timeline")
                    
                    timeline = insights['emotional_timeline']
                    if timeline:
                        dates = [item[0] for item in timeline]
                        scores = [item[1] for item in timeline]
                        
                        fig_timeline = px.line(
                            x=dates, 
                            y=scores,
                            title="Emotional Sentiment Over Time",
                            labels={'x': 'Date', 'y': 'Sentiment Score'}
                        )
                        fig_timeline.add_hline(y=0, line_dash="dash", line_color="gray")
                        st.plotly_chart(fig_timeline, use_container_width=True)
                
                # Common triggers
                if insights.get('common_triggers'):
                    st.subheader("ğŸ¯ Common Triggers")
                    for trigger in insights['common_triggers']:
                        st.write(f"â€¢ {trigger.replace('_', ' ').title()}")
                
                # Recommendations
                if insights.get('recommendations'):
                    st.subheader("ğŸ’¡ Therapeutic Recommendations")
                    for rec in insights['recommendations']:
                        st.info(rec)
            else:
                st.error(f"Error generating insights: {insights['error']}")
        else:
            st.info("Click 'Generate Insights' to see your progress analysis")
    
    with tab3:
        st.header("ğŸ†˜ Crisis Resources")
        
        st.error("**If you're experiencing a mental health emergency, please seek immediate help:**")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("ğŸ“ Crisis Hotlines")
            st.markdown("""
            **National Suicide Prevention Lifeline**
            - ğŸ“ **988** (US)
            - ğŸ“ **1-800-273-8255**
            - Available 24/7
            
            **Crisis Text Line**
            - ğŸ“± Text **HOME** to **741741**
            - Available 24/7
            
            **International Crisis Lines**
            - Visit: [IASP Crisis Centres](https://www.iasp.info/resources/Crisis_Centres/)
            """)
        
        with col2:
            st.subheader("ğŸ¥ Emergency Services")
            st.markdown("""
            **Immediate Emergency**
            - ğŸ“ **911** (US Emergency)
            - ğŸ“ **Your local emergency number**
            - Go to nearest emergency room
            
            **Online Support**
            - [7 Cups](https://www.7cups.com/) - Free emotional support
            - [BetterHelp](https://www.betterhelp.com/) - Professional counseling
            - [Psychology Today](https://www.psychologytoday.com/) - Find therapists
            """)
        
        st.subheader("ğŸ§  Mental Health Resources")
        st.markdown("""
        **Educational Resources:**
        - [National Alliance on Mental Illness (NAMI)](https://www.nami.org/)
        - [Mental Health America](https://mhanational.org/)
        - [Anxiety and Depression Association](https://adaa.org/)
        
        **Self-Help Tools:**
        - [MindTools Stress Management](https://www.mindtools.com/stress-management)
        - [Headspace Meditation App](https://www.headspace.com/)
        - [Calm Meditation App](https://www.calm.com/)
        """)
        
        st.info("ğŸ’™ **Remember: You are not alone. Help is available, and your life has value.**")

if __name__ == "__main__":
    main()
````

## Project Summary

The Virtual Psychologist Agent provides accessible mental health support through AI-powered empathetic conversations, persistent memory systems, and comprehensive emotional analysis while maintaining ethical boundaries and crisis intervention capabilities for user safety and wellbeing.

### Key Value Propositions:
- **Empathetic AI Therapy**: Natural therapeutic conversations with emotional validation and professional techniques
- **Persistent Memory**: Long-term relationship building through advanced memory systems and user context tracking
- **Crisis Intervention**: Automated detection and response to mental health emergencies with resource provision
- **Progress Tracking**: Comprehensive emotional pattern analysis and therapeutic progress monitoring

### Technical Architecture:
The system integrates LangChain for conversational AI, ChromaDB for persistent memory storage, advanced sentiment analysis models for emotional assessment, and evidence-based therapeutic frameworks, creating a comprehensive mental health support platform that prioritizes user safety while providing accessible psychological assistance and crisis intervention capabilities.