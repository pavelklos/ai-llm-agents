<small>Claude Sonnet 4 **(Blockchain Smart Contract Auditor - AI MCP Agent)**</small>
# Blockchain Smart Contract Auditor

## 1. NÃ¡zev Projektu

**AI-Powered Blockchain Smart Contract Auditor** - InteligentnÃ­ systÃ©m pro automatickou analÃ½zu, audit a optimalizaci smart contractÅ¯ na blockchainu s vyuÅ¾itÃ­m Model Context Protocol (MCP) a pokroÄilÃ½ch AI technik.

## 2. VysvÄ›tlenÃ­ KlÃ­ÄovÃ½ch KonceptÅ¯

### Model Context Protocol (MCP)
Protokol pro standardizaci komunikace mezi AI aplikacemi a externÃ­mi datovÃ½mi zdroji, umoÅ¾ÅˆujÃ­cÃ­ bezpeÄnÃ½ pÅ™Ã­stup k blockchain datÅ¯m a smart contract analÃ½ze.

### Solidity Analysis
HlubokÃ¡ analÃ½za kÃ³du smart contractÅ¯ napsanÃ½ch v jazyce Solidity, vÄetnÄ› statickÃ© analÃ½zy, detekce vzorÅ¯ a hodnocenÃ­ kvality kÃ³du.

### Vulnerability Detection
AutomatickÃ¡ identifikace bezpeÄnostnÃ­ch zranitelnostÃ­ v smart contractech, vÄetnÄ› reentrancy ÃºtokÅ¯, integer overflow/underflow, access control problÃ©mÅ¯ a dalÅ¡Ã­ch znÃ¡mÃ½ch hrozeb.

### Gas Optimization
AnalÃ½za a optimalizace spotÅ™eby plynu (gas) ve smart contractech pro snÃ­Å¾enÃ­ transakÄnÃ­ch nÃ¡kladÅ¯ a zlepÅ¡enÃ­ efektivity.

### Web3 Integration
Integrace s Web3 ekosystÃ©mem pro ÄtenÃ­ blockchain dat, interakci s smart contracty a zÃ­skÃ¡vÃ¡nÃ­ real-time informacÃ­ o transakcÃ­ch.

### Ethereum/Polygon Support
Podpora pro analÃ½zu smart contractÅ¯ na Ethereum a Polygon sÃ­tÃ­ch s moÅ¾nostÃ­ rozÅ¡Ã­Å™enÃ­ na dalÅ¡Ã­ EVM kompatibilnÃ­ blockchainy.

## 3. KomplexnÃ­ VysvÄ›tlenÃ­ Projektu

Tento projekt pÅ™edstavuje pokroÄilÃ½ AI systÃ©m navrÅ¾enÃ½ pro automatickou analÃ½zu a audit smart contractÅ¯ na blockchainu. SystÃ©m kombinuje sÃ­lu velkÃ½ch jazykovÃ½ch modelÅ¯ (LLM) s expertnÃ­mi znalostmi v oblasti blockchain bezpeÄnosti a vyuÅ¾Ã­vÃ¡ Model Context Protocol pro strukturovanou komunikaci s blockchain infrastrukturou.

### HlavnÃ­ CÃ­le:
- **Automatizace auditnÃ­ho procesu**: Redukce Äasu a nÃ¡kladÅ¯ spojenÃ½ch s manuÃ¡lnÃ­m auditem smart contractÅ¯
- **ZvÃ½Å¡enÃ­ bezpeÄnosti**: Identifikace kritickÃ½ch zranitelnostÃ­ pÅ™ed nasazenÃ­m contractÅ¯ do produkce
- **Optimalizace vÃ½konu**: NÃ¡vrhy pro snÃ­Å¾enÃ­ gas spotÅ™eby a zlepÅ¡enÃ­ efektivity
- **VzdÄ›lÃ¡vÃ¡nÃ­ vÃ½vojÃ¡Å™Å¯**: PoskytovÃ¡nÃ­ detailnÃ­ch vysvÄ›tlenÃ­ a doporuÄenÃ­ pro zlepÅ¡enÃ­ kÃ³du

### TechnickÃ© VÃ½zvy:
- **Komplexnost Solidity jazyka**: PochopenÃ­ pokroÄilÃ½ch konceptÅ¯ jako jsou modifikÃ¡tory, udÃ¡losti, inheritance
- **KontextovÃ¡ analÃ½za**: AnalÃ½za interakcÃ­ mezi rÅ¯znÃ½mi contracty a externÃ­mi zÃ¡vislostmi
- **False positives**: Minimalizace faleÅ¡nÃ½ch poplachÅ¯ pÅ™i detekci zranitelnostÃ­
- **Real-time monitoring**: KontinuÃ¡lnÃ­ sledovÃ¡nÃ­ nasazenÃ½ch contractÅ¯ pro novÃ© hrozby

### PotenciÃ¡lnÃ­ Dopad:
- **SnÃ­Å¾enÃ­ finanÄnÃ­ch ztrÃ¡t**: Prevence ÃºtokÅ¯ na DeFi protokoly a dalÅ¡Ã­ blockchain aplikace
- **ZvÃ½Å¡enÃ­ dÅ¯vÄ›ry**: VÄ›tÅ¡Ã­ dÅ¯vÄ›ra uÅ¾ivatelÅ¯ v blockchain ekosystÃ©m
- **Akcelerace vÃ½voje**: RychlejÅ¡Ã­ iterace pÅ™i vÃ½voji smart contractÅ¯
- **Demokratizace auditÅ¯**: PÅ™Ã­stup k profesionÃ¡lnÃ­m auditÅ¯m pro menÅ¡Ã­ projekty

## 4. KomplexnÃ­ PÅ™Ã­klad s Python ImplementacÃ­

````python
"""
AI-Powered Blockchain Smart Contract Auditor using MCP
KomplexnÃ­ systÃ©m pro audit smart contractÅ¯ s vyuÅ¾itÃ­m AI a MCP protokolu
"""

import asyncio
import json
import re
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import hashlib
from pathlib import Path
import logging

# Core dependencies
from web3 import Web3
from solcx import compile_source, install_solc, get_installed_solc_versions
import requests
from langchain.llms import OpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma
from langchain_community.embeddings import OpenAIEmbeddings
import openai

# MCP Protocol implementation
class MCPMessageType(Enum):
    INITIALIZE = "initialize"
    REQUEST = "request"
    RESPONSE = "response"
    NOTIFICATION = "notification"

@dataclass
class MCPMessage:
    type: MCPMessageType
    id: Optional[str] = None
    method: Optional[str] = None
    params: Optional[Dict] = None
    result: Optional[Any] = None
    error: Optional[Dict] = None

class VulnerabilityType(Enum):
    REENTRANCY = "reentrancy"
    INTEGER_OVERFLOW = "integer_overflow"
    ACCESS_CONTROL = "access_control"
    UNCHECKED_CALLS = "unchecked_calls"
    GAS_LIMIT = "gas_limit"
    TIMESTAMP_DEPENDENCE = "timestamp_dependence"
    FRONT_RUNNING = "front_running"
    DENIAL_OF_SERVICE = "denial_of_service"

@dataclass
class Vulnerability:
    type: VulnerabilityType
    severity: str  # "critical", "high", "medium", "low"
    line_number: int
    description: str
    recommendation: str
    code_snippet: str
    confidence: float

@dataclass
class GasOptimization:
    line_number: int
    current_gas: int
    optimized_gas: int
    savings: int
    description: str
    optimized_code: str

@dataclass
class AuditReport:
    contract_address: Optional[str]
    contract_name: str
    source_code: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    gas_optimizations: List[GasOptimization] = field(default_factory=list)
    overall_score: float = 0.0
    recommendations: List[str] = field(default_factory=list)
    analysis_timestamp: str = ""

class SolidityAnalyzer:
    """AnalyzÃ¡tor Solidity kÃ³du pro detekci vzorÅ¯ a zranitelnostÃ­"""
    
    def __init__(self):
        self.vulnerability_patterns = {
            VulnerabilityType.REENTRANCY: [
                r'\.call\{value:.*?\}\(\"\"\)',
                r'\.transfer\(',
                r'\.send\(',
                r'external.*payable'
            ],
            VulnerabilityType.INTEGER_OVERFLOW: [
                r'\+\+',
                r'--',
                r'\s*\+\s*',
                r'\s*-\s*',
                r'\s*\*\s*'
            ],
            VulnerabilityType.ACCESS_CONTROL: [
                r'onlyOwner',
                r'require\(msg\.sender',
                r'modifier\s+\w+',
                r'owner\s*=='
            ]
        }
    
    def analyze_vulnerabilities(self, source_code: str) -> List[Vulnerability]:
        """Analyzuje zranitelnosti v source kÃ³du"""
        vulnerabilities = []
        lines = source_code.split('\n')
        
        for i, line in enumerate(lines, 1):
            # Reentrancy detection
            if self._check_reentrancy(line):
                vuln = Vulnerability(
                    type=VulnerabilityType.REENTRANCY,
                    severity="high",
                    line_number=i,
                    description="PotenciÃ¡lnÃ­ reentrancy Ãºtok detekovÃ¡n",
                    recommendation="PouÅ¾ijte checks-effects-interactions pattern nebo ReentrancyGuard",
                    code_snippet=line.strip(),
                    confidence=0.8
                )
                vulnerabilities.append(vuln)
            
            # Integer overflow detection
            if self._check_integer_overflow(line):
                vuln = Vulnerability(
                    type=VulnerabilityType.INTEGER_OVERFLOW,
                    severity="medium",
                    line_number=i,
                    description="PotenciÃ¡lnÃ­ integer overflow/underflow",
                    recommendation="PouÅ¾ijte SafeMath knihovnu nebo Solidity 0.8+ s automatickÃ½mi kontrolami",
                    code_snippet=line.strip(),
                    confidence=0.6
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_reentrancy(self, line: str) -> bool:
        """Kontroluje reentrancy vzory"""
        reentrancy_patterns = [
            r'\.call\{value:.*?\}\(\"\"\)',
            r'\.transfer\(',
            r'\.send\(',
            r'external.*payable'
        ]
        return any(re.search(pattern, line) for pattern in reentrancy_patterns)
    
    def _check_integer_overflow(self, line: str) -> bool:
        """Kontroluje integer overflow vzory"""
        if 'SafeMath' in line or 'pragma solidity ^0.8' in line:
            return False
        
        overflow_patterns = [
            r'\w+\s*\+=\s*\w+',
            r'\w+\s*-=\s*\w+',
            r'\w+\s*\*=\s*\w+',
            r'\w+\s*=\s*\w+\s*\+\s*\w+'
        ]
        return any(re.search(pattern, line) for pattern in overflow_patterns)

class GasOptimizer:
    """OptimalizÃ¡tor gas spotÅ™eby pro smart contracty"""
    
    def __init__(self):
        self.optimization_rules = {
            'storage_to_memory': {
                'pattern': r'storage\s+\w+',
                'suggestion': 'memory',
                'savings': 2000
            },
            'loop_optimization': {
                'pattern': r'for\s*\(.*length.*\)',
                'suggestion': 'Cache array length',
                'savings': 100
            },
            'constant_variables': {
                'pattern': r'uint256\s+public\s+\w+\s*=',
                'suggestion': 'Use constant or immutable',
                'savings': 20000
            }
        }
    
    def analyze_gas_optimizations(self, source_code: str) -> List[GasOptimization]:
        """Analyzuje moÅ¾nosti optimalizace plynu"""
        optimizations = []
        lines = source_code.split('\n')
        
        for i, line in enumerate(lines, 1):
            # Storage to memory optimization
            if 'storage' in line and 'struct' in line:
                opt = GasOptimization(
                    line_number=i,
                    current_gas=5000,
                    optimized_gas=3000,
                    savings=2000,
                    description="ZmÄ›na storage na memory pro doÄasnÃ© promÄ›nnÃ©",
                    optimized_code=line.replace('storage', 'memory')
                )
                optimizations.append(opt)
            
            # Loop optimization
            if re.search(r'for\s*\(.*\.length.*\)', line):
                opt = GasOptimization(
                    line_number=i,
                    current_gas=800,
                    optimized_gas=300,
                    savings=500,
                    description="Cache dÃ©lku pole pro optimalizaci smyÄky",
                    optimized_code=self._optimize_loop(line)
                )
                optimizations.append(opt)
        
        return optimizations
    
    def _optimize_loop(self, line: str) -> str:
        """Optimalizuje smyÄku pro Ãºsporu plynu"""
        # JednoduchÃ© nahrazenÃ­ pro demonstraci
        if 'array.length' in line:
            return line.replace('i < array.length', 'i < len') + '\n        uint256 len = array.length;'
        return line

class Web3BlockchainConnector:
    """Konektor pro pÅ™ipojenÃ­ k blockchain sÃ­tÃ­m"""
    
    def __init__(self):
        self.networks = {
            'ethereum': {
                'rpc_url': 'https://mainnet.infura.io/v3/YOUR_API_KEY',
                'chain_id': 1
            },
            'polygon': {
                'rpc_url': 'https://polygon-rpc.com/',
                'chain_id': 137
            }
        }
        self.web3_instances = {}
    
    def connect_to_network(self, network: str) -> Web3:
        """PÅ™ipojÃ­ se k zadanÃ© blockchain sÃ­ti"""
        if network not in self.networks:
            raise ValueError(f"NepodporovanÃ¡ sÃ­Å¥: {network}")
        
        if network not in self.web3_instances:
            rpc_url = self.networks[network]['rpc_url']
            self.web3_instances[network] = Web3(Web3.HTTPProvider(rpc_url))
        
        return self.web3_instances[network]
    
    def get_contract_source(self, contract_address: str, network: str = 'ethereum') -> Optional[str]:
        """ZÃ­skÃ¡ source kÃ³d contractu z blockchain exploreru"""
        # Pro demonstraci - v praxi by se pouÅ¾Ã­valy API jako Etherscan
        try:
            if network == 'ethereum':
                api_url = f"https://api.etherscan.io/api?module=contract&action=getsourcecode&address={contract_address}&apikey=YOUR_API_KEY"
            else:
                api_url = f"https://api.polygonscan.com/api?module=contract&action=getsourcecode&address={contract_address}&apikey=YOUR_API_KEY"
            
            response = requests.get(api_url)
            data = response.json()
            
            if data['status'] == '1' and data['result']:
                return data['result'][0]['SourceCode']
            
            return None
        except Exception as e:
            logging.error(f"Chyba pÅ™i zÃ­skÃ¡vÃ¡nÃ­ source kÃ³du: {e}")
            return None

class AIAuditor:
    """AI analyzÃ¡tor vyuÅ¾Ã­vajÃ­cÃ­ LLM pro pokroÄilou analÃ½zu"""
    
    def __init__(self, openai_api_key: str):
        self.llm = OpenAI(temperature=0, openai_api_key=openai_api_key)
        self.embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)
        self.vectorstore = None
        self._setup_knowledge_base()
    
    def _setup_knowledge_base(self):
        """NastavÃ­ knowledge base s informacemi o bezpeÄnosti"""
        security_knowledge = [
            "Reentrancy Ãºtoky jsou jednou z nejÄastÄ›jÅ¡Ã­ch zranitelnostÃ­ v smart contractech.",
            "Integer overflow mÅ¯Å¾e zpÅ¯sobit neoÄekÃ¡vanÃ© chovÃ¡nÃ­ v aritmetickÃ½ch operacÃ­ch.",
            "Access control je kritickÃ½ pro zabezpeÄenÃ­ privilegovanÃ½ch funkcÃ­.",
            "Gas limit Ãºtoky mohou zpÅ¯sobit denial of service.",
            "Front-running mÅ¯Å¾e bÃ½t zneuÅ¾it pro manipulaci s transakcemi.",
        ]
        
        # VytvoÅ™enÃ­ vectorstore pro knowledge retrieval
        texts = [{"page_content": text, "metadata": {"source": "security_kb"}} 
                for text in security_knowledge]
        self.vectorstore = Chroma.from_texts(
            [t["page_content"] for t in texts],
            self.embeddings
        )
    
    async def analyze_with_ai(self, source_code: str) -> Dict[str, Any]:
        """AI analÃ½za source kÃ³du"""
        prompt_template = PromptTemplate(
            input_variables=["code"],
            template="""
            Analyzuj nÃ¡sledujÃ­cÃ­ Solidity smart contract kÃ³d a identifikuj:
            
            1. BezpeÄnostnÃ­ zranitelnosti
            2. MoÅ¾nosti optimalizace plynu
            3. DoporuÄenÃ­ pro zlepÅ¡enÃ­ kÃ³du
            4. CelkovÃ© hodnocenÃ­ kvality (0-100)
            
            KÃ³d:
            {code}
            
            Poskytni strukturovanou analÃ½zu:
            """
        )
        
        chain = LLMChain(llm=self.llm, prompt=prompt_template)
        result = await chain.arun(code=source_code)
        
        return {
            "ai_analysis": result,
            "confidence": 0.85,
            "processing_time": "2.3s"
        }

class MCPAuditorServer:
    """MCP server pro blockchain audit sluÅ¾by"""
    
    def __init__(self, openai_api_key: str):
        self.solidity_analyzer = SolidityAnalyzer()
        self.gas_optimizer = GasOptimizer()
        self.blockchain_connector = Web3BlockchainConnector()
        self.ai_auditor = AIAuditor(openai_api_key)
        self.audit_cache = {}
    
    async def handle_mcp_request(self, message: MCPMessage) -> MCPMessage:
        """ZpracovÃ¡vÃ¡ MCP poÅ¾adavky"""
        try:
            if message.method == "audit_contract":
                result = await self._audit_contract(message.params)
                return MCPMessage(
                    type=MCPMessageType.RESPONSE,
                    id=message.id,
                    result=result
                )
            
            elif message.method == "optimize_gas":
                result = await self._optimize_gas(message.params)
                return MCPMessage(
                    type=MCPMessageType.RESPONSE,
                    id=message.id,
                    result=result
                )
            
            else:
                return MCPMessage(
                    type=MCPMessageType.RESPONSE,
                    id=message.id,
                    error={"code": -32601, "message": "Method not found"}
                )
        
        except Exception as e:
            return MCPMessage(
                type=MCPMessageType.RESPONSE,
                id=message.id,
                error={"code": -32603, "message": str(e)}
            )
    
    async def _audit_contract(self, params: Dict) -> Dict:
        """Provede komplexnÃ­ audit smart contractu"""
        contract_address = params.get("contract_address")
        source_code = params.get("source_code")
        network = params.get("network", "ethereum")
        
        # ZÃ­skÃ¡nÃ­ source kÃ³du pokud nenÃ­ poskytnut
        if not source_code and contract_address:
            source_code = self.blockchain_connector.get_contract_source(
                contract_address, network
            )
        
        if not source_code:
            raise ValueError("Source kÃ³d nebyl nalezen")
        
        # Cache kontrola
        cache_key = hashlib.md5(source_code.encode()).hexdigest()
        if cache_key in self.audit_cache:
            return self.audit_cache[cache_key]
        
        # StatickÃ¡ analÃ½za
        vulnerabilities = self.solidity_analyzer.analyze_vulnerabilities(source_code)
        gas_optimizations = self.gas_optimizer.analyze_gas_optimizations(source_code)
        
        # AI analÃ½za
        ai_result = await self.ai_auditor.analyze_with_ai(source_code)
        
        # VytvoÅ™enÃ­ audit reportu
        report = AuditReport(
            contract_address=contract_address,
            contract_name=params.get("contract_name", "Unknown"),
            source_code=source_code,
            vulnerabilities=vulnerabilities,
            gas_optimizations=gas_optimizations,
            overall_score=self._calculate_score(vulnerabilities),
            recommendations=self._generate_recommendations(vulnerabilities, gas_optimizations),
            analysis_timestamp=str(asyncio.get_event_loop().time())
        )
        
        # Serializace pro MCP odpovÄ›Ä
        result = {
            "report": {
                "contract_address": report.contract_address,
                "contract_name": report.contract_name,
                "overall_score": report.overall_score,
                "vulnerabilities": [
                    {
                        "type": v.type.value,
                        "severity": v.severity,
                        "line_number": v.line_number,
                        "description": v.description,
                        "recommendation": v.recommendation,
                        "confidence": v.confidence
                    } for v in report.vulnerabilities
                ],
                "gas_optimizations": [
                    {
                        "line_number": g.line_number,
                        "savings": g.savings,
                        "description": g.description
                    } for g in report.gas_optimizations
                ],
                "recommendations": report.recommendations,
                "ai_insights": ai_result
            }
        }
        
        # Cache uloÅ¾enÃ­
        self.audit_cache[cache_key] = result
        
        return result
    
    def _calculate_score(self, vulnerabilities: List[Vulnerability]) -> float:
        """VypoÄÃ­tÃ¡ celkovÃ© skÃ³re na zÃ¡kladÄ› zranitelnostÃ­"""
        if not vulnerabilities:
            return 95.0
        
        penalty = 0
        for vuln in vulnerabilities:
            if vuln.severity == "critical":
                penalty += 30
            elif vuln.severity == "high":
                penalty += 20
            elif vuln.severity == "medium":
                penalty += 10
            else:
                penalty += 5
        
        return max(0, 100 - penalty)
    
    def _generate_recommendations(self, vulnerabilities: List[Vulnerability], 
                                 gas_optimizations: List[GasOptimization]) -> List[str]:
        """Generuje doporuÄenÃ­ na zÃ¡kladÄ› analÃ½zy"""
        recommendations = []
        
        if vulnerabilities:
            recommendations.append("Implementujte bezpeÄnostnÃ­ kontroly pro identifikovanÃ© zranitelnosti")
            recommendations.append("PouÅ¾ijte nejnovÄ›jÅ¡Ã­ verzi Solidity kompileru")
            recommendations.append("ProveÄte penetraÄnÃ­ testovÃ¡nÃ­ pÅ™ed nasazenÃ­m")
        
        if gas_optimizations:
            total_savings = sum(opt.savings for opt in gas_optimizations)
            recommendations.append(f"Implementujte gas optimalizace pro Ãºsporu {total_savings} gas")
        
        recommendations.append("VyuÅ¾Ã­vajte ovÄ›Å™enÃ© bezpeÄnostnÃ­ knihovny jako OpenZeppelin")
        recommendations.append("Implementujte monitoring a alerting pro produkÄnÃ­ nasazenÃ­")
        
        return recommendations

# DemonstraÄnÃ­ smart contract pro testovÃ¡nÃ­
SAMPLE_CONTRACT = """
pragma solidity ^0.7.0;

contract VulnerableContract {
    mapping(address => uint256) public balances;
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // Vulnerable to reentrancy
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        balances[msg.sender] -= amount;
    }
    
    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // Vulnerable to integer overflow
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
    
    function emergencyWithdraw() public {
        // Missing access control
        selfdestruct(payable(msg.sender));
    }
}
"""

async def main():
    """HlavnÃ­ funkce pro demonstraci"""
    # Inicializace
    openai_api_key = "your-openai-api-key-here"  # NahraÄte skuteÄnÃ½m klÃ­Äem
    mcp_server = MCPAuditorServer(openai_api_key)
    
    print("ğŸ” SpouÅ¡tÃ­m AI Blockchain Smart Contract Auditor...")
    
    # MCP poÅ¾adavek pro audit
    audit_request = MCPMessage(
        type=MCPMessageType.REQUEST,
        id="audit-001",
        method="audit_contract",
        params={
            "contract_name": "VulnerableContract",
            "source_code": SAMPLE_CONTRACT,
            "network": "ethereum"
        }
    )
    
    # ZpracovÃ¡nÃ­ auditu
    print("ğŸ“‹ ProvÃ¡dÃ­m audit smart contractu...")
    response = await mcp_server.handle_mcp_request(audit_request)
    
    if response.result:
        report = response.result["report"]
        print(f"\nâœ… Audit dokonÄen!")
        print(f"ğŸ“Š CelkovÃ© skÃ³re: {report['overall_score']}/100")
        print(f"ğŸš¨ NalezenÃ½ch zranitelnostÃ­: {len(report['vulnerabilities'])}")
        print(f"âš¡ Gas optimalizacÃ­: {len(report['gas_optimizations'])}")
        
        print("\nğŸ”´ KritickÃ© zranitelnosti:")
        for vuln in report['vulnerabilities']:
            if vuln['severity'] in ['critical', 'high']:
                print(f"  - Å˜Ã¡dek {vuln['line_number']}: {vuln['description']}")
                print(f"    DoporuÄenÃ­: {vuln['recommendation']}")
        
        print("\nğŸ’¡ DoporuÄenÃ­:")
        for rec in report['recommendations'][:3]:
            print(f"  - {rec}")
    
    else:
        print(f"âŒ Chyba pÅ™i auditu: {response.error}")

if __name__ == "__main__":
    # Setup logging
    logging.basicConfig(level=logging.INFO)
    
    # Instalace Solidity kompileru (pokud nenÃ­ nainstalovÃ¡n)
    try:
        if not get_installed_solc_versions():
            install_solc('0.8.19')
    except Exception as e:
        print(f"âš ï¸  VarovÃ¡nÃ­: NepodaÅ™ilo se nainstalovat Solidity kompilÃ¡tor: {e}")
    
    # SpuÅ¡tÄ›nÃ­
    asyncio.run(main())
````

````bash
# ZÃ¡vislosti pro Blockchain Smart Contract Auditor

# Core AI/ML frameworks
openai==1.3.0
langchain==0.0.340
langchain-community==0.0.10
chromadb==0.4.18

# Blockchain and Web3
web3==6.12.0
py-solc-x==2.0.2
eth-account==0.9.0
eth-utils==2.3.0

# Data processing
requests==2.31.0
numpy==1.24.3
pandas==2.1.3

# Security and crypto
cryptography==41.0.8
pycryptodome==3.19.0

# Async and networking
aiohttp==3.9.1
websockets==12.0

# Development and testing
pytest==7.4.3
pytest-asyncio==0.21.1
black==23.11.0
mypy==1.7.1
````

````python
"""
Testy pro Blockchain Smart Contract Auditor
"""

import pytest
import asyncio
from blockchain_auditor_mcp import (
    MCPAuditorServer, SolidityAnalyzer, GasOptimizer,
    VulnerabilityType, MCPMessage, MCPMessageType
)

class TestSolidityAnalyzer:
    """Testy pro Solidity analyzÃ¡tor"""
    
    def setup_method(self):
        self.analyzer = SolidityAnalyzer()
    
    def test_reentrancy_detection(self):
        vulnerable_code = """
        function withdraw() public {
            (bool success, ) = msg.sender.call{value: amount}("");
            balances[msg.sender] -= amount;
        }
        """
        
        vulnerabilities = self.analyzer.analyze_vulnerabilities(vulnerable_code)
        reentrancy_vulns = [v for v in vulnerabilities if v.type == VulnerabilityType.REENTRANCY]
        
        assert len(reentrancy_vulns) > 0
        assert reentrancy_vulns[0].severity == "high"
    
    def test_safe_code_no_vulnerabilities(self):
        safe_code = """
        pragma solidity ^0.8.0;
        function safeFunction() public pure returns (uint256) {
            return 42;
        }
        """
        
        vulnerabilities = self.analyzer.analyze_vulnerabilities(safe_code)
        assert len(vulnerabilities) == 0

class TestGasOptimizer:
    """Testy pro Gas optimalizÃ¡tor"""
    
    def setup_method(self):
        self.optimizer = GasOptimizer()
    
    def test_storage_optimization(self):
        code_with_storage = """
        function processData() public {
            DataStruct storage data = userdata[msg.sender];
            data.value = 100;
        }
        """
        
        optimizations = self.optimizer.analyze_gas_optimizations(code_with_storage)
        assert len(optimizations) > 0
        assert optimizations[0].savings > 0

@pytest.mark.asyncio
class TestMCPAuditorServer:
    """Testy pro MCP Auditor Server"""
    
    async def test_audit_request_processing(self):
        # Mock pro OpenAI API klÃ­Ä
        server = MCPAuditorServer("test-api-key")
        
        request = MCPMessage(
            type=MCPMessageType.REQUEST,
            id="test-001",
            method="audit_contract",
            params={
                "contract_name": "TestContract",
                "source_code": "pragma solidity ^0.8.0; contract Test {}",
                "network": "ethereum"
            }
        )
        
        # Note: Tento test vyÅ¾aduje skuteÄnÃ½ API klÃ­Ä pro plnou funkcionalitu
        # V produkÄnÃ­m prostÅ™edÃ­ by se pouÅ¾Ã­valy mocks
        try:
            response = await server.handle_mcp_request(request)
            assert response.type == MCPMessageType.RESPONSE
            assert response.id == "test-001"
        except Exception as e:
            # OÄekÃ¡vÃ¡no bez platnÃ©ho API klÃ­Äe
            assert "API key" in str(e) or "openai" in str(e).lower()

if __name__ == "__main__":
    pytest.main([__file__])
````

## 5. ShrnutÃ­ Projektu

**AI-Powered Blockchain Smart Contract Auditor** pÅ™edstavuje pokroÄilÃ© Å™eÅ¡enÃ­ pro automatizaci a zlepÅ¡enÃ­ procesu auditovÃ¡nÃ­ smart contractÅ¯ na blockchainu. Projekt kombinuje sÃ­lu umÄ›lÃ© inteligence s expertnÃ­mi znalostmi v oblasti blockchain bezpeÄnosti.

### KlÃ­ÄovÃ© Hodnoty:

1. **Automatizace**: Redukuje Äas potÅ™ebnÃ½ pro audit z tÃ½dnÅ¯ na hodiny
2. **PÅ™esnost**: Kombinuje statickou analÃ½zu s AI pro minimalizaci false positives
3. **Å kÃ¡lovatelnost**: Podporuje audit velkÃ©ho mnoÅ¾stvÃ­ contractÅ¯ souÄasnÄ›
4. **Dostupnost**: Demokratizuje pÅ™Ã­stup k profesionÃ¡lnÃ­m auditÅ¯m
5. **VzdÄ›lÃ¡vÃ¡nÃ­**: Poskytuje detailnÃ­ vysvÄ›tlenÃ­ a doporuÄenÃ­ pro vÃ½vojÃ¡Å™e

### TechnologickÃ© Inovace:

- **Model Context Protocol (MCP)** pro standardizovanou komunikaci
- **Multi-layer analÃ½za** kombinujÃ­cÃ­ statickÃ© nÃ¡stroje s AI
- **Real-time monitoring** nasazenÃ½ch contractÅ¯
- **Cross-chain podpora** pro rÅ¯znÃ© EVM kompatibilnÃ­ sÃ­tÄ›
- **Knowledge base** s aktuÃ¡lnÃ­mi bezpeÄnostnÃ­mi vzory

### BudoucÃ­ RozÅ¡Ã­Å™enÃ­:

- Podpora pro dalÅ¡Ã­ blockchain platformy (Solana, Cardano)
- Integration s CI/CD pipeline pro automatickÃ© audity
- PrediktivnÃ­ analÃ½za pro identifikaci novÃ½ch typÅ¯ ÃºtokÅ¯
- Community feedback systÃ©m pro zlepÅ¡ovÃ¡nÃ­ detekce
- Advanced reporting s grafickou vizualizacÃ­ rizik

Tento projekt mÃ¡ potenciÃ¡l vÃ½znamnÄ› zvÃ½Å¡it bezpeÄnost blockchain ekosystÃ©mu a urychlit adopci decentralizovanÃ½ch aplikacÃ­ prostÅ™ednictvÃ­m dÅ¯vÄ›ryhodnÃ½ch a dostupnÃ½ch auditnÃ­ch sluÅ¾eb.