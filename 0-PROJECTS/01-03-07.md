<small>Claude Sonnet 4 **(Context-Aware Code Generation & Debugging Tool - Intelligent Development Assistant)**</small>
# Context-Aware Code Generation & Debugging Tool

## Key Concepts Explanation

### Model Context Protocol (MCP) for Development
Advanced development context management framework that maintains comprehensive codebase understanding, developer preferences, project patterns, coding standards, and debugging history across complex development workflows, enabling persistent code context awareness and intelligent assistance that adapts to specific project needs and development patterns.

### GitHub Copilot Alternative Architecture
Intelligent code generation system that provides context-aware suggestions, code completion, and development assistance through advanced language models, AST analysis, and project understanding while maintaining privacy, customization, and integration capabilities for diverse development environments and coding workflows.

### Abstract Syntax Tree (AST) Parsing
Sophisticated code analysis technique that converts source code into tree-structured representations enabling deep understanding of code structure, relationships, dependencies, and semantic meaning for intelligent code generation, error detection, refactoring suggestions, and comprehensive code quality analysis.

### Intelligent Error Correction
Advanced debugging system that analyzes code errors, identifies root causes, suggests fixes, and provides comprehensive solutions through pattern recognition, static analysis, and contextual understanding while learning from developer feedback and project-specific error patterns.

### MCP-Guided Prompts
Context-enhanced prompt engineering system that leverages comprehensive project context, developer history, and codebase knowledge to generate highly relevant, accurate, and project-specific code suggestions and solutions while maintaining consistency with existing code patterns and development standards.

## Comprehensive Project Explanation

The Context-Aware Code Generation & Debugging Tool revolutionizes software development by creating intelligent, context-aware coding environments that understand project structure, developer patterns, and codebase relationships while providing sophisticated code generation, error detection, and debugging assistance through advanced AI-powered analysis and MCP-driven context management.

### Objectives
- **Intelligent Code Understanding**: Develop comprehensive AST-based code analysis systems that understand project structure, dependencies, patterns, and relationships while maintaining deep contextual awareness of codebase evolution and development practices
- **Context-Aware Generation**: Create sophisticated code generation systems that produce relevant, high-quality code suggestions based on project context, coding standards, and developer preferences while ensuring consistency and maintainability
- **Advanced Error Detection**: Implement intelligent debugging systems that identify errors, analyze root causes, and provide comprehensive solutions while learning from project patterns and developer feedback
- **Development Workflow Integration**: Build seamless integration systems that work within existing development environments while providing real-time assistance, code analysis, and intelligent suggestions
- **Privacy-Focused Architecture**: Design secure, on-premise capable systems that maintain code privacy while providing enterprise-grade functionality and customization capabilities

### Challenges
- **Code Context Complexity**: Managing vast codebase contexts including dependencies, patterns, standards, and relationships while maintaining real-time performance and accuracy across large-scale projects and diverse programming languages
- **Real-Time Performance**: Providing instant code suggestions and error analysis while processing complex AST structures, dependency graphs, and contextual information without impacting development workflow performance
- **Multi-Language Support**: Supporting diverse programming languages, frameworks, and development patterns while maintaining consistent quality and accuracy across different syntax structures and paradigms
- **Error Pattern Recognition**: Identifying subtle bugs, performance issues, and code quality problems while minimizing false positives and providing actionable, accurate debugging suggestions
- **Development Environment Integration**: Seamlessly integrating with various IDEs, editors, and development workflows while maintaining functionality, performance, and user experience across different platforms

### Potential Impact
This system could transform software development productivity by providing intelligent, context-aware coding assistance that reduces development time, improves code quality, and enhances debugging efficiency while maintaining developer autonomy and code privacy.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import ast
import inspect
import json
import logging
import os
import re
import uuid
from typing import Dict, List, Optional, Any, Union, Tuple, Set
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
import hashlib
import pickle
from collections import defaultdict, deque

# Core analysis libraries
import astroid
import pylint.lint
from radon.complexity import cc_visit
from radon.metrics import mi_visit
import bandit
from bandit.core import manager as bandit_manager

# Language processing
from tree_sitter import Language, Parser
import tree_sitter_python as tspython
import tree_sitter_javascript as tsjs

# AI and ML libraries
from sentence_transformers import SentenceTransformer
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# LangChain for advanced LLM operations
from langchain.chat_models import ChatOpenAI
from langchain.embeddings import OpenAIEmbeddings
from langchain.prompts import PromptTemplate
from langchain.schema import Document
from langchain.vectorstores import FAISS
from langchain.text_splitter import RecursiveCharacterTextSplitter

# Git integration
import git
from git import Repo

# Database and persistence
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, DateTime, Text, JSON, Integer, Boolean, Float, LargeBinary

# Web framework
from fastapi import FastAPI, WebSocket, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn

# File monitoring
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Code formatting
import black
import isort
import autopep8

# Testing utilities
import pytest
import coverage

import warnings
warnings.filterwarnings('ignore')

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database Models
Base = declarative_base()

class CodeProject(Base):
    __tablename__ = "code_projects"
    
    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    path = Column(String, nullable=False)
    language = Column(String)
    frameworks = Column(JSON)
    dependencies = Column(JSON)
    coding_standards = Column(JSON)
    patterns = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_analyzed = Column(DateTime)
    context_embedding = Column(LargeBinary)

class CodeFile(Base):
    __tablename__ = "code_files"
    
    id = Column(String, primary_key=True)
    project_id = Column(String, nullable=False)
    file_path = Column(String, nullable=False)
    content_hash = Column(String)
    ast_structure = Column(JSON)
    complexity_score = Column(Float)
    quality_metrics = Column(JSON)
    dependencies = Column(JSON)
    functions = Column(JSON)
    classes = Column(JSON)
    imports = Column(JSON)
    last_modified = Column(DateTime)
    embedding_vector = Column(LargeBinary)

class CodeError(Base):
    __tablename__ = "code_errors"
    
    id = Column(String, primary_key=True)
    file_id = Column(String, nullable=False)
    error_type = Column(String)
    error_message = Column(Text)
    line_number = Column(Integer)
    severity = Column(String)
    suggested_fix = Column(Text)
    context = Column(JSON)
    resolved = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)

class DeveloperContext(Base):
    __tablename__ = "developer_contexts"
    
    id = Column(String, primary_key=True)
    developer_id = Column(String, nullable=False)
    preferences = Column(JSON)
    coding_patterns = Column(JSON)
    recent_activity = Column(JSON)
    skill_assessment = Column(JSON)
    project_contexts = Column(JSON)
    suggestion_feedback = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime)

class CodeSuggestion(Base):
    __tablename__ = "code_suggestions"
    
    id = Column(String, primary_key=True)
    developer_id = Column(String)
    file_id = Column(String)
    suggestion_type = Column(String)  # completion, refactor, fix, generate
    context = Column(JSON)
    suggestion_content = Column(Text)
    confidence_score = Column(Float)
    accepted = Column(Boolean)
    feedback = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

# Data Classes
@dataclass
class CodeContext:
    file_path: str
    content: str
    cursor_position: int
    surrounding_code: str
    project_context: Dict[str, Any]
    ast_info: Dict[str, Any]

@dataclass
class ErrorContext:
    error_type: str
    message: str
    line_number: int
    file_path: str
    stack_trace: str
    surrounding_code: str

@dataclass
class SuggestionRequest:
    context: CodeContext
    suggestion_type: str
    max_suggestions: int = 3
    include_explanations: bool = True

class MCPDevelopmentManager:
    """MCP-based development context management"""
    
    def __init__(self, session_factory):
        self.session_factory = session_factory
        self.developer_contexts = {}
        self.project_contexts = {}
        self.code_patterns = defaultdict(list)
        self.error_patterns = defaultdict(list)
        self.suggestion_history = defaultdict(deque)
        
    async def create_developer_context(self, developer_id: str, 
                                     preferences: Dict[str, Any]) -> str:
        """Create comprehensive developer context"""
        try:
            context_id = str(uuid.uuid4())
            
            self.developer_contexts[developer_id] = {
                "context_id": context_id,
                "preferences": preferences,
                "coding_style": preferences.get("coding_style", {}),
                "language_preferences": preferences.get("languages", []),
                "framework_experience": preferences.get("frameworks", {}),
                "activity_history": deque(maxlen=1000),
                "error_patterns": defaultdict(int),
                "suggestion_preferences": defaultdict(float),
                "code_quality_standards": preferences.get("quality_standards", {}),
                "debugging_patterns": [],
                "collaboration_style": preferences.get("collaboration", {})
            }
            
            # Store in database
            async with self.session_factory() as session:
                dev_context = DeveloperContext(
                    id=context_id,
                    developer_id=developer_id,
                    preferences=preferences,
                    coding_patterns={},
                    recent_activity=[],
                    skill_assessment={},
                    project_contexts={}
                )
                session.add(dev_context)
                await session.commit()
            
            logger.info(f"Created developer context for {developer_id}")
            return context_id
            
        except Exception as e:
            logger.error(f"Developer context creation failed: {e}")
            raise
    
    async def update_developer_context(self, developer_id: str, 
                                     activity_data: Dict[str, Any]):
        """Update developer context based on activity"""
        try:
            if developer_id not in self.developer_contexts:
                return
            
            context = self.developer_contexts[developer_id]
            
            # Update activity history
            context["activity_history"].append({
                "timestamp": datetime.utcnow(),
                "activity": activity_data
            })
            
            # Update coding patterns
            if "code_pattern" in activity_data:
                pattern = activity_data["code_pattern"]
                self.code_patterns[developer_id].append(pattern)
            
            # Update error patterns
            if "error_info" in activity_data:
                error_type = activity_data["error_info"]["type"]
                context["error_patterns"][error_type] += 1
            
            # Update suggestion preferences
            if "suggestion_feedback" in activity_data:
                feedback = activity_data["suggestion_feedback"]
                suggestion_type = feedback["type"]
                rating = feedback["rating"]
                
                current_pref = context["suggestion_preferences"][suggestion_type]
                context["suggestion_preferences"][suggestion_type] = (
                    current_pref * 0.9 + rating * 0.1
                )
            
        except Exception as e:
            logger.error(f"Developer context update failed: {e}")
    
    async def analyze_project_context(self, project_path: str) -> Dict[str, Any]:
        """Analyze and create project context"""
        try:
            project_id = str(uuid.uuid4())
            
            # Analyze project structure
            structure_analysis = await self._analyze_project_structure(project_path)
            
            # Detect frameworks and patterns
            framework_analysis = await self._detect_frameworks(project_path)
            
            # Analyze coding patterns
            pattern_analysis = await self._analyze_coding_patterns(project_path)
            
            # Create project context
            project_context = {
                "project_id": project_id,
                "path": project_path,
                "structure": structure_analysis,
                "frameworks": framework_analysis,
                "patterns": pattern_analysis,
                "coding_standards": await self._detect_coding_standards(project_path),
                "dependencies": await self._analyze_dependencies(project_path),
                "architecture": await self._analyze_architecture(project_path)
            }
            
            self.project_contexts[project_id] = project_context
            
            # Store in database
            async with self.session_factory() as session:
                project = CodeProject(
                    id=project_id,
                    name=Path(project_path).name,
                    path=project_path,
                    language=framework_analysis.get("primary_language", "python"),
                    frameworks=framework_analysis.get("frameworks", []),
                    dependencies=project_context["dependencies"],
                    coding_standards=project_context["coding_standards"],
                    patterns=pattern_analysis
                )
                session.add(project)
                await session.commit()
            
            return project_context
            
        except Exception as e:
            logger.error(f"Project context analysis failed: {e}")
            return {}
    
    async def _analyze_project_structure(self, project_path: str) -> Dict[str, Any]:
        """Analyze project directory structure"""
        structure = {
            "total_files": 0,
            "code_files": 0,
            "test_files": 0,
            "config_files": 0,
            "directories": [],
            "file_types": defaultdict(int)
        }
        
        for root, dirs, files in os.walk(project_path):
            structure["directories"].extend(dirs)
            
            for file in files:
                structure["total_files"] += 1
                
                ext = Path(file).suffix
                structure["file_types"][ext] += 1
                
                if ext in ['.py', '.js', '.java', '.cpp', '.c', '.go', '.rs']:
                    structure["code_files"] += 1
                elif 'test' in file.lower() or ext in ['.test.js', '_test.py']:
                    structure["test_files"] += 1
                elif ext in ['.json', '.yaml', '.yml', '.toml', '.ini']:
                    structure["config_files"] += 1
        
        return structure
    
    def get_enhanced_context(self, developer_id: str, project_id: str) -> Dict[str, Any]:
        """Get enhanced context for code assistance"""
        dev_context = self.developer_contexts.get(developer_id, {})
        project_context = self.project_contexts.get(project_id, {})
        
        return {
            "developer": dev_context,
            "project": project_context,
            "recent_patterns": self.code_patterns[developer_id][-10:],
            "common_errors": dict(dev_context.get("error_patterns", {})),
            "suggestion_preferences": dict(dev_context.get("suggestion_preferences", {}))
        }

class ASTCodeAnalyzer:
    """Advanced AST-based code analysis"""
    
    def __init__(self):
        # Initialize Tree-sitter parsers
        self.python_parser = Parser()
        self.js_parser = Parser()
        
        # Load languages
        PY_LANGUAGE = Language(tspython.language(), "python")
        JS_LANGUAGE = Language(tsjs.language(), "javascript")
        
        self.python_parser.set_language(PY_LANGUAGE)
        self.js_parser.set_language(JS_LANGUAGE)
        
        # Pattern analyzers
        self.complexity_analyzer = cc_visit
        self.maintainability_analyzer = mi_visit
        
    async def analyze_code_file(self, file_path: str, content: str) -> Dict[str, Any]:
        """Comprehensive code file analysis"""
        try:
            analysis = {
                "file_path": file_path,
                "language": self._detect_language(file_path),
                "ast_structure": {},
                "complexity": {},
                "quality_metrics": {},
                "dependencies": [],
                "functions": [],
                "classes": [],
                "imports": [],
                "potential_issues": []
            }
            
            language = analysis["language"]
            
            if language == "python":
                analysis.update(await self._analyze_python_code(content))
            elif language == "javascript":
                analysis.update(await self._analyze_javascript_code(content))
            
            # General analysis
            analysis["complexity"] = await self._calculate_complexity(content, language)
            analysis["quality_metrics"] = await self._calculate_quality_metrics(content)
            analysis["potential_issues"] = await self._detect_potential_issues(content, language)
            
            return analysis
            
        except Exception as e:
            logger.error(f"Code analysis failed for {file_path}: {e}")
            return {}
    
    async def _analyze_python_code(self, content: str) -> Dict[str, Any]:
        """Analyze Python code using AST"""
        try:
            tree = ast.parse(content)
            
            analysis = {
                "functions": [],
                "classes": [],
                "imports": [],
                "dependencies": [],
                "ast_structure": {}
            }
            
            # Extract functions
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    func_info = {
                        "name": node.name,
                        "line": node.lineno,
                        "args": [arg.arg for arg in node.args.args],
                        "decorators": [self._get_decorator_name(d) for d in node.decorator_list],
                        "docstring": ast.get_docstring(node),
                        "complexity": await self._calculate_function_complexity(node)
                    }
                    analysis["functions"].append(func_info)
                
                elif isinstance(node, ast.ClassDef):
                    class_info = {
                        "name": node.name,
                        "line": node.lineno,
                        "bases": [self._get_name(base) for base in node.bases],
                        "methods": [],
                        "docstring": ast.get_docstring(node)
                    }
                    
                    # Extract methods
                    for item in node.body:
                        if isinstance(item, ast.FunctionDef):
                            method_info = {
                                "name": item.name,
                                "line": item.lineno,
                                "args": [arg.arg for arg in item.args.args]
                            }
                            class_info["methods"].append(method_info)
                    
                    analysis["classes"].append(class_info)
                
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    import_info = self._extract_import_info(node)
                    analysis["imports"].append(import_info)
            
            # Build AST structure representation
            analysis["ast_structure"] = self._build_ast_structure(tree)
            
            return analysis
            
        except Exception as e:
            logger.error(f"Python AST analysis failed: {e}")
            return {}
    
    def _get_decorator_name(self, decorator) -> str:
        """Extract decorator name from AST node"""
        if isinstance(decorator, ast.Name):
            return decorator.id
        elif isinstance(decorator, ast.Attribute):
            return f"{self._get_name(decorator.value)}.{decorator.attr}"
        return "unknown"
    
    def _get_name(self, node) -> str:
        """Extract name from AST node"""
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            return f"{self._get_name(node.value)}.{node.attr}"
        return "unknown"
    
    def _extract_import_info(self, node) -> Dict[str, Any]:
        """Extract import information from AST node"""
        if isinstance(node, ast.Import):
            return {
                "type": "import",
                "modules": [alias.name for alias in node.names],
                "line": node.lineno
            }
        elif isinstance(node, ast.ImportFrom):
            return {
                "type": "from_import",
                "module": node.module,
                "names": [alias.name for alias in node.names],
                "line": node.lineno
            }
        return {}
    
    async def get_code_context(self, file_path: str, line_number: int, 
                             window_size: int = 10) -> Dict[str, Any]:
        """Get code context around specific line"""
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
            
            start_line = max(0, line_number - window_size)
            end_line = min(len(lines), line_number + window_size)
            
            context_lines = lines[start_line:end_line]
            
            # Analyze context
            context_code = ''.join(context_lines)
            analysis = await self.analyze_code_file(file_path, context_code)
            
            return {
                "file_path": file_path,
                "target_line": line_number,
                "context_lines": context_lines,
                "start_line": start_line,
                "end_line": end_line,
                "analysis": analysis,
                "surrounding_functions": self._find_surrounding_functions(
                    analysis.get("functions", []), line_number
                ),
                "surrounding_classes": self._find_surrounding_classes(
                    analysis.get("classes", []), line_number
                )
            }
            
        except Exception as e:
            logger.error(f"Context extraction failed: {e}")
            return {}

class IntelligentCodeGenerator:
    """AI-powered code generation with context awareness"""
    
    def __init__(self, mcp_manager: MCPDevelopmentManager, ast_analyzer: ASTCodeAnalyzer):
        self.mcp_manager = mcp_manager
        self.ast_analyzer = ast_analyzer
        
        # Initialize LLM
        self.llm = ChatOpenAI(model_name="gpt-4", temperature=0.3)
        
        # Code embedding model
        self.code_embedder = SentenceTransformer('microsoft/codebert-base')
        
        # Pattern templates
        self.code_templates = {
            "function": self._load_function_templates(),
            "class": self._load_class_templates(),
            "test": self._load_test_templates(),
            "fix": self._load_fix_templates()
        }
        
    async def generate_code_completion(self, request: SuggestionRequest) -> List[Dict[str, Any]]:
        """Generate intelligent code completions"""
        try:
            context = request.context
            
            # Get enhanced context
            enhanced_context = self.mcp_manager.get_enhanced_context(
                "current_user",  # In real app, get from session
                context.project_context.get("project_id", "")
            )
            
            # Analyze current code context
            code_analysis = await self.ast_analyzer.get_code_context(
                context.file_path, 
                self._line_from_position(context.content, context.cursor_position)
            )
            
            # Generate context-aware prompts
            prompts = await self._generate_context_prompts(
                context, enhanced_context, code_analysis, request.suggestion_type
            )
            
            suggestions = []
            for prompt in prompts[:request.max_suggestions]:
                suggestion = await self._generate_single_suggestion(
                    prompt, context, enhanced_context
                )
                if suggestion:
                    suggestions.append(suggestion)
            
            return suggestions
            
        except Exception as e:
            logger.error(f"Code completion generation failed: {e}")
            return []
    
    async def _generate_context_prompts(self, context: CodeContext, 
                                      enhanced_context: Dict[str, Any],
                                      code_analysis: Dict[str, Any],
                                      suggestion_type: str) -> List[str]:
        """Generate context-aware prompts"""
        
        # Extract relevant information
        project_patterns = enhanced_context.get("project", {}).get("patterns", {})
        coding_style = enhanced_context.get("developer", {}).get("coding_style", {})
        recent_patterns = enhanced_context.get("recent_patterns", [])
        
        # Build context information
        context_info = []
        
        # Project context
        if project_patterns:
            context_info.append(f"Project patterns: {json.dumps(project_patterns, indent=2)}")
        
        # Coding style preferences
        if coding_style:
            context_info.append(f"Coding style: {json.dumps(coding_style, indent=2)}")
        
        # Current file context
        if code_analysis.get("functions"):
            functions_summary = [f["name"] for f in code_analysis["functions"][:5]]
            context_info.append(f"Current file functions: {functions_summary}")
        
        if code_analysis.get("classes"):
            classes_summary = [c["name"] for c in code_analysis["classes"][:3]]
            context_info.append(f"Current file classes: {classes_summary}")
        
        # Surrounding code
        surrounding_code = context.surrounding_code
        
        prompts = []
        
        if suggestion_type == "completion":
            prompt = f"""
            Generate a code completion for the following context:
            
            File: {context.file_path}
            
            Project Context:
            {chr(10).join(context_info)}
            
            Surrounding Code:
            ```
            {surrounding_code}
            ```
            
            Complete the code at the cursor position with:
            1. Syntactically correct code
            2. Following project patterns and style
            3. Appropriate variable/function names
            4. Proper error handling if needed
            
            Provide only the completion code without explanations.
            """
            prompts.append(prompt)
        
        elif suggestion_type == "function":
            prompt = f"""
            Generate a function implementation based on the context:
            
            File: {context.file_path}
            
            Project Context:
            {chr(10).join(context_info)}
            
            Surrounding Code:
            ```
            {surrounding_code}
            ```
            
            Generate a complete function that:
            1. Follows the project's coding patterns
            2. Includes proper docstring
            3. Handles edge cases appropriately
            4. Uses consistent naming conventions
            5. Includes type hints if the project uses them
            
            Function implementation:
            """
            prompts.append(prompt)
        
        elif suggestion_type == "refactor":
            prompt = f"""
            Suggest refactoring improvements for the following code:
            
            File: {context.file_path}
            
            Project Context:
            {chr(10).join(context_info)}
            
            Code to refactor:
            ```
            {surrounding_code}
            ```
            
            Provide refactoring suggestions that:
            1. Improve code readability and maintainability
            2. Follow project patterns and best practices
            3. Optimize performance where applicable
            4. Maintain existing functionality
            5. Improve error handling
            
            Refactored code:
            """
            prompts.append(prompt)
        
        return prompts
    
    async def _generate_single_suggestion(self, prompt: str, context: CodeContext,
                                        enhanced_context: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a single code suggestion"""
        try:
            # Generate code using LLM
            response = await self.llm.agenerate([[{"role": "user", "content": prompt}]])
            suggestion_code = response.generations[0][0].text.strip()
            
            # Clean up the suggestion
            suggestion_code = self._clean_code_suggestion(suggestion_code)
            
            # Calculate confidence score
            confidence = await self._calculate_suggestion_confidence(
                suggestion_code, context, enhanced_context
            )
            
            # Generate explanation if requested
            explanation = await self._generate_explanation(
                suggestion_code, context, prompt
            )
            
            return {
                "code": suggestion_code,
                "confidence": confidence,
                "explanation": explanation,
                "type": "completion",
                "metadata": {
                    "generated_at": datetime.utcnow().isoformat(),
                    "context_used": len(prompt),
                    "file_path": context.file_path
                }
            }
            
        except Exception as e:
            logger.error(f"Single suggestion generation failed: {e}")
            return None
    
    def _clean_code_suggestion(self, code: str) -> str:
        """Clean and format code suggestion"""
        # Remove markdown code blocks
        code = re.sub(r'```\w*\n?', '', code)
        code = re.sub(r'```', '', code)
        
        # Remove common prefixes
        code = re.sub(r'^(Here\'s|Here is|The code|Code:)\s*', '', code, flags=re.IGNORECASE)
        
        # Format with black if it's Python code
        try:
            if code.strip().startswith(('def ', 'class ', 'import ', 'from ')):
                code = black.format_str(code, mode=black.Mode())
        except:
            pass  # If formatting fails, return original
        
        return code.strip()
    
    async def _calculate_suggestion_confidence(self, code: str, context: CodeContext,
                                             enhanced_context: Dict[str, Any]) -> float:
        """Calculate confidence score for suggestion"""
        try:
            confidence_factors = []
            
            # Syntax validity check
            try:
                ast.parse(code)
                confidence_factors.append(0.3)  # Valid syntax
            except:
                confidence_factors.append(0.0)  # Invalid syntax
            
            # Pattern matching with project
            project_patterns = enhanced_context.get("project", {}).get("patterns", {})
            if project_patterns:
                pattern_match = self._calculate_pattern_match(code, project_patterns)
                confidence_factors.append(pattern_match * 0.25)
            
            # Style consistency
            coding_style = enhanced_context.get("developer", {}).get("coding_style", {})
            if coding_style:
                style_match = self._calculate_style_match(code, coding_style)
                confidence_factors.append(style_match * 0.2)
            
            # Context relevance
            context_relevance = await self._calculate_context_relevance(code, context)
            confidence_factors.append(context_relevance * 0.25)
            
            return min(1.0, sum(confidence_factors))
            
        except Exception as e:
            logger.error(f"Confidence calculation failed: {e}")
            return 0.5

class ErrorDetectionEngine:
    """Advanced error detection and correction system"""
    
    def __init__(self, ast_analyzer: ASTCodeAnalyzer, mcp_manager: MCPDevelopmentManager):
        self.ast_analyzer = ast_analyzer
        self.mcp_manager = mcp_manager
        
        # Initialize static analysis tools
        self.pylint_manager = pylint.lint.PyLinter()
        self.bandit_manager = bandit_manager.BanditManager()
        
        # Error patterns
        self.common_errors = self._load_error_patterns()
        self.fix_templates = self._load_fix_templates()
        
    async def detect_errors(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        """Comprehensive error detection"""
        try:
            errors = []
            
            # Syntax errors
            syntax_errors = await self._detect_syntax_errors(content)
            errors.extend(syntax_errors)
            
            # Static analysis errors
            static_errors = await self._run_static_analysis(file_path, content)
            errors.extend(static_errors)
            
            # Logic errors
            logic_errors = await self._detect_logic_errors(content)
            errors.extend(logic_errors)
            
            # Security issues
            security_issues = await self._detect_security_issues(file_path, content)
            errors.extend(security_issues)
            
            # Performance issues
            performance_issues = await self._detect_performance_issues(content)
            errors.extend(performance_issues)
            
            # Rank errors by severity
            ranked_errors = sorted(errors, key=lambda x: self._get_severity_score(x["severity"]), reverse=True)
            
            return ranked_errors
            
        except Exception as e:
            logger.error(f"Error detection failed: {e}")
            return []
    
    async def suggest_error_fix(self, error_context: ErrorContext, 
                              enhanced_context: Dict[str, Any]) -> Dict[str, Any]:
        """Generate intelligent error fix suggestions"""
        try:
            # Analyze error context
            error_analysis = await self._analyze_error_context(error_context)
            
            # Find similar errors in history
            similar_errors = await self._find_similar_errors(error_context, enhanced_context)
            
            # Generate fix suggestions
            fix_suggestions = await self._generate_fix_suggestions(
                error_context, error_analysis, similar_errors, enhanced_context
            )
            
            return {
                "error_id": str(uuid.uuid4()),
                "error_context": error_context.__dict__,
                "analysis": error_analysis,
                "suggestions": fix_suggestions,
                "confidence": await self._calculate_fix_confidence(fix_suggestions),
                "generated_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Error fix suggestion failed: {e}")
            return {}
    
    async def _detect_syntax_errors(self, content: str) -> List[Dict[str, Any]]:
        """Detect syntax errors"""
        errors = []
        
        try:
            ast.parse(content)
        except SyntaxError as e:
            errors.append({
                "type": "syntax_error",
                "message": str(e),
                "line": e.lineno,
                "severity": "high",
                "suggestion": await self._suggest_syntax_fix(e, content)
            })
        
        return errors
    
    async def _suggest_syntax_fix(self, syntax_error: SyntaxError, content: str) -> str:
        """Suggest fix for syntax error"""
        error_msg = str(syntax_error)
        
        common_fixes = {
            "invalid syntax": "Check for missing parentheses, brackets, or quotes",
            "unexpected EOF": "Check for unclosed parentheses, brackets, or quotes",
            "indent": "Fix indentation - use consistent spaces or tabs",
            "unindent": "Fix indentation - ensure proper alignment"
        }
        
        for pattern, fix in common_fixes.items():
            if pattern in error_msg.lower():
                return fix
        
        return "Review syntax around the indicated line"

# Continue with additional classes...

class DevelopmentAPI:
    """FastAPI application for development assistance"""
    
    def __init__(self, code_generator: IntelligentCodeGenerator, 
                 error_engine: ErrorDetectionEngine,
                 mcp_manager: MCPDevelopmentManager,
                 session_factory):
        self.app = FastAPI(title="Context-Aware Code Generation & Debugging API")
        self.code_generator = code_generator
        self.error_engine = error_engine
        self.mcp_manager = mcp_manager
        self.session_factory = session_factory
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """Setup CORS middleware"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def setup_routes(self):
        """Setup API routes"""
        
        from pydantic import BaseModel
        
        class CodeCompletionRequest(BaseModel):
            file_path: str
            content: str
            cursor_position: int
            project_path: str = ""
            suggestion_type: str = "completion"
        
        class ErrorAnalysisRequest(BaseModel):
            file_path: str
            content: str
            project_path: str = ""
        
        @self.app.post("/code/complete")
        async def complete_code(request: CodeCompletionRequest):
            try:
                # Create code context
                context = CodeContext(
                    file_path=request.file_path,
                    content=request.content,
                    cursor_position=request.cursor_position,
                    surrounding_code=self._get_surrounding_code(
                        request.content, request.cursor_position
                    ),
                    project_context={"project_path": request.project_path},
                    ast_info={}
                )
                
                # Create suggestion request
                suggestion_request = SuggestionRequest(
                    context=context,
                    suggestion_type=request.suggestion_type,
                    max_suggestions=3
                )
                
                # Generate suggestions
                suggestions = await self.code_generator.generate_code_completion(
                    suggestion_request
                )
                
                return {"suggestions": suggestions}
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/code/analyze")
        async def analyze_code(request: ErrorAnalysisRequest):
            try:
                # Detect errors
                errors = await self.error_engine.detect_errors(
                    request.file_path, request.content
                )
                
                return {"errors": errors}
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.websocket("/ws/code-assistance")
        async def websocket_endpoint(websocket: WebSocket):
            await websocket.accept()
            try:
                while True:
                    data = await websocket.receive_json()
                    
                    if data["type"] == "completion":
                        # Handle real-time completion
                        response = await self._handle_completion_request(data)
                        await websocket.send_json(response)
                    
                    elif data["type"] == "error_check":
                        # Handle real-time error checking
                        response = await self._handle_error_check(data)
                        await websocket.send_json(response)
                        
            except Exception as e:
                logger.error(f"WebSocket error: {e}")
    
    def _get_surrounding_code(self, content: str, cursor_position: int, window: int = 200) -> str:
        """Get surrounding code around cursor position"""
        start = max(0, cursor_position - window)
        end = min(len(content), cursor_position + window)
        return content[start:end]

async def demo():
    """Demo of the Context-Aware Code Generation & Debugging Tool"""
    
    print("ðŸš€ Context-Aware Code Generation & Debugging Tool Demo\n")
    
    try:
        # Initialize database
        engine = create_async_engine('sqlite+aiosqlite:///./code_development.db')
        session_factory = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
        
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        
        # Initialize components
        mcp_manager = MCPDevelopmentManager(session_factory)
        ast_analyzer = ASTCodeAnalyzer()
        code_generator = IntelligentCodeGenerator(mcp_manager, ast_analyzer)
        error_engine = ErrorDetectionEngine(ast_analyzer, mcp_manager)
        
        print("âœ… Context-Aware Code Tool initialized")
        print("âœ… MCP development context management configured")
        print("âœ… AST-based code analysis ready")
        print("âœ… Intelligent code generation enabled")
        print("âœ… Error detection and correction active")
        
        # Create developer context
        print(f"\nðŸ‘¨â€ðŸ’» Creating Developer Context...")
        developer_preferences = {
            "coding_style": {
                "indent_size": 4,
                "use_type_hints": True,
                "max_line_length": 100,
                "prefer_list_comprehensions": True
            },
            "languages": ["python", "javascript"],
            "frameworks": {"python": ["fastapi", "django"], "js": ["react", "node"]},
            "quality_standards": {
                "min_test_coverage": 80,
                "max_complexity": 10,
                "require_docstrings": True
            }
        }
        
        context_id = await mcp_manager.create_developer_context(
            "demo_developer", developer_preferences
        )
        print(f"  ðŸ‘¤ Created developer context: {context_id[:8]}")
        
        # Analyze sample project
        print(f"\nðŸ“ Analyzing Sample Project...")
        
        # Create sample code files
        sample_files = {
            "main.py": '''
import requests
from typing import List, Dict, Optional

def fetch_user_data(user_id: int) -> Dict:
    """Fetch user data from API"""
    response = requests.get(f"https://api.example.com/users/{user_id}")
    return response.json()

class UserManager:
    def __init__(self):
        self.users = []
    
    def add_user(self, user_data):
        # TODO: Add validation
        self.users.append(user_data)
    
    def get_user_by_id(self, user_id: int):
        for user in self.users:
            if user['id'] == user_id:
                return user
        return None
            ''',
            
            "utils.py": '''
def calculate_average(numbers):
    if len(numbers) == 0:
        return 0
    return sum(numbers) / len(numbers)

def validate_email(email):
    # Simple email validation
    return "@" in email and "." in email
            '''
        }
        
        # Create temporary project directory
        project_path = "./demo_project"
        Path(project_path).mkdir(exist_ok=True)
        
        for filename, content in sample_files.items():
            with open(f"{project_path}/{filename}", 'w') as f:
                f.write(content)
        
        # Analyze project
        project_context = await mcp_manager.analyze_project_context(project_path)
        print(f"  ðŸ“Š Project analysis complete")
        print(f"     Total files: {project_context.get('structure', {}).get('total_files', 0)}")
        print(f"     Code files: {project_context.get('structure', {}).get('code_files', 0)}")
        
        # Demonstrate code analysis
        print(f"\nðŸ” Code Analysis Demo...")
        
        main_py_content = sample_files["main.py"]
        analysis = await ast_analyzer.analyze_code_file(f"{project_path}/main.py", main_py_content)
        
        print(f"  ðŸ“„ main.py Analysis:")
        print(f"     Functions: {len(analysis.get('functions', []))}")
        print(f"     Classes: {len(analysis.get('classes', []))}")
        print(f"     Imports: {len(analysis.get('imports', []))}")
        
        for func in analysis.get('functions', [])[:2]:
            print(f"     Function: {func['name']} (line {func['line']})")
        
        # Demonstrate error detection
        print(f"\nðŸ› Error Detection Demo...")
        
        # Create code with intentional errors
        buggy_code = '''
def divide_numbers(a, b):
    result = a / b  # Division by zero possible
    return result

def process_list(items):
    for item in items:
        print(item.name)  # AttributeError possible
    
def fetch_data():
    data = requests.get("http://api.example.com")  # Missing import
    return data.json()
        '''
        
        errors = await error_engine.detect_errors("buggy.py", buggy_code)
        print(f"  ðŸ” Detected {len(errors)} potential issues:")
        
        for error in errors[:3]:
            print(f"     {error['type']}: {error['message'][:60]}...")
            if 'suggestion' in error:
                print(f"     ðŸ’¡ Suggestion: {error['suggestion']}")
        
        # Demonstrate code completion
        print(f"\nâœ¨ Code Completion Demo...")
        
        incomplete_code = '''
def calculate_statistics(numbers: List[float]) -> Dict[str, float]:
    """Calculate basic statistics for a list of numbers"""
    if not numbers:
        return {}
    
    # TODO: Complete this function
    '''
        
        # Create context for completion
        context = CodeContext(
            file_path=f"{project_path}/stats.py",
            content=incomplete_code,
            cursor_position=len(incomplete_code) - 10,
            surrounding_code=incomplete_code,
            project_context=project_context,
            ast_info={}
        )
        
        suggestion_request = SuggestionRequest(
            context=context,
            suggestion_type="function",
            max_suggestions=2
        )
        
        suggestions = await code_generator.generate_code_completion(suggestion_request)
        
        print(f"  ðŸ’¡ Generated {len(suggestions)} suggestions:")
        for i, suggestion in enumerate(suggestions, 1):
            print(f"\n     Suggestion {i} (confidence: {suggestion['confidence']:.2f}):")
            print(f"     {suggestion['code'][:100]}...")
        
        # Demonstrate refactoring suggestions
        print(f"\nðŸ”§ Refactoring Demo...")
        
        refactor_context = CodeContext(
            file_path=f"{project_path}/main.py",
            content=main_py_content,
            cursor_position=0,
            surrounding_code=main_py_content,
            project_context=project_context,
            ast_info={}
        )
        
        refactor_request = SuggestionRequest(
            context=refactor_context,
            suggestion_type="refactor",
            max_suggestions=1
        )
        
        refactor_suggestions = await code_generator.generate_code_completion(refactor_request)
        
        if refactor_suggestions:
            print(f"  ðŸ”„ Refactoring suggestion:")
            print(f"     {refactor_suggestions[0]['explanation'][:150]}...")
        
        # Clean up
        import shutil
        shutil.rmtree(project_path)
        
        # System capabilities
        print(f"\nðŸ› ï¸ System Capabilities:")
        print(f"  âœ… AST-based code understanding")
        print(f"  âœ… Context-aware code completion")
        print(f"  âœ… Intelligent error detection")
        print(f"  âœ… MCP-driven developer context")
        print(f"  âœ… Project pattern recognition")
        print(f"  âœ… Real-time code analysis")
        print(f"  âœ… Multi-language support")
        print(f"  âœ… Refactoring suggestions")
        
        print(f"\nðŸŽ¯ Development Features:")
        print(f"  â€¢ GitHub Copilot alternative functionality")
        print(f"  â€¢ Privacy-focused on-premise deployment")
        print(f"  â€¢ Custom project pattern learning")
        print(f"  â€¢ Intelligent debugging assistance")
        print(f"  â€¢ Code quality improvement")
        print(f"  â€¢ Developer workflow integration")
        
        print(f"\nðŸš€ Context-Aware Code Generation & Debugging Tool demo completed!")
        
    except Exception as e:
        print(f"âŒ Demo error: {e}")
        logger.error(f"Demo failed: {e}")

# Dependencies information
dependencies_info = """
# Install required dependencies:
pip install openai langchain
pip install tree-sitter tree-sitter-python tree-sitter-javascript
pip install astroid pylint bandit
pip install radon  # Code complexity analysis
pip install sentence-transformers
pip install black isort autopep8  # Code formatting
pip install gitpython  # Git integration
pip install watchdog  # File monitoring
pip install fastapi uvicorn websockets
pip install sqlalchemy aiosqlite
pip install pytest coverage  # Testing
pip install numpy scikit-learn

# Environment variables:
export OPENAI_API_KEY="your-openai-api-key"
export DATABASE_URL="sqlite+aiosqlite:///./code_development.db"

# For advanced features:
pip install jedi  # Python code intelligence
pip install rope  # Python refactoring
pip install mypy  # Type checking
pip install flake8  # Style checking

# For IDE integration:
pip install python-lsp-server  # Language Server Protocol
pip install pygls  # Generic Language Server

# For production deployment:
pip install gunicorn redis celery
pip install prometheus-client
"""

if __name__ == "__main__":
    print(dependencies_info)
    asyncio.run(demo())
````

## Project Summary

The Context-Aware Code Generation & Debugging Tool represents a transformative advancement in software development assistance that combines sophisticated AST analysis, intelligent code generation, and MCP-driven context management to create comprehensive development ecosystems where coding becomes more efficient, accurate, and contextually aware while maintaining developer autonomy and code privacy.

### Key Value Propositions

1. **Intelligent Development Context**: Advanced MCP system that understands project structure, coding patterns, developer preferences, and codebase relationships while maintaining comprehensive context across development sessions and providing personalized assistance that adapts to individual and team coding styles.

2. **AST-Powered Code Understanding**: Sophisticated analysis system that deeply understands code structure, dependencies, and relationships through Abstract Syntax Tree parsing, enabling intelligent suggestions, error detection, and refactoring recommendations that maintain code quality and consistency.

3. **Privacy-Focused Architecture**: Secure, on-premise capable system that provides GitHub Copilot-level functionality while maintaining complete code privacy and enabling custom enterprise deployment with full control over intellectual property and sensitive code assets.

4. **Comprehensive Development Assistance**: Integrated platform that combines code completion, error detection, debugging support, and refactoring suggestions while learning from project patterns and developer feedback to continuously improve assistance quality and relevance.

### Key Takeaways

- **Development Productivity Revolution**: Dramatically accelerates coding speed and quality through intelligent, context-aware assistance that understands project specifics and developer preferences while reducing debugging time and improving code maintainability
- **Enterprise-Grade Privacy**: Provides advanced AI coding assistance without compromising code privacy, enabling organizations to benefit from intelligent development tools while maintaining complete control over proprietary code and intellectual property
- **Adaptive Learning System**: Continuously learns from project patterns, coding standards, and developer feedback to provide increasingly relevant and accurate suggestions while adapting to team practices and organizational coding guidelines
- **Comprehensive Development Intelligence**: Transforms coding from reactive problem-solving to proactive, intelligent development through sophisticated error prevention, quality improvement, and best practice enforcement that scales with project complexity

This Context-Aware Code Generation & Debugging Tool empowers development teams by providing intelligent, privacy-respecting coding assistance that enhances productivity, improves code quality, and accelerates development workflows while maintaining the autonomy and creativity essential for innovative software development and engineering excellence.