<small>Claude Sonnet 4 **(AI Asistent pro Dokumentaci Kódu s RAG)**</small>
# Code Documentation Assistant

## Klíčové Koncepty

### RAG (Retrieval-Augmented Generation)
Technika kombinující vyhledávání relevantních informací z databáze znalostí s generováním odpovědí pomocí LLM. Umožňuje AI systémům poskytovat přesné a kontextové odpovědi založené na konkrétních datech.

### GitHub Repozitáře
Verzované úložiště zdrojového kódu obsahující historii změn, dokumentaci a kolaborativní nástroje. Slouží jako zdroj dat pro analýzu a pochopení kódových struktur.

### CodeBERT
Specializovaný BERT model trénovaný na programovacím kódu. Rozumí syntaxi a sémantice různých programovacích jazyků a dokáže generovat embeddingy pro kódové fragmenty.

### LanceDB
Vysokorychlostní vektorová databáze optimalizovaná pro AI aplikace. Podporuje efektivní vyhledávání podobnosti a škálovatelné ukládání embeddings.

### StarCoder2
Moderní generativní model specializovaný na programovací kód. Dokáže generovat, dokončovat a vysvětlovat kód v různých programovacích jazycích.

## Komplexní Vysvětlení Projektu

### Cíle Projektu
AI Asistent pro Dokumentaci Kódu je inteligentní systém navržený pro automatizované zodpovídání programátorských otázek prostřednictvím analýzy kódových repozitářů. Systém kombinuje pokročilé techniky vyhledávání s generativní AI pro poskytování přesných a kontextových odpovědí.

### Klíčové Výzvy
- **Sémantické porozumění kódu**: Rozpoznání vzorů, funkcionalit a vztahů v kódu
- **Škálovatelnost**: Zpracování velkých kódových bází s miliony řádků kódu
- **Kontextová relevance**: Poskytnutí odpovědí specifických pro daný projekt a technologie
- **Multijazyčnost**: Podpora různých programovacích jazyků a frameworků

### Potenciální Dopad
Systém může dramaticky zrychlit onboarding nových vývojářů, zlepšit kvalitu dokumentace a snížit čas potřebný na pochopení složitých kódových struktur. Umožňuje automatizované generování příkladů kódu a best practices specifických pro daný projekt.

## Komplexní Implementace v Pythonu

### Instalace Závislostí

````python
# requirements.txt
transformers==4.35.0
sentence-transformers==2.2.2
lancedb==0.3.1
openai==1.3.0
langchain==0.0.340
langchain-community==0.0.10
gitpython==3.1.40
tree-sitter==0.20.4
tree-sitter-python==0.20.4
numpy==1.24.3
pandas==2.0.3
uvicorn==0.24.0
fastapi==0.104.1
pydantic==2.5.0
aiofiles==23.2.1
````

### Základní Architektura

````python
import os
import asyncio
import logging
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import json

import lancedb
import numpy as np
import pandas as pd
from sentence_transformers import SentenceTransformer
from transformers import AutoTokenizer, AutoModel
import torch
from git import Repo
import tree_sitter_python as tspython
from tree_sitter import Language, Parser

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document
from langchain.llms import OpenAI
from langchain.chains import RetrievalQA
from langchain.vectorstores import LanceDB
from langchain.embeddings.base import Embeddings

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class CodeFragment:
    """Reprezentace fragmentu kódu s metadaty"""
    content: str
    file_path: str
    function_name: Optional[str]
    class_name: Optional[str]
    language: str
    line_start: int
    line_end: int
    documentation: Optional[str] = None

class CodeBERTEmbeddings(Embeddings):
    """Custom embedding třída pro CodeBERT"""
    
    def __init__(self, model_name: str = "microsoft/codebert-base"):
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModel.from_pretrained(model_name)
        self.model.eval()
    
    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        """Generuje embeddingy pro seznam dokumentů"""
        embeddings = []
        
        for text in texts:
            # Tokenizace a encoding
            inputs = self.tokenizer(
                text, 
                return_tensors="pt", 
                truncation=True, 
                padding=True,
                max_length=512
            )
            
            with torch.no_grad():
                outputs = self.model(**inputs)
                # Použití CLS tokenu jako reprezentace
                embedding = outputs.last_hidden_state[:, 0, :].numpy()[0]
                embeddings.append(embedding.tolist())
        
        return embeddings
    
    def embed_query(self, text: str) -> List[float]:
        """Generuje embedding pro dotaz"""
        return self.embed_documents([text])[0]

class CodeAnalyzer:
    """Analyzátor kódu využívající Tree-sitter"""
    
    def __init__(self):
        # Inicializace Tree-sitter parseru
        PY_LANGUAGE = Language(tspython.language(), "python")
        self.parser = Parser()
        self.parser.set_language(PY_LANGUAGE)
    
    def extract_functions(self, code: str, file_path: str) -> List[CodeFragment]:
        """Extrakce funkcí z Python kódu"""
        tree = self.parser.parse(bytes(code, "utf8"))
        functions = []
        
        def traverse_tree(node, parent_class=None):
            if node.type == "function_definition":
                func_name = None
                docstring = None
                
                # Najití názvu funkce
                for child in node.children:
                    if child.type == "identifier":
                        func_name = code[child.start_byte:child.end_byte]
                        break
                
                # Extrakce docstringu
                for child in node.children:
                    if child.type == "block":
                        for stmt in child.children:
                            if stmt.type == "expression_statement":
                                expr_child = stmt.children[0]
                                if expr_child.type == "string":
                                    docstring = code[expr_child.start_byte:expr_child.end_byte]
                                break
                        break
                
                function_code = code[node.start_byte:node.end_byte]
                start_line = node.start_point[0] + 1
                end_line = node.end_point[0] + 1
                
                functions.append(CodeFragment(
                    content=function_code,
                    file_path=file_path,
                    function_name=func_name,
                    class_name=parent_class,
                    language="python",
                    line_start=start_line,
                    line_end=end_line,
                    documentation=docstring
                ))
            
            elif node.type == "class_definition":
                class_name = None
                for child in node.children:
                    if child.type == "identifier":
                        class_name = code[child.start_byte:child.end_byte]
                        break
                
                # Rekurzivně procházej třídu
                for child in node.children:
                    traverse_tree(child, class_name)
            
            # Pokračuj v rekurzi
            for child in node.children:
                if node.type != "class_definition":  # Prevent double processing
                    traverse_tree(child, parent_class)
        
        traverse_tree(tree.root_node)
        return functions

class RepositoryProcessor:
    """Procesor pro analýzu Git repozitářů"""
    
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path)
        self.analyzer = CodeAnalyzer()
        
    def clone_repository(self, repo_url: str) -> None:
        """Klonování repozitáře"""
        if not self.repo_path.exists():
            logger.info(f"Klonování repozitáře: {repo_url}")
            Repo.clone_from(repo_url, self.repo_path)
        else:
            logger.info(f"Repozitář již existuje: {self.repo_path}")
    
    def process_repository(self) -> List[CodeFragment]:
        """Zpracování celého repozitáře"""
        fragments = []
        
        # Projdi všechny Python soubory
        for py_file in self.repo_path.rglob("*.py"):
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Extrakce funkcí a tříd
                file_fragments = self.analyzer.extract_functions(
                    content, 
                    str(py_file.relative_to(self.repo_path))
                )
                fragments.extend(file_fragments)
                
            except Exception as e:
                logger.warning(f"Chyba při zpracování {py_file}: {e}")
        
        logger.info(f"Zpracováno {len(fragments)} fragmentů kódu")
        return fragments

class VectorDatabase:
    """Správce vektorové databáze LanceDB"""
    
    def __init__(self, db_path: str = "./code_db"):
        self.db_path = db_path
        self.db = lancedb.connect(db_path)
        self.embeddings = CodeBERTEmbeddings()
        
    def create_table(self, fragments: List[CodeFragment]) -> None:
        """Vytvoření tabulky s embeddingy"""
        logger.info("Generování embeddings pro fragmenty kódu...")
        
        # Příprava dat
        data = []
        contents = [f.content for f in fragments]
        
        # Generování embeddings
        embeddings = self.embeddings.embed_documents(contents)
        
        for fragment, embedding in zip(fragments, embeddings):
            data.append({
                "id": len(data),
                "content": fragment.content,
                "file_path": fragment.file_path,
                "function_name": fragment.function_name or "",
                "class_name": fragment.class_name or "",
                "language": fragment.language,
                "line_start": fragment.line_start,
                "line_end": fragment.line_end,
                "documentation": fragment.documentation or "",
                "vector": embedding
            })
        
        # Vytvoření tabulky
        if "code_fragments" in self.db.table_names():
            self.db.drop_table("code_fragments")
        
        self.table = self.db.create_table("code_fragments", data)
        logger.info(f"Vytvořena tabulka s {len(data)} záznamy")
    
    def search_similar(self, query: str, limit: int = 5) -> List[Dict]:
        """Vyhledání podobných fragmentů kódu"""
        query_embedding = self.embeddings.embed_query(query)
        
        results = (self.table
                  .search(query_embedding)
                  .limit(limit)
                  .to_pandas())
        
        return results.to_dict('records')

class CodeDocumentationAssistant:
    """Hlavní třída AI asistenta"""
    
    def __init__(self, openai_api_key: str):
        self.openai_api_key = openai_api_key
        os.environ["OPENAI_API_KEY"] = openai_api_key
        
        self.vector_db = VectorDatabase()
        self.llm = OpenAI(temperature=0.2)
        
    def setup_repository(self, repo_url: str, repo_name: str) -> None:
        """Nastavení repozitáře pro analýzu"""
        processor = RepositoryProcessor(f"./repos/{repo_name}")
        processor.clone_repository(repo_url)
        
        fragments = processor.process_repository()
        self.vector_db.create_table(fragments)
        
        logger.info("Repozitář byl úspěšně nastaven")
    
    def answer_question(self, question: str) -> str:
        """Zodpovězení otázky na základě kódu"""
        # Vyhledání relevantních fragmentů
        similar_fragments = self.vector_db.search_similar(question, limit=3)
        
        # Sestavení kontextu
        context = "\n\n".join([
            f"Soubor: {frag['file_path']}\n"
            f"Funkce: {frag['function_name']}\n"
            f"Kód:\n{frag['content']}"
            for frag in similar_fragments
        ])
        
        # Generování odpovědi
        prompt = f"""
Na základě následujícího kódu odpověz na otázku uživatele.

Kontext kódu:
{context}

Otázka uživatele: {question}

Poskytni detailní odpověď s příklady kódu kde je to relevantní:
"""
        
        response = self.llm(prompt)
        return response
    
    def generate_code_example(self, description: str) -> str:
        """Generování příkladu kódu na základě popisu"""
        similar_fragments = self.vector_db.search_similar(description, limit=2)
        
        context = "\n\n".join([
            f"Příklad z {frag['file_path']}:\n{frag['content']}"
            for frag in similar_fragments
        ])
        
        prompt = f"""
Na základě následujících příkladů kódu vytvoř nový příklad pro: {description}

Existující příklady:
{context}

Vytvoř nový, podobný příklad kódu s vysvětlením:
"""
        
        response = self.llm(prompt)
        return response

# Demonstrační ukázka použití
async def main():
    """Hlavní demonstrační funkce"""
    
    # Inicializace asistenta
    assistant = CodeDocumentationAssistant("your-openai-api-key")
    
    # Vytvoření ukázkového repozitáře
    sample_code = """
def calculate_fibonacci(n):
    \"\"\"
    Vypočítá n-té Fibonacciho číslo.
    
    Args:
        n (int): Pozice v sekvenci
        
    Returns:
        int: Fibonacciho číslo
    \"\"\"
    if n <= 1:
        return n
    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)

class DataProcessor:
    \"\"\"Třída pro zpracování dat\"\"\"
    
    def __init__(self, data):
        self.data = data
    
    def process(self):
        \"\"\"Zpracuje data a vrátí výsledek\"\"\"
        return [x * 2 for x in self.data]
    
    def filter_positive(self):
        \"\"\"Filtruje pouze pozitivní hodnoty\"\"\"
        return [x for x in self.data if x > 0]
"""
    
    # Vytvoření ukázkové struktury
    os.makedirs("./repos/sample_project", exist_ok=True)
    with open("./repos/sample_project/main.py", "w") as f:
        f.write(sample_code)
    
    # Zpracování ukázkového projektu
    processor = RepositoryProcessor("./repos/sample_project")
    fragments = processor.process_repository()
    assistant.vector_db.create_table(fragments)
    
    # Testovací otázky
    questions = [
        "Jak vypočítat Fibonacciho číslo?",
        "Jak filtrovat pozitivní čísla ze seznamu?",
        "Jak vytvořit třídu pro zpracování dat?"
    ]
    
    print("=== AI Asistent pro Dokumentaci Kódu ===\n")
    
    for question in questions:
        print(f"Otázka: {question}")
        answer = assistant.answer_question(question)
        print(f"Odpověď: {answer}\n")
        print("-" * 50 + "\n")

if __name__ == "__main__":
    asyncio.run(main())
````

### API Server

````python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import uvicorn

app = FastAPI(title="Code Documentation Assistant API")

# Globální instance asistenta
assistant: Optional[CodeDocumentationAssistant] = None

class QuestionRequest(BaseModel):
    question: str

class RepositorySetupRequest(BaseModel):
    repo_url: str
    repo_name: str

class CodeGenerationRequest(BaseModel):
    description: str

@app.on_event("startup")
async def startup_event():
    global assistant
    # Inicializace s API klíčem z environment
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("OPENAI_API_KEY není nastaven")
    assistant = CodeDocumentationAssistant(api_key)

@app.post("/setup-repository")
async def setup_repository(request: RepositorySetupRequest):
    """Nastavení repozitáře pro analýzu"""
    try:
        assistant.setup_repository(request.repo_url, request.repo_name)
        return {"message": "Repozitář byl úspěšně nastaven"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/ask-question")
async def ask_question(request: QuestionRequest):
    """Zodpovězení otázky o kódu"""
    try:
        answer = assistant.answer_question(request.question)
        return {"question": request.question, "answer": answer}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/generate-code")
async def generate_code(request: CodeGenerationRequest):
    """Generování příkladu kódu"""
    try:
        code_example = assistant.generate_code_example(request.description)
        return {"description": request.description, "code_example": code_example}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### Testovací Skripty

````python
import unittest
from unittest.mock import Mock, patch
import tempfile
import os

class TestCodeDocumentationAssistant(unittest.TestCase):
    
    def setUp(self):
        self.test_code = '''
def test_function():
    """Test function docstring"""
    return "test"

class TestClass:
    def method(self):
        return True
'''
        
    def test_code_analyzer(self):
        """Test analýzy kódu"""
        analyzer = CodeAnalyzer()
        fragments = analyzer.extract_functions(self.test_code, "test.py")
        
        self.assertEqual(len(fragments), 2)  # funkce + metoda
        self.assertEqual(fragments[0].function_name, "test_function")
        self.assertIn("Test function docstring", fragments[0].documentation)
    
    def test_embeddings_generation(self):
        """Test generování embeddings"""
        embeddings = CodeBERTEmbeddings()
        texts = ["def hello(): pass", "class Test: pass"]
        
        result = embeddings.embed_documents(texts)
        
        self.assertEqual(len(result), 2)
        self.assertEqual(len(result[0]), 768)  # CodeBERT dimension
    
    @patch('openai.OpenAI')
    def test_question_answering(self, mock_openai):
        """Test zodpovídání otázek"""
        mock_openai.return_value.return_value = "Mocked response"
        
        assistant = CodeDocumentationAssistant("fake-key")
        # Mock vector database
        assistant.vector_db.search_similar = Mock(return_value=[
            {"content": "def test(): pass", "file_path": "test.py", "function_name": "test"}
        ])
        
        answer = assistant.answer_question("How to test?")
        self.assertIsInstance(answer, str)

if __name__ == "__main__":
    unittest.main()
````

## Shrnutí Projektu

AI Asistent pro Dokumentaci Kódu představuje pokročilé řešení pro automatizované pochopení a dokumentování kódových struktur. Kombinuje sílu moderních AI technologií s efektivním vyhledáváním pro poskytování kontextových odpovědí na programátorské otázky.

### Klíčové Výhody
- **Rychlé onboarding**: Nové členy týmu rychle seznámí s kódovou základnou
- **Automatizovaná dokumentace**: Generuje příklady a vysvětlení na základě existującího kódu
- **Škálovatelnost**: Efektivně zpracovává velké kódové repozitáře
- **Multijazyčnost**: Podporuje různé programovací jazyky

### Technologické Inovace
Projekt využívá nejmodernější technologie včetně CodeBERT pro porozumění kódu, LanceDB pro rychlé vyhledávání a pokročilé RAG techniky pro generování přesných odpovědí. Architektura je navržena pro snadnou rozšiřitelnost a integraci s existujícími vývojovými workflow.