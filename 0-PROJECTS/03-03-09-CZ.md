<small>Claude Sonnet 4 **(E-commerce Product Recommender s RAG Architekturou)**</small>
# E-commerce Product Recommender

## Klíčové Koncepty

### RAG (Retrieval-Augmented Generation)
Architektura, která kombinuje vyhledávání relevantních informací z databáze s generativními AI modely. V kontextu e-commerce umožňuje porozumět přirozeným dotazům uživatelů a najít odpovídající produkty.

### Product Catalog
Strukturovaná databáze produktů obsahující názvy, popisy, kategorie, vlastnosti a metadata. Funguje jako zdroj dat pro RAG systém.

### CLIP Embeddings
Multimodální embedingy od OpenAI, které dokáží zakódovat jak text, tak obrázky do společného vektorového prostoru. Umožňují sémantické vyhledávání produktů.

### Elasticsearch
Vysoce výkonný vyhledávací engine založený na Apache Lucene. Poskytuje full-text search, filtrování a agregace pro produktové katalogy.

### Command R+
Pokročilý jazykový model od Cohere optimalizovaný pro RAG aplikace a komplexní reasoning úlohy.

## Komplexní Vysvětlení Projektu

### Cíle Projektu
Vytvořit inteligentní doporučovací systém pro e-commerce, který rozumí přirozeným dotazům zákazníků typu "Potřebuji dárek pro moji maminku, která miluje turistiku". Systém musí:

1. **Porozumět kontextu** - Analyzovat záměr, osobu příjemce a preference
2. **Vyhledat relevantní produkty** - Použít sémantické vyhledávání v katalogu
3. **Personalizovat doporučení** - Přizpůsobit výsledky podle kontextu
4. **Vysvětlit výběr** - Poskytnout zdůvodnění doporučení

### Technické Výzvy
- **Porozumění záměru**: Extrakce entity (příjemce, aktivita, rozpočet)
- **Sémantické mapování**: Propojení přirozených dotazů s produktovými atributy
- **Multimodální vyhledávání**: Kombinace textových a vizuálních dat
- **Škálovatelnost**: Efektivní vyhledávání v rozsáhlých katalozích

### Dopad a Hodnota
- **Zvýšení konverzí**: Intuitivnější nákupní zážitek
- **Snížení návratnosti**: Přesnější doporučení = spokojení zákazníci
- **Operační efektivita**: Automatizace zákaznické podpory

## Komplexní Implementace v Pythonu

### Závislosti a Instalace

````python
# requirements.txt
langchain==0.1.0
elasticsearch==8.11.1
sentence-transformers==2.2.2
cohere==4.37
openai==1.3.8
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
numpy==1.24.3
pandas==2.0.3
python-dotenv==1.0.0
````

### Konfigurace Prostředí

````python
import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    elasticsearch_url: str = "http://localhost:9200"
    cohere_api_key: str = ""
    openai_api_key: str = ""
    index_name: str = "product_catalog"
    
    class Config:
        env_file = ".env"

settings = Settings()
````

### Datový Model

````python
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime

class Product(BaseModel):
    id: str
    name: str
    description: str
    category: str
    subcategory: str
    price: float
    currency: str = "CZK"
    brand: str
    tags: List[str]
    attributes: Dict[str, Any]
    image_url: Optional[str] = None
    rating: Optional[float] = None
    reviews_count: int = 0

class SearchQuery(BaseModel):
    query: str
    filters: Optional[Dict[str, Any]] = None
    max_results: int = 10

class Recommendation(BaseModel):
    product: Product
    score: float
    reasoning: str

class SearchResponse(BaseModel):
    query: str
    recommendations: List[Recommendation]
    total_found: int
    processing_time: float
````

### Generátor Testovacích Dat

````python
import json
import random
from typing import List
from models import Product

class ProductDataGenerator:
    def __init__(self):
        self.outdoor_products = [
            {
                "name": "Turistické boty Salomon X Ultra 3",
                "description": "Lehké a odolné turistické boty s pokročilou technologií pro maximální pohodlí na dlouhých túrách",
                "category": "Sport a outdoor",
                "subcategory": "Turistické boty",
                "price": 3299.0,
                "brand": "Salomon",
                "tags": ["turistika", "outdoor", "boty", "waterproof", "trekking"],
                "attributes": {
                    "velikosti": ["36", "37", "38", "39", "40", "41", "42"],
                    "material": "syntetika/mesh",
                    "waterproof": True,
                    "vaha": "320g",
                    "pohlave": "unisex"
                }
            },
            {
                "name": "Batoh Deuter Futura Pro 36",
                "description": "Profesionální turistický batoh s ventilačním systémem a ergonomickým designem",
                "category": "Sport a outdoor",
                "subcategory": "Batohy",
                "price": 4599.0,
                "brand": "Deuter",
                "tags": ["batoh", "turistika", "trekking", "outdoor", "ventilace"],
                "attributes": {
                    "objem": "36L",
                    "material": "nylon",
                    "vaha": "1.8kg",
                    "rain_cover": True,
                    "pohlave": "unisex"
                }
            },
            {
                "name": "Fleecová bunda Patagonia Better Sweater",
                "description": "Tepla a pohodlna fleecova bunda idealni pro outdoorove aktivity",
                "category": "Oblečení",
                "subcategory": "Bundy",
                "price": 2799.0,
                "brand": "Patagonia",
                "tags": ["fleece", "bunda", "outdoor", "teplo", "turistika"],
                "attributes": {
                    "velikosti": ["XS", "S", "M", "L", "XL"],
                    "material": "polyester fleece",
                    "vaha": "450g",
                    "pohlave": "dámské"
                }
            }
        ]
    
    def generate_products(self, count: int = 50) -> List[Product]:
        products = []
        
        # Přidat základní outdoor produkty
        for i, base_product in enumerate(self.outdoor_products):
            product = Product(
                id=f"prod_{i+1:03d}",
                name=base_product["name"],
                description=base_product["description"],
                category=base_product["category"],
                subcategory=base_product["subcategory"],
                price=base_product["price"],
                brand=base_product["brand"],
                tags=base_product["tags"],
                attributes=base_product["attributes"],
                image_url=f"https://example.com/images/prod_{i+1:03d}.jpg",
                rating=round(random.uniform(3.5, 5.0), 1),
                reviews_count=random.randint(10, 500)
            )
            products.append(product)
        
        # Generovat další produkty
        categories = [
            ("Elektronika", ["Telefony", "Laptopy", "Tablety"]),
            ("Knihy", ["Cestopisy", "Outdoor průvodci", "Mapy"]),
            ("Domácnost", ["Kuchyňské potřeby", "Dekorace"])
        ]
        
        for i in range(len(self.outdoor_products), count):
            category, subcategories = random.choice(categories)
            subcategory = random.choice(subcategories)
            
            product = Product(
                id=f"prod_{i+1:03d}",
                name=f"Produkt {i+1}",
                description=f"Popis produktu {i+1} v kategorii {subcategory}",
                category=category,
                subcategory=subcategory,
                price=round(random.uniform(299, 9999), 2),
                brand=random.choice(["BrandA", "BrandB", "BrandC"]),
                tags=[subcategory.lower(), category.lower()],
                attributes={"generic": True},
                image_url=f"https://example.com/images/prod_{i+1:03d}.jpg",
                rating=round(random.uniform(3.0, 5.0), 1),
                reviews_count=random.randint(5, 200)
            )
            products.append(product)
        
        return products

    def save_to_json(self, products: List[Product], filename: str = "products.json"):
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump([p.dict() for p in products], f, ensure_ascii=False, indent=2)
````

### Elasticsearch Klient

````python
from elasticsearch import Elasticsearch
from typing import List, Dict, Any, Optional
import logging
from models import Product
from config import settings

logger = logging.getLogger(__name__)

class ElasticsearchClient:
    def __init__(self):
        self.client = Elasticsearch([settings.elasticsearch_url])
        self.index_name = settings.index_name
    
    def create_index(self):
        """Vytvoří index s optimalizovaným mappingem pro produkty"""
        mapping = {
            "mappings": {
                "properties": {
                    "name": {
                        "type": "text",
                        "analyzer": "czech",
                        "fields": {
                            "keyword": {"type": "keyword"}
                        }
                    },
                    "description": {
                        "type": "text",
                        "analyzer": "czech"
                    },
                    "category": {"type": "keyword"},
                    "subcategory": {"type": "keyword"},
                    "brand": {"type": "keyword"},
                    "price": {"type": "float"},
                    "tags": {"type": "keyword"},
                    "rating": {"type": "float"},
                    "attributes": {"type": "object"},
                    "embedding": {
                        "type": "dense_vector",
                        "dims": 384
                    }
                }
            },
            "settings": {
                "analysis": {
                    "analyzer": {
                        "czech": {
                            "tokenizer": "standard",
                            "filter": ["lowercase", "czech_stop"]
                        }
                    },
                    "filter": {
                        "czech_stop": {
                            "type": "stop",
                            "stopwords": ["a", "aby", "ale", "ani", "ano", "až", "být", "co", "či"]
                        }
                    }
                }
            }
        }
        
        try:
            if self.client.indices.exists(index=self.index_name):
                self.client.indices.delete(index=self.index_name)
            
            self.client.indices.create(index=self.index_name, body=mapping)
            logger.info(f"Index {self.index_name} byl úspěšně vytvořen")
        except Exception as e:
            logger.error(f"Chyba při vytváření indexu: {e}")
            raise
    
    def index_products(self, products: List[Product], embeddings: List[List[float]]):
        """Indexuje produkty s jejich embedingy"""
        try:
            for product, embedding in zip(products, embeddings):
                doc = product.dict()
                doc['embedding'] = embedding
                
                self.client.index(
                    index=self.index_name,
                    id=product.id,
                    body=doc
                )
            
            self.client.indices.refresh(index=self.index_name)
            logger.info(f"Indexováno {len(products)} produktů")
        except Exception as e:
            logger.error(f"Chyba při indexování: {e}")
            raise
    
    def semantic_search(self, query_embedding: List[float], size: int = 10, filters: Optional[Dict] = None) -> List[Dict]:
        """Provede sémantické vyhledávání pomocí vektorů"""
        search_body = {
            "query": {
                "bool": {
                    "must": [{
                        "script_score": {
                            "query": {"match_all": {}},
                            "script": {
                                "source": "cosineSimilarity(params.query_vector, 'embedding') + 1.0",
                                "params": {"query_vector": query_embedding}
                            }
                        }
                    }]
                }
            },
            "size": size
        }
        
        # Přidání filtrů
        if filters:
            filter_clauses = []
            for field, value in filters.items():
                if isinstance(value, list):
                    filter_clauses.append({"terms": {field: value}})
                else:
                    filter_clauses.append({"term": {field: value}})
            
            if filter_clauses:
                search_body["query"]["bool"]["filter"] = filter_clauses
        
        try:
            response = self.client.search(index=self.index_name, body=search_body)
            return response['hits']['hits']
        except Exception as e:
            logger.error(f"Chyba při vyhledávání: {e}")
            raise
    
    def text_search(self, query: str, size: int = 10) -> List[Dict]:
        """Provede full-text vyhledávání"""
        search_body = {
            "query": {
                "multi_match": {
                    "query": query,
                    "fields": ["name^2", "description", "tags^1.5"],
                    "type": "best_fields",
                    "fuzziness": "AUTO"
                }
            },
            "size": size
        }
        
        try:
            response = self.client.search(index=self.index_name, body=search_body)
            return response['hits']['hits']
        except Exception as e:
            logger.error(f"Chyba při textovém vyhledávání: {e}")
            raise
````

### Embedding Engine

````python
from sentence_transformers import SentenceTransformer
from typing import List, Dict, Any
import logging
from models import Product

logger = logging.getLogger(__name__)

class EmbeddingEngine:
    def __init__(self, model_name: str = "paraphrase-multilingual-MiniLM-L12-v2"):
        """Inicializuje embedding model optimalizovaný pro češtinu"""
        try:
            self.model = SentenceTransformer(model_name)
            logger.info(f"Embedding model {model_name} načten")
        except Exception as e:
            logger.error(f"Chyba při načítání modelu: {e}")
            raise
    
    def create_product_text(self, product: Product) -> str:
        """Vytvoří textovou reprezentaci produktu pro embedding"""
        text_parts = [
            product.name,
            product.description,
            product.category,
            product.subcategory,
            product.brand,
            " ".join(product.tags)
        ]
        
        # Přidání atributů
        for key, value in product.attributes.items():
            if isinstance(value, (str, int, float, bool)):
                text_parts.append(f"{key}: {value}")
        
        return " ".join(filter(None, text_parts))
    
    def encode_products(self, products: List[Product]) -> List[List[float]]:
        """Vytvoří embedingy pro seznam produktů"""
        try:
            texts = [self.create_product_text(product) for product in products]
            embeddings = self.model.encode(texts, convert_to_tensor=False)
            return embeddings.tolist()
        except Exception as e:
            logger.error(f"Chyba při vytváření embedingů: {e}")
            raise
    
    def encode_query(self, query: str) -> List[float]:
        """Vytvoří embedding pro vyhledávací dotaz"""
        try:
            embedding = self.model.encode([query], convert_to_tensor=False)
            return embedding[0].tolist()
        except Exception as e:
            logger.error(f"Chyba při kódování dotazu: {e}")
            raise
````

### RAG Engine s Cohere

````python
import cohere
from typing import List, Dict, Any, Optional
import logging
import re
from models import Product, Recommendation, SearchResponse
from config import settings

logger = logging.getLogger(__name__)

class RAGEngine:
    def __init__(self):
        try:
            self.cohere_client = cohere.Client(settings.cohere_api_key)
            logger.info("Cohere klient inicializován")
        except Exception as e:
            logger.error(f"Chyba při inicializaci Cohere: {e}")
            raise
    
    def extract_intent(self, query: str) -> Dict[str, Any]:
        """Extrahuje záměr a entity z uživatelského dotazu"""
        prompt = f"""
Analyzuj následující dotaz zákazníka e-shopu a extrahuj klíčové informace:

Dotaz: "{query}"

Identifikuj:
1. PŘÍJEMCE: Pro koho je produkt (já, mama, táta, dítě, atd.)
2. AKTIVITA/ZÁJEM: Jaké aktivity nebo zájmy jsou zmíněny
3. ROZPOČET: Jakýkoliv zmíněný rozpočet nebo cenové preference
4. KATEGORIE: Jaký typ produktu hledá
5. VLASTNOSTI: Specifické požadavky nebo vlastnosti

Odpověz ve formátu JSON:
{{
    "recipient": "string",
    "activities": ["list"],
    "budget": "string nebo null",
    "product_type": "string",
    "properties": ["list"],
    "intent": "gift/personal/recommendation"
}}
        """
        
        try:
            response = self.cohere_client.generate(
                model="command-r-plus",
                prompt=prompt,
                max_tokens=300,
                temperature=0.1
            )
            
            # Extrakce JSON z odpovědi
            response_text = response.generations[0].text.strip()
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            
            if json_match:
                import json
                return json.loads(json_match.group())
            else:
                return self._fallback_intent_extraction(query)
                
        except Exception as e:
            logger.error(f"Chyba při extrakci záměru: {e}")
            return self._fallback_intent_extraction(query)
    
    def _fallback_intent_extraction(self, query: str) -> Dict[str, Any]:
        """Záložní extrakce záměru pomocí keyword matching"""
        query_lower = query.lower()
        
        # Základní detekce
        recipient = "neurčeno"
        if any(word in query_lower for word in ["mama", "maminku", "matku"]):
            recipient = "mama"
        elif any(word in query_lower for word in ["táta", "tatínka", "otce"]):
            recipient = "táta"
        elif any(word in query_lower for word in ["dítě", "dítěte", "syn", "dceru"]):
            recipient = "dítě"
        
        activities = []
        if any(word in query_lower for word in ["turistika", "turistiku", "túry", "hiking"]):
            activities.append("turistika")
        if any(word in query_lower for word in ["sport", "cvičení", "fitness"]):
            activities.append("sport")
        
        intent = "gift" if any(word in query_lower for word in ["dárek", "darček", "gift"]) else "personal"
        
        return {
            "recipient": recipient,
            "activities": activities,
            "budget": None,
            "product_type": "neurčeno",
            "properties": [],
            "intent": intent
        }
    
    def generate_search_keywords(self, intent: Dict[str, Any]) -> str:
        """Generuje optimalizované klíčová slova pro vyhledávání"""
        keywords = []
        
        if intent.get("activities"):
            keywords.extend(intent["activities"])
        
        if intent.get("recipient") and intent["recipient"] != "neurčeno":
            if intent["recipient"] == "mama":
                keywords.extend(["dámské", "ženy"])
            elif intent["recipient"] == "táta":
                keywords.extend(["pánské", "muži"])
        
        if intent.get("properties"):
            keywords.extend(intent["properties"])
        
        return " ".join(keywords) if keywords else intent.get("product_type", "")
    
    def explain_recommendation(self, product: Product, intent: Dict[str, Any], score: float) -> str:
        """Generuje vysvětlení doporučení"""
        prompt = f"""
Vysvětli, proč doporučuješ tento produkt zákazníkovi:

ZÁMĚR ZÁKAZNÍKA:
- Příjemce: {intent.get('recipient', 'neurčeno')}
- Aktivity: {', '.join(intent.get('activities', []))}
- Typ: {intent.get('intent', 'neurčeno')}

DOPORUČENÝ PRODUKT:
- Název: {product.name}
- Popis: {product.description}
- Kategorie: {product.category} / {product.subcategory}
- Značka: {product.brand}
- Cena: {product.price} {product.currency}
- Hodnocení: {product.rating}/5.0

Napiš stručné a přesvědčivé vysvětlení (max 2 věty), proč je tento produkt vhodný.
        """
        
        try:
            response = self.cohere_client.generate(
                model="command-r-plus",
                prompt=prompt,
                max_tokens=150,
                temperature=0.3
            )
            return response.generations[0].text.strip()
        except Exception as e:
            logger.error(f"Chyba při generování vysvětlení: {e}")
            return f"Tento produkt je vhodný díky vysokému hodnocení ({product.rating}/5.0) a relevanci k vašemu dotazu."
````

### Hlavní Doporučovací Služba

````python
import time
import logging
from typing import List, Optional, Dict, Any
from models import SearchQuery, SearchResponse, Recommendation, Product
from elasticsearch_client import ElasticsearchClient
from embedding_engine import EmbeddingEngine
from rag_engine import RAGEngine

logger = logging.getLogger(__name__)

class RecommenderService:
    def __init__(self):
        self.es_client = ElasticsearchClient()
        self.embedding_engine = EmbeddingEngine()
        self.rag_engine = RAGEngine()
    
    def search_products(self, query: SearchQuery) -> SearchResponse:
        """Hlavní metoda pro vyhledávání a doporučování produktů"""
        start_time = time.time()
        
        try:
            # 1. Extrakce záměru z dotazu
            intent = self.rag_engine.extract_intent(query.query)
            logger.info(f"Extrahovaný záměr: {intent}")
            
            # 2. Generování optimalizovaných klíčových slov
            search_keywords = self.rag_engine.generate_search_keywords(intent)
            
            # 3. Sémantické vyhledávání
            query_embedding = self.embedding_engine.encode_query(query.query + " " + search_keywords)
            semantic_results = self.es_client.semantic_search(
                query_embedding, 
                size=query.max_results * 2,  # Získáme více kandidátů
                filters=query.filters
            )
            
            # 4. Kombinace s textovým vyhledáváním pro lepší pokrytí
            text_results = self.es_client.text_search(query.query, size=query.max_results)
            
            # 5. Kombinace a deduplikace výsledků
            combined_results = self._combine_results(semantic_results, text_results)
            
            # 6. Vytvoření doporučení s vysvětleními
            recommendations = []
            for result in combined_results[:query.max_results]:
                product_data = result['_source']
                product_data.pop('embedding', None)  # Odstraníme embedding z výstupu
                
                product = Product(**product_data)
                score = result['_score']
                
                reasoning = self.rag_engine.explain_recommendation(product, intent, score)
                
                recommendation = Recommendation(
                    product=product,
                    score=score,
                    reasoning=reasoning
                )
                recommendations.append(recommendation)
            
            processing_time = time.time() - start_time
            
            return SearchResponse(
                query=query.query,
                recommendations=recommendations,
                total_found=len(combined_results),
                processing_time=processing_time
            )
            
        except Exception as e:
            logger.error(f"Chyba při vyhledávání: {e}")
            raise
    
    def _combine_results(self, semantic_results: List[Dict], text_results: List[Dict]) -> List[Dict]:
        """Kombinuje výsledky sémantického a textového vyhledávání"""
        seen_ids = set()
        combined = []
        
        # Přidáme sémantické výsledky (mají vyšší prioritu)
        for result in semantic_results:
            product_id = result['_id']
            if product_id not in seen_ids:
                seen_ids.add(product_id)
                combined.append(result)
        
        # Přidáme textové výsledky, které ještě nemáme
        for result in text_results:
            product_id = result['_id']
            if product_id not in seen_ids:
                seen_ids.add(product_id)
                # Upravíme skóre pro textové výsledky
                result['_score'] = result['_score'] * 0.8
                combined.append(result)
        
        # Seřadíme podle skóre
        combined.sort(key=lambda x: x['_score'], reverse=True)
        return combined
    
    def initialize_index(self, products: List[Product]):
        """Inicializuje index s produkty"""
        try:
            # Vytvoření indexu
            self.es_client.create_index()
            
            # Generování embedingů
            logger.info("Generuji embedingy pro produkty...")
            embeddings = self.embedding_engine.encode_products(products)
            
            # Indexování produktů
            logger.info("Indexuji produkty...")
            self.es_client.index_products(products, embeddings)
            
            logger.info(f"Index úspěšně inicializován s {len(products)} produkty")
            
        except Exception as e:
            logger.error(f"Chyba při inicializaci indexu: {e}")
            raise
````

### FastAPI Aplikace

````python
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import logging
import uvicorn
from contextlib import asynccontextmanager

from models import SearchQuery, SearchResponse
from recommender_service import RecommenderService
from data_generator import ProductDataGenerator

# Konfigurace loggingu
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Globální instance služby
recommender_service = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global recommender_service
    logger.info("Inicializuji doporučovací službu...")
    
    try:
        recommender_service = RecommenderService()
        
        # Generování a indexování testovacích dat
        logger.info("Generuji testovací data...")
        data_generator = ProductDataGenerator()
        products = data_generator.generate_products(count=100)
        data_generator.save_to_json(products)
        
        # Inicializace indexu
        recommender_service.initialize_index(products)
        logger.info("Služba je připravena k použití")
        
    except Exception as e:
        logger.error(f"Chyba při inicializaci: {e}")
        raise
    
    yield
    
    # Shutdown
    logger.info("Ukončuji službu...")

app = FastAPI(
    title="E-commerce Product Recommender",
    description="AI-powered product recommendation system with RAG",
    version="1.0.0",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    return {"message": "E-commerce Product Recommender API"}

@app.post("/search", response_model=SearchResponse)
async def search_products(query: SearchQuery):
    """Vyhledá produkty podle přirozeného dotazu"""
    try:
        if not recommender_service:
            raise HTTPException(status_code=503, detail="Služba není inicializována")
        
        result = recommender_service.search_products(query)
        return result
        
    except Exception as e:
        logger.error(f"Chyba při vyhledávání: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Kontrola stavu služby"""
    return {
        "status": "healthy" if recommender_service else "initializing",
        "service": "E-commerce Product Recommender"
    }

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

### Testovací Skripty

````python
import asyncio
import json
from models import SearchQuery
from recommender_service import RecommenderService
from data_generator import ProductDataGenerator

async def test_recommender():
    """Test doporučovacího systému"""
    print("🚀 Spouštím test doporučovacího systému...")
    
    # Inicializace služby
    service = RecommenderService()
    
    # Generování dat
    generator = ProductDataGenerator()
    products = generator.generate_products(50)
    
    # Inicializace indexu
    print("📦 Inicializuji index s produkty...")
    service.initialize_index(products)
    
    # Testovací dotazy
    test_queries = [
        "Potřebuji dárek pro moji maminku, která miluje turistiku",
        "Hledám kvalitní outdoor boty do hor",
        "Chci batoh na víkendové túry",
        "Něco teplého na turistiku pro ženu"
    ]
    
    print("\n🔍 Testovací vyhledávání:")
    print("=" * 50)
    
    for query_text in test_queries:
        print(f"\n📝 Dotaz: '{query_text}'")
        print("-" * 40)
        
        query = SearchQuery(query=query_text, max_results=3)
        response = service.search_products(query)
        
        print(f"⏱️  Čas zpracování: {response.processing_time:.2f}s")
        print(f"📊 Nalezeno: {response.total_found} produktů")
        
        for i, rec in enumerate(response.recommendations, 1):
            print(f"\n{i}. {rec.product.name}")
            print(f"   💰 Cena: {rec.product.price} {rec.product.currency}")
            print(f"   ⭐ Hodnocení: {rec.product.rating}/5.0")
            print(f"   🎯 Skóre: {rec.score:.2f}")
            print(f"   💡 Zdůvodnění: {rec.reasoning}")

if __name__ == "__main__":
    asyncio.run(test_recommender())
````

### Docker Konfigurace

````dockerfile
FROM python:3.11-slim

WORKDIR /app

# Instalace závislostí
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Kopírování kódu
COPY . .

# Exponování portu
EXPOSE 8000

# Spuštění aplikace
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
````

````yaml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.1
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
    ports:
      - "9200:9200"
    volumes:
      - es_data:/usr/share/elasticsearch/data

  recommender:
    build: .
    ports:
      - "8000:8000"
    environment:
      - ELASTICSEARCH_URL=http://elasticsearch:9200
      - COHERE_API_KEY=${COHERE_API_KEY}
    depends_on:
      - elasticsearch
    volumes:
      - .:/app

volumes:
  es_data:
````

## Shrnutí Projektu

### Klíčové Výhody
- **Přirozené porozumění**: Systém rozumí konverzačním dotazům v češtině
- **Multimodální vyhledávání**: Kombinace textových a sémantických technik
- **Kontextové doporučení**: Zohlednění příjemce, aktivity a záměru
- **Vysvětlitelnost**: Každé doporučení je podložené zdůvodněním

### Technické Inovace
- Kombinace CLIP embedingů s česky optimalizovanými modely
- Hybridní vyhledávání (sémantické + textové)
- RAG architektura s Command R+ pro pokročilé reasoning
- Škálovatelná Elasticsearch infrastruktura

### Budoucí Rozšíření
- **Personalizace**: Učení z historie uživatele
- **Vizuální vyhledávání**: Vyhledávání podle obrázků
- **Real-time doporučení**: Streamování aktualizací
- **A/B testování**: Optimalizace algoritmů

Tento projekt demonstruje praktickou implementaci RAG architektury pro e-commerce s důrazem na uživatelskou přívětivost a českou lokalizaci.