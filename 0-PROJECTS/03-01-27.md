<small>Claude Sonnet 4 **(Cryptocurrency and Blockchain Intelligence with RAG)**</small>
# Cryptocurrency and Blockchain Intelligence

## Key Concepts Explanation

### Retrieval-Augmented Generation (RAG)
A technique that combines information retrieval with generative AI to provide accurate, contextual analysis of cryptocurrency markets by first retrieving relevant data from blockchain networks, market feeds, and research documents, then using an LLM to generate comprehensive investment insights and risk assessments.

### Market Analysis
Comprehensive evaluation of cryptocurrency markets including price movements, trading volumes, market capitalization trends, correlation analysis, and technical indicators to identify patterns, opportunities, and risks in digital asset markets.

### White Papers
Technical documents published by cryptocurrency projects that detail their technology, tokenomics, use cases, and implementation roadmaps, serving as primary sources for fundamental analysis and project evaluation.

### Trading Patterns
Recurring behaviors and trends in cryptocurrency trading including volume patterns, price movements, whale activity, and market cycles that can be analyzed to predict future market behavior and inform trading strategies.

### DeFi Protocols
Decentralized Finance protocols that provide financial services through smart contracts, including lending platforms, decentralized exchanges, yield farming opportunities, and liquidity pools that require analysis for risk and return assessment.

### Smart Contract Analysis
Technical evaluation of blockchain smart contracts including code auditing, security assessment, gas optimization analysis, and functionality verification to assess the reliability and safety of DeFi protocols and cryptocurrency projects.

### Risk Assessment
Systematic evaluation of potential risks in cryptocurrency investments including market risk, liquidity risk, regulatory risk, technology risk, and counterparty risk to inform investment decisions and portfolio management strategies.

## Comprehensive Project Explanation

The Cryptocurrency and Blockchain Intelligence platform is an AI-powered system that democratizes access to sophisticated blockchain analysis and cryptocurrency market intelligence. By leveraging RAG technology, this platform combines real-time market data, technical analysis, smart contract evaluation, and research synthesis to provide comprehensive insights for investors, traders, and blockchain developers.

### Objectives
- **Market Intelligence**: Provide real-time analysis of cryptocurrency markets with AI-powered insights and predictive analytics
- **Risk Management**: Deliver comprehensive risk assessment tools for cryptocurrency investments and DeFi protocol evaluation
- **Research Synthesis**: Aggregate and analyze white papers, technical documentation, and market research to inform investment decisions
- **Smart Contract Security**: Analyze smart contracts for security vulnerabilities and functionality assessment
- **Portfolio Optimization**: Offer personalized recommendations for cryptocurrency portfolio construction and management

### Challenges
- **Data Quality and Reliability**: Managing inconsistent data sources, API limitations, and ensuring accurate real-time market information
- **Market Volatility**: Handling extreme price volatility and rapid market changes that can quickly invalidate analysis
- **Regulatory Compliance**: Navigating evolving regulatory landscapes and ensuring compliance with financial regulations
- **Smart Contract Complexity**: Analyzing increasingly complex DeFi protocols and identifying subtle security vulnerabilities
- **Information Overload**: Processing vast amounts of market data, social sentiment, and technical information efficiently

### Potential Impact
- **Democratized Analysis**: Making institutional-grade cryptocurrency analysis accessible to retail investors and smaller firms
- **Enhanced Security**: Improving smart contract security through automated analysis and vulnerability detection
- **Market Efficiency**: Contributing to more efficient price discovery and reduced information asymmetries in crypto markets
- **Risk Reduction**: Helping investors make more informed decisions and avoid common cryptocurrency investment pitfalls
- **Innovation Acceleration**: Supporting blockchain development through comprehensive protocol analysis and research synthesis

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
langchain==0.1.0
openai==1.3.0
chromadb==0.4.18
pandas==2.1.4
numpy==1.24.3
requests==2.31.0
python-dotenv==1.0.0
pydantic==2.5.0
fastapi==0.104.1
uvicorn==0.24.0
web3==6.12.0
ccxt==4.1.77
yfinance==0.2.22
plotly==5.17.0
streamlit==1.28.1
aiohttp==3.9.1
beautifulsoup4==4.12.2
ta-lib==0.4.28
scikit-learn==1.3.2
scipy==1.11.4
asyncio==3.4.3
websockets==12.0
pycoingecko==3.1.0
eth-account==0.9.0
solana==0.30.2
````

### Core Implementation

````python
# main.py
import os
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple, Union
from dataclasses import dataclass, asdict
from pydantic import BaseModel
import asyncio
import logging
from pathlib import Path
import aiohttp
import ccxt.async_support as ccxt
from web3 import Web3

from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import Document
import chromadb
import openai
from dotenv import load_dotenv

import talib
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
from scipy import stats

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class CryptoCurrency:
    symbol: str
    name: str
    current_price: float
    market_cap: int
    volume_24h: int
    price_change_24h: float
    price_change_percentage_24h: float
    market_cap_rank: int
    circulating_supply: float
    total_supply: Optional[float]
    max_supply: Optional[float]
    ath: float
    ath_date: str
    atl: float
    atl_date: str

@dataclass
class TradingSignal:
    symbol: str
    signal_type: str  # buy, sell, hold
    strength: float  # 0-1
    confidence: float  # 0-1
    reasoning: str
    technical_indicators: Dict[str, float]
    timestamp: datetime
    target_price: Optional[float]
    stop_loss: Optional[float]

@dataclass
class DeFiProtocol:
    protocol_id: str
    name: str
    category: str  # lending, dex, yield farming, etc.
    tvl: float  # Total Value Locked
    apy: float
    risk_score: float  # 0-10 scale
    audit_status: str
    smart_contract_address: str
    blockchain: str
    description: str
    risks: List[str]
    rewards: List[str]

@dataclass
class SmartContractAnalysis:
    contract_address: str
    blockchain: str
    contract_type: str
    security_score: float  # 0-10
    vulnerabilities: List[str]
    gas_efficiency: float
    code_quality: float
    audit_findings: List[str]
    recommendations: List[str]
    last_analyzed: datetime

@dataclass
class MarketSentiment:
    timestamp: datetime
    fear_greed_index: int  # 0-100
    social_sentiment: float  # -1 to 1
    news_sentiment: float  # -1 to 1
    whale_activity: str  # high, medium, low
    institutional_flow: float
    retail_sentiment: float

@dataclass
class RiskAssessment:
    asset_symbol: str
    overall_risk_score: float  # 0-10
    market_risk: float
    liquidity_risk: float
    technology_risk: float
    regulatory_risk: float
    counterparty_risk: float
    volatility_score: float
    correlation_risks: Dict[str, float]
    recommendations: List[str]

class CryptoDataCollector:
    """Collects cryptocurrency and blockchain data from various sources"""
    
    def __init__(self):
        self.exchanges = {}
        self.w3 = Web3(Web3.HTTPProvider(os.getenv("ETHEREUM_RPC_URL", "https://eth-mainnet.g.alchemy.com/v2/demo")))
        self.sample_data = self._generate_sample_data()
    
    def _generate_sample_data(self):
        """Generate comprehensive sample cryptocurrency data"""
        return {
            'currencies': [
                CryptoCurrency(
                    symbol="BTC",
                    name="Bitcoin",
                    current_price=43250.50,
                    market_cap=847500000000,
                    volume_24h=28500000000,
                    price_change_24h=1250.75,
                    price_change_percentage_24h=2.98,
                    market_cap_rank=1,
                    circulating_supply=19600000,
                    total_supply=19600000,
                    max_supply=21000000,
                    ath=69045.00,
                    ath_date="2021-11-10",
                    atl=67.81,
                    atl_date="2013-07-06"
                ),
                CryptoCurrency(
                    symbol="ETH",
                    name="Ethereum",
                    current_price=2650.25,
                    market_cap=318750000000,
                    volume_24h=15200000000,
                    price_change_24h=85.30,
                    price_change_percentage_24h=3.33,
                    market_cap_rank=2,
                    circulating_supply=120280000,
                    total_supply=120280000,
                    max_supply=None,
                    ath=4878.26,
                    ath_date="2021-11-10",
                    atl=0.43,
                    atl_date="2015-10-21"
                ),
                CryptoCurrency(
                    symbol="SOL",
                    name="Solana",
                    current_price=98.75,
                    market_cap=42850000000,
                    volume_24h=2100000000,
                    price_change_24h=4.25,
                    price_change_percentage_24h=4.5,
                    market_cap_rank=5,
                    circulating_supply=434000000,
                    total_supply=580000000,
                    max_supply=None,
                    ath=259.96,
                    ath_date="2021-11-06",
                    atl=0.50,
                    atl_date="2020-05-11"
                )
            ],
            'defi_protocols': [
                DeFiProtocol(
                    protocol_id="uniswap",
                    name="Uniswap V3",
                    category="DEX",
                    tvl=3850000000,
                    apy=0.25,
                    risk_score=3.5,
                    audit_status="Audited by Trail of Bits",
                    smart_contract_address="0x1F98431c8aD98523631AE4a59f267346ea31F984",
                    blockchain="Ethereum",
                    description="Leading decentralized exchange with concentrated liquidity",
                    risks=["Impermanent loss", "Smart contract risk", "Regulatory risk"],
                    rewards=["Trading fees", "UNI token rewards", "High liquidity"]
                ),
                DeFiProtocol(
                    protocol_id="aave",
                    name="Aave V3",
                    category="Lending",
                    tvl=5200000000,
                    apy=0.045,
                    risk_score=4.2,
                    audit_status="Audited by OpenZeppelin",
                    smart_contract_address="0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2",
                    blockchain="Ethereum",
                    description="Decentralized lending protocol with flash loans",
                    risks=["Liquidation risk", "Interest rate volatility", "Smart contract bugs"],
                    rewards=["Interest earnings", "AAVE rewards", "Flash loan fees"]
                ),
                DeFiProtocol(
                    protocol_id="compound",
                    name="Compound V3",
                    category="Lending",
                    tvl=2100000000,
                    apy=0.038,
                    risk_score=3.8,
                    audit_status="Audited by Trail of Bits",
                    smart_contract_address="0xc3d688B66703497DAA19211EEdff47f25384cdc3",
                    blockchain="Ethereum",
                    description="Algorithmic money market protocol",
                    risks=["Collateral risk", "Governance risk", "Oracle manipulation"],
                    rewards=["Supply interest", "COMP rewards", "Borrowing incentives"]
                )
            ],
            'smart_contracts': [
                SmartContractAnalysis(
                    contract_address="0x1F98431c8aD98523631AE4a59f267346ea31F984",
                    blockchain="Ethereum",
                    contract_type="DEX Factory",
                    security_score=8.5,
                    vulnerabilities=["Potential front-running in certain conditions"],
                    gas_efficiency=7.8,
                    code_quality=9.2,
                    audit_findings=["Minor optimization suggestions", "No critical vulnerabilities"],
                    recommendations=["Implement MEV protection", "Gas optimization for small trades"],
                    last_analyzed=datetime.now() - timedelta(days=7)
                ),
                SmartContractAnalysis(
                    contract_address="0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2",
                    blockchain="Ethereum",
                    contract_type="Lending Pool",
                    security_score=9.1,
                    vulnerabilities=[],
                    gas_efficiency=8.2,
                    code_quality=9.5,
                    audit_findings=["Comprehensive testing", "Formal verification completed"],
                    recommendations=["Monitor oracle dependencies", "Regular parameter updates"],
                    last_analyzed=datetime.now() - timedelta(days=3)
                )
            ],
            'market_sentiment': MarketSentiment(
                timestamp=datetime.now(),
                fear_greed_index=65,
                social_sentiment=0.25,
                news_sentiment=0.15,
                whale_activity="medium",
                institutional_flow=1500000000,
                retail_sentiment=0.35
            )
        }
    
    async def fetch_market_data(self, symbols: List[str]) -> Dict[str, CryptoCurrency]:
        """Fetch real-time market data for cryptocurrencies"""
        # In production, this would call actual APIs like CoinGecko, CoinMarketCap, etc.
        logger.info(f"Fetching market data for {symbols}")
        
        market_data = {}
        for symbol in symbols:
            # Find matching sample data
            crypto = next((c for c in self.sample_data['currencies'] if c.symbol == symbol.upper()), None)
            if crypto:
                market_data[symbol] = crypto
        
        return market_data
    
    async def get_trading_history(self, symbol: str, timeframe: str = "1d", limit: int = 100) -> pd.DataFrame:
        """Get historical trading data for technical analysis"""
        # Generate sample OHLCV data
        dates = pd.date_range(end=datetime.now(), periods=limit, freq='D')
        
        # Simulate price data with some volatility
        base_price = 40000 if symbol == "BTC" else 2500 if symbol == "ETH" else 95
        price_changes = np.random.normal(0, 0.02, limit)  # 2% daily volatility
        
        prices = [base_price]
        for change in price_changes[1:]:
            new_price = prices[-1] * (1 + change)
            prices.append(max(new_price, base_price * 0.5))  # Prevent extreme drops
        
        df = pd.DataFrame({
            'timestamp': dates,
            'open': prices,
            'high': [p * (1 + abs(np.random.normal(0, 0.01))) for p in prices],
            'low': [p * (1 - abs(np.random.normal(0, 0.01))) for p in prices],
            'close': prices,
            'volume': np.random.uniform(1000000, 50000000, limit)
        })
        
        return df
    
    async def analyze_defi_protocol(self, protocol_id: str) -> Optional[DeFiProtocol]:
        """Analyze a DeFi protocol for risks and opportunities"""
        protocol = next((p for p in self.sample_data['defi_protocols'] if p.protocol_id == protocol_id), None)
        return protocol
    
    async def get_smart_contract_analysis(self, contract_address: str) -> Optional[SmartContractAnalysis]:
        """Get smart contract security analysis"""
        analysis = next((a for a in self.sample_data['smart_contracts'] if a.contract_address == contract_address), None)
        return analysis
    
    async def get_market_sentiment(self) -> MarketSentiment:
        """Get current market sentiment indicators"""
        return self.sample_data['market_sentiment']

class TechnicalAnalyzer:
    """Performs technical analysis on cryptocurrency price data"""
    
    def __init__(self):
        self.indicators = {}
    
    def calculate_indicators(self, df: pd.DataFrame) -> Dict[str, float]:
        """Calculate various technical indicators"""
        close_prices = df['close'].values
        high_prices = df['high'].values
        low_prices = df['low'].values
        volume = df['volume'].values
        
        indicators = {}
        
        try:
            # Moving Averages
            indicators['sma_20'] = talib.SMA(close_prices, timeperiod=20)[-1]
            indicators['sma_50'] = talib.SMA(close_prices, timeperiod=50)[-1]
            indicators['ema_12'] = talib.EMA(close_prices, timeperiod=12)[-1]
            indicators['ema_26'] = talib.EMA(close_prices, timeperiod=26)[-1]
            
            # MACD
            macd, macdsignal, macdhist = talib.MACD(close_prices)
            indicators['macd'] = macd[-1] if not np.isnan(macd[-1]) else 0
            indicators['macd_signal'] = macdsignal[-1] if not np.isnan(macdsignal[-1]) else 0
            
            # RSI
            indicators['rsi'] = talib.RSI(close_prices, timeperiod=14)[-1]
            
            # Bollinger Bands
            bb_upper, bb_middle, bb_lower = talib.BBANDS(close_prices)
            indicators['bb_upper'] = bb_upper[-1]
            indicators['bb_middle'] = bb_middle[-1]
            indicators['bb_lower'] = bb_lower[-1]
            
            # Stochastic
            slowk, slowd = talib.STOCH(high_prices, low_prices, close_prices)
            indicators['stoch_k'] = slowk[-1] if not np.isnan(slowk[-1]) else 50
            indicators['stoch_d'] = slowd[-1] if not np.isnan(slowd[-1]) else 50
            
            # Volume indicators
            indicators['volume_sma'] = np.mean(volume[-20:])
            indicators['current_volume'] = volume[-1]
            
            # Volatility
            indicators['volatility'] = np.std(close_prices[-20:]) / np.mean(close_prices[-20:])
            
        except Exception as e:
            logger.warning(f"Error calculating some indicators: {e}")
            # Fill with neutral values if calculation fails
            for key in ['sma_20', 'sma_50', 'ema_12', 'ema_26', 'macd', 'macd_signal', 
                       'rsi', 'bb_upper', 'bb_middle', 'bb_lower', 'stoch_k', 'stoch_d']:
                indicators.setdefault(key, close_prices[-1])
            indicators.setdefault('volume_sma', np.mean(volume))
            indicators.setdefault('current_volume', volume[-1])
            indicators.setdefault('volatility', 0.02)
        
        return indicators
    
    def generate_trading_signal(self, symbol: str, indicators: Dict[str, float], current_price: float) -> TradingSignal:
        """Generate trading signal based on technical indicators"""
        
        signals = []
        reasoning_parts = []
        
        # RSI Analysis
        rsi = indicators.get('rsi', 50)
        if rsi > 70:
            signals.append(-0.3)  # Overbought - bearish
            reasoning_parts.append(f"RSI ({rsi:.1f}) indicates overbought conditions")
        elif rsi < 30:
            signals.append(0.3)  # Oversold - bullish
            reasoning_parts.append(f"RSI ({rsi:.1f}) indicates oversold conditions")
        
        # MACD Analysis
        macd = indicators.get('macd', 0)
        macd_signal = indicators.get('macd_signal', 0)
        if macd > macd_signal:
            signals.append(0.2)  # Bullish crossover
            reasoning_parts.append("MACD showing bullish momentum")
        else:
            signals.append(-0.2)  # Bearish crossover
            reasoning_parts.append("MACD showing bearish momentum")
        
        # Moving Average Analysis
        sma_20 = indicators.get('sma_20', current_price)
        sma_50 = indicators.get('sma_50', current_price)
        if current_price > sma_20 > sma_50:
            signals.append(0.25)  # Bullish trend
            reasoning_parts.append("Price above both 20 and 50 SMA - bullish trend")
        elif current_price < sma_20 < sma_50:
            signals.append(-0.25)  # Bearish trend
            reasoning_parts.append("Price below both 20 and 50 SMA - bearish trend")
        
        # Bollinger Bands Analysis
        bb_upper = indicators.get('bb_upper', current_price * 1.02)
        bb_lower = indicators.get('bb_lower', current_price * 0.98)
        bb_position = (current_price - bb_lower) / (bb_upper - bb_lower)
        if bb_position > 0.8:
            signals.append(-0.15)  # Near upper band - potential reversal
            reasoning_parts.append("Price near upper Bollinger Band")
        elif bb_position < 0.2:
            signals.append(0.15)  # Near lower band - potential bounce
            reasoning_parts.append("Price near lower Bollinger Band")
        
        # Volume Analysis
        volume_ratio = indicators.get('current_volume', 0) / indicators.get('volume_sma', 1)
        if volume_ratio > 1.5:
            signals.append(0.1)  # High volume confirms moves
            reasoning_parts.append("Above-average volume supports price movement")
        
        # Calculate overall signal
        overall_signal = np.mean(signals) if signals else 0
        confidence = min(abs(overall_signal) * 2, 1.0)
        
        # Determine signal type
        if overall_signal > 0.1:
            signal_type = "buy"
            target_price = current_price * 1.05
            stop_loss = current_price * 0.95
        elif overall_signal < -0.1:
            signal_type = "sell"
            target_price = current_price * 0.95
            stop_loss = current_price * 1.05
        else:
            signal_type = "hold"
            target_price = None
            stop_loss = None
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            strength=abs(overall_signal),
            confidence=confidence,
            reasoning="; ".join(reasoning_parts),
            technical_indicators=indicators,
            timestamp=datetime.now(),
            target_price=target_price,
            stop_loss=stop_loss
        )

class RiskAnalyzer:
    """Analyzes various types of risks in cryptocurrency investments"""
    
    def __init__(self):
        self.correlation_matrix = {}
    
    def calculate_volatility_risk(self, price_data: pd.DataFrame) -> float:
        """Calculate volatility-based risk score"""
        returns = price_data['close'].pct_change().dropna()
        volatility = returns.std() * np.sqrt(365)  # Annualized volatility
        
        # Convert to 0-10 risk score (higher volatility = higher risk)
        # Crypto volatility typically ranges from 20% to 200%
        risk_score = min(volatility * 5, 10)
        return risk_score
    
    def assess_liquidity_risk(self, crypto: CryptoCurrency) -> float:
        """Assess liquidity risk based on volume and market cap"""
        # Calculate volume to market cap ratio
        volume_ratio = crypto.volume_24h / crypto.market_cap if crypto.market_cap > 0 else 0
        
        # Higher volume ratio = lower liquidity risk
        if volume_ratio > 0.1:
            return 2.0  # Low risk
        elif volume_ratio > 0.05:
            return 4.0  # Medium risk
        elif volume_ratio > 0.01:
            return 6.0  # High risk
        else:
            return 9.0  # Very high risk
    
    def evaluate_technology_risk(self, contract_analysis: Optional[SmartContractAnalysis]) -> float:
        """Evaluate technology and smart contract risks"""
        if not contract_analysis:
            return 7.0  # High risk if no analysis available
        
        # Base risk on security score (inverted)
        base_risk = 10 - contract_analysis.security_score
        
        # Adjust for vulnerabilities
        vulnerability_penalty = len(contract_analysis.vulnerabilities) * 0.5
        
        # Adjust for audit status
        audit_bonus = -1.0 if contract_analysis.audit_findings else 0
        
        total_risk = base_risk + vulnerability_penalty + audit_bonus
        return max(0, min(total_risk, 10))
    
    def assess_regulatory_risk(self, crypto: CryptoCurrency) -> float:
        """Assess regulatory risk based on asset characteristics"""
        # This is simplified - in reality would consider:
        # - Regulatory announcements
        # - Compliance status
        # - Geographic restrictions
        
        risk_factors = {
            'BTC': 3.0,  # Generally accepted
            'ETH': 4.0,  # Some regulatory concerns around staking
            'USDT': 6.0,  # Stablecoin regulatory scrutiny
            'SOL': 5.0,  # Newer chain with some concerns
        }
        
        return risk_factors.get(crypto.symbol, 6.0)  # Default medium-high risk
    
    def calculate_comprehensive_risk(self, 
                                   crypto: CryptoCurrency, 
                                   price_data: pd.DataFrame,
                                   contract_analysis: Optional[SmartContractAnalysis] = None) -> RiskAssessment:
        """Calculate comprehensive risk assessment"""
        
        # Calculate individual risk components
        volatility_risk = self.calculate_volatility_risk(price_data)
        liquidity_risk = self.assess_liquidity_risk(crypto)
        technology_risk = self.evaluate_technology_risk(contract_analysis)
        regulatory_risk = self.assess_regulatory_risk(crypto)
        
        # Market risk (based on market cap rank and dominance)
        market_risk = min(crypto.market_cap_rank / 10, 8.0) if crypto.market_cap_rank else 8.0
        
        # Counterparty risk (simplified)
        counterparty_risk = 4.0  # Base assumption for decentralized assets
        
        # Overall risk (weighted average)
        weights = {
            'market': 0.25,
            'liquidity': 0.20,
            'volatility': 0.20,
            'technology': 0.15,
            'regulatory': 0.15,
            'counterparty': 0.05
        }
        
        overall_risk = (
            market_risk * weights['market'] +
            liquidity_risk * weights['liquidity'] +
            volatility_risk * weights['volatility'] +
            technology_risk * weights['technology'] +
            regulatory_risk * weights['regulatory'] +
            counterparty_risk * weights['counterparty']
        )
        
        # Generate recommendations based on risk levels
        recommendations = []
        if overall_risk > 7:
            recommendations.append("High-risk asset - consider small position sizes")
            recommendations.append("Implement strict stop-loss orders")
        elif overall_risk > 5:
            recommendations.append("Medium-risk asset - suitable for diversified portfolios")
            recommendations.append("Monitor market conditions closely")
        else:
            recommendations.append("Lower-risk asset - suitable for core holdings")
            recommendations.append("Consider larger position sizes with proper risk management")
        
        if volatility_risk > 7:
            recommendations.append("High volatility - expect significant price swings")
        if liquidity_risk > 6:
            recommendations.append("Liquidity concerns - may be difficult to exit large positions")
        if technology_risk > 6:
            recommendations.append("Technology risks identified - monitor development updates")
        if regulatory_risk > 6:
            recommendations.append("Regulatory uncertainty - stay updated on compliance requirements")
        
        return RiskAssessment(
            asset_symbol=crypto.symbol,
            overall_risk_score=overall_risk,
            market_risk=market_risk,
            liquidity_risk=liquidity_risk,
            technology_risk=technology_risk,
            regulatory_risk=regulatory_risk,
            counterparty_risk=counterparty_risk,
            volatility_score=volatility_risk,
            correlation_risks={},  # Simplified for this example
            recommendations=recommendations
        )

class CryptoIntelligenceRAG:
    """RAG system for cryptocurrency and blockchain intelligence"""
    
    def __init__(self):
        # Initialize OpenAI
        openai.api_key = os.getenv("OPENAI_API_KEY")
        
        # Initialize components
        self.embeddings = OpenAIEmbeddings()
        self.llm = ChatOpenAI(model="gpt-4", temperature=0.3)
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        
        # Initialize vector store
        self.client = chromadb.PersistentClient(path="./crypto_intelligence_db")
        self.vectorstore = Chroma(
            client=self.client,
            collection_name="crypto_knowledge",
            embedding_function=self.embeddings
        )
        
        self.data_collector = CryptoDataCollector()
        self.technical_analyzer = TechnicalAnalyzer()
        self.risk_analyzer = RiskAnalyzer()
    
    async def initialize_knowledge_base(self):
        """Initialize the knowledge base with cryptocurrency and blockchain data"""
        logger.info("Initializing crypto intelligence knowledge base...")
        
        documents = []
        
        # Add cryptocurrency information
        for crypto in self.data_collector.sample_data['currencies']:
            doc_content = f"""
            Cryptocurrency: {crypto.name} ({crypto.symbol})
            Current Price: ${crypto.current_price:,.2f}
            Market Cap: ${crypto.market_cap:,}
            24h Volume: ${crypto.volume_24h:,}
            24h Change: {crypto.price_change_percentage_24h:+.2f}%
            Market Cap Rank: #{crypto.market_cap_rank}
            Circulating Supply: {crypto.circulating_supply:,.0f}
            Total Supply: {crypto.total_supply:,.0f if crypto.total_supply else 'N/A'}
            Max Supply: {crypto.max_supply:,.0f if crypto.max_supply else 'N/A'}
            All-Time High: ${crypto.ath:,.2f} on {crypto.ath_date}
            All-Time Low: ${crypto.atl:,.2f} on {crypto.atl_date}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "cryptocurrency",
                    "symbol": crypto.symbol,
                    "name": crypto.name,
                    "market_cap_rank": crypto.market_cap_rank,
                    "current_price": crypto.current_price
                }
            ))
        
        # Add DeFi protocol information
        for protocol in self.data_collector.sample_data['defi_protocols']:
            doc_content = f"""
            DeFi Protocol: {protocol.name}
            Category: {protocol.category}
            Total Value Locked (TVL): ${protocol.tvl:,.0f}
            Annual Percentage Yield (APY): {protocol.apy:.1%}
            Risk Score: {protocol.risk_score}/10
            Audit Status: {protocol.audit_status}
            Blockchain: {protocol.blockchain}
            Smart Contract: {protocol.smart_contract_address}
            Description: {protocol.description}
            Risks: {'; '.join(protocol.risks)}
            Rewards: {'; '.join(protocol.rewards)}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "defi_protocol",
                    "protocol_id": protocol.protocol_id,
                    "name": protocol.name,
                    "category": protocol.category,
                    "tvl": protocol.tvl,
                    "risk_score": protocol.risk_score
                }
            ))
        
        # Add smart contract analysis
        for analysis in self.data_collector.sample_data['smart_contracts']:
            doc_content = f"""
            Smart Contract Analysis
            Address: {analysis.contract_address}
            Blockchain: {analysis.blockchain}
            Contract Type: {analysis.contract_type}
            Security Score: {analysis.security_score}/10
            Gas Efficiency: {analysis.gas_efficiency}/10
            Code Quality: {analysis.code_quality}/10
            Vulnerabilities: {'; '.join(analysis.vulnerabilities) if analysis.vulnerabilities else 'None identified'}
            Audit Findings: {'; '.join(analysis.audit_findings)}
            Recommendations: {'; '.join(analysis.recommendations)}
            Last Analyzed: {analysis.last_analyzed.strftime('%Y-%m-%d')}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "smart_contract_analysis",
                    "contract_address": analysis.contract_address,
                    "blockchain": analysis.blockchain,
                    "security_score": analysis.security_score,
                    "contract_type": analysis.contract_type
                }
            ))
        
        # Add market sentiment data
        sentiment = self.data_collector.sample_data['market_sentiment']
        doc_content = f"""
        Market Sentiment Analysis
        Timestamp: {sentiment.timestamp.strftime('%Y-%m-%d %H:%M:%S')}
        Fear & Greed Index: {sentiment.fear_greed_index}/100
        Social Sentiment: {sentiment.social_sentiment:+.2f}
        News Sentiment: {sentiment.news_sentiment:+.2f}
        Whale Activity: {sentiment.whale_activity}
        Institutional Flow: ${sentiment.institutional_flow:,.0f}
        Retail Sentiment: {sentiment.retail_sentiment:+.2f}
        """
        documents.append(Document(
            page_content=doc_content,
            metadata={
                "type": "market_sentiment",
                "fear_greed_index": sentiment.fear_greed_index,
                "social_sentiment": sentiment.social_sentiment,
                "whale_activity": sentiment.whale_activity
            }
        ))
        
        # Add general crypto knowledge
        crypto_concepts = [
            {
                "title": "Blockchain Technology",
                "content": "Blockchain is a distributed ledger technology that maintains a continuously growing list of records, called blocks, which are linked and secured using cryptography. It provides transparency, immutability, and decentralization."
            },
            {
                "title": "DeFi (Decentralized Finance)",
                "content": "DeFi refers to a blockchain-based form of finance that does not rely on central financial intermediaries. It includes protocols for lending, borrowing, trading, and earning yield on cryptocurrency assets."
            },
            {
                "title": "Smart Contracts",
                "content": "Smart contracts are self-executing contracts with the terms of the agreement directly written into code. They automatically execute when predetermined conditions are met, eliminating the need for intermediaries."
            },
            {
                "title": "Yield Farming",
                "content": "Yield farming involves lending or staking cryptocurrency assets to generate high returns or rewards in the form of additional cryptocurrency. It's a key component of DeFi protocols."
            },
            {
                "title": "Liquidity Mining",
                "content": "Liquidity mining is the process of providing liquidity to a decentralized exchange (DEX) or protocol in exchange for rewards, typically in the form of the platform's native tokens."
            }
        ]
        
        for concept in crypto_concepts:
            documents.append(Document(
                page_content=f"Title: {concept['title']}\nContent: {concept['content']}",
                metadata={
                    "type": "crypto_concept",
                    "title": concept['title']
                }
            ))
        
        # Add documents to vector store
        if documents:
            self.vectorstore.add_documents(documents)
        
        logger.info(f"Added {len(documents)} documents to knowledge base")
    
    def retrieve_relevant_information(self, query: str, k: int = 8) -> List[Document]:
        """Retrieve relevant cryptocurrency information"""
        return self.vectorstore.similarity_search(query, k=k)
    
    async def analyze_cryptocurrency(self, symbol: str) -> Dict[str, any]:
        """Comprehensive cryptocurrency analysis"""
        
        # Get market data
        market_data = await self.data_collector.fetch_market_data([symbol])
        crypto = market_data.get(symbol)
        
        if not crypto:
            return {"error": f"Cryptocurrency {symbol} not found"}
        
        # Get historical data for technical analysis
        price_data = await self.data_collector.get_trading_history(symbol)
        
        # Calculate technical indicators
        indicators = self.technical_analyzer.calculate_indicators(price_data)
        
        # Generate trading signal
        trading_signal = self.technical_analyzer.generate_trading_signal(symbol, indicators, crypto.current_price)
        
        # Calculate risk assessment
        risk_assessment = self.risk_analyzer.calculate_comprehensive_risk(crypto, price_data)
        
        # Get market sentiment
        sentiment = await self.data_collector.get_market_sentiment()
        
        # Retrieve relevant context
        query = f"{crypto.name} {symbol} analysis market trends technical indicators"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Generate comprehensive analysis
        prompt = ChatPromptTemplate.from_template("""
        Provide a comprehensive analysis of this cryptocurrency:
        
        Cryptocurrency: {name} ({symbol})
        Current Price: ${current_price:,.2f}
        Market Cap: ${market_cap:,}
        24h Change: {price_change:+.2f}%
        Market Rank: #{rank}
        
        Technical Analysis:
        - RSI: {rsi:.1f}
        - MACD: {macd:.4f}
        - Price vs SMA20: {price_vs_sma:.2%}
        - Volatility: {volatility:.2%}
        
        Trading Signal: {signal_type} (Strength: {signal_strength:.2f}, Confidence: {confidence:.2f})
        Signal Reasoning: {signal_reasoning}
        
        Risk Assessment:
        - Overall Risk Score: {risk_score:.1f}/10
        - Volatility Risk: {volatility_risk:.1f}/10
        - Liquidity Risk: {liquidity_risk:.1f}/10
        
        Market Sentiment:
        - Fear & Greed Index: {fear_greed}/100
        - Social Sentiment: {social_sentiment:+.2f}
        
        Additional Context: {context}
        
        Provide analysis covering:
        1. Current market position and trends
        2. Technical analysis interpretation
        3. Risk factors and considerations
        4. Investment thesis (bullish/bearish/neutral)
        5. Key levels to watch (support/resistance)
        6. Recommendations for different investor types
        7. Potential catalysts and risks ahead
        
        Make it actionable and balanced, suitable for investment decision-making.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "name": crypto.name,
            "symbol": crypto.symbol,
            "current_price": crypto.current_price,
            "market_cap": crypto.market_cap,
            "price_change": crypto.price_change_percentage_24h,
            "rank": crypto.market_cap_rank,
            "rsi": indicators.get('rsi', 50),
            "macd": indicators.get('macd', 0),
            "price_vs_sma": (crypto.current_price - indicators.get('sma_20', crypto.current_price)) / indicators.get('sma_20', crypto.current_price),
            "volatility": indicators.get('volatility', 0.02),
            "signal_type": trading_signal.signal_type,
            "signal_strength": trading_signal.strength,
            "confidence": trading_signal.confidence,
            "signal_reasoning": trading_signal.reasoning,
            "risk_score": risk_assessment.overall_risk_score,
            "volatility_risk": risk_assessment.volatility_score,
            "liquidity_risk": risk_assessment.liquidity_risk,
            "fear_greed": sentiment.fear_greed_index,
            "social_sentiment": sentiment.social_sentiment,
            "context": context
        })
        
        return {
            "cryptocurrency": asdict(crypto),
            "analysis": response.content,
            "technical_indicators": indicators,
            "trading_signal": asdict(trading_signal),
            "risk_assessment": asdict(risk_assessment),
            "market_sentiment": asdict(sentiment),
            "analysis_timestamp": datetime.now().isoformat()
        }
    
    async def analyze_defi_protocol(self, protocol_id: str) -> Dict[str, any]:
        """Analyze DeFi protocol for risks and opportunities"""
        
        protocol = await self.data_collector.analyze_defi_protocol(protocol_id)
        if not protocol:
            return {"error": f"DeFi protocol {protocol_id} not found"}
        
        # Get smart contract analysis if available
        contract_analysis = await self.data_collector.get_smart_contract_analysis(protocol.smart_contract_address)
        
        # Retrieve relevant context
        query = f"{protocol.name} DeFi {protocol.category} risks rewards analysis"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        prompt = ChatPromptTemplate.from_template("""
        Analyze this DeFi protocol for investment and usage considerations:
        
        Protocol: {name}
        Category: {category}
        Total Value Locked: ${tvl:,.0f}
        APY: {apy:.1%}
        Risk Score: {risk_score}/10
        Audit Status: {audit_status}
        Blockchain: {blockchain}
        
        Identified Risks: {risks}
        Potential Rewards: {rewards}
        
        Smart Contract Security Score: {security_score}/10
        Contract Analysis: {contract_info}
        
        Context: {context}
        
        Provide comprehensive analysis including:
        1. Protocol overview and value proposition
        2. Risk-reward assessment
        3. Security considerations
        4. Comparison with alternatives
        5. User suitability (conservative vs aggressive)
        6. Entry and exit strategies
        7. Monitoring recommendations
        8. Red flags to watch for
        
        Focus on actionable insights for DeFi users and investors.
        """)
        
        contract_info = f"Security vulnerabilities: {', '.join(contract_analysis.vulnerabilities) if contract_analysis and contract_analysis.vulnerabilities else 'None identified'}" if contract_analysis else "No smart contract analysis available"
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "name": protocol.name,
            "category": protocol.category,
            "tvl": protocol.tvl,
            "apy": protocol.apy,
            "risk_score": protocol.risk_score,
            "audit_status": protocol.audit_status,
            "blockchain": protocol.blockchain,
            "risks": "; ".join(protocol.risks),
            "rewards": "; ".join(protocol.rewards),
            "security_score": contract_analysis.security_score if contract_analysis else 0,
            "contract_info": contract_info,
            "context": context
        })
        
        return {
            "protocol": asdict(protocol),
            "analysis": response.content,
            "smart_contract_analysis": asdict(contract_analysis) if contract_analysis else None,
            "analysis_timestamp": datetime.now().isoformat()
        }
    
    async def generate_market_report(self, focus_area: str = "general") -> Dict[str, any]:
        """Generate comprehensive market report"""
        
        # Get market data for major cryptocurrencies
        major_cryptos = ["BTC", "ETH", "SOL"]
        market_data = await self.data_collector.fetch_market_data(major_cryptos)
        
        # Get market sentiment
        sentiment = await self.data_collector.get_market_sentiment()
        
        # Retrieve relevant market context
        query = f"cryptocurrency market {focus_area} trends analysis outlook"
        relevant_docs = self.retrieve_relevant_information(query, k=8)
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Prepare market summary
        market_summary = []
        for symbol, crypto in market_data.items():
            market_summary.append(f"{crypto.name}: ${crypto.current_price:,.2f} ({crypto.price_change_percentage_24h:+.2f}%)")
        
        prompt = ChatPromptTemplate.from_template("""
        Generate a comprehensive cryptocurrency market report:
        
        Focus Area: {focus_area}
        
        Major Cryptocurrencies:
        {market_summary}
        
        Market Sentiment:
        - Fear & Greed Index: {fear_greed}/100
        - Social Sentiment: {social_sentiment:+.2f}
        - News Sentiment: {news_sentiment:+.2f}
        - Whale Activity: {whale_activity}
        - Institutional Flow: ${institutional_flow:,.0f}
        
        Market Context: {context}
        
        Create a comprehensive report covering:
        1. Executive Summary
        2. Market Overview and Key Movements
        3. Sentiment Analysis and Market Psychology
        4. Technical Analysis Summary
        5. DeFi and Altcoin Highlights
        6. Risk Factors and Concerns
        7. Opportunities and Investment Themes
        8. Short-term and Long-term Outlook
        9. Actionable Recommendations
        
        Make it professional and suitable for investors and traders.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "focus_area": focus_area,
            "market_summary": "\n".join(market_summary),
            "fear_greed": sentiment.fear_greed_index,
            "social_sentiment": sentiment.social_sentiment,
            "news_sentiment": sentiment.news_sentiment,
            "whale_activity": sentiment.whale_activity,
            "institutional_flow": sentiment.institutional_flow,
            "context": context
        })
        
        return {
            "focus_area": focus_area,
            "market_report": response.content,
            "market_data": {symbol: asdict(crypto) for symbol, crypto in market_data.items()},
            "market_sentiment": asdict(sentiment),
            "report_timestamp": datetime.now().isoformat()
        }

class CryptoIntelligenceAssistant:
    """Main assistant orchestrating cryptocurrency and blockchain intelligence"""
    
    def __init__(self):
        self.rag_system = CryptoIntelligenceRAG()
        self.initialized = False
    
    async def initialize(self):
        """Initialize the intelligence assistant"""
        if not self.initialized:
            await self.rag_system.initialize_knowledge_base()
            self.initialized = True
            logger.info("Crypto Intelligence Assistant initialized successfully")
    
    async def analyze_asset(self, symbol: str) -> Dict[str, any]:
        """Comprehensive asset analysis"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.analyze_cryptocurrency(symbol)
    
    async def evaluate_defi_opportunity(self, protocol_id: str) -> Dict[str, any]:
        """Evaluate DeFi protocol opportunity"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.analyze_defi_protocol(protocol_id)
    
    async def get_market_intelligence(self, focus: str = "general") -> Dict[str, any]:
        """Get comprehensive market intelligence report"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.generate_market_report(focus)
    
    async def compare_cryptocurrencies(self, symbols: List[str]) -> Dict[str, any]:
        """Compare multiple cryptocurrencies"""
        
        if not self.initialized:
            await self.initialize()
        
        analyses = {}
        for symbol in symbols:
            analysis = await self.rag_system.analyze_cryptocurrency(symbol)
            if "error" not in analysis:
                analyses[symbol] = analysis
        
        if not analyses:
            return {"error": "No valid cryptocurrencies found for comparison"}
        
        # Generate comparison report
        comparison_data = []
        for symbol, analysis in analyses.items():
            crypto = analysis['cryptocurrency']
            risk = analysis['risk_assessment']
            signal = analysis['trading_signal']
            
            comparison_data.append(f"""
            {crypto['name']} ({symbol}):
            - Price: ${crypto['current_price']:,.2f} ({crypto['price_change_percentage_24h']:+.2f}%)
            - Market Cap Rank: #{crypto['market_cap_rank']}
            - Risk Score: {risk['overall_risk_score']:.1f}/10
            - Trading Signal: {signal['signal_type']} (Confidence: {signal['confidence']:.2f})
            """)
        
        prompt = ChatPromptTemplate.from_template("""
        Compare these cryptocurrencies and provide investment insights:
        
        {comparison_data}
        
        Provide comprehensive comparison covering:
        1. Performance comparison (price, market cap, volume)
        2. Risk-adjusted returns analysis
        3. Technical analysis comparison
        4. Risk profile differences
        5. Investment suitability for different profiles
        6. Correlation and portfolio diversification benefits
        7. Relative valuation assessment
        8. Recommendation ranking with rationale
        
        Make it actionable for portfolio construction and investment decisions.
        """)
        
        chain = prompt | self.rag_system.llm
        response = await chain.ainvoke({
            "comparison_data": "\n".join(comparison_data)
        })
        
        return {
            "symbols": symbols,
            "individual_analyses": analyses,
            "comparison_report": response.content,
            "comparison_timestamp": datetime.now().isoformat()
        }

# Example usage and testing
async def main():
    """Main function demonstrating the Crypto Intelligence Assistant"""
    
    print(" Initializing Cryptocurrency and Blockchain Intelligence Assistant...")
    assistant = CryptoIntelligenceAssistant()
    
    try:
        # Initialize the system
        await assistant.initialize()
        print(" Crypto Intelligence Assistant initialized successfully")
        
        # Analyze cryptocurrency
        print("\n Analyzing Bitcoin...")
        btc_analysis = await assistant.analyze_asset("BTC")
        
        print(" BTC Analysis Complete:")
        if "cryptocurrency" in btc_analysis:
            crypto = btc_analysis["cryptocurrency"]
            print(f"Price: ${crypto['current_price']:,.2f}")
            print(f"24h Change: {crypto['price_change_percentage_24h']:+.2f}%")
            print(f"Market Cap Rank: #{crypto['market_cap_rank']}")
            print(f"Analysis preview: {btc_analysis['analysis'][:200]}...")
        
        # Evaluate DeFi protocol
        print("\n Evaluating Uniswap protocol...")
        defi_analysis = await assistant.evaluate_defi_opportunity("uniswap")
        
        print(" DeFi Analysis Complete:")
        if "protocol" in defi_analysis:
            protocol = defi_analysis["protocol"]
            print(f"Protocol: {protocol['name']}")
            print(f"TVL: ${protocol['tvl']:,.0f}")
            print(f"Risk Score: {protocol['risk_score']}/10")
            print(f"Analysis preview: {defi_analysis['analysis'][:200]}...")
        
        # Get market intelligence
        print("\n Generating market intelligence report...")
        market_report = await assistant.get_market_intelligence("DeFi")
        
        print(" Market Report Generated:")
        print(f"Focus: {market_report['focus_area']}")
        print(f"Report preview: {market_report['market_report'][:200]}...")
        
        # Compare cryptocurrencies
        print("\n Comparing cryptocurrencies...")
        comparison = await assistant.compare_cryptocurrencies(["BTC", "ETH", "SOL"])
        
        print(" Cryptocurrency Comparison Complete:")
        print(f"Compared: {', '.join(comparison['symbols'])}")
        print(f"Comparison preview: {comparison['comparison_report'][:200]}...")
        
        print("\n Cryptocurrency and Blockchain Intelligence demonstration completed successfully!")
        
    except Exception as e:
        logger.error(f"Error in main execution: {str(e)}")
        print(f" Error: {str(e)}")

if __name__ == "__main__":
    # Set up environment variables
    os.environ.setdefault("OPENAI_API_KEY", "your-openai-api-key-here")
    os.environ.setdefault("ETHEREUM_RPC_URL", "your-ethereum-rpc-url-here")
    
    # Run the main function
    asyncio.run(main())
````

## Project Summary

The **Cryptocurrency and Blockchain Intelligence** platform represents a cutting-edge approach to digital asset analysis, combining RAG technology with comprehensive market data and blockchain analytics to provide institutional-grade intelligence accessible to all investors. This system revolutionizes cryptocurrency investment decision-making by offering AI-powered insights that synthesize complex market dynamics, technical analysis, and risk assessment.

### Key Value Propositions

**Democratized Analysis**: Makes sophisticated cryptocurrency analysis accessible to retail investors by providing the same level of intelligence traditionally available only to institutional players, leveling the playing field in digital asset markets.

**Comprehensive Risk Management**: Delivers multi-dimensional risk assessment covering market, liquidity, technology, and regulatory risks, enabling more informed investment decisions and better portfolio protection in volatile crypto markets.

**Real-time Intelligence**: Combines live market data with AI analysis to provide timely insights on market trends, trading opportunities, and risk factors, essential for success in fast-moving cryptocurrency markets.

**DeFi Protocol Analysis**: Offers detailed evaluation of decentralized finance protocols including smart contract security assessment, yield opportunity analysis, and risk-reward optimization for DeFi participants.

### Technical Excellence

The implementation showcases advanced fintech engineering with **LangChain** for RAG orchestration, **CCXT** for multi-exchange connectivity, **Web3** for blockchain interaction, **TA-Lib** for technical analysis, and **ChromaDB** for financial knowledge storage. The architecture supports real-time data processing, multi-asset analysis, and scalable intelligence generation.

### Impact and Applications

This platform serves cryptocurrency investors, DeFi participants, blockchain developers, financial advisors, and institutional traders. Applications include portfolio optimization, risk management, DeFi yield farming, smart contract auditing, and market research for cryptocurrency projects.

The project demonstrates how AI can transform cryptocurrency investing from speculation to informed decision-making, providing the analytical tools necessary to navigate the complex and rapidly evolving digital asset landscape. Through intelligent automation and comprehensive analysis, this system contributes to more efficient and safer cryptocurrency markets while empowering investors with institutional-grade intelligence.