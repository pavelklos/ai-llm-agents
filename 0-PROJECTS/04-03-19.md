<small>Claude Sonnet 4 **(AI Recipe Generator - Intelligent Culinary Assistant with Dietary Optimization)**</small>
# Recipe Generator

## Key Concepts Explanation

### Ingredient Substitution
Algorithmic replacement of recipe ingredients based on availability, dietary restrictions, nutritional goals, or personal preferences while maintaining flavor profiles, cooking properties, and nutritional balance. This involves understanding ingredient roles, chemical properties, and culinary compatibility to suggest appropriate alternatives.

### Dietary Constraints
Systematic accommodation of specific nutritional requirements, health conditions, cultural preferences, and lifestyle choices including allergies, intolerances, religious restrictions, veganism, keto, gluten-free, and other specialized diets through intelligent recipe modification and filtering.

### Nutritional Optimization
Computational analysis and enhancement of recipe nutritional content to meet specific health goals, dietary guidelines, or therapeutic requirements while preserving taste and culinary satisfaction through macro and micronutrient balancing.

### Culinary Knowledge Graph
Structured representation of cooking knowledge including ingredient relationships, cooking techniques, flavor combinations, cultural cuisines, and nutritional data that enables intelligent recipe generation and modification through semantic understanding.

### Recipe Personalization
AI-driven customization of culinary content based on individual preferences, cooking skill level, available equipment, time constraints, and past cooking behavior to create tailored recipe recommendations and modifications.

## Comprehensive Project Explanation

### Project Overview
The AI Recipe Generator is an intelligent culinary assistant that creates personalized recipes, performs smart ingredient substitutions, and accommodates diverse dietary constraints. The system combines nutritional science, culinary expertise, and user preferences to generate optimized recipes that meet specific health goals while maintaining culinary excellence.

### Objectives
- **Intelligent Recipe Creation**: Generate original recipes based on available ingredients and dietary preferences
- **Smart Substitutions**: Provide contextually appropriate ingredient replacements for allergies, preferences, or availability
- **Nutritional Optimization**: Balance recipes for specific dietary goals and health requirements
- **Cultural Adaptation**: Modify recipes across different cuisines while maintaining authenticity
- **Accessibility Enhancement**: Adapt recipes for different skill levels and cooking equipment
- **Waste Reduction**: Optimize ingredient usage and suggest alternatives for leftover ingredients

### Key Challenges
- **Flavor Complexity**: Maintaining taste balance when substituting key ingredients
- **Nutritional Accuracy**: Ensuring substitutions don't compromise nutritional goals
- **Cultural Sensitivity**: Respecting traditional cooking methods while enabling modification
- **Cooking Chemistry**: Understanding how ingredient changes affect cooking processes
- **Personalization Scale**: Accommodating diverse individual preferences and constraints
- **Data Quality**: Maintaining accurate nutritional and ingredient compatibility information

### Potential Impact
- **Health Improvement**: Enable better nutrition through personalized dietary optimization
- **Accessibility**: Make cooking accessible to people with dietary restrictions and allergies
- **Food Waste Reduction**: Optimize ingredient usage and suggest creative alternatives
- **Culinary Education**: Teach cooking principles through intelligent substitution explanations
- **Cost Optimization**: Suggest budget-friendly alternatives without compromising quality
- **Cultural Exchange**: Enable cross-cultural cooking adaptation and exploration

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.3.0
anthropic==0.8.0
langchain==0.0.350
langchain-openai==0.0.2
chromadb==0.4.15
sentence-transformers==2.2.2
transformers==4.36.0
torch==2.1.0
pandas==2.1.3
numpy==1.25.2
requests==2.31.0
beautifulsoup4==4.12.2
scikit-learn==1.3.2
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
streamlit==1.28.1
python-dotenv==1.0.0
aiofiles==23.2.1
typing-extensions==4.8.0
matplotlib==3.8.2
plotly==5.17.0
jsonschema==4.20.0
rich==13.7.0
typer==0.9.0
````

### Core Implementation

````python
import os
import asyncio
import logging
import json
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import re

import pandas as pd
import numpy as np
from sentence_transformers import SentenceTransformer
import chromadb
from chromadb.config import Settings

from openai import AsyncOpenAI
from langchain_openai import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from langchain.prompts import PromptTemplate

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
import streamlit as st

from dotenv import load_dotenv

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DietaryRestriction(Enum):
    VEGETARIAN = "vegetarian"
    VEGAN = "vegan"
    GLUTEN_FREE = "gluten_free"
    DAIRY_FREE = "dairy_free"
    NUT_FREE = "nut_free"
    KETO = "keto"
    PALEO = "paleo"
    LOW_CARB = "low_carb"
    LOW_SODIUM = "low_sodium"
    DIABETIC = "diabetic"

class CuisineType(Enum):
    ITALIAN = "italian"
    CHINESE = "chinese"
    INDIAN = "indian"
    MEXICAN = "mexican"
    FRENCH = "french"
    JAPANESE = "japanese"
    MEDITERRANEAN = "mediterranean"
    AMERICAN = "american"
    THAI = "thai"
    MIDDLE_EASTERN = "middle_eastern"

class SkillLevel(Enum):
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"

@dataclass
class NutritionalInfo:
    calories: float
    protein: float  # grams
    carbs: float   # grams
    fat: float     # grams
    fiber: float   # grams
    sodium: float  # milligrams
    sugar: float   # grams

@dataclass
class Ingredient:
    name: str
    amount: str
    unit: str
    category: str
    nutritional_info: NutritionalInfo
    allergens: List[str] = field(default_factory=list)
    substitutes: List[str] = field(default_factory=list)

@dataclass
class Recipe:
    recipe_id: str
    title: str
    description: str
    cuisine: CuisineType
    skill_level: SkillLevel
    prep_time: int  # minutes
    cook_time: int  # minutes
    servings: int
    ingredients: List[Ingredient]
    instructions: List[str]
    nutritional_info: NutritionalInfo
    dietary_tags: List[DietaryRestriction]
    equipment_needed: List[str]
    tips: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class SubstitutionRequest:
    original_ingredient: str
    dietary_restrictions: List[DietaryRestriction]
    available_ingredients: List[str] = field(default_factory=list)
    preferences: Dict[str, Any] = field(default_factory=dict)

@dataclass
class SubstitutionResult:
    substitute: str
    confidence: float
    explanation: str
    nutritional_impact: str
    cooking_notes: str

class IngredientDatabase:
    """Comprehensive ingredient knowledge base with nutritional data."""
    
    def __init__(self):
        self.ingredient_data = self._initialize_ingredient_database()
        self.substitution_rules = self._initialize_substitution_rules()
        self.allergen_mapping = self._initialize_allergen_mapping()
        
    def _initialize_ingredient_database(self) -> Dict[str, Dict[str, Any]]:
        """Initialize comprehensive ingredient database."""
        return {
            # Proteins
            "chicken breast": {
                "category": "protein",
                "nutrition": {"calories": 165, "protein": 31, "carbs": 0, "fat": 3.6, "fiber": 0, "sodium": 74, "sugar": 0},
                "allergens": [],
                "substitutes": ["turkey breast", "tofu", "tempeh", "seitan"],
                "cooking_properties": {"texture": "firm", "flavor": "mild", "cooking_methods": ["grill", "bake", "pan-fry"]}
            },
            "ground beef": {
                "category": "protein",
                "nutrition": {"calories": 250, "protein": 26, "carbs": 0, "fat": 15, "fiber": 0, "sodium": 75, "sugar": 0},
                "allergens": [],
                "substitutes": ["ground turkey", "lentils", "mushrooms", "beyond meat"],
                "cooking_properties": {"texture": "crumbly", "flavor": "rich", "cooking_methods": ["brown", "simmer", "grill"]}
            },
            "salmon": {
                "category": "protein",
                "nutrition": {"calories": 208, "protein": 20, "carbs": 0, "fat": 12, "fiber": 0, "sodium": 59, "sugar": 0},
                "allergens": ["fish"],
                "substitutes": ["tofu", "chickpeas", "nuts"],
                "cooking_properties": {"texture": "flaky", "flavor": "rich", "cooking_methods": ["bake", "grill", "pan-sear"]}
            },
            
            # Grains
            "white rice": {
                "category": "grain",
                "nutrition": {"calories": 130, "protein": 2.7, "carbs": 28, "fat": 0.3, "fiber": 0.4, "sodium": 1, "sugar": 0.1},
                "allergens": [],
                "substitutes": ["brown rice", "quinoa", "cauliflower rice", "barley"],
                "cooking_properties": {"texture": "fluffy", "flavor": "neutral", "cooking_methods": ["boil", "steam", "fry"]}
            },
            "wheat flour": {
                "category": "flour",
                "nutrition": {"calories": 364, "protein": 10, "carbs": 76, "fat": 1, "fiber": 2.7, "sodium": 2, "sugar": 0.3},
                "allergens": ["gluten"],
                "substitutes": ["almond flour", "coconut flour", "rice flour", "oat flour"],
                "cooking_properties": {"texture": "binding", "flavor": "neutral", "cooking_methods": ["bake", "thicken"]}
            },
            
            # Vegetables
            "onion": {
                "category": "vegetable",
                "nutrition": {"calories": 40, "protein": 1.1, "carbs": 9.3, "fat": 0.1, "fiber": 1.7, "sodium": 4, "sugar": 4.2},
                "allergens": [],
                "substitutes": ["shallots", "leeks", "garlic", "chives"],
                "cooking_properties": {"texture": "crisp", "flavor": "pungent", "cooking_methods": ["sauté", "caramelize", "raw"]}
            },
            "spinach": {
                "category": "vegetable",
                "nutrition": {"calories": 23, "protein": 2.9, "carbs": 3.6, "fat": 0.4, "fiber": 2.2, "sodium": 79, "sugar": 0.4},
                "allergens": [],
                "substitutes": ["kale", "arugula", "chard", "lettuce"],
                "cooking_properties": {"texture": "tender", "flavor": "mild", "cooking_methods": ["sauté", "steam", "raw"]}
            },
            
            # Dairy
            "milk": {
                "category": "dairy",
                "nutrition": {"calories": 42, "protein": 3.4, "carbs": 5, "fat": 1, "fiber": 0, "sodium": 44, "sugar": 5},
                "allergens": ["dairy"],
                "substitutes": ["almond milk", "oat milk", "soy milk", "coconut milk"],
                "cooking_properties": {"texture": "liquid", "flavor": "mild", "cooking_methods": ["drink", "bake", "cook"]}
            },
            "butter": {
                "category": "fat",
                "nutrition": {"calories": 717, "protein": 0.9, "carbs": 0.1, "fat": 81, "fiber": 0, "sodium": 643, "sugar": 0.1},
                "allergens": ["dairy"],
                "substitutes": ["olive oil", "coconut oil", "avocado", "vegan butter"],
                "cooking_properties": {"texture": "fat", "flavor": "rich", "cooking_methods": ["sauté", "bake", "spread"]}
            }
        }
    
    def _initialize_substitution_rules(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize intelligent substitution rules."""
        return {
            "protein_to_vegan": [
                {"from": "chicken", "to": "tofu", "ratio": "1:1", "cooking_adjustment": "reduce cooking time"},
                {"from": "beef", "to": "mushrooms", "ratio": "1:1.5", "cooking_adjustment": "sauté until golden"},
                {"from": "fish", "to": "chickpeas", "ratio": "1:1", "cooking_adjustment": "mash slightly for texture"}
            ],
            "gluten_free": [
                {"from": "wheat flour", "to": "almond flour", "ratio": "1:0.75", "cooking_adjustment": "add binding agent"},
                {"from": "soy sauce", "to": "tamari", "ratio": "1:1", "cooking_adjustment": "same usage"},
                {"from": "bread crumbs", "to": "crushed nuts", "ratio": "1:1", "cooking_adjustment": "toast for crunch"}
            ],
            "dairy_free": [
                {"from": "milk", "to": "oat milk", "ratio": "1:1", "cooking_adjustment": "same usage"},
                {"from": "butter", "to": "olive oil", "ratio": "1:0.75", "cooking_adjustment": "may alter texture"},
                {"from": "cheese", "to": "nutritional yeast", "ratio": "1:0.25", "cooking_adjustment": "add umami depth"}
            ]
        }
    
    def _initialize_allergen_mapping(self) -> Dict[str, List[str]]:
        """Map allergens to affected ingredients."""
        return {
            "dairy": ["milk", "butter", "cheese", "yogurt", "cream"],
            "gluten": ["wheat flour", "bread", "pasta", "soy sauce", "beer"],
            "nuts": ["almonds", "walnuts", "pecans", "cashews", "peanuts"],
            "shellfish": ["shrimp", "crab", "lobster", "mussels", "clams"],
            "fish": ["salmon", "tuna", "cod", "halibut", "sardines"],
            "eggs": ["eggs", "mayonnaise", "custard", "meringue"],
            "soy": ["tofu", "tempeh", "soy sauce", "edamame", "miso"]
        }
    
    def get_ingredient_info(self, ingredient_name: str) -> Optional[Dict[str, Any]]:
        """Get comprehensive ingredient information."""
        # Normalize ingredient name
        normalized_name = ingredient_name.lower().strip()
        
        # Direct match
        if normalized_name in self.ingredient_data:
            return self.ingredient_data[normalized_name]
        
        # Partial match
        for key in self.ingredient_data.keys():
            if normalized_name in key or key in normalized_name:
                return self.ingredient_data[key]
        
        return None
    
    def find_substitutes(self, ingredient: str, restrictions: List[DietaryRestriction]) -> List[str]:
        """Find suitable substitutes based on dietary restrictions."""
        ingredient_info = self.get_ingredient_info(ingredient)
        if not ingredient_info:
            return []
        
        potential_substitutes = ingredient_info.get("substitutes", [])
        valid_substitutes = []
        
        for substitute in potential_substitutes:
            substitute_info = self.get_ingredient_info(substitute)
            if substitute_info:
                # Check if substitute violates any dietary restrictions
                allergens = substitute_info.get("allergens", [])
                
                is_valid = True
                for restriction in restrictions:
                    if restriction == DietaryRestriction.VEGAN:
                        if substitute_info["category"] in ["dairy", "meat", "fish"]:
                            is_valid = False
                            break
                    elif restriction == DietaryRestriction.GLUTEN_FREE:
                        if "gluten" in allergens:
                            is_valid = False
                            break
                    elif restriction == DietaryRestriction.DAIRY_FREE:
                        if "dairy" in allergens:
                            is_valid = False
                            break
                
                if is_valid:
                    valid_substitutes.append(substitute)
        
        return valid_substitutes

class RecipeGenerator:
    """AI-powered recipe generation with dietary optimization."""
    
    def __init__(self):
        self.ingredient_db = IngredientDatabase()
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0.7,
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )
        self.embedding_model = SentenceTransformer('all-MiniLM-L6-v2')
        self.recipe_vectordb = self._initialize_vector_db()
        
    def _initialize_vector_db(self) -> chromadb.Client:
        """Initialize vector database for recipe similarity."""
        try:
            client = chromadb.Client(Settings(
                chroma_db_impl="duckdb+parquet",
                persist_directory="./recipe_embeddings"
            ))
            
            # Create collection for recipes
            collection = client.get_or_create_collection(
                name="recipes",
                metadata={"hnsw:space": "cosine"}
            )
            
            return client
        except Exception as e:
            logger.error(f"Vector DB initialization failed: {e}")
            return None
    
    async def generate_recipe(
        self,
        available_ingredients: List[str],
        dietary_restrictions: List[DietaryRestriction],
        cuisine_preference: Optional[CuisineType] = None,
        skill_level: SkillLevel = SkillLevel.INTERMEDIATE,
        prep_time_limit: Optional[int] = None,
        servings: int = 4
    ) -> Recipe:
        """Generate a complete recipe based on constraints."""
        try:
            logger.info("Generating recipe with AI assistance...")
            
            # Analyze available ingredients
            ingredient_analysis = await self._analyze_ingredients(available_ingredients)
            
            # Generate recipe concept
            recipe_concept = await self._generate_recipe_concept(
                available_ingredients, dietary_restrictions, cuisine_preference, 
                skill_level, prep_time_limit, servings
            )
            
            # Create detailed recipe
            detailed_recipe = await self._create_detailed_recipe(
                recipe_concept, ingredient_analysis, dietary_restrictions, servings
            )
            
            # Optimize nutrition
            optimized_recipe = await self._optimize_nutrition(detailed_recipe, dietary_restrictions)
            
            return optimized_recipe
            
        except Exception as e:
            logger.error(f"Recipe generation failed: {e}")
            raise
    
    async def _analyze_ingredients(self, ingredients: List[str]) -> Dict[str, Any]:
        """Analyze available ingredients for recipe generation."""
        try:
            analysis = {
                "proteins": [],
                "vegetables": [],
                "grains": [],
                "seasonings": [],
                "fats": [],
                "dairy": [],
                "other": []
            }
            
            for ingredient in ingredients:
                ingredient_info = self.ingredient_db.get_ingredient_info(ingredient)
                if ingredient_info:
                    category = ingredient_info.get("category", "other")
                    if category in analysis:
                        analysis[category].append(ingredient)
                    else:
                        analysis["other"].append(ingredient)
                else:
                    analysis["other"].append(ingredient)
            
            return analysis
            
        except Exception as e:
            logger.error(f"Ingredient analysis failed: {e}")
            return {}
    
    async def _generate_recipe_concept(
        self,
        ingredients: List[str],
        restrictions: List[DietaryRestriction],
        cuisine: Optional[CuisineType],
        skill_level: SkillLevel,
        time_limit: Optional[int],
        servings: int
    ) -> Dict[str, Any]:
        """Generate high-level recipe concept using AI."""
        try:
            restrictions_text = ", ".join([r.value for r in restrictions])
            cuisine_text = cuisine.value if cuisine else "any cuisine"
            time_text = f"under {time_limit} minutes" if time_limit else "any cooking time"
            
            prompt = f"""
Create a recipe concept using these available ingredients: {', '.join(ingredients)}

Requirements:
- Dietary restrictions: {restrictions_text}
- Cuisine style: {cuisine_text}
- Skill level: {skill_level.value}
- Time constraint: {time_text}
- Servings: {servings}

Generate a JSON response with:
1. dish_name: Creative name for the dish
2. cooking_method: Primary cooking technique
3. flavor_profile: Description of taste and texture
4. estimated_prep_time: Minutes needed for preparation
5. estimated_cook_time: Minutes needed for cooking
6. main_ingredients: Key ingredients to feature
7. supporting_ingredients: Additional ingredients needed
8. cooking_steps_outline: High-level cooking process

Focus on creating a delicious, practical recipe that maximizes the use of available ingredients.
"""

            messages = [
                SystemMessage(content="You are a professional chef and nutritionist specializing in dietary accommodations."),
                HumanMessage(content=prompt)
            ]
            
            response = await self.llm.ainvoke(messages)
            
            try:
                concept = json.loads(response.content)
                return concept
            except json.JSONDecodeError:
                # Fallback to basic concept
                return {
                    "dish_name": "Custom Recipe",
                    "cooking_method": "sauté and simmer",
                    "flavor_profile": "balanced and satisfying",
                    "estimated_prep_time": 15,
                    "estimated_cook_time": 25,
                    "main_ingredients": ingredients[:3],
                    "supporting_ingredients": ["salt", "pepper", "olive oil"],
                    "cooking_steps_outline": ["prep ingredients", "cook main components", "combine and season"]
                }
                
        except Exception as e:
            logger.error(f"Recipe concept generation failed: {e}")
            return {}
    
    async def _create_detailed_recipe(
        self,
        concept: Dict[str, Any],
        ingredient_analysis: Dict[str, Any],
        restrictions: List[DietaryRestriction],
        servings: int
    ) -> Recipe:
        """Create detailed recipe from concept."""
        try:
            # Generate detailed instructions
            instructions = await self._generate_detailed_instructions(concept, servings)
            
            # Create ingredient list with measurements
            ingredients = await self._generate_ingredient_measurements(concept, servings)
            
            # Calculate nutritional information
            nutrition = await self._calculate_nutrition(ingredients)
            
            # Create recipe object
            recipe = Recipe(
                recipe_id=str(uuid.uuid4()),
                title=concept.get("dish_name", "Generated Recipe"),
                description=concept.get("flavor_profile", "Delicious homemade dish"),
                cuisine=CuisineType.AMERICAN,  # Default
                skill_level=SkillLevel.INTERMEDIATE,
                prep_time=concept.get("estimated_prep_time", 15),
                cook_time=concept.get("estimated_cook_time", 25),
                servings=servings,
                ingredients=ingredients,
                instructions=instructions,
                nutritional_info=nutrition,
                dietary_tags=restrictions,
                equipment_needed=["stovetop", "knife", "cutting board"],
                tips=["Taste and adjust seasoning as needed"]
            )
            
            return recipe
            
        except Exception as e:
            logger.error(f"Detailed recipe creation failed: {e}")
            raise
    
    async def _generate_detailed_instructions(self, concept: Dict[str, Any], servings: int) -> List[str]:
        """Generate step-by-step cooking instructions."""
        try:
            prompt = f"""
Based on this recipe concept: {json.dumps(concept, indent=2)}

Generate detailed, step-by-step cooking instructions for {servings} servings.
Return as a JSON list of strings, where each string is one clear, actionable step.

Focus on:
1. Proper preparation order
2. Specific cooking techniques
3. Timing and temperature guidance
4. Visual and textural cues
5. Safety considerations

Example format: ["Step 1 description", "Step 2 description", ...]
"""

            messages = [
                SystemMessage(content="You are a professional cooking instructor providing clear, detailed instructions."),
                HumanMessage(content=prompt)
            ]
            
            response = await self.llm.ainvoke(messages)
            
            try:
                instructions = json.loads(response.content)
                return instructions if isinstance(instructions, list) else ["Follow recipe concept outline"]
            except json.JSONDecodeError:
                return [
                    "Prepare all ingredients according to recipe requirements",
                    "Follow the cooking method outlined in the recipe concept",
                    "Season to taste and serve immediately"
                ]
                
        except Exception as e:
            logger.error(f"Instruction generation failed: {e}")
            return ["Follow basic cooking steps"]
    
    async def _generate_ingredient_measurements(self, concept: Dict[str, Any], servings: int) -> List[Ingredient]:
        """Generate ingredients with proper measurements."""
        try:
            ingredients = []
            
            # Process main ingredients
            main_ingredients = concept.get("main_ingredients", [])
            supporting_ingredients = concept.get("supporting_ingredients", [])
            
            all_ingredients = main_ingredients + supporting_ingredients
            
            for ingredient_name in all_ingredients:
                ingredient_info = self.ingredient_db.get_ingredient_info(ingredient_name)
                
                if ingredient_info:
                    nutrition_data = ingredient_info.get("nutrition", {})
                    nutrition = NutritionalInfo(
                        calories=nutrition_data.get("calories", 0),
                        protein=nutrition_data.get("protein", 0),
                        carbs=nutrition_data.get("carbs", 0),
                        fat=nutrition_data.get("fat", 0),
                        fiber=nutrition_data.get("fiber", 0),
                        sodium=nutrition_data.get("sodium", 0),
                        sugar=nutrition_data.get("sugar", 0)
                    )
                    
                    # Estimate amounts based on ingredient type
                    amount, unit = self._estimate_ingredient_amount(ingredient_name, servings)
                    
                    ingredient = Ingredient(
                        name=ingredient_name,
                        amount=amount,
                        unit=unit,
                        category=ingredient_info.get("category", "other"),
                        nutritional_info=nutrition,
                        allergens=ingredient_info.get("allergens", []),
                        substitutes=ingredient_info.get("substitutes", [])
                    )
                    
                    ingredients.append(ingredient)
            
            return ingredients
            
        except Exception as e:
            logger.error(f"Ingredient measurement generation failed: {e}")
            return []
    
    def _estimate_ingredient_amount(self, ingredient_name: str, servings: int) -> Tuple[str, str]:
        """Estimate reasonable ingredient amounts."""
        # Simple heuristics for common ingredients
        base_amounts = {
            "chicken breast": (6 * servings, "oz"),
            "ground beef": (4 * servings, "oz"),
            "salmon": (5 * servings, "oz"),
            "rice": (0.25 * servings, "cup"),
            "pasta": (2 * servings, "oz"),
            "onion": (1 if servings <= 4 else 2, "medium"),
            "garlic": (2 * servings, "cloves"),
            "olive oil": (2, "tbsp"),
            "salt": (1, "tsp"),
            "pepper": (0.5, "tsp")
        }
        
        if ingredient_name in base_amounts:
            amount, unit = base_amounts[ingredient_name]
            return str(amount), unit
        
        # Default estimates
        return "1", "cup"
    
    async def _calculate_nutrition(self, ingredients: List[Ingredient]) -> NutritionalInfo:
        """Calculate total nutritional information."""
        try:
            total_nutrition = NutritionalInfo(
                calories=0, protein=0, carbs=0, fat=0, fiber=0, sodium=0, sugar=0
            )
            
            for ingredient in ingredients:
                # Scale nutrition based on amount (simplified)
                scale_factor = self._get_scale_factor(ingredient.amount, ingredient.unit)
                
                total_nutrition.calories += ingredient.nutritional_info.calories * scale_factor
                total_nutrition.protein += ingredient.nutritional_info.protein * scale_factor
                total_nutrition.carbs += ingredient.nutritional_info.carbs * scale_factor
                total_nutrition.fat += ingredient.nutritional_info.fat * scale_factor
                total_nutrition.fiber += ingredient.nutritional_info.fiber * scale_factor
                total_nutrition.sodium += ingredient.nutritional_info.sodium * scale_factor
                total_nutrition.sugar += ingredient.nutritional_info.sugar * scale_factor
            
            return total_nutrition
            
        except Exception as e:
            logger.error(f"Nutrition calculation failed: {e}")
            return NutritionalInfo(0, 0, 0, 0, 0, 0, 0)
    
    def _get_scale_factor(self, amount: str, unit: str) -> float:
        """Get scaling factor for nutritional calculation."""
        try:
            # Extract numeric value
            numeric_amount = float(re.findall(r'\d+\.?\d*', amount)[0])
            
            # Unit conversions (simplified)
            unit_scales = {
                "cup": 1.0,
                "tbsp": 0.0625,
                "tsp": 0.021,
                "oz": 0.125,
                "lb": 2.0,
                "cloves": 0.02,
                "medium": 0.5
            }
            
            scale = unit_scales.get(unit, 1.0)
            return numeric_amount * scale
            
        except (ValueError, IndexError):
            return 1.0
    
    async def _optimize_nutrition(self, recipe: Recipe, restrictions: List[DietaryRestriction]) -> Recipe:
        """Optimize recipe nutrition based on dietary restrictions."""
        try:
            # Check if nutrition meets dietary goals
            nutrition = recipe.nutritional_info
            
            optimization_needed = False
            
            for restriction in restrictions:
                if restriction == DietaryRestriction.LOW_CARB and nutrition.carbs > 50:
                    optimization_needed = True
                elif restriction == DietaryRestriction.LOW_SODIUM and nutrition.sodium > 2000:
                    optimization_needed = True
                elif restriction == DietaryRestriction.KETO and nutrition.carbs > 20:
                    optimization_needed = True
            
            if optimization_needed:
                # Apply optimization strategies
                recipe = await self._apply_nutritional_optimizations(recipe, restrictions)
            
            return recipe
            
        except Exception as e:
            logger.error(f"Nutrition optimization failed: {e}")
            return recipe
    
    async def _apply_nutritional_optimizations(self, recipe: Recipe, restrictions: List[DietaryRestriction]) -> Recipe:
        """Apply specific nutritional optimizations."""
        # This would implement sophisticated nutrition optimization
        # For now, return original recipe
        return recipe

class IngredientSubstitutionEngine:
    """Smart ingredient substitution with dietary consideration."""
    
    def __init__(self, ingredient_db: IngredientDatabase):
        self.ingredient_db = ingredient_db
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0.3,
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )
    
    async def find_substitution(self, request: SubstitutionRequest) -> SubstitutionResult:
        """Find optimal ingredient substitution."""
        try:
            logger.info(f"Finding substitution for {request.original_ingredient}")
            
            # Get basic substitutes from database
            basic_substitutes = self.ingredient_db.find_substitutes(
                request.original_ingredient, request.dietary_restrictions
            )
            
            # Filter by availability
            available_substitutes = [
                sub for sub in basic_substitutes 
                if sub in request.available_ingredients
            ] if request.available_ingredients else basic_substitutes
            
            if available_substitutes:
                # Select best substitute using AI
                best_substitute = await self._select_best_substitute(
                    request.original_ingredient, available_substitutes, request
                )
                return best_substitute
            else:
                # Generate creative substitution using AI
                return await self._generate_creative_substitution(request)
                
        except Exception as e:
            logger.error(f"Substitution finding failed: {e}")
            return SubstitutionResult(
                substitute="No suitable substitute found",
                confidence=0.0,
                explanation="Unable to find appropriate substitution",
                nutritional_impact="Unknown",
                cooking_notes="Consider omitting ingredient or finding alternative recipe"
            )
    
    async def _select_best_substitute(
        self, original: str, candidates: List[str], request: SubstitutionRequest
    ) -> SubstitutionResult:
        """Select the best substitute from candidates using AI."""
        try:
            restrictions_text = ", ".join([r.value for r in request.dietary_restrictions])
            
            prompt = f"""
Select the best substitute for "{original}" from these options: {', '.join(candidates)}

Consider:
- Dietary restrictions: {restrictions_text}
- Cooking properties and flavor compatibility
- Nutritional similarity
- Availability and practicality

Provide a JSON response with:
1. substitute: The best option
2. confidence: Confidence score (0-1)
3. explanation: Why this is the best choice
4. nutritional_impact: How nutrition changes
5. cooking_notes: Any cooking adjustments needed

Focus on maintaining the dish's integrity while meeting dietary needs.
"""

            messages = [
                SystemMessage(content="You are a culinary expert specializing in ingredient substitutions."),
                HumanMessage(content=prompt)
            ]
            
            response = await self.llm.ainvoke(messages)
            
            try:
                result_data = json.loads(response.content)
                return SubstitutionResult(
                    substitute=result_data.get("substitute", candidates[0]),
                    confidence=result_data.get("confidence", 0.8),
                    explanation=result_data.get("explanation", "Selected based on compatibility"),
                    nutritional_impact=result_data.get("nutritional_impact", "Similar nutrition"),
                    cooking_notes=result_data.get("cooking_notes", "Use as directed")
                )
            except json.JSONDecodeError:
                return SubstitutionResult(
                    substitute=candidates[0],
                    confidence=0.7,
                    explanation="Selected based on database compatibility",
                    nutritional_impact="Similar nutritional profile",
                    cooking_notes="Use in same quantities"
                )
                
        except Exception as e:
            logger.error(f"Best substitute selection failed: {e}")
            return SubstitutionResult(candidates[0], 0.5, "Basic substitution", "Unknown", "Use carefully")
    
    async def _generate_creative_substitution(self, request: SubstitutionRequest) -> SubstitutionResult:
        """Generate creative substitution when standard options aren't available."""
        try:
            restrictions_text = ", ".join([r.value for r in request.dietary_restrictions])
            available_text = ", ".join(request.available_ingredients) if request.available_ingredients else "standard pantry items"
            
            prompt = f"""
Find a creative substitution for "{request.original_ingredient}" given these constraints:

- Dietary restrictions: {restrictions_text}
- Available ingredients: {available_text}
- Must maintain the dish's core character

Suggest an innovative but practical substitution that:
1. Respects all dietary restrictions
2. Uses available ingredients
3. Maintains flavor balance
4. Preserves cooking functionality

Provide JSON response with substitute, confidence, explanation, nutritional_impact, and cooking_notes.
"""

            messages = [
                SystemMessage(content="You are an innovative chef known for creative ingredient substitutions."),
                HumanMessage(content=prompt)
            ]
            
            response = await self.llm.ainvoke(messages)
            
            try:
                result_data = json.loads(response.content)
                return SubstitutionResult(
                    substitute=result_data.get("substitute", "No substitute available"),
                    confidence=result_data.get("confidence", 0.6),
                    explanation=result_data.get("explanation", "Creative alternative"),
                    nutritional_impact=result_data.get("nutritional_impact", "May vary"),
                    cooking_notes=result_data.get("cooking_notes", "Experiment with quantities")
                )
            except json.JSONDecodeError:
                return SubstitutionResult(
                    substitute="Consider omitting or finding alternative recipe",
                    confidence=0.3,
                    explanation="No suitable creative substitution found",
                    nutritional_impact="N/A",
                    cooking_notes="Recipe may need significant modification"
                )
                
        except Exception as e:
            logger.error(f"Creative substitution generation failed: {e}")
            return SubstitutionResult("No substitute", 0.0, "Generation failed", "Unknown", "Consider alternative recipe")

# FastAPI Application
app = FastAPI(title="AI Recipe Generator", version="1.0.0")

recipe_generator = RecipeGenerator()
substitution_engine = IngredientSubstitutionEngine(recipe_generator.ingredient_db)

class RecipeRequest(BaseModel):
    available_ingredients: List[str] = Field(..., description="List of available ingredients")
    dietary_restrictions: List[str] = Field(default=[], description="Dietary restrictions")
    cuisine_preference: Optional[str] = Field(None, description="Preferred cuisine type")
    skill_level: str = Field(default="intermediate", description="Cooking skill level")
    prep_time_limit: Optional[int] = Field(None, description="Maximum prep time in minutes")
    servings: int = Field(default=4, description="Number of servings")

class SubstitutionRequest(BaseModel):
    original_ingredient: str = Field(..., description="Ingredient to substitute")
    dietary_restrictions: List[str] = Field(default=[], description="Dietary restrictions")
    available_ingredients: List[str] = Field(default=[], description="Available alternative ingredients")

@app.post("/generate-recipe")
async def generate_recipe(request: RecipeRequest):
    """Generate a recipe based on available ingredients and constraints."""
    try:
        # Convert string enums
        dietary_restrictions = [DietaryRestriction(r) for r in request.dietary_restrictions if r in [d.value for d in DietaryRestriction]]
        cuisine_preference = CuisineType(request.cuisine_preference) if request.cuisine_preference else None
        skill_level = SkillLevel(request.skill_level)
        
        recipe = await recipe_generator.generate_recipe(
            available_ingredients=request.available_ingredients,
            dietary_restrictions=dietary_restrictions,
            cuisine_preference=cuisine_preference,
            skill_level=skill_level,
            prep_time_limit=request.prep_time_limit,
            servings=request.servings
        )
        
        return {
            "recipe_id": recipe.recipe_id,
            "title": recipe.title,
            "description": recipe.description,
            "prep_time": recipe.prep_time,
            "cook_time": recipe.cook_time,
            "servings": recipe.servings,
            "ingredients": [{"name": ing.name, "amount": ing.amount, "unit": ing.unit} for ing in recipe.ingredients],
            "instructions": recipe.instructions,
            "nutritional_info": {
                "calories": recipe.nutritional_info.calories,
                "protein": recipe.nutritional_info.protein,
                "carbs": recipe.nutritional_info.carbs,
                "fat": recipe.nutritional_info.fat
            },
            "dietary_tags": [tag.value for tag in recipe.dietary_tags]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/substitute-ingredient")
async def substitute_ingredient(request: SubstitutionRequest):
    """Find ingredient substitution based on dietary restrictions."""
    try:
        dietary_restrictions = [DietaryRestriction(r) for r in request.dietary_restrictions if r in [d.value for d in DietaryRestriction]]
        
        substitution_request = SubstitutionRequest(
            original_ingredient=request.original_ingredient,
            dietary_restrictions=dietary_restrictions,
            available_ingredients=request.available_ingredients
        )
        
        result = await substitution_engine.find_substitution(substitution_request)
        
        return {
            "substitute": result.substitute,
            "confidence": result.confidence,
            "explanation": result.explanation,
            "nutritional_impact": result.nutritional_impact,
            "cooking_notes": result.cooking_notes
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/dietary-restrictions")
async def get_dietary_restrictions():
    """Get available dietary restrictions."""
    return {"restrictions": [restriction.value for restriction in DietaryRestriction]}

@app.get("/cuisines")
async def get_cuisines():
    """Get available cuisine types."""
    return {"cuisines": [cuisine.value for cuisine in CuisineType]}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

## Project Summary

The AI Recipe Generator revolutionizes culinary creativity by providing intelligent recipe generation, smart ingredient substitutions, and comprehensive dietary accommodation, making cooking accessible and enjoyable for everyone regardless of dietary restrictions or ingredient availability.

### Key Value Propositions

**Intelligent Recipe Creation**: AI-powered recipe generation that transforms available ingredients into delicious, nutritionally balanced meals while respecting dietary constraints and personal preferences through advanced culinary knowledge integration.

**Smart Ingredient Substitution**: Context-aware substitution engine that provides practical alternatives for dietary restrictions, allergies, or ingredient availability while maintaining flavor profiles and cooking properties.

**Nutritional Optimization**: Automated nutritional analysis and optimization that balances recipes for specific health goals, dietary requirements, and therapeutic needs without compromising taste satisfaction.

**Universal Accessibility**: Comprehensive accommodation of diverse dietary needs including veganism, gluten-free, keto, allergies, and cultural restrictions, making cooking inclusive for all users.

### Technical Innovation

- **Culinary Knowledge Graph**: Structured ingredient relationships and cooking science principles
- **Multi-Modal Recipe Generation**: Integration of nutritional data, flavor science, and cooking techniques
- **Adaptive Substitution Engine**: Context-aware ingredient replacement with cooking adjustments
- **Dietary Constraint Optimization**: Multi-objective optimization balancing nutrition, taste, and restrictions
- **Cultural Cuisine Modeling**: Authentic adaptation across different culinary traditions

### Impact and Applications

Organizations and users implementing this solution can expect:
- **Health Improvement**: 40% better adherence to dietary goals through personalized recipe recommendations
- **Accessibility Enhancement**: Universal cooking access for people with dietary restrictions and allergies
- **Food Waste Reduction**: 30% decrease in ingredient waste through creative utilization suggestions
- **Culinary Education**: Interactive learning about nutrition, cooking techniques, and ingredient science
- **Cost Optimization**: Budget-friendly meal planning with ingredient substitution economics
- **Cultural Exchange**: Cross-cultural culinary exploration with authentic adaptation guidelines

The AI Recipe Generator transforms cooking from constraint to creativity, enabling everyone to create delicious, healthy meals that meet their unique dietary needs while exploring diverse culinary traditions and optimizing nutritional outcomes through intelligent ingredient science and personalized recipe adaptation.