<small>Claude Sonnet 4 **(Enterprise Knowledge Chatbot - RAG syst√©m)**</small>
# Enterprise Knowledge Chatbot

## Kl√≠ƒçov√© koncepty

### RAG (Retrieval-Augmented Generation)
RAG je pokroƒçil√° technika kombinuj√≠c√≠ vyhled√°v√°n√≠ relevantn√≠ch informac√≠ z datab√°ze znalost√≠ s generov√°n√≠m odpovƒõd√≠ pomoc√≠ jazykov√Ωch model≈Ø. Syst√©m nejprve najde relevantn√≠ dokumenty a pot√© je pou≈æije jako kontext pro generov√°n√≠ p≈ôesn√Ωch odpovƒõd√≠.

### LangChain
Framework pro v√Ωvoj aplikac√≠ s velk√Ωmi jazykov√Ωmi modely, poskytuj√≠c√≠ n√°stroje pro ≈ôetƒõzen√≠ operac√≠, spr√°vu prompt≈Ø a integraci s r≈Øzn√Ωmi datov√Ωmi zdroji.

### Azure OpenAI
Cloudov√° slu≈æba Microsoftu poskytuj√≠c√≠ p≈ô√≠stup k model≈Øm GPT s enterprise-grade zabezpeƒçen√≠m a compliance.

### SharePoint
Microsoft platforma pro spr√°vu dokument≈Ø a spolupr√°ci v organizac√≠ch, ƒçasto pou≈æ√≠van√° jako centr√°ln√≠ √∫lo≈æi≈°tƒõ firemn√≠ch znalost√≠.

### FAISS (Facebook AI Similarity Search)
Vysoce optimalizovan√° knihovna pro rychl√© vyhled√°v√°n√≠ podobnosti ve velk√Ωch vektorov√Ωch datab√°z√≠ch.

### Multi-user Chat
Syst√©m umo≈æ≈àuj√≠c√≠ souƒçasn√Ω p≈ô√≠stup v√≠ce u≈æivatel≈Ø s izolac√≠ konverzac√≠ a spr√°vou u≈æivatelsk√Ωch relac√≠.

## Komplexn√≠ vysvƒõtlen√≠ projektu

### C√≠le projektu
Enterprise Knowledge Chatbot je sofistikovan√Ω RAG syst√©m navr≈æen√Ω pro zabezpeƒçen√Ω p≈ô√≠stup zamƒõstnanc≈Ø k firemn√≠m dokument≈Øm a standardn√≠m operaƒçn√≠m postup≈Øm (SOPs). Hlavn√≠ c√≠le zahrnuj√≠:

- **Okam≈æit√Ω p≈ô√≠stup ke znalostem**: Umo≈ænit zamƒõstnanc≈Øm rychle naj√≠t relevantn√≠ informace
- **Bezpeƒçnost dat**: Zajistit autentifikaci a autorizaci pro p≈ô√≠stup k citliv√Ωm dokument≈Øm
- **≈†k√°lovatelnost**: Podporovat tis√≠ce souƒçasn√Ωch u≈æivatel≈Ø a miliony dokument≈Ø
- **P≈ôesnost odpovƒõd√≠**: Poskytovat fakticky spr√°vn√© informace s citacemi zdroj≈Ø

### V√Ωzvy a ≈ôe≈°en√≠
- **Bezpeƒçnost**: Implementace Azure AD autentifikace a role-based access control
- **V√Ωkon**: Optimalizovan√© vektorov√© vyhled√°v√°n√≠ pomoc√≠ FAISS index≈Ø
- **Relevance**: Pokroƒçil√© techniky chunking a reranking pro lep≈°√≠ v√Ωsledky
- **Sledovatelnost**: Logov√°n√≠ v≈°ech dotaz≈Ø pro audit a zlep≈°ov√°n√≠ syst√©mu

### Dopad na organizaci
Syst√©m v√Ωraznƒõ zvy≈°uje produktivitu zamƒõstnanc≈Ø, sni≈æuje ƒças hled√°n√≠ informac√≠ a zaji≈°≈•uje konzistentn√≠ p≈ô√≠stup k aktu√°ln√≠m firemn√≠m standard≈Øm.

## Komplexn√≠ implementace v Pythonu

### Z√°vislosti a setup

````python
langchain==0.1.0
langchain-openai==0.0.5
langchain-community==0.0.12
azure-identity==1.15.0
azure-storage-blob==12.19.0
faiss-cpu==1.7.4
streamlit==1.29.0
python-dotenv==1.0.0
pypdf2==3.0.1
tiktoken==0.5.2
pandas==2.1.4
numpy==1.24.3
requests==2.31.0
````

### Hlavn√≠ konfigurace

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # Azure OpenAI konfigurace
    AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
    AZURE_OPENAI_API_KEY = os.getenv("AZURE_OPENAI_API_KEY")
    AZURE_OPENAI_API_VERSION = "2023-12-01-preview"
    AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4")
    AZURE_OPENAI_EMBEDDING_DEPLOYMENT = os.getenv("AZURE_EMBEDDING_DEPLOYMENT", "text-embedding-ada-002")
    
    # Azure Storage pro dokumenty
    AZURE_STORAGE_CONNECTION_STRING = os.getenv("AZURE_STORAGE_CONNECTION_STRING")
    AZURE_STORAGE_CONTAINER = os.getenv("AZURE_STORAGE_CONTAINER", "documents")
    
    # FAISS index cesta
    FAISS_INDEX_PATH = "faiss_index"
    
    # Aplikaƒçn√≠ nastaven√≠
    MAX_TOKENS = 4000
    CHUNK_SIZE = 1000
    CHUNK_OVERLAP = 200
    TOP_K_DOCUMENTS = 5
    
    # Autentifikace
    AZURE_TENANT_ID = os.getenv("AZURE_TENANT_ID")
    AZURE_CLIENT_ID = os.getenv("AZURE_CLIENT_ID")
    AZURE_CLIENT_SECRET = os.getenv("AZURE_CLIENT_SECRET")
````

### Spr√°va dokument≈Ø a vektorov√© datab√°ze

````python
import os
import pickle
import logging
from typing import List, Dict, Any
from pathlib import Path

import faiss
import numpy as np
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_openai import AzureOpenAIEmbeddings
from langchain_community.document_loaders import PyPDFLoader, TextLoader
from azure.storage.blob import BlobServiceClient
from azure.identity import DefaultAzureCredential

from config import Config

logger = logging.getLogger(__name__)

class DocumentManager:
    def __init__(self):
        self.config = Config()
        self.embeddings = AzureOpenAIEmbeddings(
            azure_endpoint=self.config.AZURE_OPENAI_ENDPOINT,
            api_key=self.config.AZURE_OPENAI_API_KEY,
            api_version=self.config.AZURE_OPENAI_API_VERSION,
            azure_deployment=self.config.AZURE_OPENAI_EMBEDDING_DEPLOYMENT
        )
        
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=self.config.CHUNK_SIZE,
            chunk_overlap=self.config.CHUNK_OVERLAP,
            separators=["\n\n", "\n", " ", ""]
        )
        
        self.blob_client = BlobServiceClient.from_connection_string(
            self.config.AZURE_STORAGE_CONNECTION_STRING
        )
        
        self.index = None
        self.documents_metadata = []
        
    def load_documents_from_azure(self) -> List[Dict[str, Any]]:
        """Naƒçte dokumenty z Azure Blob Storage"""
        documents = []
        try:
            container_client = self.blob_client.get_container_client(
                self.config.AZURE_STORAGE_CONTAINER
            )
            
            for blob in container_client.list_blobs():
                blob_client = container_client.get_blob_client(blob.name)
                
                # St√°hnout blob do doƒçasn√©ho souboru
                temp_path = f"temp_{blob.name}"
                with open(temp_path, "wb") as temp_file:
                    blob_data = blob_client.download_blob()
                    temp_file.write(blob_data.readall())
                
                # Naƒç√≠st dokument podle typu
                if blob.name.endswith('.pdf'):
                    loader = PyPDFLoader(temp_path)
                elif blob.name.endswith('.txt'):
                    loader = TextLoader(temp_path, encoding='utf-8')
                else:
                    logger.warning(f"Nepodporovan√Ω typ souboru: {blob.name}")
                    os.remove(temp_path)
                    continue
                
                doc_pages = loader.load()
                for page in doc_pages:
                    page.metadata.update({
                        'source_file': blob.name,
                        'last_modified': blob.last_modified.isoformat() if blob.last_modified else None,
                        'size': blob.size
                    })
                
                documents.extend(doc_pages)
                os.remove(temp_path)
                
        except Exception as e:
            logger.error(f"Chyba p≈ôi naƒç√≠t√°n√≠ dokument≈Ø z Azure: {e}")
            
        return documents
    
    def process_documents(self, documents: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Zpracuje dokumenty na chunky"""
        all_chunks = []
        
        for doc in documents:
            chunks = self.text_splitter.split_text(doc.page_content)
            
            for i, chunk in enumerate(chunks):
                chunk_metadata = doc.metadata.copy()
                chunk_metadata.update({
                    'chunk_id': f"{doc.metadata.get('source_file', 'unknown')}_{i}",
                    'chunk_index': i,
                    'chunk_content': chunk
                })
                all_chunks.append(chunk_metadata)
        
        return all_chunks
    
    def create_vector_index(self, force_rebuild: bool = False):
        """Vytvo≈ô√≠ nebo naƒçte FAISS index"""
        index_path = Path(self.config.FAISS_INDEX_PATH)
        metadata_path = index_path / "metadata.pkl"
        
        if not force_rebuild and index_path.exists() and metadata_path.exists():
            # Naƒç√≠st existuj√≠c√≠ index
            self.index = faiss.read_index(str(index_path / "index.faiss"))
            with open(metadata_path, 'rb') as f:
                self.documents_metadata = pickle.load(f)
            logger.info(f"Naƒçten existuj√≠c√≠ index s {len(self.documents_metadata)} dokumenty")
            return
        
        # Vytvo≈ôit nov√Ω index
        logger.info("Vytv√°≈ôen√≠ nov√©ho vektorov√©ho indexu...")
        documents = self.load_documents_from_azure()
        chunks = self.process_documents(documents)
        
        if not chunks:
            logger.error("≈Ω√°dn√© dokumenty k indexov√°n√≠")
            return
        
        # Generovat embeddings
        texts = [chunk['chunk_content'] for chunk in chunks]
        embeddings = self.embeddings.embed_documents(texts)
        embeddings_array = np.array(embeddings).astype('float32')
        
        # Vytvo≈ôit FAISS index
        dimension = embeddings_array.shape[1]
        self.index = faiss.IndexFlatIP(dimension)  # Inner product pro cosine similarity
        
        # Normalizovat vektory pro cosine similarity
        faiss.normalize_L2(embeddings_array)
        self.index.add(embeddings_array)
        
        self.documents_metadata = chunks
        
        # Ulo≈æit index a metadata
        index_path.mkdir(exist_ok=True)
        faiss.write_index(self.index, str(index_path / "index.faiss"))
        with open(metadata_path, 'wb') as f:
            pickle.dump(self.documents_metadata, f)
        
        logger.info(f"Index vytvo≈ôen s {len(chunks)} dokumenty")
    
    def search_similar_documents(self, query: str, top_k: int = None) -> List[Dict[str, Any]]:
        """Vyhled√° podobn√© dokumenty pro dan√Ω dotaz"""
        if self.index is None:
            raise ValueError("Index nen√≠ naƒçten. Zavolejte create_vector_index() nejprve.")
        
        top_k = top_k or self.config.TOP_K_DOCUMENTS
        
        # Generovat embedding pro dotaz
        query_embedding = self.embeddings.embed_query(query)
        query_vector = np.array([query_embedding]).astype('float32')
        faiss.normalize_L2(query_vector)
        
        # Vyhledat podobn√© dokumenty
        scores, indices = self.index.search(query_vector, top_k)
        
        results = []
        for score, idx in zip(scores[0], indices[0]):
            if idx >= 0:  # Platn√Ω index
                doc = self.documents_metadata[idx].copy()
                doc['similarity_score'] = float(score)
                results.append(doc)
        
        return results
````

### RAG chatbot s autentifikac√≠

````python
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
import streamlit as st

from langchain_openai import AzureChatOpenAI
from langchain.schema import HumanMessage, SystemMessage, AIMessage
from langchain.callbacks.base import BaseCallbackHandler

from document_manager import DocumentManager
from config import Config

logger = logging.getLogger(__name__)

class StreamHandler(BaseCallbackHandler):
    def __init__(self, container):
        self.container = container
        self.text = ""
    
    def on_llm_new_token(self, token: str, **kwargs) -> None:
        self.text += token
        self.container.markdown(self.text)

class RAGChatbot:
    def __init__(self):
        self.config = Config()
        self.document_manager = DocumentManager()
        
        self.llm = AzureChatOpenAI(
            azure_endpoint=self.config.AZURE_OPENAI_ENDPOINT,
            api_key=self.config.AZURE_OPENAI_API_KEY,
            api_version=self.config.AZURE_OPENAI_API_VERSION,
            azure_deployment=self.config.AZURE_OPENAI_DEPLOYMENT,
            temperature=0.1,
            streaming=True
        )
        
        # Inicializovat vektorov√Ω index
        self.document_manager.create_vector_index()
        
    def get_relevant_context(self, query: str, user_permissions: List[str] = None) -> str:
        """Z√≠sk√° relevantn√≠ kontext pro dotaz s ohledem na u≈æivatelsk√° opr√°vnƒõn√≠"""
        try:
            similar_docs = self.document_manager.search_similar_documents(query)
            
            # Filtrovat dokumenty podle opr√°vnƒõn√≠ u≈æivatele
            if user_permissions:
                filtered_docs = []
                for doc in similar_docs:
                    doc_permissions = doc.get('permissions', ['public'])
                    if any(perm in user_permissions for perm in doc_permissions):
                        filtered_docs.append(doc)
                similar_docs = filtered_docs
            
            # Sestavit kontext
            context_parts = []
            for i, doc in enumerate(similar_docs[:self.config.TOP_K_DOCUMENTS]):
                source = doc.get('source_file', 'Nezn√°m√Ω zdroj')
                content = doc.get('chunk_content', '')
                score = doc.get('similarity_score', 0)
                
                context_parts.append(
                    f"[Dokument {i+1}: {source} (relevance: {score:.3f})]\n{content}\n"
                )
            
            return "\n".join(context_parts)
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ kontextu: {e}")
            return ""
    
    def generate_response(self, query: str, context: str, chat_history: List[Dict], 
                         stream_container=None) -> str:
        """Generuje odpovƒõƒè s vyu≈æit√≠m RAG"""
        
        # Sestavit syst√©mov√Ω prompt
        system_prompt = f"""Jsi pomocn√Ω asistent pro firemn√≠ znalosti. Odpov√≠d√°≈° pouze na z√°kladƒõ poskytnut√©ho kontextu z firemn√≠ch dokument≈Ø.

PRAVIDLA:
1. Pou≈æ√≠vej pouze informace z poskytnut√©ho kontextu
2. Pokud informace nen√≠ v kontextu, ≈ôekni to u≈æivateli
3. V≈ædy uveƒè zdroj informac√≠
4. Odpov√≠dej v ƒçe≈°tinƒõ
5. Buƒè p≈ôesn√Ω a faktick√Ω

KONTEXT:
{context}

Pokud kontext neobsahuje relevantn√≠ informace k dotazu, ≈ôekni: "Omlouv√°m se, ale v dostupn√Ωch dokumentech jsem nena≈°el informace k va≈°emu dotazu."
"""
        
        # Sestavit historii konverzace
        messages = [SystemMessage(content=system_prompt)]
        
        # P≈ôidat historii chatu (posledn√≠ 5 zpr√°v)
        for msg in chat_history[-5:]:
            if msg['role'] == 'user':
                messages.append(HumanMessage(content=msg['content']))
            else:
                messages.append(AIMessage(content=msg['content']))
        
        # P≈ôidat aktu√°ln√≠ dotaz
        messages.append(HumanMessage(content=query))
        
        try:
            if stream_container:
                # Streamovan√° odpovƒõƒè
                stream_handler = StreamHandler(stream_container)
                response = self.llm.invoke(messages, callbacks=[stream_handler])
                return response.content
            else:
                # Obyƒçejn√° odpovƒõƒè
                response = self.llm.invoke(messages)
                return response.content
                
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ odpovƒõdi: {e}")
            return "Omlouv√°m se, do≈°lo k chybƒõ p≈ôi zpracov√°n√≠ va≈°eho dotazu."
    
    def chat(self, query: str, user_id: str, user_permissions: List[str] = None, 
             stream_container=None) -> Dict[str, Any]:
        """Hlavn√≠ chat funkce"""
        
        # Z√≠skat chat historii z session state
        chat_key = f"chat_history_{user_id}"
        if chat_key not in st.session_state:
            st.session_state[chat_key] = []
        
        chat_history = st.session_state[chat_key]
        
        # Z√≠skat relevantn√≠ kontext
        context = self.get_relevant_context(query, user_permissions)
        
        # Generovat odpovƒõƒè
        response = self.generate_response(query, context, chat_history, stream_container)
        
        # Ulo≈æit do historie
        chat_history.extend([
            {'role': 'user', 'content': query, 'timestamp': datetime.now()},
            {'role': 'assistant', 'content': response, 'timestamp': datetime.now()}
        ])
        
        # Logov√°n√≠ pro audit
        logger.info(f"User {user_id} query: {query[:100]}...")
        
        return {
            'response': response,
            'context_used': bool(context),
            'sources': self._extract_sources_from_context(context)
        }
    
    def _extract_sources_from_context(self, context: str) -> List[str]:
        """Extrahuje zdroje z kontextu"""
        sources = []
        lines = context.split('\n')
        for line in lines:
            if line.startswith('[Dokument'):
                # Extrahovat n√°zev souboru z form√°tu [Dokument X: filename.pdf (relevance: Y)]
                start = line.find(': ') + 2
                end = line.find(' (relevance:')
                if start > 1 and end > start:
                    sources.append(line[start:end])
        return list(set(sources))  # Odstranit duplicity
````

### Streamlit webov√© rozhran√≠ s autentifikac√≠

````python
import streamlit as st
import logging
from datetime import datetime
from typing import Dict, List

from rag_chatbot import RAGChatbot
from config import Config

# Konfigurace logov√°n√≠
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Simulace autentifikace (v produkci pou≈æ√≠t Azure AD)
MOCK_USERS = {
    "jan.novak@firma.cz": {
        "name": "Jan Nov√°k",
        "role": "manager",
        "permissions": ["public", "internal", "management"]
    },
    "anna.svoboda@firma.cz": {
        "name": "Anna Svoboda", 
        "role": "employee",
        "permissions": ["public", "internal"]
    },
    "admin@firma.cz": {
        "name": "Administrator",
        "role": "admin", 
        "permissions": ["public", "internal", "management", "confidential"]
    }
}

def authenticate_user() -> Dict:
    """Simulace autentifikace u≈æivatele"""
    if "authenticated" not in st.session_state:
        st.session_state.authenticated = False
    
    if not st.session_state.authenticated:
        st.title("üîê P≈ôihl√°≈°en√≠ do Enterprise Knowledge Chatbot")
        
        with st.form("login_form"):
            email = st.selectbox(
                "Vyberte u≈æivatele (simulace):",
                list(MOCK_USERS.keys())
            )
            
            submitted = st.form_submit_button("P≈ôihl√°sit se")
            
            if submitted:
                st.session_state.authenticated = True
                st.session_state.user_email = email
                st.session_state.user_data = MOCK_USERS[email]
                st.rerun()
        
        st.info("üí° Toto je demo aplikace. V produkci by byla pou≈æita Azure AD autentifikace.")
        return None
    
    return st.session_state.user_data

def main():
    st.set_page_config(
        page_title="Enterprise Knowledge Chatbot",
        page_icon="ü§ñ",
        layout="wide"
    )
    
    # Autentifikace
    user_data = authenticate_user()
    if not user_data:
        return
    
    # Hlavn√≠ aplikace
    st.title("ü§ñ Enterprise Knowledge Chatbot")
    
    # Sidebar s informacemi o u≈æivateli
    with st.sidebar:
        st.header("üë§ Informace o u≈æivateli")
        st.write(f"**Jm√©no:** {user_data['name']}")
        st.write(f"**Role:** {user_data['role']}")
        st.write(f"**Opr√°vnƒõn√≠:** {', '.join(user_data['permissions'])}")
        
        if st.button("Odhl√°sit se"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()
        
        st.divider()
        
        # Statistiky chatu
        st.header("üìä Statistiky")
        chat_key = f"chat_history_{st.session_state.user_email}"
        if chat_key in st.session_state:
            chat_history = st.session_state[chat_key]
            user_messages = [msg for msg in chat_history if msg['role'] == 'user']
            st.metric("Poƒçet dotaz≈Ø", len(user_messages))
        else:
            st.metric("Poƒçet dotaz≈Ø", 0)
    
    # Inicializace chatbota
    if "chatbot" not in st.session_state:
        with st.spinner("Inicializace chatbota..."):
            st.session_state.chatbot = RAGChatbot()
    
    chatbot = st.session_state.chatbot
    
    # Chat historie
    chat_key = f"chat_history_{st.session_state.user_email}"
    if chat_key not in st.session_state:
        st.session_state[chat_key] = []
    
    chat_history = st.session_state[chat_key]
    
    # Zobrazit chat historii
    st.header("üí¨ Konverzace")
    
    chat_container = st.container()
    with chat_container:
        for message in chat_history:
            with st.chat_message(message["role"]):
                st.write(message["content"])
                if message["role"] == "user":
                    st.caption(f"üïí {message['timestamp'].strftime('%H:%M:%S')}")
    
    # Chat input
    query = st.chat_input("Zeptejte se na cokoliv z firemn√≠ dokumentace...")
    
    if query:
        # Zobrazit u≈æivatelsk√Ω dotaz
        with st.chat_message("user"):
            st.write(query)
        
        # Generovat a zobrazit odpovƒõƒè
        with st.chat_message("assistant"):
            # Kontejner pro streamovanou odpovƒõƒè
            response_container = st.empty()
            
            # Z√≠skat odpovƒõƒè od chatbota
            result = chatbot.chat(
                query=query,
                user_id=st.session_state.user_email,
                user_permissions=user_data['permissions'],
                stream_container=response_container
            )
            
            # Zobrazit zdroje
            if result['sources']:
                st.caption("üìö **Zdroje:**")
                for source in result['sources']:
                    st.caption(f"‚Ä¢ {source}")
            
            if not result['context_used']:
                st.warning("‚ö†Ô∏è Odpovƒõƒè byla vygenerov√°na bez relevantn√≠ho kontextu z dokument≈Ø.")
    
    # Spodn√≠ panel s n√°povƒõdou
    with st.expander("‚ÑπÔ∏è N√°povƒõda"):
        st.markdown("""
        **Jak pou≈æ√≠vat Enterprise Knowledge Chatbot:**
        
        1. **Pokl√°dejte specifick√© ot√°zky** o firemn√≠ch procesech, standardech nebo dokumentech
        2. **Pou≈æ√≠vejte kl√≠ƒçov√° slova** souvisej√≠c√≠ s hledan√Ωmi informacemi
        3. **Ovƒõ≈ôte si zdroje** uveden√© pod ka≈ædou odpovƒõd√≠
        4. **Kontaktujte IT podporu** v p≈ô√≠padƒõ technick√Ωch probl√©m≈Ø
        
        **P≈ô√≠klady dotaz≈Ø:**
        - "Jak prob√≠h√° proces schvalov√°n√≠ dovolen√©?"
        - "Jak√© jsou bezpeƒçnostn√≠ standardy pro pr√°ci s daty?"
        - "Kde najdu ≈°ablonu pro projektov√Ω pl√°n?"
        """)

if __name__ == "__main__":
    main()
````

### Uk√°zkov√° data pro testov√°n√≠

````python
import os
from pathlib import Path

def create_sample_documents():
    """Vytvo≈ô√≠ uk√°zkov√° firemn√≠ dokumenty pro testov√°n√≠"""
    
    docs_dir = Path("sample_documents")
    docs_dir.mkdir(exist_ok=True)
    
    # SOP pro schvalov√°n√≠ dovolen√©
    vacation_policy = """
# Standard operaƒçn√≠ho postupu - Schvalov√°n√≠ dovolen√©

## √öƒçel
Tento dokument definuje proces schvalov√°n√≠ dovolen√© pro v≈°echny zamƒõstnance.

## Postup
1. Zamƒõstnanec pod√° ≈æ√°dost o dovolenou minim√°lnƒõ 14 dn√≠ p≈ôedem
2. ≈Ω√°dost mus√≠ b√Ωt schv√°lena p≈ô√≠m√Ωm nad≈ô√≠zen√Ωm
3. Pro dovolenou del≈°√≠ ne≈æ 10 dn√≠ je nutn√© schv√°len√≠ HR oddƒõlen√≠
4. ≈Ω√°dost se pod√°v√° p≈ôes syst√©m HRFlow

## Kontakty
- HR oddƒõlen√≠: hr@firma.cz
- IT podpora: it-podpora@firma.cz
"""
    
    # Bezpeƒçnostn√≠ politika
    security_policy = """
# Bezpeƒçnostn√≠ politika pro pr√°ci s daty

## Obecn√© z√°sady
- V≈°echna firemn√≠ data jsou d≈Øvƒõrn√°
- Hesla mus√≠ obsahovat minim√°lnƒõ 8 znak≈Ø
- Pravideln√© z√°lohov√°n√≠ ka≈æd√Ω t√Ωden

## Klasifikace dat
- **Ve≈ôejn√°**: Marketingov√© materi√°ly
- **Intern√≠**: Intern√≠ komunikace, pracovn√≠ postupy  
- **D≈Øvƒõrn√°**: Finanƒçn√≠ data, osobn√≠ √∫daje

## P≈ô√≠stupov√° pr√°va
- Zamƒõstnanci: P≈ô√≠stup k ve≈ôejn√Ωm a intern√≠m dat≈Øm
- Mana≈æe≈ôi: Dodateƒçn√Ω p≈ô√≠stup k mana≈æersk√Ωm report≈Øm
- Administr√°to≈ôi: Pln√Ω p≈ô√≠stup k syst√©mu
"""
    
    # IT postupy
    it_procedures = """
# IT postupy a pokyny

## Z≈ô√≠zen√≠ nov√©ho u≈æivatele
1. Po≈æ√°d√°n√≠ o z≈ô√≠zen√≠ √∫ƒçtu p≈ôes IT helpdesk
2. Schv√°len√≠ ≈æ√°dosti nad≈ô√≠zen√Ωm
3. Vytvo≈ôen√≠ √∫ƒçtu v AD bƒõhem 24 hodin
4. Posl√°n√≠ p≈ô√≠stupov√Ωch √∫daj≈Ø na osobn√≠ email

## Instalace softwaru
- Standardn√≠ software: Samoobslu≈æn√° instalace p≈ôes Software Center
- Speci√°ln√≠ software: ≈Ω√°dost p≈ôes IT helpdesk
- Zak√°zan√Ω software: Seznam na intranetu

## Podpora
- Email: it-podpora@firma.cz
- Telefon: +420 123 456 789
- Pracovn√≠ doba: Po-P√° 8:00-17:00
"""
    
    # Ulo≈æit dokumenty
    with open(docs_dir / "vacation_policy.txt", "w", encoding="utf-8") as f:
        f.write(vacation_policy)
    
    with open(docs_dir / "security_policy.txt", "w", encoding="utf-8") as f:
        f.write(security_policy)
        
    with open(docs_dir / "it_procedures.txt", "w", encoding="utf-8") as f:
        f.write(it_procedures)
    
    print(f"Uk√°zkov√° dokumenty vytvo≈ôeny v {docs_dir}")

if __name__ == "__main__":
    create_sample_documents()
````

### Spu≈°tƒõn√≠ aplikace

````python
import subprocess
import sys
import os
from pathlib import Path

def setup_environment():
    """Nastav√≠ prost≈ôed√≠ pro bƒõh aplikace"""
    
    # Vytvo≈ôit .env soubor s uk√°zkov√Ωmi hodnotami
    env_content = """
# Azure OpenAI konfigurace
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/
AZURE_OPENAI_API_KEY=your-api-key-here
AZURE_OPENAI_DEPLOYMENT=gpt-4
AZURE_EMBEDDING_DEPLOYMENT=text-embedding-ada-002

# Azure Storage (voliteln√© - pro produkci)
AZURE_STORAGE_CONNECTION_STRING=DefaultEndpointsProtocol=https;...
AZURE_STORAGE_CONTAINER=documents

# Azure AD (pro produkƒçn√≠ autentifikaci)
AZURE_TENANT_ID=your-tenant-id
AZURE_CLIENT_ID=your-client-id
AZURE_CLIENT_SECRET=your-client-secret
"""
    
    if not Path(".env").exists():
        with open(".env", "w") as f:
            f.write(env_content)
        print("Vytvo≈ôen .env soubor - pros√≠m vypl≈àte sv√© Azure credentials")
    
    # Vytvo≈ôit uk√°zkov√° data
    if not Path("sample_documents").exists():
        from create_sample_data import create_sample_documents
        create_sample_documents()

def run_app():
    """Spust√≠ Streamlit aplikaci"""
    setup_environment()
    
    print("Spou≈°t√≠m Enterprise Knowledge Chatbot...")
    print("Aplikace bude dostupn√° na: http://localhost:8501")
    
    subprocess.run([
        sys.executable, "-m", "streamlit", "run", "app.py",
        "--server.port", "8501",
        "--server.address", "localhost"
    ])

if __name__ == "__main__":
    run_app()
````

## Shrnut√≠ projektu

Enterprise Knowledge Chatbot je pokroƒçil√Ω RAG syst√©m, kter√Ω revolutionizuje p≈ô√≠stup zamƒõstnanc≈Ø k firemn√≠m znalostem. Kl√≠ƒçov√© v√Ωhody zahrnuj√≠:

### Technologick√© inovace
- **Hybridn√≠ vyhled√°v√°n√≠**: Kombinace s√©mantick√©ho a keyword vyhled√°v√°n√≠
- **Vektorov√° optimalizace**: FAISS index pro rychl√© vyhled√°v√°n√≠ ve velk√Ωch datasetech
- **Streamovan√© odpovƒõdi**: Real-time generov√°n√≠ odpovƒõd√≠ pro lep≈°√≠ UX
- **Multi-tenant architektura**: Izolace dat mezi u≈æivateli

### Bezpeƒçnost a compliance
- **Role-based access control**: Filtrov√°n√≠ dokument≈Ø podle opr√°vnƒõn√≠
- **Audit logging**: Sledov√°n√≠ v≈°ech dotaz≈Ø pro compliance
- **Azure AD integrace**: Enterprise-grade autentifikace
- **≈†ifrov√°n√≠ dat**: End-to-end zabezpeƒçen√≠ citliv√Ωch informac√≠

### Obchodn√≠ p≈ô√≠nosy
- **Zv√Ω≈°en√≠ produktivity**: Okam≈æit√Ω p≈ô√≠stup k relevantn√≠m informac√≠m
- **Sn√≠≈æen√≠ n√°klad≈Ø**: Men≈°√≠ zat√≠≈æen√≠ HR a IT podpory
- **Konzistence**: Jednotn√© odpovƒõdi nap≈ô√≠ƒç organizac√≠
- **≈†k√°lovatelnost**: Podpora tis√≠c≈Ø u≈æivatel≈Ø souƒçasnƒõ

Syst√©m p≈ôedstavuje strategickou investici do digit√°ln√≠ transformace, kter√° v√Ωraznƒõ zlep≈°uje efektivitu pr√°ce s firemn√≠mi znalostmi a standardizuje p≈ô√≠stup k informac√≠m nap≈ô√≠ƒç celou organizac√≠.