<small>Claude Sonnet 4 **(Anal√Ωza Finanƒçn√≠ch Trh≈Ø a Podpora Rozhodov√°n√≠ - Multi-Agent Syst√©m)**</small>
# Financial Market Analysis and Decision Support

## Kl√≠ƒçov√© Koncepty Projektu

### Multi-Agent Collaboration (Spolupr√°ce Multi-Agent≈Ø)
Koordinovan√© p≈Øsoben√≠ specializovan√Ωch AI agent≈Ø, kde ka≈æd√Ω agent m√° specifickou roli a schopnosti. Agenti komunikuj√≠ mezi sebou, sd√≠lej√≠ informace a spoleƒçnƒõ ≈ôe≈°√≠ komplexn√≠ √∫koly, kter√© by jeden agent nemohl efektivnƒõ zvl√°dnout.

### Real-Time Data Processing (Zpracov√°n√≠ Dat v Re√°ln√©m ƒåase)
Kontinu√°ln√≠ p≈ô√≠jem, zpracov√°n√≠ a anal√Ωza finanƒçn√≠ch dat z v√≠ce zdroj≈Ø souƒçasnƒõ. Zahrnuje okam≈æit√© reakce na zmƒõny tr≈æn√≠ch podm√≠nek a automatick√© aktualizace anal√Ωz.

### Financial Forecasting (Finanƒçn√≠ Progn√≥zov√°n√≠)
Pou≈æit√≠ machine learning algoritm≈Ø a statistick√Ωch model≈Ø pro predikci budouc√≠ch tr≈æn√≠ch trend≈Ø, cen akci√≠ a ekonomick√Ωch ukazatel≈Ø na z√°kladƒõ historick√Ωch dat a souƒçasn√Ωch tr≈æn√≠ch podm√≠nek.

### News Sentiment Analysis (Anal√Ωza Sentimentu Zpr√°v)
Automatick√© vyhodnocov√°n√≠ emoƒçn√≠ho zabarven√≠ a dopadu finanƒçn√≠ch zpr√°v na trhy. Vyu≈æ√≠v√° NLP techniky pro pochopen√≠, zda jsou zpr√°vy pozitivn√≠, negativn√≠ nebo neutr√°ln√≠.

### Trading APIs Integration (Integrace Trading API)
P≈ôipojen√≠ k brokersk√Ωm platform√°m a finanƒçn√≠m datov√Ωm slu≈æb√°m pro z√≠sk√°v√°n√≠ real-time dat, historick√Ωch informac√≠ a p≈ô√≠padn√© automatick√© obchodov√°n√≠.

### Agent Communication Protocol (Protokol Komunikace Agent≈Ø)
Standardizovan√Ω zp≈Øsob v√Ωmƒõny informac√≠ mezi agenty, vƒçetnƒõ form√°t≈Ø zpr√°v, priorit √∫kol≈Ø a mechanism≈Ø koordinace rozhodov√°n√≠.

## Komplexn√≠ Vysvƒõtlen√≠ Projektu

### C√≠le Projektu
Tento projekt vytv√°≈ô√≠ inteligentn√≠ multi-agent syst√©m pro podporu finanƒçn√≠ch poradc≈Ø p≈ôi anal√Ωze trh≈Ø a rozhodov√°n√≠ o investic√≠ch. Syst√©m kombinuje s√≠lu nƒõkolika specializovan√Ωch AI agent≈Ø, kter√© spolupracuj√≠ na poskytov√°n√≠ komplexn√≠ch finanƒçn√≠ch anal√Ωz.

### Hlavn√≠ V√Ωzvy
- **Komplexita finanƒçn√≠ch dat**: Integrace r≈Øznorod√Ωch datov√Ωch zdroj≈Ø (ceny, objemy, zpr√°vy, ekonomick√© ukazatele)
- **Rychlost rozhodov√°n√≠**: Nutnost real-time anal√Ωzy pro ƒçasovƒõ kritick√° rozhodnut√≠
- **Koordinace agent≈Ø**: Efektivn√≠ komunikace a synchronizace mezi specializovan√Ωmi agenty
- **P≈ôesnost predikc√≠**: Kombinov√°n√≠ r≈Øzn√Ωch analytick√Ωch p≈ô√≠stup≈Ø pro zv√Ω≈°en√≠ spolehlivosti

### Potenci√°ln√≠ Dopad
Syst√©m m≈Ø≈æe v√Ωraznƒõ zlep≈°it kvalitu investiƒçn√≠ch rozhodnut√≠, sn√≠≈æit rizika portfolia a umo≈ænit rychlej≈°√≠ reakce na tr≈æn√≠ zmƒõny. Pro finanƒçn√≠ poradce p≈ôedstavuje mocn√Ω n√°stroj pro lep≈°√≠ slu≈æby klient≈Øm.

## Komplexn√≠ Implementace Projektu

### Instalace Z√°vislost√≠

````python
# requirements.txt
crewai==0.28.8
langchain==0.1.16
openai==1.23.6
anthropic==0.25.8
yfinance==0.2.18
beautifulsoup4==4.12.2
requests==2.31.0
pandas==2.0.3
numpy==1.24.3
scikit-learn==1.3.0
plotly==5.15.0
python-dotenv==1.0.0
websocket-client==1.6.1
````

### Hlavn√≠ Implementace

````python
import os
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Any
import pandas as pd
import numpy as np
import yfinance as yf
import requests
from bs4 import BeautifulSoup
import json
from dataclasses import dataclass

from crewai import Agent, Task, Crew, Process
from langchain.llms import OpenAI
from langchain_anthropic import ChatAnthropic
from langchain.tools import Tool
from langchain.schema import BaseOutputParser

@dataclass
class MarketData:
    symbol: str
    price: float
    change: float
    volume: int
    timestamp: datetime

@dataclass
class NewsItem:
    title: str
    content: str
    sentiment_score: float
    source: str
    timestamp: datetime

class FinancialDataTool:
    """N√°stroj pro z√≠sk√°v√°n√≠ finanƒçn√≠ch dat"""
    
    def get_stock_data(self, symbol: str, period: str = "1d") -> Dict:
        try:
            stock = yf.Ticker(symbol)
            data = stock.history(period=period)
            
            if data.empty:
                return {"error": f"≈Ω√°dn√° data pro symbol {symbol}"}
            
            latest = data.iloc[-1]
            previous = data.iloc[-2] if len(data) > 1 else latest
            
            return {
                "symbol": symbol,
                "price": float(latest['Close']),
                "change": float(latest['Close'] - previous['Close']),
                "change_percent": float((latest['Close'] - previous['Close']) / previous['Close'] * 100),
                "volume": int(latest['Volume']),
                "high": float(latest['High']),
                "low": float(latest['Low']),
                "timestamp": latest.name.isoformat()
            }
        except Exception as e:
            return {"error": f"Chyba p≈ôi z√≠sk√°v√°n√≠ dat: {str(e)}"}
    
    def get_multiple_stocks(self, symbols: List[str]) -> List[Dict]:
        results = []
        for symbol in symbols:
            data = self.get_stock_data(symbol)
            if "error" not in data:
                results.append(data)
        return results
    
    def get_historical_data(self, symbol: str, days: int = 30) -> pd.DataFrame:
        try:
            stock = yf.Ticker(symbol)
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            data = stock.history(start=start_date, end=end_date)
            return data
        except Exception as e:
            print(f"Chyba p≈ôi z√≠sk√°v√°n√≠ historick√Ωch dat: {e}")
            return pd.DataFrame()

class NewsScrapingTool:
    """N√°stroj pro sbƒõr a anal√Ωzu zpr√°v"""
    
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
    
    def get_financial_news(self, query: str = "stock market") -> List[Dict]:
        """Simulace z√≠sk√°v√°n√≠ finanƒçn√≠ch zpr√°v"""
        # V re√°ln√© implementaci by zde bylo vol√°n√≠ API nebo web scraping
        sample_news = [
            {
                "title": "Technologick√© akcie rostou na optimismu ohlednƒõ AI",
                "content": "Akcie technologick√Ωch spoleƒçnost√≠ zaznamenaly r≈Øst...",
                "sentiment": "pozitivn√≠",
                "source": "Financial Times",
                "timestamp": datetime.now().isoformat()
            },
            {
                "title": "Centr√°ln√≠ banka zva≈æuje zmƒõnu √∫rokov√Ωch sazeb",
                "content": "P≈ôedstavitel√© centr√°ln√≠ banky naznaƒçili mo≈æn√© zmƒõny...",
                "sentiment": "neutr√°ln√≠",
                "source": "Reuters",
                "timestamp": (datetime.now() - timedelta(hours=2)).isoformat()
            },
            {
                "title": "Energetick√Ω sektor pod tlakem nov√Ωch regulac√≠",
                "content": "Nov√© environment√°ln√≠ regulace ovliv≈àuj√≠ energetick√© spoleƒçnosti...",
                "sentiment": "negativn√≠",
                "source": "Bloomberg",
                "timestamp": (datetime.now() - timedelta(hours=4)).isoformat()
            }
        ]
        return sample_news
    
    def analyze_sentiment(self, text: str) -> float:
        """Jednoduch√° anal√Ωza sentimentu"""
        positive_words = ["r≈Øst", "optimismus", "pozitivn√≠", "zisk", "√∫spƒõch"]
        negative_words = ["pokles", "krize", "negativn√≠", "ztr√°ta", "probl√©m"]
        
        text_lower = text.lower()
        positive_count = sum(1 for word in positive_words if word in text_lower)
        negative_count = sum(1 for word in negative_words if word in text_lower)
        
        if positive_count > negative_count:
            return 0.7
        elif negative_count > positive_count:
            return -0.7
        else:
            return 0.0

class RiskAnalysisTool:
    """N√°stroj pro anal√Ωzu rizik"""
    
    def calculate_volatility(self, prices: List[float]) -> float:
        if len(prices) < 2:
            return 0.0
        
        returns = [(prices[i] / prices[i-1] - 1) for i in range(1, len(prices))]
        return float(np.std(returns) * np.sqrt(252))  # Annualized volatility
    
    def calculate_var(self, returns: List[float], confidence: float = 0.05) -> float:
        """Value at Risk calculation"""
        if not returns:
            return 0.0
        return float(np.percentile(returns, confidence * 100))
    
    def assess_portfolio_risk(self, portfolio: Dict[str, float]) -> Dict:
        """Anal√Ωza rizika portfolia"""
        financial_tool = FinancialDataTool()
        total_risk = 0.0
        risk_breakdown = {}
        
        for symbol, weight in portfolio.items():
            hist_data = financial_tool.get_historical_data(symbol, 60)
            if not hist_data.empty:
                prices = hist_data['Close'].tolist()
                volatility = self.calculate_volatility(prices)
                risk_breakdown[symbol] = volatility * weight
                total_risk += volatility * weight
        
        return {
            "total_risk": total_risk,
            "risk_breakdown": risk_breakdown,
            "risk_level": "vysok√©" if total_risk > 0.3 else "st≈ôedn√≠" if total_risk > 0.15 else "n√≠zk√©"
        }

class FinancialAgentSystem:
    """Hlavn√≠ syst√©m finanƒçn√≠ch agent≈Ø"""
    
    def __init__(self):
        self.financial_tool = FinancialDataTool()
        self.news_tool = NewsScrapingTool()
        self.risk_tool = RiskAnalysisTool()
        
        # Nastaven√≠ LLM
        self.openai_llm = OpenAI(temperature=0.1)
        
        self.setup_agents()
        self.setup_tools()
    
    def setup_tools(self):
        """Nastaven√≠ n√°stroj≈Ø pro agenty"""
        self.tools = [
            Tool(
                name="get_stock_data",
                description="Z√≠sk√°n√≠ aktu√°ln√≠ch dat o akci√≠ch",
                func=lambda symbol: json.dumps(self.financial_tool.get_stock_data(symbol))
            ),
            Tool(
                name="get_financial_news",
                description="Z√≠sk√°n√≠ finanƒçn√≠ch zpr√°v",
                func=lambda query: json.dumps(self.news_tool.get_financial_news(query))
            ),
            Tool(
                name="analyze_risk",
                description="Anal√Ωza rizika portfolia",
                func=lambda portfolio: json.dumps(self.risk_tool.assess_portfolio_risk(eval(portfolio)))
            )
        ]
    
    def setup_agents(self):
        """Nastaven√≠ specializovan√Ωch agent≈Ø"""
        
        # Agent pro anal√Ωzu trend≈Ø
        self.trend_agent = Agent(
            role="Analytik Trend≈Ø",
            goal="Analyzovat tr≈æn√≠ trendy a identifikovat p≈ô√≠le≈æitosti",
            backstory="Jsem expert na technickou anal√Ωzu s 10letou zku≈°enost√≠ v identifikaci tr≈æn√≠ch vzorc≈Ø.",
            verbose=True,
            allow_delegation=False,
            llm=self.openai_llm,
            tools=self.tools
        )
        
        # Agent pro anal√Ωzu rizik
        self.risk_agent = Agent(
            role="Analytik Rizik",
            goal="Vyhodnocovat a kvantifikovat investiƒçn√≠ rizika",
            backstory="Specializuji se na ≈ô√≠zen√≠ rizik a portfolio management s d≈Ørazem na ochranu kapit√°lu.",
            verbose=True,
            allow_delegation=False,
            llm=self.openai_llm,
            tools=self.tools
        )
        
        # Agent pro sentiment analysis
        self.sentiment_agent = Agent(
            role="Analytik Sentimentu",
            goal="Analyzovat sentiment zpr√°v a jejich dopad na trhy",
            backstory="Jsem expert na anal√Ωzu tr≈æn√≠ho sentimentu a dopad m√©di√≠ na investiƒçn√≠ rozhodov√°n√≠.",
            verbose=True,
            allow_delegation=False,
            llm=self.openai_llm,
            tools=self.tools
        )
        
        # Agent pro portfolio balancing
        self.portfolio_agent = Agent(
            role="Portfolio Mana≈æer",
            goal="Optimalizovat slo≈æen√≠ portfolia na z√°kladƒõ anal√Ωz ostatn√≠ch agent≈Ø",
            backstory="Specializuji se na strategick√© alokace aktiv a optimalizaci portfolia pro r≈Øzn√© investiƒçn√≠ profily.",
            verbose=True,
            allow_delegation=False,
            llm=self.openai_llm,
            tools=self.tools
        )
    
    def create_analysis_tasks(self, symbols: List[str], portfolio: Dict[str, float] = None):
        """Vytvo≈ôen√≠ √∫kol≈Ø pro anal√Ωzu"""
        
        symbols_str = ", ".join(symbols)
        portfolio_str = str(portfolio) if portfolio else "{}"
        
        # √ökol pro anal√Ωzu trend≈Ø
        trend_task = Task(
            description=f"Analyzuj tr≈æn√≠ trendy pro akcie: {symbols_str}. "
                       f"Poskytni technickou anal√Ωzu, identifikuj kl√≠ƒçov√© podpory a odpory, "
                       f"a doporuƒç smƒõr investice pro ka≈ædou akcii.",
            agent=self.trend_agent,
            expected_output="Detailn√≠ technick√° anal√Ωza s doporuƒçen√≠mi pro ka≈ædou akcii"
        )
        
        # √ökol pro anal√Ωzu rizik
        risk_task = Task(
            description=f"Proveƒè anal√Ωzu rizik pro portfolio: {portfolio_str} "
                       f"a akcie: {symbols_str}. Vyhodno≈• volatilitu, korelace a celkov√© riziko.",
            agent=self.risk_agent,
            expected_output="Komplexn√≠ hodnocen√≠ rizik s kvantitativn√≠mi metrikami"
        )
        
        # √ökol pro sentiment anal√Ωzu
        sentiment_task = Task(
            description=f"Analyzuj sentiment finanƒçn√≠ch zpr√°v t√Ωkaj√≠c√≠ch se akci√≠: {symbols_str}. "
                       f"Vyhodno≈• dopad zpr√°v na tr≈æn√≠ n√°ladu a oƒçek√°v√°n√≠ investor≈Ø.",
            agent=self.sentiment_agent,
            expected_output="Anal√Ωza sentimentu s hodnocen√≠m dopadu na investiƒçn√≠ rozhodov√°n√≠"
        )
        
        # √ökol pro portfolio optimalizaci
        portfolio_task = Task(
            description=f"Na z√°kladƒõ anal√Ωz trend≈Ø, rizik a sentimentu navrhni optim√°ln√≠ "
                       f"alokaci pro portfolio obsahuj√≠c√≠ akcie: {symbols_str}. "
                       f"Zohledni souƒçasn√© portfolio: {portfolio_str}",
            agent=self.portfolio_agent,
            expected_output="Konkr√©tn√≠ doporuƒçen√≠ pro alokaci portfolia s od≈Øvodnƒõn√≠m"
        )
        
        return [trend_task, risk_task, sentiment_task, portfolio_task]
    
    def run_analysis(self, symbols: List[str], portfolio: Dict[str, float] = None):
        """Spu≈°tƒõn√≠ kompletn√≠ anal√Ωzy"""
        try:
            tasks = self.create_analysis_tasks(symbols, portfolio)
            
            # Vytvo≈ôen√≠ crew (t√Ωmu agent≈Ø)
            financial_crew = Crew(
                agents=[self.trend_agent, self.risk_agent, self.sentiment_agent, self.portfolio_agent],
                tasks=tasks,
                process=Process.sequential,
                verbose=True
            )
            
            # Spu≈°tƒõn√≠ anal√Ωzy
            result = financial_crew.kickoff()
            
            return {
                "status": "success",
                "analysis": result,
                "timestamp": datetime.now().isoformat(),
                "symbols_analyzed": symbols,
                "portfolio": portfolio
            }
            
        except Exception as e:
            return {
                "status": "error",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }

def create_sample_portfolio():
    """Vytvo≈ôen√≠ uk√°zkov√©ho portfolia"""
    return {
        "AAPL": 0.30,   # Apple Inc.
        "GOOGL": 0.25,  # Alphabet Inc.
        "MSFT": 0.20,   # Microsoft Corp.
        "TSLA": 0.15,   # Tesla Inc.
        "NVDA": 0.10    # NVIDIA Corp.
    }

def main():
    """Hlavn√≠ funkce pro demonstraci syst√©mu"""
    print("üöÄ Spou≈°t√≠m Financial Multi-Agent System...")
    
    # Vytvo≈ôen√≠ syst√©mu
    agent_system = FinancialAgentSystem()
    
    # Definov√°n√≠ akci√≠ pro anal√Ωzu
    symbols_to_analyze = ["AAPL", "GOOGL", "MSFT", "TSLA", "NVDA"]
    
    # Uk√°zkov√© portfolio
    sample_portfolio = create_sample_portfolio()
    
    print(f"üìä Analyzuji akcie: {', '.join(symbols_to_analyze)}")
    print(f"üíº Portfolio: {sample_portfolio}")
    print("\n" + "="*50)
    
    # Spu≈°tƒõn√≠ anal√Ωzy
    result = agent_system.run_analysis(symbols_to_analyze, sample_portfolio)
    
    if result["status"] == "success":
        print("‚úÖ Anal√Ωza √∫spƒõ≈°nƒõ dokonƒçena!")
        print(f"üïí ƒåas dokonƒçen√≠: {result['timestamp']}")
        print("\nüìã V√Ωsledky anal√Ωzy:")
        print("-" * 30)
        print(result["analysis"])
    else:
        print("‚ùå Chyba p≈ôi anal√Ωze:")
        print(result["error"])

if __name__ == "__main__":
    main()
````

### Roz≈°√≠≈ôen√° Funkcionalita

````python
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import warnings
warnings.filterwarnings('ignore')

class AdvancedAnalytics:
    """Pokroƒçil√© analytick√© funkce"""
    
    def __init__(self):
        self.models = {}
    
    def create_portfolio_visualization(self, portfolio_data: Dict, performance_data: List[Dict]):
        """Vytvo≈ôen√≠ vizualizace portfolia"""
        
        # Graf alokace portfolia
        labels = list(portfolio_data.keys())
        values = list(portfolio_data.values())
        
        fig_pie = go.Figure(data=[go.Pie(
            labels=labels, 
            values=values,
            title="Alokace Portfolia"
        )])
        
        # Graf v√Ωkonnosti v ƒçase
        if performance_data:
            dates = [item['date'] for item in performance_data]
            returns = [item['return'] for item in performance_data]
            
            fig_performance = go.Figure()
            fig_performance.add_trace(go.Scatter(
                x=dates,
                y=returns,
                mode='lines+markers',
                name='Portfolio Return',
                line=dict(color='blue', width=2)
            ))
            fig_performance.update_layout(
                title="V√Ωkonnost Portfolia v ƒåase",
                xaxis_title="Datum",
                yaxis_title="V√Ωnos (%)"
            )
            
            return fig_pie, fig_performance
        
        return fig_pie, None
    
    def predict_stock_price(self, symbol: str, days_ahead: int = 5):
        """Predikce ceny akcie pomoc√≠ machine learning"""
        try:
            financial_tool = FinancialDataTool()
            hist_data = financial_tool.get_historical_data(symbol, 90)
            
            if hist_data.empty:
                return None
            
            # P≈ô√≠prava features
            hist_data['SMA_5'] = hist_data['Close'].rolling(window=5).mean()
            hist_data['SMA_20'] = hist_data['Close'].rolling(window=20).mean()
            hist_data['RSI'] = self.calculate_rsi(hist_data['Close'])
            hist_data['Volume_SMA'] = hist_data['Volume'].rolling(window=5).mean()
            
            # Odstranƒõn√≠ NaN hodnot
            hist_data = hist_data.dropna()
            
            if len(hist_data) < 20:
                return None
            
            # Features a target
            features = ['Open', 'High', 'Low', 'Volume', 'SMA_5', 'SMA_20', 'RSI', 'Volume_SMA']
            X = hist_data[features].values
            y = hist_data['Close'].shift(-1).dropna().values  # P≈ôedpovƒõƒè n√°sleduj√≠c√≠ho dne
            
            # √öprava velikosti
            X = X[:-1]  # Odstranƒõn√≠ posledn√≠ho ≈ô√°dku kv≈Øli shift
            
            if len(X) != len(y):
                return None
            
            # Tr√©nov√°n√≠ modelu
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
            
            model = RandomForestRegressor(n_estimators=100, random_state=42)
            model.fit(X_train, y_train)
            
            # Predikce
            last_features = X[-1].reshape(1, -1)
            predicted_price = model.predict(last_features)[0]
            
            # Aktu√°ln√≠ cena
            current_price = hist_data['Close'].iloc[-1]
            
            return {
                "symbol": symbol,
                "current_price": float(current_price),
                "predicted_price": float(predicted_price),
                "change_prediction": float((predicted_price - current_price) / current_price * 100),
                "model_score": float(model.score(X_test, y_test)),
                "prediction_days": days_ahead
            }
            
        except Exception as e:
            print(f"Chyba p≈ôi predikci pro {symbol}: {e}")
            return None
    
    def calculate_rsi(self, prices: pd.Series, period: int = 14):
        """V√Ωpoƒçet RSI indik√°toru"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def generate_trading_signals(self, symbol: str):
        """Generov√°n√≠ obchodn√≠ch sign√°l≈Ø"""
        try:
            financial_tool = FinancialDataTool()
            hist_data = financial_tool.get_historical_data(symbol, 60)
            
            if hist_data.empty:
                return None
            
            # Technick√© indik√°tory
            hist_data['SMA_20'] = hist_data['Close'].rolling(window=20).mean()
            hist_data['SMA_50'] = hist_data['Close'].rolling(window=50).mean()
            hist_data['RSI'] = self.calculate_rsi(hist_data['Close'])
            
            latest = hist_data.iloc[-1]
            
            signals = []
            
            # SMA crossover signal
            if latest['SMA_20'] > latest['SMA_50']:
                signals.append({
                    "type": "BUY",
                    "indicator": "SMA Crossover",
                    "strength": "st≈ôedn√≠",
                    "description": "SMA20 je nad SMA50 - b√Ωƒç√≠ trend"
                })
            else:
                signals.append({
                    "type": "SELL",
                    "indicator": "SMA Crossover", 
                    "strength": "st≈ôedn√≠",
                    "description": "SMA20 je pod SMA50 - medvƒõd√≠ trend"
                })
            
            # RSI signal
            if latest['RSI'] < 30:
                signals.append({
                    "type": "BUY",
                    "indicator": "RSI",
                    "strength": "siln√Ω",
                    "description": f"RSI {latest['RSI']:.1f} - p≈ôeprod√°no"
                })
            elif latest['RSI'] > 70:
                signals.append({
                    "type": "SELL",
                    "indicator": "RSI",
                    "strength": "siln√Ω", 
                    "description": f"RSI {latest['RSI']:.1f} - p≈ôekoupeno"
                })
            
            return {
                "symbol": symbol,
                "signals": signals,
                "current_price": float(latest['Close']),
                "sma_20": float(latest['SMA_20']),
                "sma_50": float(latest['SMA_50']),
                "rsi": float(latest['RSI']),
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            print(f"Chyba p≈ôi generov√°n√≠ sign√°l≈Ø pro {symbol}: {e}")
            return None

class RealTimeMonitor:
    """Monitor pro real-time sledov√°n√≠"""
    
    def __init__(self):
        self.monitored_symbols = []
        self.alerts = []
    
    def add_symbol(self, symbol: str, alert_conditions: Dict):
        """P≈ôid√°n√≠ symbolu pro monitoring"""
        self.monitored_symbols.append({
            "symbol": symbol,
            "conditions": alert_conditions,
            "last_check": datetime.now()
        })
    
    def check_alerts(self):
        """Kontrola alert podm√≠nek"""
        financial_tool = FinancialDataTool()
        new_alerts = []
        
        for item in self.monitored_symbols:
            symbol = item["symbol"]
            conditions = item["conditions"]
            
            data = financial_tool.get_stock_data(symbol)
            
            if "error" in data:
                continue
            
            # Kontrola cenov√Ωch alert≈Ø
            if "price_above" in conditions and data["price"] > conditions["price_above"]:
                new_alerts.append({
                    "symbol": symbol,
                    "type": "PRICE_ABOVE",
                    "message": f"{symbol} p≈ôekroƒçil cenu {conditions['price_above']}",
                    "current_price": data["price"],
                    "timestamp": datetime.now().isoformat()
                })
            
            if "price_below" in conditions and data["price"] < conditions["price_below"]:
                new_alerts.append({
                    "symbol": symbol,
                    "type": "PRICE_BELOW", 
                    "message": f"{symbol} klesl pod cenu {conditions['price_below']}",
                    "current_price": data["price"],
                    "timestamp": datetime.now().isoformat()
                })
            
            # Kontrola zmƒõn v procentech
            if "change_above" in conditions and abs(data["change_percent"]) > conditions["change_above"]:
                new_alerts.append({
                    "symbol": symbol,
                    "type": "VOLATILITY",
                    "message": f"{symbol} m√° velkou zmƒõnu: {data['change_percent']:.2f}%",
                    "change_percent": data["change_percent"],
                    "timestamp": datetime.now().isoformat()
                })
        
        self.alerts.extend(new_alerts)
        return new_alerts

def demonstrate_advanced_features():
    """Demonstrace pokroƒçil√Ωch funkc√≠"""
    print("üî¨ Demonstrace pokroƒçil√Ωch analytick√Ωch funkc√≠...")
    
    analytics = AdvancedAnalytics()
    monitor = RealTimeMonitor()
    
    # Predikce cen
    symbols = ["AAPL", "GOOGL", "MSFT"]
    
    print("\nüìà Predikce cen akci√≠:")
    print("-" * 40)
    
    for symbol in symbols:
        prediction = analytics.predict_stock_price(symbol)
        if prediction:
            print(f"{symbol}:")
            print(f"  Souƒçasn√° cena: ${prediction['current_price']:.2f}")
            print(f"  Predikovan√° cena: ${prediction['predicted_price']:.2f}")
            print(f"  Oƒçek√°van√° zmƒõna: {prediction['change_prediction']:.2f}%")
            print(f"  Model p≈ôesnost: {prediction['model_score']:.3f}")
            print()
    
    # Obchodn√≠ sign√°ly
    print("\nüìä Obchodn√≠ sign√°ly:")
    print("-" * 40)
    
    for symbol in symbols[:2]:  # Jen pro prvn√≠ dva symboly
        signals = analytics.generate_trading_signals(symbol)
        if signals:
            print(f"{symbol} (${signals['current_price']:.2f}):")
            for signal in signals['signals']:
                print(f"  {signal['type']} - {signal['indicator']}: {signal['description']}")
            print()
    
    # Nastaven√≠ monitoringu
    print("\nüîî Nastaven√≠ price alert≈Ø:")
    print("-" * 40)
    
    monitor.add_symbol("AAPL", {
        "price_above": 200,
        "price_below": 150,
        "change_above": 5.0
    })
    
    alerts = monitor.check_alerts()
    if alerts:
        for alert in alerts:
            print(f"ALERT: {alert['message']}")
    else:
        print("≈Ω√°dn√© aktivn√≠ alerty")

if __name__ == "__main__":
    demonstrate_advanced_features()
````

### Konfigurace a Spu≈°tƒõn√≠

````python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    """Konfigurace aplikace"""
    
    # API kl√≠ƒçe
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")
    
    # Finanƒçn√≠ API
    ALPHA_VANTAGE_KEY = os.getenv("ALPHA_VANTAGE_KEY")
    FINNHUB_API_KEY = os.getenv("FINNHUB_API_KEY")
    
    # Datab√°ze
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///financial_agents.db")
    
    # Nastaven√≠ agent≈Ø
    AGENT_TEMPERATURE = 0.1
    MAX_ITERATIONS = 3
    
    # Monitoring
    ALERT_CHECK_INTERVAL = 300  # sekund
    DATA_REFRESH_INTERVAL = 60   # sekund
    
    @classmethod
    def validate_config(cls):
        """Validace konfigurace"""
        required_keys = ["OPENAI_API_KEY"]
        missing_keys = [key for key in required_keys if not getattr(cls, key)]
        
        if missing_keys:
            raise ValueError(f"Chyb√≠ povinn√© konfiguraƒçn√≠ kl√≠ƒçe: {missing_keys}")
        
        return True

# .env soubor template
ENV_TEMPLATE = """
# API kl√≠ƒçe
OPENAI_API_KEY=your_openai_api_key_here
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Voliteln√© finanƒçn√≠ API
ALPHA_VANTAGE_KEY=your_alpha_vantage_key_here
FINNHUB_API_KEY=your_finnhub_key_here

# Datab√°ze
DATABASE_URL=sqlite:///financial_agents.db
"""
````

## Shrnut√≠ Projektu

### Kl√≠ƒçov√© Hodnoty
Tento multi-agent syst√©m pro anal√Ωzu finanƒçn√≠ch trh≈Ø p≈ôedstavuje pokroƒçil√© ≈ôe≈°en√≠ pro podporu investiƒçn√≠ch rozhodnut√≠. Kombinuje s√≠lu specializovan√Ωch AI agent≈Ø s real-time daty a modern√≠mi analytick√Ωmi technikami.

### Hlavn√≠ P≈ô√≠nosy
- **Komplexn√≠ anal√Ωza**: Kombinace technick√© anal√Ωzy, fundament√°ln√≠ anal√Ωzy a sentiment anal√Ωzy
- **Real-time monitoring**: Okam≈æit√© reakce na tr≈æn√≠ zmƒõny a cenov√© pohyby
- **Koordinovan√° inteligence**: Agenti spolupracuj√≠ pro dosa≈æen√≠ lep≈°√≠ch v√Ωsledk≈Ø ne≈æ samostatnƒõ
- **≈†k√°lovatelnost**: Snadn√© p≈ôid√°v√°n√≠ nov√Ωch agent≈Ø a funkcionalit

### Technologick√© V√Ωhody
- Vyu≈æit√≠ modern√≠ch framework≈Ø (CrewAI, LangChain)
- Integrace s re√°ln√Ωmi finanƒçn√≠mi API
- Machine learning pro predikci cen
- Vizualizace a reporting

### Mo≈ænosti Roz≈°√≠≈ôen√≠
- Integrace s trading platformami pro automatick√© obchodov√°n√≠
- Pokroƒçil√© risk management algoritmy
- Backtesting strategi√≠ na historick√Ωch datech
- Personalizace pro r≈Øzn√© investiƒçn√≠ profily
- Mobiln√≠ aplikace pro monitoring portfolia

Syst√©m poskytuje solid z√°klad pro v√Ωvoj profesion√°ln√≠ch finanƒçn√≠ch n√°stroj≈Ø a m≈Ø≈æe v√Ωraznƒõ zlep≈°it kvalitu investiƒçn√≠ch rozhodnut√≠ finanƒçn√≠ch poradc≈Ø i individu√°ln√≠ch investor≈Ø.