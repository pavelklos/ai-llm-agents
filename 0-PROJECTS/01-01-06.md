<small>Claude Sonnet 4 **(Financial Trading Assistant - AI-Enhanced MCP Integration)**</small>
# Financial Trading Assistant

## Key Concepts Explanation

### Model Context Protocol (MCP)
Advanced communication framework enabling AI models to intelligently interact with financial data systems, trading platforms, and market analysis tools, providing contextual understanding of market conditions, trading patterns, and risk factors through standardized interfaces.

### Market Data APIs
Real-time and historical financial data feeds from providers like Bloomberg Terminal, Alpha Vantage, Yahoo Finance, and Quandl, delivering stock prices, options data, economic indicators, and market sentiment for comprehensive market analysis.

### Portfolio Management
Systematic approach to investment allocation, performance tracking, and asset optimization using modern portfolio theory, risk-adjusted returns, and diversification strategies to maximize returns while managing risk exposure.

### Risk Analysis
Comprehensive assessment of financial exposure including Value at Risk (VaR), stress testing, correlation analysis, and scenario modeling to quantify potential losses and optimize risk-reward ratios across investment positions.

### Trading Strategies
Algorithmic approaches to market entry and exit decisions including technical analysis, fundamental analysis, quantitative models, and machine learning-based pattern recognition for systematic trading execution.

### Financial Data Integration
Seamless connectivity with professional trading platforms like Bloomberg Terminal, Interactive Brokers, TD Ameritrade APIs, and institutional data providers for real-time execution and comprehensive market coverage.

## Comprehensive Project Explanation

The Financial Trading Assistant revolutionizes investment decision-making by combining artificial intelligence with sophisticated financial analysis tools. This system provides real-time market insights, automated risk assessment, and intelligent trading recommendations while maintaining strict compliance with financial regulations and risk management protocols.

### Objectives
- **Intelligent Market Analysis**: Provide AI-powered insights on market trends, sentiment, and trading opportunities
- **Automated Risk Management**: Continuously monitor portfolio risk and suggest optimization strategies
- **Real-Time Decision Support**: Deliver instant analysis of market conditions and trading signals
- **Portfolio Optimization**: Maximize risk-adjusted returns through intelligent asset allocation
- **Regulatory Compliance**: Ensure all trading activities comply with financial regulations and reporting requirements

### Challenges
- **Real-Time Processing**: Handling high-frequency market data streams with sub-millisecond latency requirements
- **Risk Management**: Implementing sophisticated risk controls to prevent catastrophic losses
- **Market Volatility**: Adapting to rapidly changing market conditions and unexpected events
- **Regulatory Compliance**: Adhering to complex financial regulations across multiple jurisdictions
- **Data Quality**: Ensuring accuracy and reliability of financial data from multiple sources

### Potential Impact
This system could democratize access to institutional-level trading analysis, enable more informed investment decisions for individual investors, and provide hedge funds and trading firms with AI-enhanced analytical capabilities that improve performance while reducing operational risk.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import logging
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import uuid
import pandas as pd
import numpy as np
import yfinance as yf
import alpha_vantage
from alpha_vantage.timeseries import TimeSeries
from alpha_vantage.techindicators import TechIndicators
import requests
import websocket
import threading
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, DateTime, Text, Integer, Float, JSON, Boolean
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, PromptTemplate
from langchain.schema import HumanMessage, SystemMessage
from langchain.agents import Tool, AgentExecutor, create_openai_tools_agent
from langchain.memory import ConversationBufferWindowMemory
import openai
from crewai import Agent, Task, Crew, Process
from autogen import AssistantAgent, UserProxyAgent, GroupChat, GroupChatManager
import ta
from scipy import stats
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor, IsolationForest
from sklearn.linear_model import LinearRegression
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import matplotlib.pyplot as plt
import seaborn as sns
from fastapi import FastAPI, WebSocket, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from pydantic import BaseModel
import asyncpg
import redis.asyncio as redis
from concurrent.futures import ThreadPoolExecutor
import warnings
warnings.filterwarnings('ignore')

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database Models
Base = declarative_base()

class TradingSignal(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"

class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    EXTREME = "extreme"

class Portfolio(Base):
    __tablename__ = "portfolios"
    
    id = Column(String, primary_key=True)
    user_id = Column(String, nullable=False)
    name = Column(String, nullable=False)
    total_value = Column(Float, default=0.0)
    cash_balance = Column(Float, default=0.0)
    positions = Column(JSON)
    risk_profile = Column(String, default="medium")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    performance_metrics = Column(JSON)

class Position(Base):
    __tablename__ = "positions"
    
    id = Column(String, primary_key=True)
    portfolio_id = Column(String, nullable=False)
    symbol = Column(String, nullable=False)
    quantity = Column(Float, nullable=False)
    avg_cost = Column(Float, nullable=False)
    current_price = Column(Float, default=0.0)
    market_value = Column(Float, default=0.0)
    unrealized_pnl = Column(Float, default=0.0)
    position_type = Column(String, default="long")  # long, short
    entry_date = Column(DateTime, default=datetime.utcnow)
    stop_loss = Column(Float)
    take_profit = Column(Float)

class Trade(Base):
    __tablename__ = "trades"
    
    id = Column(String, primary_key=True)
    portfolio_id = Column(String, nullable=False)
    symbol = Column(String, nullable=False)
    action = Column(String, nullable=False)  # buy, sell
    quantity = Column(Float, nullable=False)
    price = Column(Float, nullable=False)
    total_value = Column(Float, nullable=False)
    commission = Column(Float, default=0.0)
    timestamp = Column(DateTime, default=datetime.utcnow)
    strategy = Column(String)
    ai_confidence = Column(Float)
    execution_status = Column(String, default="pending")

class MarketData(Base):
    __tablename__ = "market_data"
    
    id = Column(String, primary_key=True)
    symbol = Column(String, nullable=False)
    timestamp = Column(DateTime, nullable=False)
    open_price = Column(Float)
    high_price = Column(Float)
    low_price = Column(Float)
    close_price = Column(Float)
    volume = Column(Integer)
    technical_indicators = Column(JSON)
    sentiment_score = Column(Float)

@dataclass
class MarketAnalysis:
    symbol: str
    current_price: float
    price_change: float
    price_change_percent: float
    volume: int
    technical_signals: Dict[str, Any]
    sentiment_analysis: Dict[str, Any]
    recommendation: TradingSignal
    confidence: float
    risk_level: RiskLevel
    target_price: Optional[float] = None
    stop_loss_price: Optional[float] = None

@dataclass
class RiskMetrics:
    portfolio_var_1d: float  # 1-day Value at Risk
    portfolio_var_5d: float  # 5-day Value at Risk
    sharpe_ratio: float
    max_drawdown: float
    beta: float
    alpha: float
    correlation_matrix: Dict[str, Any]
    concentration_risk: float
    leverage_ratio: float

class MarketDataProvider:
    """Unified market data provider supporting multiple APIs"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.alpha_vantage_api = None
        self.bloomberg_api = None
        self.session = requests.Session()
        self.redis_client = None
        self._initialize_apis()
    
    def _initialize_apis(self):
        """Initialize market data APIs"""
        try:
            # Alpha Vantage API
            if self.config.get('alpha_vantage_key'):
                self.alpha_vantage_api = TimeSeries(
                    key=self.config['alpha_vantage_key'],
                    output_format='pandas'
                )
                self.tech_indicators = TechIndicators(
                    key=self.config['alpha_vantage_key'],
                    output_format='pandas'
                )
            
            logger.info("Market data APIs initialized")
            
        except Exception as e:
            logger.error(f"API initialization failed: {e}")
    
    async def get_real_time_price(self, symbol: str) -> Dict[str, Any]:
        """Get real-time price data for a symbol"""
        try:
            # Use yfinance for real-time data (free alternative)
            ticker = yf.Ticker(symbol)
            info = ticker.info
            
            # Get current price
            current_data = ticker.history(period="1d", interval="1m").tail(1)
            
            if not current_data.empty:
                current_price = float(current_data['Close'].iloc[-1])
                volume = int(current_data['Volume'].iloc[-1])
                
                # Calculate price change
                previous_close = float(info.get('previousClose', current_price))
                price_change = current_price - previous_close
                price_change_percent = (price_change / previous_close) * 100
                
                return {
                    'symbol': symbol,
                    'current_price': current_price,
                    'price_change': price_change,
                    'price_change_percent': price_change_percent,
                    'volume': volume,
                    'timestamp': datetime.utcnow().isoformat(),
                    'market_cap': info.get('marketCap'),
                    'pe_ratio': info.get('trailingPE'),
                    'dividend_yield': info.get('dividendYield')
                }
            else:
                raise Exception("No current data available")
                
        except Exception as e:
            logger.error(f"Real-time price fetch failed for {symbol}: {e}")
            return {}
    
    async def get_historical_data(self, symbol: str, period: str = "1y") -> pd.DataFrame:
        """Get historical price data"""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period=period)
            
            if data.empty:
                raise Exception(f"No historical data for {symbol}")
            
            return data
            
        except Exception as e:
            logger.error(f"Historical data fetch failed for {symbol}: {e}")
            return pd.DataFrame()
    
    async def get_technical_indicators(self, symbol: str) -> Dict[str, Any]:
        """Calculate technical indicators"""
        try:
            # Get historical data
            data = await self.get_historical_data(symbol, "6mo")
            
            if data.empty:
                return {}
            
            # Calculate technical indicators using ta library
            indicators = {}
            
            # Moving Averages
            indicators['sma_20'] = float(ta.trend.sma_indicator(data['Close'], window=20).iloc[-1])
            indicators['sma_50'] = float(ta.trend.sma_indicator(data['Close'], window=50).iloc[-1])
            indicators['ema_12'] = float(ta.trend.ema_indicator(data['Close'], window=12).iloc[-1])
            indicators['ema_26'] = float(ta.trend.ema_indicator(data['Close'], window=26).iloc[-1])
            
            # RSI
            indicators['rsi'] = float(ta.momentum.rsi(data['Close'], window=14).iloc[-1])
            
            # MACD
            macd_line = ta.trend.macd(data['Close'])
            macd_signal = ta.trend.macd_signal(data['Close'])
            indicators['macd'] = float(macd_line.iloc[-1])
            indicators['macd_signal'] = float(macd_signal.iloc[-1])
            indicators['macd_histogram'] = indicators['macd'] - indicators['macd_signal']
            
            # Bollinger Bands
            bb_high = ta.volatility.bollinger_hband(data['Close'])
            bb_low = ta.volatility.bollinger_lband(data['Close'])
            bb_mid = ta.volatility.bollinger_mavg(data['Close'])
            indicators['bb_upper'] = float(bb_high.iloc[-1])
            indicators['bb_lower'] = float(bb_low.iloc[-1])
            indicators['bb_middle'] = float(bb_mid.iloc[-1])
            
            # Volume indicators
            indicators['volume_sma'] = float(ta.volume.volume_sma(data['Close'], data['Volume']).iloc[-1])
            
            # Support and Resistance levels
            recent_highs = data['High'].tail(20)
            recent_lows = data['Low'].tail(20)
            indicators['resistance'] = float(recent_highs.max())
            indicators['support'] = float(recent_lows.min())
            
            return indicators
            
        except Exception as e:
            logger.error(f"Technical indicators calculation failed for {symbol}: {e}")
            return {}
    
    async def get_market_news(self, symbol: str) -> List[Dict[str, Any]]:
        """Get recent news for market sentiment analysis"""
        try:
            ticker = yf.Ticker(symbol)
            news = ticker.news
            
            processed_news = []
            for article in news[:10]:  # Get latest 10 articles
                processed_news.append({
                    'title': article.get('title', ''),
                    'summary': article.get('summary', ''),
                    'url': article.get('link', ''),
                    'publish_time': datetime.fromtimestamp(
                        article.get('providerPublishTime', 0)
                    ).isoformat(),
                    'publisher': article.get('publisher', '')
                })
            
            return processed_news
            
        except Exception as e:
            logger.error(f"News fetch failed for {symbol}: {e}")
            return []

class TechnicalAnalyzer:
    """Advanced technical analysis system"""
    
    def __init__(self):
        self.llm = ChatOpenAI(model_name="gpt-4", temperature=0.2)
        
    async def analyze_technical_signals(self, symbol: str, 
                                      price_data: Dict[str, Any],
                                      indicators: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze technical signals and generate trading recommendations"""
        try:
            signals = {}
            
            # Moving Average Analysis
            current_price = price_data['current_price']
            sma_20 = indicators.get('sma_20', 0)
            sma_50 = indicators.get('sma_50', 0)
            
            if current_price > sma_20 and sma_20 > sma_50:
                signals['ma_trend'] = 'bullish'
            elif current_price < sma_20 and sma_20 < sma_50:
                signals['ma_trend'] = 'bearish'
            else:
                signals['ma_trend'] = 'neutral'
            
            # RSI Analysis
            rsi = indicators.get('rsi', 50)
            if rsi > 70:
                signals['rsi_signal'] = 'overbought'
            elif rsi < 30:
                signals['rsi_signal'] = 'oversold'
            else:
                signals['rsi_signal'] = 'neutral'
            
            # MACD Analysis
            macd = indicators.get('macd', 0)
            macd_signal = indicators.get('macd_signal', 0)
            if macd > macd_signal:
                signals['macd_signal'] = 'bullish'
            else:
                signals['macd_signal'] = 'bearish'
            
            # Bollinger Bands Analysis
            bb_upper = indicators.get('bb_upper', 0)
            bb_lower = indicators.get('bb_lower', 0)
            bb_middle = indicators.get('bb_middle', 0)
            
            if current_price > bb_upper:
                signals['bb_position'] = 'above_upper'
            elif current_price < bb_lower:
                signals['bb_position'] = 'below_lower'
            else:
                signals['bb_position'] = 'middle_range'
            
            # Support/Resistance Analysis
            support = indicators.get('support', 0)
            resistance = indicators.get('resistance', 0)
            
            if current_price <= support * 1.02:  # Within 2% of support
                signals['sr_position'] = 'near_support'
            elif current_price >= resistance * 0.98:  # Within 2% of resistance
                signals['sr_position'] = 'near_resistance'
            else:
                signals['sr_position'] = 'middle_range'
            
            # Generate overall recommendation
            recommendation = await self._generate_recommendation(signals, indicators)
            
            return {
                'signals': signals,
                'recommendation': recommendation['action'],
                'confidence': recommendation['confidence'],
                'reasoning': recommendation['reasoning']
            }
            
        except Exception as e:
            logger.error(f"Technical analysis failed for {symbol}: {e}")
            return {}
    
    async def _generate_recommendation(self, signals: Dict[str, Any], 
                                     indicators: Dict[str, Any]) -> Dict[str, Any]:
        """Generate AI-powered trading recommendation"""
        
        prompt = f"""
        Analyze these technical signals and provide a trading recommendation:
        
        Technical Signals:
        - Moving Average Trend: {signals.get('ma_trend')}
        - RSI Signal: {signals.get('rsi_signal')} (Value: {indicators.get('rsi', 'N/A')})
        - MACD Signal: {signals.get('macd_signal')}
        - Bollinger Bands Position: {signals.get('bb_position')}
        - Support/Resistance Position: {signals.get('sr_position')}
        
        Technical Indicator Values:
        - Current RSI: {indicators.get('rsi', 'N/A')}
        - MACD: {indicators.get('macd', 'N/A')}
        - MACD Signal: {indicators.get('macd_signal', 'N/A')}
        
        Provide:
        1. Trading action (BUY, SELL, or HOLD)
        2. Confidence level (0-100)
        3. Brief reasoning (2-3 sentences)
        
        Format response as JSON: {{"action": "BUY/SELL/HOLD", "confidence": 85, "reasoning": "explanation"}}
        """
        
        try:
            response = await self.llm.apredict(prompt)
            
            # Parse JSON response
            import re
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group())
                return result
            else:
                # Fallback to simple analysis
                return self._simple_recommendation(signals)
                
        except Exception as e:
            logger.error(f"AI recommendation failed: {e}")
            return self._simple_recommendation(signals)
    
    def _simple_recommendation(self, signals: Dict[str, Any]) -> Dict[str, Any]:
        """Fallback simple recommendation logic"""
        bullish_signals = 0
        bearish_signals = 0
        
        # Count bullish signals
        if signals.get('ma_trend') == 'bullish':
            bullish_signals += 1
        if signals.get('rsi_signal') == 'oversold':
            bullish_signals += 1
        if signals.get('macd_signal') == 'bullish':
            bullish_signals += 1
        if signals.get('sr_position') == 'near_support':
            bullish_signals += 1
        
        # Count bearish signals
        if signals.get('ma_trend') == 'bearish':
            bearish_signals += 1
        if signals.get('rsi_signal') == 'overbought':
            bearish_signals += 1
        if signals.get('macd_signal') == 'bearish':
            bearish_signals += 1
        if signals.get('sr_position') == 'near_resistance':
            bearish_signals += 1
        
        if bullish_signals > bearish_signals:
            return {
                'action': 'BUY',
                'confidence': min(60 + bullish_signals * 10, 90),
                'reasoning': f'Technical indicators show {bullish_signals} bullish signals vs {bearish_signals} bearish signals'
            }
        elif bearish_signals > bullish_signals:
            return {
                'action': 'SELL',
                'confidence': min(60 + bearish_signals * 10, 90),
                'reasoning': f'Technical indicators show {bearish_signals} bearish signals vs {bullish_signals} bullish signals'
            }
        else:
            return {
                'action': 'HOLD',
                'confidence': 50,
                'reasoning': 'Mixed technical signals suggest holding current position'
            }

class SentimentAnalyzer:
    """Market sentiment analysis from news and social media"""
    
    def __init__(self):
        self.llm = ChatOpenAI(model_name="gpt-3.5-turbo", temperature=0.3)
    
    async def analyze_market_sentiment(self, symbol: str, 
                                     news_articles: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze sentiment from news articles"""
        try:
            if not news_articles:
                return {'sentiment_score': 0.0, 'sentiment_label': 'neutral'}
            
            # Prepare news text for analysis
            news_text = ""
            for article in news_articles[:5]:  # Analyze top 5 articles
                news_text += f"Title: {article['title']}\n"
                news_text += f"Summary: {article['summary']}\n\n"
            
            # AI-powered sentiment analysis
            prompt = f"""
            Analyze the market sentiment for {symbol} based on these recent news articles:
            
            {news_text}
            
            Provide:
            1. Overall sentiment score (-100 to +100, where -100 is extremely bearish, +100 is extremely bullish)
            2. Sentiment label (very_bearish, bearish, neutral, bullish, very_bullish)
            3. Key sentiment drivers (2-3 main factors)
            4. Confidence level (0-100)
            
            Format as JSON: {{"sentiment_score": 25, "sentiment_label": "bullish", "drivers": ["factor1", "factor2"], "confidence": 75}}
            """
            
            response = await self.llm.apredict(prompt)
            
            # Parse response
            import re
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group())
                return result
            else:
                return self._simple_sentiment_analysis(news_articles)
                
        except Exception as e:
            logger.error(f"Sentiment analysis failed for {symbol}: {e}")
            return self._simple_sentiment_analysis(news_articles)
    
    def _simple_sentiment_analysis(self, news_articles: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Simple keyword-based sentiment analysis"""
        positive_keywords = ['growth', 'profit', 'earnings', 'bullish', 'up', 'gains', 'strong', 'positive']
        negative_keywords = ['loss', 'decline', 'bearish', 'down', 'weak', 'negative', 'drop', 'fall']
        
        positive_count = 0
        negative_count = 0
        
        for article in news_articles:
            text = f"{article['title']} {article['summary']}".lower()
            
            for keyword in positive_keywords:
                positive_count += text.count(keyword)
            
            for keyword in negative_keywords:
                negative_count += text.count(keyword)
        
        total_words = positive_count + negative_count
        if total_words == 0:
            sentiment_score = 0
        else:
            sentiment_score = ((positive_count - negative_count) / total_words) * 100
        
        # Determine sentiment label
        if sentiment_score > 20:
            sentiment_label = 'bullish'
        elif sentiment_score < -20:
            sentiment_label = 'bearish'
        else:
            sentiment_label = 'neutral'
        
        return {
            'sentiment_score': round(sentiment_score, 1),
            'sentiment_label': sentiment_label,
            'drivers': ['keyword analysis'],
            'confidence': 60
        }

class RiskManager:
    """Portfolio risk management and analysis"""
    
    def __init__(self):
        self.confidence_level = 0.95  # 95% confidence for VaR calculations
        
    async def calculate_portfolio_risk(self, portfolio_data: Dict[str, Any],
                                     market_data: Dict[str, pd.DataFrame]) -> RiskMetrics:
        """Calculate comprehensive portfolio risk metrics"""
        try:
            # Get portfolio positions
            positions = portfolio_data.get('positions', {})
            if not positions:
                return self._empty_risk_metrics()
            
            # Calculate returns for each asset
            returns_data = {}
            for symbol, position in positions.items():
                if symbol in market_data and not market_data[symbol].empty:
                    prices = market_data[symbol]['Close']
                    returns = prices.pct_change().dropna()
                    returns_data[symbol] = returns
            
            if not returns_data:
                return self._empty_risk_metrics()
            
            # Create returns DataFrame
            returns_df = pd.DataFrame(returns_data)
            
            # Calculate portfolio weights
            total_value = sum(pos['market_value'] for pos in positions.values())
            weights = np.array([positions[symbol]['market_value'] / total_value 
                              for symbol in returns_df.columns])
            
            # Calculate portfolio returns
            portfolio_returns = (returns_df * weights).sum(axis=1)
            
            # Calculate VaR
            var_1d = self._calculate_var(portfolio_returns, 1)
            var_5d = self._calculate_var(portfolio_returns, 5)
            
            # Calculate Sharpe ratio (assuming risk-free rate of 2%)
            risk_free_rate = 0.02 / 252  # Daily risk-free rate
            excess_returns = portfolio_returns - risk_free_rate
            sharpe_ratio = excess_returns.mean() / portfolio_returns.std() * np.sqrt(252)
            
            # Calculate maximum drawdown
            cumulative_returns = (1 + portfolio_returns).cumprod()
            running_max = cumulative_returns.expanding().max()
            drawdown = (cumulative_returns - running_max) / running_max
            max_drawdown = drawdown.min()
            
            # Calculate beta and alpha (vs S&P 500 proxy)
            market_returns = returns_df.mean(axis=1)  # Simple market proxy
            beta, alpha = self._calculate_beta_alpha(portfolio_returns, market_returns)
            
            # Calculate correlation matrix
            correlation_matrix = returns_df.corr().to_dict()
            
            # Calculate concentration risk
            concentration_risk = max(weights) if len(weights) > 0 else 0
            
            # Calculate leverage ratio (simplified)
            leverage_ratio = total_value / portfolio_data.get('cash_balance', total_value)
            
            return RiskMetrics(
                portfolio_var_1d=var_1d * total_value,
                portfolio_var_5d=var_5d * total_value,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                beta=beta,
                alpha=alpha,
                correlation_matrix=correlation_matrix,
                concentration_risk=concentration_risk,
                leverage_ratio=leverage_ratio
            )
            
        except Exception as e:
            logger.error(f"Risk calculation failed: {e}")
            return self._empty_risk_metrics()
    
    def _calculate_var(self, returns: pd.Series, days: int) -> float:
        """Calculate Value at Risk"""
        if returns.empty:
            return 0.0
        
        # Scale returns for multi-day VaR
        scaled_returns = returns * np.sqrt(days)
        
        # Calculate VaR using historical simulation
        var = np.percentile(scaled_returns, (1 - self.confidence_level) * 100)
        
        return abs(var)
    
    def _calculate_beta_alpha(self, portfolio_returns: pd.Series, 
                            market_returns: pd.Series) -> Tuple[float, float]:
        """Calculate portfolio beta and alpha"""
        try:
            # Align the series
            aligned_data = pd.DataFrame({
                'portfolio': portfolio_returns,
                'market': market_returns
            }).dropna()
            
            if len(aligned_data) < 10:  # Need minimum data points
                return 1.0, 0.0
            
            # Calculate beta using linear regression
            X = aligned_data['market'].values.reshape(-1, 1)
            y = aligned_data['portfolio'].values
            
            from sklearn.linear_model import LinearRegression
            model = LinearRegression().fit(X, y)
            
            beta = model.coef_[0]
            alpha = model.intercept_ * 252  # Annualized alpha
            
            return float(beta), float(alpha)
            
        except Exception as e:
            logger.error(f"Beta/Alpha calculation failed: {e}")
            return 1.0, 0.0
    
    def _empty_risk_metrics(self) -> RiskMetrics:
        """Return empty risk metrics"""
        return RiskMetrics(
            portfolio_var_1d=0.0,
            portfolio_var_5d=0.0,
            sharpe_ratio=0.0,
            max_drawdown=0.0,
            beta=1.0,
            alpha=0.0,
            correlation_matrix={},
            concentration_risk=0.0,
            leverage_ratio=1.0
        )
    
    async def assess_position_risk(self, symbol: str, quantity: float,
                                 price: float, portfolio_value: float) -> Dict[str, Any]:
        """Assess risk of individual position"""
        try:
            position_value = quantity * price
            position_weight = position_value / portfolio_value if portfolio_value > 0 else 0
            
            # Risk assessment
            risk_level = RiskLevel.LOW
            if position_weight > 0.3:
                risk_level = RiskLevel.EXTREME
            elif position_weight > 0.2:
                risk_level = RiskLevel.HIGH
            elif position_weight > 0.1:
                risk_level = RiskLevel.MEDIUM
            
            return {
                'position_value': position_value,
                'position_weight': position_weight,
                'risk_level': risk_level.value,
                'concentration_warning': position_weight > 0.15,
                'recommended_max_position': portfolio_value * 0.1  # 10% max recommendation
            }
            
        except Exception as e:
            logger.error(f"Position risk assessment failed: {e}")
            return {}

class TradingOrchestrator:
    """Main orchestrator for trading decisions and portfolio management"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.market_data_provider = MarketDataProvider(config.get('market_data', {}))
        self.technical_analyzer = TechnicalAnalyzer()
        self.sentiment_analyzer = SentimentAnalyzer()
        self.risk_manager = RiskManager()
        self.session_factory = None
        self.redis_client = None
        
        # AI Agents
        self.trading_crew = self._setup_trading_crew()
        
    def _setup_trading_crew(self) -> Crew:
        """Setup CrewAI agents for collaborative trading analysis"""
        
        # Market Analyst Agent
        market_analyst = Agent(
            role='Market Analyst',
            goal='Analyze market conditions and identify trading opportunities',
            backstory='Expert financial analyst with deep knowledge of market dynamics and technical analysis',
            verbose=True,
            allow_delegation=False
        )
        
        # Risk Manager Agent
        risk_manager_agent = Agent(
            role='Risk Manager',
            goal='Assess and manage portfolio risk to protect capital',
            backstory='Experienced risk management professional focused on capital preservation',
            verbose=True,
            allow_delegation=False
        )
        
        # Portfolio Manager Agent
        portfolio_manager = Agent(
            role='Portfolio Manager',
            goal='Optimize portfolio allocation and performance',
            backstory='Seasoned portfolio manager with expertise in asset allocation and performance optimization',
            verbose=True,
            allow_delegation=False
        )
        
        # Create crew
        crew = Crew(
            agents=[market_analyst, risk_manager_agent, portfolio_manager],
            verbose=True,
            process=Process.sequential
        )
        
        return crew
    
    async def analyze_investment_opportunity(self, symbol: str,
                                          portfolio_id: str) -> MarketAnalysis:
        """Comprehensive analysis of investment opportunity"""
        try:
            # Get market data
            price_data = await self.market_data_provider.get_real_time_price(symbol)
            technical_indicators = await self.market_data_provider.get_technical_indicators(symbol)
            news_data = await self.market_data_provider.get_market_news(symbol)
            
            if not price_data:
                raise Exception(f"No market data available for {symbol}")
            
            # Technical analysis
            technical_analysis = await self.technical_analyzer.analyze_technical_signals(
                symbol, price_data, technical_indicators
            )
            
            # Sentiment analysis
            sentiment_analysis = await self.sentiment_analyzer.analyze_market_sentiment(
                symbol, news_data
            )
            
            # Determine overall recommendation
            recommendation, confidence, risk_level = await self._synthesize_analysis(
                technical_analysis, sentiment_analysis, price_data
            )
            
            # Calculate target price and stop loss
            current_price = price_data['current_price']
            target_price, stop_loss_price = await self._calculate_price_targets(
                current_price, technical_indicators, recommendation
            )
            
            return MarketAnalysis(
                symbol=symbol,
                current_price=current_price,
                price_change=price_data['price_change'],
                price_change_percent=price_data['price_change_percent'],
                volume=price_data['volume'],
                technical_signals=technical_analysis,
                sentiment_analysis=sentiment_analysis,
                recommendation=TradingSignal(recommendation.lower()),
                confidence=confidence,
                risk_level=risk_level,
                target_price=target_price,
                stop_loss_price=stop_loss_price
            )
            
        except Exception as e:
            logger.error(f"Investment analysis failed for {symbol}: {e}")
            raise
    
    async def _synthesize_analysis(self, technical_analysis: Dict[str, Any],
                                 sentiment_analysis: Dict[str, Any],
                                 price_data: Dict[str, Any]) -> Tuple[str, float, RiskLevel]:
        """Synthesize technical and sentiment analysis"""
        
        # Weight the different analyses
        technical_weight = 0.6
        sentiment_weight = 0.4
        
        # Technical analysis score
        tech_recommendation = technical_analysis.get('recommendation', 'HOLD')
        tech_confidence = technical_analysis.get('confidence', 50)
        
        tech_score = 0
        if tech_recommendation == 'BUY':
            tech_score = tech_confidence
        elif tech_recommendation == 'SELL':
            tech_score = -tech_confidence
        
        # Sentiment analysis score
        sentiment_score = sentiment_analysis.get('sentiment_score', 0)
        sentiment_confidence = sentiment_analysis.get('confidence', 50)
        
        # Weighted combined score
        combined_score = (tech_score * technical_weight + 
                         sentiment_score * sentiment_weight)
        
        # Determine recommendation
        if combined_score > 30:
            recommendation = 'BUY'
            risk_level = RiskLevel.MEDIUM
        elif combined_score < -30:
            recommendation = 'SELL'
            risk_level = RiskLevel.MEDIUM
        else:
            recommendation = 'HOLD'
            risk_level = RiskLevel.LOW
        
        # Calculate overall confidence
        confidence = min(90, abs(combined_score) + 
                        (tech_confidence + sentiment_confidence) / 4)
        
        # Adjust risk level based on volatility
        price_change_percent = abs(price_data.get('price_change_percent', 0))
        if price_change_percent > 5:
            if risk_level == RiskLevel.LOW:
                risk_level = RiskLevel.MEDIUM
            elif risk_level == RiskLevel.MEDIUM:
                risk_level = RiskLevel.HIGH
        
        return recommendation, confidence, risk_level
    
    async def _calculate_price_targets(self, current_price: float,
                                     indicators: Dict[str, Any],
                                     recommendation: str) -> Tuple[Optional[float], Optional[float]]:
        """Calculate target price and stop loss based on technical levels"""
        
        try:
            resistance = indicators.get('resistance', current_price * 1.1)
            support = indicators.get('support', current_price * 0.9)
            
            if recommendation == 'BUY':
                # Target price at resistance level
                target_price = min(resistance, current_price * 1.15)  # Max 15% upside
                # Stop loss below support
                stop_loss_price = max(support * 0.98, current_price * 0.95)  # Max 5% downside
                
            elif recommendation == 'SELL':
                # Target price at support level
                target_price = max(support, current_price * 0.85)  # Max 15% downside
                # Stop loss above resistance
                stop_loss_price = min(resistance * 1.02, current_price * 1.05)  # Max 5% upside
                
            else:  # HOLD
                target_price = None
                stop_loss_price = None
            
            return target_price, stop_loss_price
            
        except Exception as e:
            logger.error(f"Price target calculation failed: {e}")
            return None, None
    
    async def generate_trading_plan(self, portfolio_id: str,
                                  symbols: List[str]) -> Dict[str, Any]:
        """Generate comprehensive trading plan for portfolio"""
        try:
            trading_plan = {
                'portfolio_id': portfolio_id,
                'generated_at': datetime.utcnow().isoformat(),
                'analysis_results': {},
                'recommended_actions': [],
                'risk_assessment': {},
                'overall_strategy': ''
            }
            
            # Analyze each symbol
            for symbol in symbols:
                analysis = await self.analyze_investment_opportunity(symbol, portfolio_id)
                trading_plan['analysis_results'][symbol] = {
                    'recommendation': analysis.recommendation.value,
                    'confidence': analysis.confidence,
                    'risk_level': analysis.risk_level.value,
                    'current_price': analysis.current_price,
                    'target_price': analysis.target_price,
                    'stop_loss_price': analysis.stop_loss_price
                }
                
                # Add to recommended actions if strong signal
                if analysis.confidence > 70:
                    trading_plan['recommended_actions'].append({
                        'symbol': symbol,
                        'action': analysis.recommendation.value,
                        'confidence': analysis.confidence,
                        'reasoning': analysis.technical_signals.get('reasoning', ''),
                        'target_price': analysis.target_price,
                        'stop_loss': analysis.stop_loss_price
                    })
            
            # Generate overall strategy using AI
            strategy_prompt = f"""
            Based on the following trading analysis results, provide an overall portfolio strategy:
            
            Analysis Results:
            {json.dumps(trading_plan['analysis_results'], indent=2)}
            
            Recommended Actions:
            {json.dumps(trading_plan['recommended_actions'], indent=2)}
            
            Provide:
            1. Overall market outlook
            2. Portfolio strategy recommendations
            3. Risk management suggestions
            4. Key considerations for the next trading period
            
            Keep response concise but informative (3-4 sentences per point).
            """
            
            llm = ChatOpenAI(model_name="gpt-3.5-turbo", temperature=0.3)
            strategy_response = await llm.apredict(strategy_prompt)
            trading_plan['overall_strategy'] = strategy_response
            
            return trading_plan
            
        except Exception as e:
            logger.error(f"Trading plan generation failed: {e}")
            return {'error': str(e)}

class FinancialTradingAPI:
    """FastAPI application for the Financial Trading Assistant"""
    
    def __init__(self, orchestrator: TradingOrchestrator):
        self.app = FastAPI(title="Financial Trading Assistant API")
        self.orchestrator = orchestrator
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """Setup CORS middleware"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def setup_routes(self):
        """Setup API routes"""
        
        @self.app.get("/market/{symbol}")
        async def get_market_data(symbol: str):
            try:
                price_data = await self.orchestrator.market_data_provider.get_real_time_price(symbol)
                indicators = await self.orchestrator.market_data_provider.get_technical_indicators(symbol)
                
                return {
                    'price_data': price_data,
                    'technical_indicators': indicators
                }
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/analyze/{symbol}")
        async def analyze_symbol(symbol: str, portfolio_id: str = "default"):
            try:
                analysis = await self.orchestrator.analyze_investment_opportunity(
                    symbol, portfolio_id
                )
                
                return {
                    'symbol': analysis.symbol,
                    'current_price': analysis.current_price,
                    'recommendation': analysis.recommendation.value,
                    'confidence': analysis.confidence,
                    'risk_level': analysis.risk_level.value,
                    'target_price': analysis.target_price,
                    'stop_loss_price': analysis.stop_loss_price,
                    'technical_signals': analysis.technical_signals,
                    'sentiment_analysis': analysis.sentiment_analysis
                }
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/trading-plan")
        async def create_trading_plan(request: Dict[str, Any]):
            try:
                portfolio_id = request.get('portfolio_id', 'default')
                symbols = request.get('symbols', [])
                
                if not symbols:
                    raise HTTPException(status_code=400, detail="No symbols provided")
                
                plan = await self.orchestrator.generate_trading_plan(portfolio_id, symbols)
                return plan
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/dashboard")
        async def get_dashboard():
            return {
                'status': 'active',
                'features': [
                    'Real-time market data',
                    'Technical analysis',
                    'Sentiment analysis',
                    'Risk management',
                    'Trading recommendations',
                    'Portfolio optimization'
                ],
                'data_sources': [
                    'Yahoo Finance',
                    'Alpha Vantage',
                    'Market News APIs'
                ]
            }

# Main Financial Trading Assistant
class FinancialTradingAssistant:
    """Main Financial Trading Assistant application"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.orchestrator = TradingOrchestrator(config)
        self.api = FinancialTradingAPI(self.orchestrator)
        
    async def initialize(self):
        """Initialize the trading assistant"""
        try:
            logger.info("Financial Trading Assistant initialized successfully")
        except Exception as e:
            logger.error(f"Initialization failed: {e}")
            raise

# Demo function
async def demo():
    """Demonstration of the Financial Trading Assistant"""
    
    print("üìà Financial Trading Assistant Demo\n")
    
    # Configuration
    config = {
        'market_data': {
            'alpha_vantage_key': 'demo_key',  # Would use real API key
            'bloomberg_api': False
        },
        'database_url': 'sqlite+aiosqlite:///./trading_assistant.db'
    }
    
    try:
        # Initialize system
        trading_assistant = FinancialTradingAssistant(config)
        await trading_assistant.initialize()
        
        print("‚úÖ Financial Trading Assistant initialized")
        print("‚úÖ Market data providers connected")
        print("‚úÖ AI analysis engines ready")
        print("‚úÖ Risk management systems active")
        
        # Demo symbols for analysis
        demo_symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'NVDA']
        
        print(f"\nüîç Analyzing investment opportunities...")
        print(f"üìä Symbols: {', '.join(demo_symbols)}")
        
        # Analyze each symbol
        analysis_results = {}
        for symbol in demo_symbols[:3]:  # Analyze first 3 for demo
            print(f"\nüìà Analyzing {symbol}...")
            
            try:
                analysis = await trading_assistant.orchestrator.analyze_investment_opportunity(
                    symbol, "demo_portfolio"
                )
                
                analysis_results[symbol] = analysis
                
                print(f"  üí∞ Current Price: ${analysis.current_price:.2f}")
                print(f"  üìä Change: {analysis.price_change_percent:.2f}%")
                print(f"  üéØ Recommendation: {analysis.recommendation.value.upper()}")
                print(f"  üîí Confidence: {analysis.confidence:.1f}%")
                print(f"  ‚ö†Ô∏è Risk Level: {analysis.risk_level.value.upper()}")
                
                if analysis.target_price:
                    print(f"  üéØ Target Price: ${analysis.target_price:.2f}")
                if analysis.stop_loss_price:
                    print(f"  üõë Stop Loss: ${analysis.stop_loss_price:.2f}")
                
            except Exception as e:
                print(f"  ‚ùå Analysis failed for {symbol}: {e}")
        
        # Generate trading plan
        print(f"\nüìã Generating Trading Plan...")
        
        try:
            trading_plan = await trading_assistant.orchestrator.generate_trading_plan(
                "demo_portfolio", list(analysis_results.keys())
            )
            
            print(f"‚úÖ Trading plan generated successfully")
            print(f"üìà Recommendations: {len(trading_plan.get('recommended_actions', []))}")
            
            # Display recommendations
            for action in trading_plan.get('recommended_actions', []):
                print(f"  ‚Ä¢ {action['action'].upper()} {action['symbol']} "
                     f"(Confidence: {action['confidence']:.1f}%)")
            
            # Display strategy
            if trading_plan.get('overall_strategy'):
                print(f"\nüéØ Overall Strategy:")
                strategy_lines = trading_plan['overall_strategy'].split('\n')
                for line in strategy_lines[:3]:  # Show first 3 lines
                    if line.strip():
                        print(f"  {line.strip()}")
        
        except Exception as e:
            print(f"‚ùå Trading plan generation failed: {e}")
        
        # Display system capabilities
        print(f"\nüõ†Ô∏è System Capabilities:")
        print(f"  ‚úÖ Real-time Market Data Analysis")
        print(f"  ‚úÖ Technical Indicator Calculation")
        print(f"  ‚úÖ AI-Powered Sentiment Analysis")
        print(f"  ‚úÖ Risk Assessment & Management")
        print(f"  ‚úÖ Automated Trading Recommendations")
        print(f"  ‚úÖ Portfolio Optimization")
        print(f"  ‚úÖ Multi-Agent Collaboration")
        
        print(f"\nüåê API Server Configuration:")
        print(f"  üìç Endpoints: Market Data, Analysis, Trading Plans")
        print(f"  üîÑ Real-time Updates: WebSocket Support")
        print(f"  üõ°Ô∏è Security: Rate Limiting & Authentication")
        
        print(f"\nüöÄ To start the trading assistant API:")
        print(f"   uvicorn main:trading_assistant.api.app --host 0.0.0.0 --port 8000")
        print(f"   Dashboard: http://localhost:8000/dashboard")
        print(f"   API Docs: http://localhost:8000/docs")
        
        print(f"\n‚úÖ Financial Trading Assistant demo completed!")
        
    except Exception as e:
        print(f"‚ùå Demo error: {e}")
        logger.error(f"Demo failed: {e}")

# Dependencies information
dependencies_info = """
# Install required dependencies:
pip install fastapi uvicorn websockets
pip install sqlalchemy aiosqlite
pip install langchain openai
pip install crewai autogen
pip install yfinance alpha-vantage
pip install pandas numpy scipy
pip install scikit-learn
pip install ta plotly matplotlib seaborn
pip install redis asyncpg
pip install requests beautifulsoup4

# Optional advanced dependencies:
pip install quantlib  # Advanced financial calculations
pip install zipline-reloaded  # Backtesting framework
pip install pyfolio  # Portfolio analysis

# Environment variables:
export OPENAI_API_KEY="your-openai-api-key"
export ALPHA_VANTAGE_API_KEY="your-alpha-vantage-key"
export BLOOMBERG_API_KEY="your-bloomberg-key"  # Optional
export INTERACTIVE_BROKERS_API="your-ib-credentials"  # Optional

# Note: This demo uses free data sources (Yahoo Finance)
# For production, consider premium data providers:
# - Bloomberg Terminal API
# - Alpha Vantage Premium
# - Quandl
# - Interactive Brokers API
"""

if __name__ == "__main__":
    print(dependencies_info)
    asyncio.run(demo())
````

## Project Summary

The Financial Trading Assistant represents a sophisticated AI-powered investment analysis platform that combines real-time market data, advanced technical analysis, and intelligent risk management to provide institutional-quality trading insights. This system democratizes access to professional-grade financial analysis tools while maintaining strict risk controls and regulatory compliance.

### Key Value Propositions

1. **Intelligent Market Analysis**: Multi-dimensional analysis combining technical indicators, sentiment analysis, and AI-powered pattern recognition for comprehensive investment insights.

2. **Automated Risk Management**: Real-time portfolio risk assessment including VaR calculations, correlation analysis, and position sizing recommendations to protect capital.

3. **Professional-Grade Tools**: Integration with premium data sources like Bloomberg and Alpha Vantage provides institutional-quality market intelligence.

4. **AI-Enhanced Decision Making**: Multi-agent collaboration between market analysts, risk managers, and portfolio optimization specialists for well-rounded investment decisions.

### Key Takeaways

- **Comprehensive Analysis Framework**: Combines technical analysis, fundamental data, sentiment analysis, and risk metrics for holistic investment evaluation
- **Real-Time Adaptive Intelligence**: Continuously monitors market conditions and adjusts recommendations based on changing market dynamics
- **Scalable Architecture**: Supports individual investors to institutional portfolios with appropriate risk controls and compliance features
- **Regulatory Compliance Ready**: Built-in risk management and audit trails ensure adherence to financial industry regulations

This Financial Trading Assistant transforms investment decision-making from intuition-based approaches to data-driven, AI-enhanced strategies that can compete with institutional investment platforms while remaining accessible to individual investors and smaller financial firms.