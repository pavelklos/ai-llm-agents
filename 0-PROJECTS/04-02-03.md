<small>Claude Sonnet 4 **(Code-to-Comment Generator)**</small>
# Code-to-Comment Generator

## Key Concepts Explanation

### Code Generation
Automated creation of human-readable code comments, docstrings, and documentation from existing source code using advanced language models that understand programming patterns and conventions.

### Transformer Models
Deep learning architectures specifically designed for sequence-to-sequence tasks, enabling the model to understand code context and generate coherent documentation that follows programming best practices.

### Docstring Generation
Automated creation of structured documentation strings that describe function parameters, return values, exceptions, and usage examples following language-specific conventions (PEP 257 for Python).

### Abstract Syntax Tree (AST)
Structured representation of source code that enables programmatic analysis of code structure, function signatures, and logical flow for intelligent comment generation.

### GitHub Copilot-style Architecture
AI-powered code assistance that provides real-time suggestions and documentation generation integrated into development workflows and IDEs.

### Code Intelligence
Advanced understanding of programming patterns, design principles, and best practices to generate contextually appropriate and technically accurate documentation.

## Comprehensive Project Explanation

### Objectives
The Code-to-Comment Generator aims to automate documentation creation, improve code maintainability, and enhance developer productivity by generating high-quality comments, docstrings, and explanatory documentation from source code.

### Key Features
- **Intelligent Comment Generation**: Context-aware comments for complex code blocks
- **Docstring Automation**: PEP 257 compliant docstrings with parameter descriptions
- **Multi-language Support**: Support for Python, JavaScript, Java, and other languages
- **Code Analysis**: AST-based code structure understanding
- **Style Consistency**: Adherence to project-specific documentation standards
- **IDE Integration**: Seamless integration with popular development environments

### Challenges
- **Context Understanding**: Accurately interpreting code intent and business logic
- **Style Consistency**: Maintaining consistent documentation style across projects
- **Complex Code Patterns**: Handling advanced programming constructs and patterns
- **Performance Optimization**: Real-time generation without impacting development workflow
- **Language Specificity**: Adapting to different programming language conventions

### Potential Impact
This system can significantly reduce documentation overhead, improve code quality, accelerate onboarding for new team members, and maintain consistent documentation standards across development teams.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
langchain==0.1.0
langchain-openai==0.0.5
transformers==4.36.0
torch==2.1.0
ast-tools==0.4.0
tree-sitter==0.20.4
tree-sitter-python==0.20.4
black==23.12.0
streamlit==1.29.0
gitpython==3.1.40
python-dotenv==1.0.0
jinja2==3.1.2
````

### Core Implementation

````python
import ast
import re
import os
import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import streamlit as st

from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage, AIMessage
import tree_sitter
from tree_sitter import Language, Parser
import black

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CommentType(Enum):
    INLINE = "inline"
    BLOCK = "block"
    DOCSTRING = "docstring"
    HEADER = "header"

class CodeLanguage(Enum):
    PYTHON = "python"
    JAVASCRIPT = "javascript"
    JAVA = "java"
    TYPESCRIPT = "typescript"

@dataclass
class FunctionInfo:
    name: str
    parameters: List[Dict[str, Any]]
    return_type: Optional[str]
    decorators: List[str]
    complexity: int
    line_number: int
    docstring: Optional[str]

@dataclass
class CommentSuggestion:
    content: str
    comment_type: CommentType
    line_number: int
    confidence: float
    reasoning: str

class ASTAnalyzer:
    """Advanced AST-based code analysis for intelligent comment generation."""
    
    def __init__(self):
        self.complexity_threshold = 5
    
    def analyze_python_file(self, code: str) -> Dict[str, Any]:
        """Analyze Python code using AST."""
        try:
            tree = ast.parse(code)
            analysis = {
                'functions': [],
                'classes': [],
                'imports': [],
                'complexity_hotspots': [],
                'undocumented_functions': []
            }
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    func_info = self._analyze_function(node)
                    analysis['functions'].append(func_info)
                    
                    if not func_info.docstring and func_info.complexity > 3:
                        analysis['undocumented_functions'].append(func_info)
                
                elif isinstance(node, ast.ClassDef):
                    class_info = self._analyze_class(node)
                    analysis['classes'].append(class_info)
                
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    analysis['imports'].append(self._analyze_import(node))
            
            return analysis
            
        except SyntaxError as e:
            logger.error(f"Syntax error in code: {e}")
            raise
    
    def _analyze_function(self, node: ast.FunctionDef) -> FunctionInfo:
        """Analyze individual function for complexity and structure."""
        parameters = []
        for arg in node.args.args:
            param_info = {
                'name': arg.arg,
                'annotation': ast.unparse(arg.annotation) if arg.annotation else None,
                'default': None
            }
            parameters.append(param_info)
        
        # Add defaults
        defaults = node.args.defaults
        if defaults:
            for i, default in enumerate(defaults):
                param_index = len(parameters) - len(defaults) + i
                if param_index >= 0:
                    parameters[param_index]['default'] = ast.unparse(default)
        
        return FunctionInfo(
            name=node.name,
            parameters=parameters,
            return_type=ast.unparse(node.returns) if node.returns else None,
            decorators=[ast.unparse(d) for d in node.decorator_list],
            complexity=self._calculate_complexity(node),
            line_number=node.lineno,
            docstring=ast.get_docstring(node)
        )
    
    def _analyze_class(self, node: ast.ClassDef) -> Dict[str, Any]:
        """Analyze class structure and methods."""
        methods = []
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                methods.append(self._analyze_function(item))
        
        return {
            'name': node.name,
            'methods': methods,
            'bases': [ast.unparse(base) for base in node.bases],
            'decorators': [ast.unparse(d) for d in node.decorator_list],
            'line_number': node.lineno,
            'docstring': ast.get_docstring(node)
        }
    
    def _analyze_import(self, node) -> Dict[str, Any]:
        """Analyze import statements."""
        if isinstance(node, ast.Import):
            return {
                'type': 'import',
                'modules': [alias.name for alias in node.names],
                'line_number': node.lineno
            }
        else:  # ImportFrom
            return {
                'type': 'from_import',
                'module': node.module,
                'names': [alias.name for alias in node.names],
                'line_number': node.lineno
            }
    
    def _calculate_complexity(self, node: ast.FunctionDef) -> int:
        """Calculate cyclomatic complexity of a function."""
        complexity = 1  # Base complexity
        
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.While, ast.For, ast.AsyncFor)):
                complexity += 1
            elif isinstance(child, ast.ExceptHandler):
                complexity += 1
            elif isinstance(child, ast.With):
                complexity += 1
        
        return complexity

class CommentGenerator:
    """AI-powered comment and docstring generator."""
    
    def __init__(self, openai_api_key: str):
        self.llm = ChatOpenAI(
            temperature=0.1,
            model_name="gpt-4",
            openai_api_key=openai_api_key
        )
        self.analyzer = ASTAnalyzer()
        
        # Comment generation prompts
        self.docstring_prompt = PromptTemplate(
            input_variables=["function_name", "parameters", "return_type", "function_body"],
            template="""
Generate a comprehensive Python docstring for the following function:

Function Name: {function_name}
Parameters: {parameters}
Return Type: {return_type}
Function Body:
{function_body}

Generate a PEP 257 compliant docstring that includes:
1. Brief description of what the function does
2. Parameters section with type hints and descriptions
3. Returns section describing the return value
4. Raises section if applicable
5. Example usage if helpful

Docstring:
"""
        )
        
        self.inline_comment_prompt = PromptTemplate(
            input_variables=["code_block", "context"],
            template="""
Generate concise, helpful inline comments for the following code block:

Context: {context}
Code:
{code_block}

Provide inline comments that:
1. Explain complex logic or algorithms
2. Clarify business rules or domain-specific operations
3. Highlight important implementation details
4. Are concise but informative

Comments:
"""
        )
    
    def generate_function_docstring(self, func_info: FunctionInfo, code_lines: List[str]) -> str:
        """Generate comprehensive docstring for a function."""
        try:
            # Extract function body
            function_body = '\n'.join(code_lines[func_info.line_number-1:func_info.line_number+10])
            
            # Format parameters
            params_str = ", ".join([
                f"{p['name']}: {p['annotation'] or 'Any'}" + 
                (f" = {p['default']}" if p['default'] else "")
                for p in func_info.parameters
            ])
            
            prompt = self.docstring_prompt.format(
                function_name=func_info.name,
                parameters=params_str,
                return_type=func_info.return_type or "None",
                function_body=function_body
            )
            
            docstring = self.llm.predict(prompt)
            return self._format_docstring(docstring)
            
        except Exception as e:
            logger.error(f"Error generating docstring: {e}")
            return f'"""\nTODO: Add docstring for {func_info.name}\n"""'
    
    def generate_inline_comments(self, code_block: str, context: str = "") -> List[CommentSuggestion]:
        """Generate inline comments for complex code sections."""
        try:
            prompt = self.inline_comment_prompt.format(
                code_block=code_block,
                context=context
            )
            
            response = self.llm.predict(prompt)
            return self._parse_comment_suggestions(response, code_block)
            
        except Exception as e:
            logger.error(f"Error generating inline comments: {e}")
            return []
    
    def generate_class_docstring(self, class_info: Dict[str, Any], code_lines: List[str]) -> str:
        """Generate docstring for a class."""
        try:
            class_body = '\n'.join(code_lines[class_info['line_number']-1:class_info['line_number']+15])
            
            prompt = f"""
Generate a comprehensive Python class docstring for:

Class Name: {class_info['name']}
Base Classes: {class_info['bases']}
Methods: {[m.name for m in class_info['methods']]}

Class Definition:
{class_body}

Provide a docstring that includes:
1. Purpose and responsibility of the class
2. Key attributes and their descriptions
3. Important methods overview
4. Usage examples if helpful

Docstring:
"""
            
            docstring = self.llm.predict(prompt)
            return self._format_docstring(docstring)
            
        except Exception as e:
            logger.error(f"Error generating class docstring: {e}")
            return f'"""\nTODO: Add docstring for {class_info["name"]} class\n"""'
    
    def _format_docstring(self, docstring: str) -> str:
        """Format docstring according to PEP 257."""
        # Remove any existing triple quotes
        docstring = docstring.strip().strip('"""').strip("'''")
        
        # Format as proper docstring
        lines = docstring.split('\n')
        if len(lines) == 1:
            return f'"""{lines[0]}"""'
        else:
            formatted_lines = ['"""']
            formatted_lines.extend(lines)
            formatted_lines.append('"""')
            return '\n'.join(formatted_lines)
    
    def _parse_comment_suggestions(self, response: str, code_block: str) -> List[CommentSuggestion]:
        """Parse AI response into structured comment suggestions."""
        suggestions = []
        lines = response.split('\n')
        code_lines = code_block.split('\n')
        
        for i, line in enumerate(lines):
            if line.strip() and not line.startswith('#'):
                suggestion = CommentSuggestion(
                    content=f"# {line.strip()}",
                    comment_type=CommentType.INLINE,
                    line_number=min(i, len(code_lines)-1),
                    confidence=0.8,
                    reasoning="AI-generated contextual comment"
                )
                suggestions.append(suggestion)
        
        return suggestions[:5]  # Limit to top 5 suggestions

class CodeDocumentationEngine:
    """Main engine for automated code documentation."""
    
    def __init__(self, openai_api_key: str):
        self.comment_generator = CommentGenerator(openai_api_key)
        self.analyzer = ASTAnalyzer()
    
    def process_python_file(self, code: str) -> Dict[str, Any]:
        """Process Python file and generate comprehensive documentation."""
        try:
            # Analyze code structure
            analysis = self.analyzer.analyze_python_file(code)
            code_lines = code.split('\n')
            
            documentation = {
                'original_code': code,
                'analysis': analysis,
                'generated_docstrings': {},
                'inline_comments': [],
                'suggestions': []
            }
            
            # Generate docstrings for undocumented functions
            for func_info in analysis['undocumented_functions']:
                docstring = self.comment_generator.generate_function_docstring(func_info, code_lines)
                documentation['generated_docstrings'][func_info.name] = {
                    'line_number': func_info.line_number,
                    'docstring': docstring
                }
            
            # Generate docstrings for undocumented classes
            for class_info in analysis['classes']:
                if not class_info['docstring']:
                    docstring = self.comment_generator.generate_class_docstring(class_info, code_lines)
                    documentation['generated_docstrings'][class_info['name']] = {
                        'line_number': class_info['line_number'],
                        'docstring': docstring,
                        'type': 'class'
                    }
            
            # Generate inline comments for complex functions
            for func_info in analysis['functions']:
                if func_info.complexity > 5:
                    func_code = self._extract_function_code(code_lines, func_info)
                    comments = self.comment_generator.generate_inline_comments(
                        func_code, 
                        f"Complex function: {func_info.name}"
                    )
                    documentation['inline_comments'].extend(comments)
            
            return documentation
            
        except Exception as e:
            logger.error(f"Error processing Python file: {e}")
            raise
    
    def _extract_function_code(self, code_lines: List[str], func_info: FunctionInfo) -> str:
        """Extract function code for analysis."""
        start_line = func_info.line_number - 1
        
        # Find function end by indentation
        indent_level = len(code_lines[start_line]) - len(code_lines[start_line].lstrip())
        end_line = start_line + 1
        
        while end_line < len(code_lines):
            line = code_lines[end_line]
            if line.strip() and (len(line) - len(line.lstrip())) <= indent_level:
                break
            end_line += 1
        
        return '\n'.join(code_lines[start_line:end_line])
    
    def apply_documentation(self, code: str, documentation: Dict[str, Any]) -> str:
        """Apply generated documentation to the original code."""
        try:
            lines = code.split('\n')
            
            # Apply docstrings
            for name, doc_info in documentation['generated_docstrings'].items():
                line_num = doc_info['line_number']
                docstring = doc_info['docstring']
                
                # Find insertion point (after function/class definition)
                for i in range(line_num, min(len(lines), line_num + 5)):
                    if ':' in lines[i]:
                        # Insert docstring after the definition line
                        indent = '    ' if 'type' not in doc_info else '    '
                        docstring_lines = [indent + line for line in docstring.split('\n')]
                        lines[i+1:i+1] = docstring_lines
                        break
            
            # Apply inline comments (simplified approach)
            for comment in documentation['inline_comments']:
                if comment.line_number < len(lines):
                    lines[comment.line_number] = lines[comment.line_number] + '  ' + comment.content
            
            return '\n'.join(lines)
            
        except Exception as e:
            logger.error(f"Error applying documentation: {e}")
            return code

def create_sample_code():
    """Create sample Python code for demonstration."""
    sample_code = '''
import math
from typing import List, Optional

class Calculator:
    def __init__(self):
        self.history = []
    
    def add(self, a: float, b: float) -> float:
        result = a + b
        self.history.append(f"{a} + {b} = {result}")
        return result
    
    def complex_calculation(self, numbers: List[float], operation: str) -> Optional[float]:
        if not numbers:
            return None
        
        if operation == "mean":
            total = sum(numbers)
            count = len(numbers)
            result = total / count
        elif operation == "variance":
            mean = sum(numbers) / len(numbers)
            squared_diffs = []
            for num in numbers:
                diff = num - mean
                squared_diff = diff ** 2
                squared_diffs.append(squared_diff)
            result = sum(squared_diffs) / len(squared_diffs)
        elif operation == "std_dev":
            mean = sum(numbers) / len(numbers)
            variance = sum((x - mean) ** 2 for x in numbers) / len(numbers)
            result = math.sqrt(variance)
        else:
            return None
        
        return result
    
    def fibonacci(self, n: int) -> int:
        if n <= 0:
            return 0
        elif n == 1:
            return 1
        else:
            a, b = 0, 1
            for i in range(2, n + 1):
                a, b = b, a + b
            return b

def process_data(data):
    processed = []
    for item in data:
        if isinstance(item, str):
            processed.append(item.upper())
        elif isinstance(item, (int, float)):
            processed.append(item * 2)
        else:
            processed.append(str(item))
    return processed
'''
    
    with open("sample_code.py", "w") as f:
        f.write(sample_code)
    
    return sample_code

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Code-to-Comment Generator",
        page_icon="📝",
        layout="wide"
    )
    
    st.title("📝 Code-to-Comment Generator")
    st.markdown("Automatically generate documentation, docstrings, and comments for your Python code")
    
    # Sidebar configuration
    with st.sidebar:
        st.header("⚙️ Configuration")
        api_key = st.text_input("OpenAI API Key", type="password")
        
        st.header("📋 Options")
        generate_docstrings = st.checkbox("Generate Docstrings", value=True)
        generate_inline_comments = st.checkbox("Generate Inline Comments", value=True)
        apply_black_formatting = st.checkbox("Apply Black Formatting", value=False)
        
        if st.button("Load Sample Code"):
            sample = create_sample_code()
            st.session_state['sample_code'] = sample
            st.success("Sample code loaded!")
    
    if not api_key:
        st.warning("Please enter your OpenAI API key in the sidebar to continue.")
        return
    
    # Initialize documentation engine
    doc_engine = CodeDocumentationEngine(api_key)
    
    # Code input
    st.header("📄 Input Code")
    
    # Check for loaded sample code
    default_code = st.session_state.get('sample_code', '')
    
    code_input = st.text_area(
        "Paste your Python code here:",
        value=default_code,
        height=300,
        placeholder="Enter Python code to generate documentation..."
    )
    
    if st.button("🔍 Analyze & Generate Documentation", disabled=not code_input):
        if code_input.strip():
            try:
                with st.spinner("Analyzing code and generating documentation..."):
                    # Process the code
                    documentation = doc_engine.process_python_file(code_input)
                    
                    # Display results in tabs
                    tab1, tab2, tab3, tab4 = st.tabs([
                        "📊 Analysis", 
                        "📝 Generated Docs", 
                        "💬 Comments", 
                        "🔧 Enhanced Code"
                    ])
                    
                    with tab1:
                        st.header("Code Analysis")
                        analysis = documentation['analysis']
                        
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("Functions", len(analysis['functions']))
                        with col2:
                            st.metric("Classes", len(analysis['classes']))
                        with col3:
                            st.metric("Undocumented", len(analysis['undocumented_functions']))
                        
                        if analysis['undocumented_functions']:
                            st.subheader("Undocumented Functions")
                            for func in analysis['undocumented_functions']:
                                st.write(f"• **{func.name}** (complexity: {func.complexity})")
                    
                    with tab2:
                        st.header("Generated Docstrings")
                        if documentation['generated_docstrings']:
                            for name, doc_info in documentation['generated_docstrings'].items():
                                st.subheader(f"📖 {name}")
                                st.code(doc_info['docstring'], language='python')
                        else:
                            st.info("No docstrings generated. All functions may already be documented.")
                    
                    with tab3:
                        st.header("Inline Comments")
                        if documentation['inline_comments']:
                            for comment in documentation['inline_comments']:
                                st.write(f"**Line {comment.line_number}:** {comment.content}")
                                st.caption(f"Reasoning: {comment.reasoning}")
                        else:
                            st.info("No inline comments suggested.")
                    
                    with tab4:
                        st.header("Enhanced Code")
                        enhanced_code = doc_engine.apply_documentation(code_input, documentation)
                        
                        if apply_black_formatting:
                            try:
                                enhanced_code = black.format_str(enhanced_code, mode=black.FileMode())
                            except Exception as e:
                                st.warning(f"Black formatting failed: {e}")
                        
                        st.code(enhanced_code, language='python')
                        
                        # Download button
                        st.download_button(
                            label="📥 Download Enhanced Code",
                            data=enhanced_code,
                            file_name="enhanced_code.py",
                            mime="text/python"
                        )
                        
            except SyntaxError as e:
                st.error(f"Syntax error in your code: {e}")
            except Exception as e:
                st.error(f"Error processing code: {e}")
        else:
            st.warning("Please enter some Python code to analyze.")
    
    # Additional features
    st.header("🚀 Additional Features")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("📈 Code Quality Metrics")
        if code_input:
            try:
                analysis = doc_engine.analyzer.analyze_python_file(code_input)
                avg_complexity = sum(f.complexity for f in analysis['functions']) / len(analysis['functions']) if analysis['functions'] else 0
                st.metric("Average Complexity", f"{avg_complexity:.1f}")
                st.metric("Documentation Coverage", f"{len(analysis['functions']) - len(analysis['undocumented_functions'])}/{len(analysis['functions'])}")
            except:
                st.info("Enter valid Python code to see metrics")
    
    with col2:
        st.subheader("🎯 Best Practices")
        st.markdown("""
        - **Docstrings**: Follow PEP 257 conventions
        - **Comments**: Explain 'why', not 'what'
        - **Complexity**: Keep functions under 10 complexity points
        - **Consistency**: Maintain consistent documentation style
        """)

if __name__ == "__main__":
    main()
````

### Environment Configuration

````python
OPENAI_API_KEY=your_openai_api_key_here
````

### Usage Instructions

````python
"""
Code-to-Comment Generator Setup and Usage Guide

1. Install dependencies:
   pip install -r requirements.txt

2. Set up environment:
   - Create .env file with OPENAI_API_KEY

3. Run the application:
   streamlit run code_comment_generator.py

4. Features:
   - AST-based code analysis
   - Intelligent docstring generation
   - Inline comment suggestions
   - Code complexity analysis
   - PEP 257 compliance
   - Black formatting integration

5. Usage Tips:
   - Upload Python files or paste code directly
   - Review generated documentation before applying
   - Customize comment styles for your project
   - Use with existing CI/CD pipelines

Integration Examples:
- VS Code extension
- Pre-commit hooks
- GitHub Actions
- IDE plugins
"""

def setup_code_generator():
    """Set up the code comment generator."""
    print("Setting up Code-to-Comment Generator...")
    print("Features:")
    print("- Automated docstring generation")
    print("- Inline comment suggestions")
    print("- Code complexity analysis")
    print("- AST-based code understanding")
    print("- PEP 257 compliance")
    
    print("\nReady to run: streamlit run code_comment_generator.py")

if __name__ == "__main__":
    setup_code_generator()
````

## Project Summary

The Code-to-Comment Generator demonstrates the application of advanced language models to improve code documentation and maintainability. By combining AST analysis with AI-powered content generation, it provides intelligent, context-aware documentation that follows industry best practices.

### Key Value Propositions:
- **Developer Productivity**: Automates time-consuming documentation tasks
- **Code Quality**: Ensures consistent, comprehensive documentation
- **Maintainability**: Improves code readability and long-term maintenance
- **Standards Compliance**: Follows PEP 257 and other documentation conventions
- **Intelligence**: Context-aware comments that explain complex logic

### Technical Highlights:
- AST-based code structure analysis and complexity calculation
- Transformer model integration for natural language generation
- Multi-language support architecture with extensible design
- Real-time code analysis with performance optimization
- Integration-ready design for IDEs and development workflows
- Comprehensive error handling and code validation

This system showcases how AI can enhance developer workflows by automating documentation generation while maintaining high quality standards and technical accuracy, ultimately leading to better code maintainability and team collaboration.