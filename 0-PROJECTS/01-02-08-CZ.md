<small>Claude Sonnet 4 **(Multi-Agent Game Master (RPG) s vyu≈æit√≠m MCP)**</small>
# Multi-Agent Game Master (RPG)

## Kl√≠ƒçov√© koncepty

### Model Context Protocol (MCP)
**MCP** je standardizovan√Ω protokol pro komunikaci mezi AI aplikacemi a extern√≠mi n√°stroji. Umo≈æ≈àuje modul√°rn√≠ p≈ô√≠stup k integraci r≈Øzn√Ωch slu≈æeb a datov√Ωch zdroj≈Ø.

### CrewAI
**CrewAI** je framework pro orchestraci v√≠ce AI agent≈Ø spolupracuj√≠c√≠ch na slo≈æit√Ωch √∫kolech. Ka≈æd√Ω agent m√° specifickou roli a schopnosti.

### LangGraph
**LangGraph** je knihovna pro tvorbu stavov√Ωch AI aplikac√≠ s podporou komplexn√≠ch workflow a rozhodovac√≠ch proces≈Ø.

### Character Memory
**Character Memory** je syst√©m pro uchov√°v√°n√≠ a aktualizaci dlouhodob√© pamƒõti postav, vƒçetnƒõ jejich historie, vztah≈Ø a zku≈°enost√≠.

### World Context
**World Context** reprezentuje aktu√°ln√≠ stav hern√≠ho svƒõta, vƒçetnƒõ lokac√≠, ud√°lost√≠ a glob√°ln√≠ch pravidel.

### Function Calling
**Function Calling** umo≈æ≈àuje AI agent≈Øm vykon√°vat specifick√© funkce pro manipulaci hern√≠ho stavu a interakci s prost≈ôed√≠m.

### JSON Tools
**JSON Tools** poskytuj√≠ strukturovan√© rozhran√≠ pro komunikaci mezi komponenty syst√©mu pomoc√≠ JSON sch√©mat.

## Komplexn√≠ vysvƒõtlen√≠ projektu

Tento projekt implementuje pokroƒçil√Ω AI Game Master syst√©m pro textov√© RPG hry. Syst√©m vyu≈æ√≠v√° v√≠ce specializovan√Ωch agent≈Ø, kte≈ô√≠ spolupracuj√≠ na vytv√°≈ôen√≠ immersivn√≠ho hern√≠ho z√°≈æitku.

### C√≠le projektu:
- **Adaptivn√≠ storytelling**: Dynamick√© generov√°n√≠ p≈ô√≠bƒõhu na z√°kladƒõ akc√≠ hr√°ƒç≈Ø
- **Persistentn√≠ pamƒõ≈•**: Dlouhodob√© uchov√°v√°n√≠ charakteristik postav a svƒõta
- **Multi-agent koordinace**: Specializovan√≠ agenti pro r≈Øzn√© aspekty hry
- **Realtime interakce**: Rychl√© a konzistentn√≠ odpovƒõdi na akce hr√°ƒç≈Ø

### V√Ωzvy:
- **Konzistence svƒõta**: Udr≈æen√≠ logick√©ho a konzistentn√≠ho hern√≠ho svƒõta
- **Komplexn√≠ interakce**: Spr√°va mno≈æstv√≠ promƒõnn√Ωch a vztah≈Ø
- **≈†k√°lovatelnost**: Podpora v√≠ce souƒçasn√Ωch hr√°ƒç≈Ø a rozs√°hl√Ωch svƒõt≈Ø
- **Pamƒõ≈•ov√° efektivnost**: Optimalizace ukl√°d√°n√≠ a naƒç√≠t√°n√≠ dat

### Potenci√°ln√≠ dopad:
- Revoluce v oblasti interaktivn√≠ho vypr√°vƒõn√≠
- Nov√© mo≈ænosti pro vzdƒõl√°vac√≠ aplikace
- Pokroƒçil√© n√°stroje pro game designery
- Experiment√°ln√≠ platforma pro AI research

## Komplexn√≠ implementace s Python k√≥dem

````python
fastapi==0.104.1
uvicorn==0.24.0
langchain==0.1.0
langchain-openai==0.0.2
langgraph==0.0.20
crewai==0.28.8
chromadb==0.4.18
pydantic==2.5.0
python-dotenv==1.0.0
redis==5.0.1
sqlalchemy==2.0.23
sqlite3
````

````python
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any
from datetime import datetime
from enum import Enum

class CharacterClass(str, Enum):
    WARRIOR = "warrior"
    MAGE = "mage"
    ROGUE = "rogue"
    CLERIC = "cleric"

class Character(BaseModel):
    id: str
    name: str
    character_class: CharacterClass
    level: int = 1
    health: int = 100
    mana: int = 50
    inventory: List[str] = []
    location: str = "starter_village"
    backstory: str = ""
    personality_traits: List[str] = []
    relationships: Dict[str, int] = {}  # NPC_ID -> relationship_score
    memory_fragments: List[str] = []
    last_updated: datetime = Field(default_factory=datetime.now)

class Location(BaseModel):
    id: str
    name: str
    description: str
    available_actions: List[str] = []
    npcs: List[str] = []
    items: List[str] = []
    connected_locations: List[str] = []
    environment_state: Dict[str, Any] = {}

class WorldState(BaseModel):
    current_time: str = "morning"
    weather: str = "clear"
    active_events: List[str] = []
    global_flags: Dict[str, bool] = {}
    npc_states: Dict[str, Dict] = {}
    
class GameAction(BaseModel):
    player_id: str
    action_type: str
    target: Optional[str] = None
    parameters: Dict[str, Any] = {}
    timestamp: datetime = Field(default_factory=datetime.now)

class GameResponse(BaseModel):
    narrative: str
    character_updates: Optional[Character] = None
    world_updates: Optional[Dict] = None
    available_actions: List[str] = []
    system_message: Optional[str] = None
````

````python
import chromadb
from typing import Dict, List, Optional
import json
from datetime import datetime
from src.models.game_models import Character

class CharacterMemoryManager:
    def __init__(self, persist_directory: str = "./chroma_db"):
        self.client = chromadb.PersistentClient(path=persist_directory)
        self.collection = self.client.get_or_create_collection(
            name="character_memories",
            metadata={"hnsw:space": "cosine"}
        )
    
    def store_memory(self, character_id: str, memory_text: str, 
                    memory_type: str = "general", importance: float = 0.5):
        """Ulo≈æen√≠ vzpom√≠nky postavy s vektorov√Ωm embedingem"""
        metadata = {
            "character_id": character_id,
            "memory_type": memory_type,
            "importance": importance,
            "timestamp": datetime.now().isoformat(),
        }
        
        memory_id = f"{character_id}_{datetime.now().timestamp()}"
        
        self.collection.add(
            documents=[memory_text],
            metadatas=[metadata],
            ids=[memory_id]
        )
    
    def retrieve_relevant_memories(self, character_id: str, 
                                 query: str, limit: int = 5) -> List[str]:
        """Naƒçten√≠ relevantn√≠ch vzpom√≠nek na z√°kladƒõ dotazu"""
        results = self.collection.query(
            query_texts=[query],
            where={"character_id": character_id},
            n_results=limit
        )
        
        return results['documents'][0] if results['documents'] else []
    
    def update_character_relationships(self, character_id: str, 
                                     npc_id: str, interaction_context: str):
        """Aktualizace vztah≈Ø postavy na z√°kladƒõ interakce"""
        relationship_memory = f"Interakce s {npc_id}: {interaction_context}"
        self.store_memory(character_id, relationship_memory, 
                         memory_type="relationship", importance=0.7)
    
    def get_character_summary(self, character_id: str) -> str:
        """Vytvo≈ôen√≠ shrnut√≠ postavy na z√°kladƒõ vzpom√≠nek"""
        all_memories = self.collection.query(
            query_texts=["charakteristika osobnosti historie"],
            where={"character_id": character_id},
            n_results=20
        )
        
        if not all_memories['documents']:
            return "Nov√° postava bez historie."
        
        memories_text = "\n".join(all_memories['documents'][0])
        return f"Souhrn vzpom√≠nek pro {character_id}:\n{memories_text}"
````

````python
from crewai import Agent, Task, Crew
from langchain_openai import ChatOpenAI
from langchain.tools import BaseTool
from typing import Dict, List, Any
import json

class WorldStateUpdateTool(BaseTool):
    name = "update_world_state"
    description = "Aktualizuje stav hern√≠ho svƒõta"
    
    def __init__(self, world_manager):
        super().__init__()
        self.world_manager = world_manager
    
    def _run(self, updates: str) -> str:
        try:
            update_dict = json.loads(updates)
            result = self.world_manager.update_world_state(update_dict)
            return f"Svƒõt aktualizov√°n: {result}"
        except Exception as e:
            return f"Chyba p≈ôi aktualizaci svƒõta: {str(e)}"

class CharacterUpdateTool(BaseTool):
    name = "update_character"
    description = "Aktualizuje stav postavy"
    
    def __init__(self, character_manager):
        super().__init__()
        self.character_manager = character_manager
    
    def _run(self, character_id: str, updates: str) -> str:
        try:
            update_dict = json.loads(updates)
            result = self.character_manager.update_character(character_id, update_dict)
            return f"Postava {character_id} aktualizov√°na: {result}"
        except Exception as e:
            return f"Chyba p≈ôi aktualizaci postavy: {str(e)}"

class GameMasterAgents:
    def __init__(self, llm_model: str = "gpt-4"):
        self.llm = ChatOpenAI(model=llm_model, temperature=0.7)
        
    def create_narrative_agent(self, tools: List[BaseTool]) -> Agent:
        return Agent(
            role="Mistr p≈ô√≠bƒõhu",
            goal="Vytv√°≈ôet poutav√© a konzistentn√≠ RPG p≈ô√≠bƒõhy",
            backstory="""Jsi zku≈°en√Ω vypravƒõƒç s dlouholetou prax√≠ v oblasti 
            fantasy literatury a RPG her. Tv√Ωm √∫kolem je vytv√°≈ôet immersivn√≠ 
            p≈ô√≠bƒõhy, kter√© reaguj√≠ na akce hr√°ƒç≈Ø.""",
            tools=tools,
            llm=self.llm,
            verbose=True
        )
    
    def create_world_manager_agent(self, tools: List[BaseTool]) -> Agent:
        return Agent(
            role="Spr√°vce svƒõta",
            goal="Udr≈æovat konzistenci a logiku hern√≠ho svƒõta",
            backstory="""Jsi peƒçliv√Ω archiv√°≈ô a spr√°vce rozs√°hl√Ωch fantasy svƒõt≈Ø. 
            Dohl√≠≈æ√≠≈° na logiku svƒõta, ƒçasov√© linky a interakce mezi lokacemi.""",
            tools=tools,
            llm=self.llm,
            verbose=True
        )
    
    def create_character_agent(self, tools: List[BaseTool]) -> Agent:
        return Agent(
            role="Psycholog postav",
            goal="Spravovat psychologii a v√Ωvoj hern√≠ch postav",
            backstory="""Jsi expert na lidskou psychologii aplikovanou na 
            hern√≠ postavy. Sleduje≈° jejich v√Ωvoj, vztahy a emocion√°ln√≠ reakce.""",
            tools=tools,
            llm=self.llm,
            verbose=True
        )
    
    def create_combat_agent(self, tools: List[BaseTool]) -> Agent:
        return Agent(
            role="Taktick√Ω strat√©g",
            goal="≈ò√≠dit souboje a akƒçn√≠ sekvence",
            backstory="""Jsi vojensk√Ω strat√©g specializuj√≠c√≠ se na taktick√© 
            pl√°nov√°n√≠ a veden√≠ bitev. Vytv√°≈ô√≠≈° spravedliv√© a vzru≈°uj√≠c√≠ souboje.""",
            tools=tools,
            llm=self.llm,
            verbose=True
        )
````

````python
from typing import Dict, List, Optional
from src.models.game_models import Character, GameAction, GameResponse, WorldState
from src.memory.character_memory import CharacterMemoryManager
from src.agents.game_master_agents import GameMasterAgents, WorldStateUpdateTool, CharacterUpdateTool
from crewai import Task, Crew
import json

class RPGGameEngine:
    def __init__(self):
        self.memory_manager = CharacterMemoryManager()
        self.characters: Dict[str, Character] = {}
        self.world_state = WorldState()
        self.agents = GameMasterAgents()
        
        # Inicializace n√°stroj≈Ø
        self.world_tool = WorldStateUpdateTool(self)
        self.character_tool = CharacterUpdateTool(self)
        
        # Vytvo≈ôen√≠ agent≈Ø
        tools = [self.world_tool, self.character_tool]
        self.narrative_agent = self.agents.create_narrative_agent(tools)
        self.world_agent = self.agents.create_world_manager_agent(tools)
        self.character_agent = self.agents.create_character_agent(tools)
        self.combat_agent = self.agents.create_combat_agent(tools)
    
    def register_character(self, character: Character) -> bool:
        """Registrace nov√© postavy do hry"""
        try:
            self.characters[character.id] = character
            
            # Ulo≈æen√≠ poƒç√°teƒçn√≠ vzpom√≠nky
            initial_memory = f"Postava {character.name} vstoupila do svƒõta jako {character.character_class}. {character.backstory}"
            self.memory_manager.store_memory(
                character.id, initial_memory, "origin", importance=1.0
            )
            
            return True
        except Exception as e:
            print(f"Chyba p≈ôi registraci postavy: {e}")
            return False
    
    def process_action(self, action: GameAction) -> GameResponse:
        """Zpracov√°n√≠ hern√≠ akce pomoc√≠ multi-agent syst√©mu"""
        
        # Naƒçten√≠ relevantn√≠ch vzpom√≠nek
        character = self.characters.get(action.player_id)
        if not character:
            return GameResponse(
                narrative="Postava nenalezena.",
                system_message="Chyba: Neplatn√© ID postavy"
            )
        
        relevant_memories = self.memory_manager.retrieve_relevant_memories(
            action.player_id, 
            f"{action.action_type} {action.target}",
            limit=3
        )
        
        # Kontextov√© informace pro agenty
        context = {
            "character": character.dict(),
            "world_state": self.world_state.dict(),
            "action": action.dict(),
            "relevant_memories": relevant_memories
        }
        
        # Vytvo≈ôen√≠ √∫kol≈Ø pro agenty
        narrative_task = Task(
            description=f"""
            Hr√°ƒç {character.name} vykon√°v√° akci: {action.action_type} na {action.target}.
            
            Kontext postavy: {json.dumps(context, ensure_ascii=False, indent=2)}
            
            Vytvo≈ô poutav√Ω p≈ô√≠bƒõhov√Ω text, kter√Ω popisuje v√Ωsledek t√©to akce.
            Zohledni osobnost postavy, jej√≠ historie a aktu√°ln√≠ stav svƒõta.
            """,
            agent=self.narrative_agent,
            expected_output="Detailn√≠ p≈ô√≠bƒõhov√Ω popis v√Ωsledku akce"
        )
        
        world_update_task = Task(
            description=f"""
            Na z√°kladƒõ akce {action.action_type} aktualizuj stav svƒõta.
            Zva≈æuj dopady na prost≈ôed√≠, NPC a glob√°ln√≠ ud√°losti.
            
            Aktu√°ln√≠ kontext: {json.dumps(context, ensure_ascii=False, indent=2)}
            """,
            agent=self.world_agent,
            expected_output="JSON objekt s aktualizacemi svƒõta"
        )
        
        character_update_task = Task(
            description=f"""
            Aktualizuj stav postavy {character.name} na z√°kladƒõ proveden√© akce.
            Zva≈æuj zmƒõny ve zdrav√≠, invent√°≈ôi, vztaz√≠ch a psychologick√©m stavu.
            
            Kontext: {json.dumps(context, ensure_ascii=False, indent=2)}
            """,
            agent=self.character_agent,
            expected_output="JSON objekt s aktualizacemi postavy"
        )
        
        # Spu≈°tƒõn√≠ crew
        crew = Crew(
            agents=[self.narrative_agent, self.world_agent, self.character_agent],
            tasks=[narrative_task, world_update_task, character_update_task],
            verbose=True
        )
        
        try:
            results = crew.kickoff()
            
            # Zpracov√°n√≠ v√Ωsledk≈Ø
            narrative = results.get('narrative', 'Nƒõco se stalo...')
            
            # Ulo≈æen√≠ akce do pamƒõti
            action_memory = f"Akce: {action.action_type} - {narrative[:100]}..."
            self.memory_manager.store_memory(
                action.player_id, action_memory, "action", importance=0.6
            )
            
            return GameResponse(
                narrative=narrative,
                character_updates=self.characters[action.player_id],
                available_actions=["explore", "talk", "inventory", "rest"]
            )
            
        except Exception as e:
            return GameResponse(
                narrative="Stalo se nƒõco neoƒçek√°van√©ho...",
                system_message=f"Chyba p≈ôi zpracov√°n√≠: {str(e)}"
            )
    
    def update_world_state(self, updates: Dict) -> str:
        """Aktualizace stavu svƒõta"""
        try:
            for key, value in updates.items():
                if hasattr(self.world_state, key):
                    setattr(self.world_state, key, value)
            return "√öspƒõ≈°nƒõ aktualizov√°no"
        except Exception as e:
            return f"Chyba: {str(e)}"
    
    def update_character(self, character_id: str, updates: Dict) -> str:
        """Aktualizace postavy"""
        try:
            if character_id in self.characters:
                character = self.characters[character_id]
                for key, value in updates.items():
                    if hasattr(character, key):
                        setattr(character, key, value)
                return "Postava aktualizov√°na"
            return "Postava nenalezena"
        except Exception as e:
            return f"Chyba: {str(e)}"
    
    def get_game_state_summary(self, character_id: str) -> str:
        """Z√≠sk√°n√≠ shrnut√≠ aktu√°ln√≠ho stavu hry"""
        character = self.characters.get(character_id)
        if not character:
            return "Postava nenalezena"
        
        character_summary = self.memory_manager.get_character_summary(character_id)
        
        return f"""
=== AKTU√ÅLN√ç STAV HRY ===
Postava: {character.name} (Level {character.level} {character.character_class})
Lokace: {character.location}
Zdrav√≠: {character.health}/100
Mana: {character.mana}

Stav svƒõta: {self.world_state.current_time}, {self.world_state.weather}

{character_summary}
"""
````

````python
from fastapi import FastAPI, HTTPException
from typing import Dict
import uvicorn
from src.core.game_engine import RPGGameEngine
from src.models.game_models import Character, GameAction, CharacterClass

app = FastAPI(title="AI RPG Game Master", version="1.0.0")
game_engine = RPGGameEngine()

@app.post("/character/create")
async def create_character(
    name: str,
    character_class: CharacterClass,
    backstory: str = ""
):
    """Vytvo≈ôen√≠ nov√© postavy"""
    character = Character(
        id=f"char_{len(game_engine.characters) + 1}",
        name=name,
        character_class=character_class,
        backstory=backstory
    )
    
    success = game_engine.register_character(character)
    if success:
        return {"character_id": character.id, "message": "Postava vytvo≈ôena"}
    else:
        raise HTTPException(status_code=400, detail="Chyba p≈ôi vytv√°≈ôen√≠ postavy")

@app.post("/game/action")
async def perform_action(action: GameAction):
    """Proveden√≠ hern√≠ akce"""
    response = game_engine.process_action(action)
    return response

@app.get("/game/state/{character_id}")
async def get_game_state(character_id: str):
    """Z√≠sk√°n√≠ aktu√°ln√≠ho stavu hry"""
    summary = game_engine.get_game_state_summary(character_id)
    return {"summary": summary}

@app.get("/character/{character_id}")
async def get_character(character_id: str):
    """Z√≠sk√°n√≠ informac√≠ o postavƒõ"""
    character = game_engine.characters.get(character_id)
    if character:
        return character
    else:
        raise HTTPException(status_code=404, detail="Postava nenalezena")

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````python
import asyncio
import requests
import json
from src.models.game_models import CharacterClass, GameAction

class GameClient:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.character_id = None
    
    def create_character(self, name: str, character_class: str, backstory: str):
        """Vytvo≈ôen√≠ postavy"""
        response = requests.post(
            f"{self.base_url}/character/create",
            params={
                "name": name,
                "character_class": character_class,
                "backstory": backstory
            }
        )
        
        if response.status_code == 200:
            data = response.json()
            self.character_id = data["character_id"]
            print(f"‚úÖ Postava vytvo≈ôena: {data}")
        else:
            print(f"‚ùå Chyba p≈ôi vytv√°≈ôen√≠ postavy: {response.text}")
    
    def perform_action(self, action_type: str, target: str = None, parameters: dict = None):
        """Proveden√≠ akce"""
        if not self.character_id:
            print("‚ùå Nejprve vytvo≈ôte postavy!")
            return
        
        action_data = {
            "player_id": self.character_id,
            "action_type": action_type,
            "target": target,
            "parameters": parameters or {}
        }
        
        response = requests.post(
            f"{self.base_url}/game/action",
            json=action_data
        )
        
        if response.status_code == 200:
            result = response.json()
            print(f"\nüìñ {result['narrative']}")
            if result.get('system_message'):
                print(f"üîß {result['system_message']}")
        else:
            print(f"‚ùå Chyba p≈ôi akci: {response.text}")
    
    def get_game_state(self):
        """Z√≠sk√°n√≠ stavu hry"""
        if not self.character_id:
            print("‚ùå Nejprve vytvo≈ôte postavu!")
            return
        
        response = requests.get(f"{self.base_url}/game/state/{self.character_id}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"\nüìä {data['summary']}")
        else:
            print(f"‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ stavu: {response.text}")

def main():
    """Demonstraƒçn√≠ hern√≠ session"""
    print("üéÆ === AI RPG GAME MASTER DEMO ===\n")
    
    # Inicializace klienta
    client = GameClient()
    
    # Vytvo≈ôen√≠ postavy
    print("1Ô∏è‚É£ Vytv√°≈ôen√≠ postavy...")
    client.create_character(
        name="Aelindra",
        character_class="mage",
        backstory="Mlad√° elf√≠ m√°gka hledaj√≠c√≠ ztracen√© kouzeln√© runy sv√© babiƒçky."
    )
    
    # Zobrazen√≠ poƒç√°teƒçn√≠ho stavu
    print("\n2Ô∏è‚É£ Poƒç√°teƒçn√≠ stav:")
    client.get_game_state()
    
    # Proveden√≠ nƒõkolika akc√≠
    print("\n3Ô∏è‚É£ Hern√≠ akce:")
    
    # Pr≈Øzkum
    print("\nüîç Akce: Pr≈Øzkum vesnice")
    client.perform_action("explore", "village_square")
    
    # Rozhovor s NPC
    print("\nüí¨ Akce: Rozhovor s krƒçm√°≈ôem")
    client.perform_action("talk", "innkeeper", {"topic": "local_rumors"})
    
    # Kouzlen√≠
    print("\n‚ú® Akce: Sesl√°n√≠ kouzla")
    client.perform_action("cast_spell", "light", {"spell_level": 1})
    
    # Fin√°ln√≠ stav
    print("\n4Ô∏è‚É£ Fin√°ln√≠ stav:")
    client.get_game_state()

if __name__ == "__main__":
    # Pozn√°mka: Spus≈•te nejprve API server: python src/api/game_api.py
    main()
````

````python
from setuptools import setup, find_packages

setup(
    name="ai-rpg-gamemaster",
    version="1.0.0",
    description="AI-powered RPG Game Master using MCP and multi-agent systems",
    packages=find_packages(),
    install_requires=[
        "fastapi>=0.104.1",
        "uvicorn>=0.24.0",
        "langchain>=0.1.0",
        "langchain-openai>=0.0.2",
        "langgraph>=0.0.20",
        "crewai>=0.28.8",
        "chromadb>=0.4.18",
        "pydantic>=2.5.0",
        "python-dotenv>=1.0.0",
        "redis>=5.0.1",
        "sqlalchemy>=2.0.23",
        "requests>=2.31.0"
    ],
    python_requires=">=3.9",
    author="AI RPG Developer",
    author_email="developer@ai-rpg.com",
    url="https://github.com/ai-rpg/gamemaster",
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3.9+",
    ],
)
````

## Shrnut√≠ projektu

**Multi-Agent Game Master** p≈ôedstavuje pokroƒçil√Ω syst√©m pro textov√© RPG hry vyu≈æ√≠vaj√≠c√≠ nejmodernƒõj≈°√≠ AI technologie. Projekt kombinuje **Model Context Protocol (MCP)** pro modul√°rn√≠ architekturu, **CrewAI** pro orchestraci specializovan√Ωch agent≈Ø a **LangGraph** pro slo≈æit√© rozhodovac√≠ procesy.

### Kl√≠ƒçov√© v√Ωhody:
- **Persistentn√≠ pamƒõ≈•**: Dlouhodob√© uchov√°v√°n√≠ charakteristik a historie postav
- **Adaptivn√≠ storytelling**: Dynamick√© generov√°n√≠ p≈ô√≠bƒõhu reaguj√≠c√≠ na akce hr√°ƒç≈Ø  
- **Modul√°rn√≠ architektura**: Nez√°visl√© komponenty pro snadnou √∫dr≈æbu a roz≈°√≠≈ôen√≠
- **≈†k√°lovatelnost**: Podpora v√≠ce souƒçasn√Ωch hr√°ƒç≈Ø a rozs√°hl√Ωch hern√≠ch svƒõt≈Ø

### Technick√© inovace:
- Vyu≈æit√≠ vektorov√Ωch datab√°z√≠ pro efektivn√≠ vyhled√°v√°n√≠ vzpom√≠nek
- Multi-agent syst√©m s specializovan√Ωmi rolemi
- RESTful API pro snadnou integraci
- Strukturovan√© JSON komunikace mezi komponenty

Tento projekt otev√≠r√° nov√© mo≈ænosti v oblasti interaktivn√≠ho vypr√°vƒõn√≠ a AI-assisted game designu, poskytuje robustn√≠ z√°klad pro experimentov√°n√≠ s pokroƒçil√Ωmi AI syst√©my v hern√≠m pr≈Ømyslu.