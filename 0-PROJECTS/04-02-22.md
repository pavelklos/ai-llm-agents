<small>Claude Sonnet 4 **(Nutrition Advisor with Meal Generator)**</small>
# Nutrition Advisor with Meal Generator

## Key Concepts Explanation

### Nutritional Analysis Engine
Advanced system that evaluates food intake against dietary guidelines, calculates macro/micronutrient profiles, and identifies nutritional gaps. Uses comprehensive food databases (USDA, nutrition APIs) to analyze calories, proteins, carbohydrates, fats, vitamins, and minerals, providing personalized recommendations based on age, gender, activity level, and health conditions.

### Health-Aware LLM Integration
Specialized large language model fine-tuned on nutritional science, dietary guidelines, and medical literature. Provides evidence-based nutritional advice, interprets complex dietary requirements, explains health implications of food choices, and generates personalized recommendations while maintaining safety boundaries for medical conditions.

### Intelligent Food Database
Comprehensive repository combining multiple nutrition databases with vector embeddings for semantic food search. Includes nutritional facts, ingredient lists, allergen information, and recipe databases with similarity matching for food substitutions and meal planning based on dietary restrictions and preferences.

### Personalized Meal Generation
AI-powered system that creates customized meal plans based on individual nutritional needs, dietary preferences, cultural backgrounds, and health goals. Considers factors like caloric requirements, macronutrient ratios, food allergies, budget constraints, and cooking skill levels to generate practical, enjoyable meal suggestions.

### Dietary Pattern Recognition
Machine learning system that analyzes eating habits, identifies patterns, and provides insights into nutritional trends. Tracks meal timing, food combinations, portion sizes, and nutritional adherence to help users understand their dietary behaviors and make informed improvements.

### Smart Recipe Optimization
Algorithm that modifies existing recipes to meet specific nutritional targets while maintaining taste and cooking feasibility. Suggests ingredient substitutions, portion adjustments, and cooking method changes to optimize meals for health goals like weight management, diabetes control, or athletic performance.

## Comprehensive Project Explanation

### Objectives
The Nutrition Advisor aims to democratize personalized nutrition guidance by providing AI-powered dietary analysis, meal planning, and nutritional education that adapts to individual needs, preferences, and health conditions while promoting sustainable healthy eating habits.

### Key Features
- **Personalized Nutrition Analysis**: Individual macro/micronutrient tracking with health goal alignment
- **AI Meal Planning**: Automated meal generation based on preferences, restrictions, and nutritional targets
- **Smart Food Database**: Comprehensive nutrition data with intelligent search and substitution capabilities
- **Health Integration**: Connection with health metrics, medical conditions, and fitness goals
- **Educational Content**: Evidence-based nutritional information and healthy eating guidance
- **Progress Tracking**: Long-term dietary pattern analysis and goal achievement monitoring

### Challenges
- **Data Accuracy**: Ensuring reliable nutritional information across diverse food products and recipes
- **Individual Variability**: Accounting for unique metabolic differences, health conditions, and cultural preferences
- **Medical Safety**: Providing helpful guidance while avoiding medical advice that requires professional oversight
- **Food Availability**: Considering regional food availability, seasonal variations, and budget constraints
- **Behavior Change**: Designing interventions that promote sustainable dietary habit modifications
- **Recipe Complexity**: Balancing nutritional optimization with practical cooking considerations and taste preferences

### Potential Impact
This system can improve public health outcomes, reduce healthcare costs through preventive nutrition, support individuals with dietary restrictions, enhance nutritional education, and promote sustainable eating practices while making personalized nutrition guidance accessible to broader populations.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
streamlit==1.29.0
chromadb==0.4.18
sentence-transformers==2.2.2
pandas==2.1.4
numpy==1.24.3
requests==2.31.0
plotly==5.17.0
scikit-learn==1.3.2
sqlalchemy==2.0.23
python-dotenv==1.0.0
pydantic==2.5.0
datetime
json
uuid
logging
typing
dataclasses
enum
math
````

### Core Implementation

````python
import os
import json
import uuid
import logging
import math
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import requests

from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate
from langchain.schema import Document
from sentence_transformers import SentenceTransformer
import chromadb
from sklearn.metrics.pairwise import cosine_similarity

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ActivityLevel(Enum):
    SEDENTARY = "sedentary"
    LIGHTLY_ACTIVE = "lightly_active"
    MODERATELY_ACTIVE = "moderately_active"
    VERY_ACTIVE = "very_active"
    EXTREMELY_ACTIVE = "extremely_active"

class DietaryGoal(Enum):
    WEIGHT_LOSS = "weight_loss"
    WEIGHT_GAIN = "weight_gain"
    MUSCLE_GAIN = "muscle_gain"
    MAINTAIN_WEIGHT = "maintain_weight"
    GENERAL_HEALTH = "general_health"
    DIABETES_MANAGEMENT = "diabetes_management"
    HEART_HEALTH = "heart_health"

class MealType(Enum):
    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    DINNER = "dinner"
    SNACK = "snack"

@dataclass
class UserProfile:
    user_id: str
    age: int
    gender: str  # male, female
    height_cm: float
    weight_kg: float
    activity_level: ActivityLevel
    dietary_goal: DietaryGoal
    dietary_restrictions: List[str] = field(default_factory=list)
    allergies: List[str] = field(default_factory=list)
    medical_conditions: List[str] = field(default_factory=list)
    preferred_cuisines: List[str] = field(default_factory=list)
    daily_calorie_target: Optional[float] = None
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class NutritionInfo:
    calories_per_100g: float
    protein_g: float
    carbs_g: float
    fat_g: float
    fiber_g: float
    sugar_g: float
    sodium_mg: float
    vitamins: Dict[str, float] = field(default_factory=dict)
    minerals: Dict[str, float] = field(default_factory=dict)

@dataclass
class FoodItem:
    food_id: str
    name: str
    category: str
    nutrition: NutritionInfo
    allergens: List[str] = field(default_factory=list)
    description: str = ""
    serving_size_g: float = 100.0

@dataclass
class Recipe:
    recipe_id: str
    name: str
    ingredients: List[Dict[str, Any]]  # {food_id, quantity_g, name}
    instructions: List[str]
    prep_time_minutes: int
    cook_time_minutes: int
    servings: int
    meal_type: List[MealType]
    cuisine_type: str
    difficulty_level: str  # easy, medium, hard
    total_nutrition: Optional[NutritionInfo] = None
    allergens: List[str] = field(default_factory=list)

@dataclass
class MealPlan:
    plan_id: str
    user_id: str
    date: datetime
    meals: Dict[MealType, Optional[Recipe]]
    daily_nutrition: NutritionInfo
    calorie_target: float
    meets_goals: bool

@dataclass
class NutritionAnalysis:
    analysis_id: str
    user_id: str
    date_range: Tuple[datetime, datetime]
    avg_daily_calories: float
    macro_distribution: Dict[str, float]  # protein %, carbs %, fat %
    micronutrient_gaps: List[str]
    recommendations: List[str]
    adherence_score: float

class NutritionCalculator:
    """Calculates nutritional requirements and analyzes intake."""
    
    def __init__(self):
        # Activity level multipliers for BMR
        self.activity_multipliers = {
            ActivityLevel.SEDENTARY: 1.2,
            ActivityLevel.LIGHTLY_ACTIVE: 1.375,
            ActivityLevel.MODERATELY_ACTIVE: 1.55,
            ActivityLevel.VERY_ACTIVE: 1.725,
            ActivityLevel.EXTREMELY_ACTIVE: 1.9
        }
        
        # Dietary goal calorie adjustments (percentage of TDEE)
        self.goal_adjustments = {
            DietaryGoal.WEIGHT_LOSS: -0.15,  # 15% deficit
            DietaryGoal.WEIGHT_GAIN: 0.10,   # 10% surplus
            DietaryGoal.MUSCLE_GAIN: 0.05,   # 5% surplus
            DietaryGoal.MAINTAIN_WEIGHT: 0.0,
            DietaryGoal.GENERAL_HEALTH: 0.0,
            DietaryGoal.DIABETES_MANAGEMENT: -0.05,
            DietaryGoal.HEART_HEALTH: -0.05
        }
    
    def calculate_bmr(self, user: UserProfile) -> float:
        """Calculate Basal Metabolic Rate using Mifflin-St Jeor equation."""
        if user.gender.lower() == 'male':
            bmr = 10 * user.weight_kg + 6.25 * user.height_cm - 5 * user.age + 5
        else:
            bmr = 10 * user.weight_kg + 6.25 * user.height_cm - 5 * user.age - 161
        
        return bmr
    
    def calculate_tdee(self, user: UserProfile) -> float:
        """Calculate Total Daily Energy Expenditure."""
        bmr = self.calculate_bmr(user)
        multiplier = self.activity_multipliers[user.activity_level]
        return bmr * multiplier
    
    def calculate_calorie_target(self, user: UserProfile) -> float:
        """Calculate daily calorie target based on goals."""
        tdee = self.calculate_tdee(user)
        adjustment = self.goal_adjustments[user.dietary_goal]
        return tdee * (1 + adjustment)
    
    def calculate_macro_targets(self, user: UserProfile, calories: float) -> Dict[str, float]:
        """Calculate macronutrient targets."""
        # Default macro distribution based on dietary goals
        if user.dietary_goal == DietaryGoal.MUSCLE_GAIN:
            protein_pct, carb_pct, fat_pct = 0.30, 0.40, 0.30
        elif user.dietary_goal == DietaryGoal.WEIGHT_LOSS:
            protein_pct, carb_pct, fat_pct = 0.35, 0.35, 0.30
        elif user.dietary_goal in [DietaryGoal.DIABETES_MANAGEMENT]:
            protein_pct, carb_pct, fat_pct = 0.25, 0.40, 0.35
        else:
            protein_pct, carb_pct, fat_pct = 0.25, 0.50, 0.25
        
        return {
            'protein_g': (calories * protein_pct) / 4,  # 4 cal/g
            'carbs_g': (calories * carb_pct) / 4,      # 4 cal/g
            'fat_g': (calories * fat_pct) / 9          # 9 cal/g
        }

class FoodDatabase:
    """Manages food data and nutritional information."""
    
    def __init__(self):
        self.embeddings_model = SentenceTransformer('all-MiniLM-L6-v2')
        self.chroma_client = chromadb.Client()
        
        try:
            self.collection = self.chroma_client.get_collection("food_database")
        except:
            self.collection = self.chroma_client.create_collection("food_database")
        
        self.foods = {}
        self.recipes = {}
        self._initialize_sample_data()
    
    def _initialize_sample_data(self):
        """Initialize with sample food and recipe data."""
        sample_foods = [
            {
                'name': 'Chicken Breast',
                'category': 'Protein',
                'nutrition': NutritionInfo(
                    calories_per_100g=165, protein_g=31, carbs_g=0,
                    fat_g=3.6, fiber_g=0, sugar_g=0, sodium_mg=74
                ),
                'allergens': [],
                'description': 'Lean poultry protein source'
            },
            {
                'name': 'Brown Rice',
                'category': 'Grains',
                'nutrition': NutritionInfo(
                    calories_per_100g=112, protein_g=2.6, carbs_g=23,
                    fat_g=0.9, fiber_g=1.8, sugar_g=0.4, sodium_mg=5
                ),
                'allergens': [],
                'description': 'Whole grain complex carbohydrate'
            },
            {
                'name': 'Broccoli',
                'category': 'Vegetables',
                'nutrition': NutritionInfo(
                    calories_per_100g=34, protein_g=2.8, carbs_g=7,
                    fat_g=0.4, fiber_g=2.6, sugar_g=1.5, sodium_mg=33
                ),
                'allergens': [],
                'description': 'Nutrient-dense green vegetable'
            },
            {
                'name': 'Salmon',
                'category': 'Protein',
                'nutrition': NutritionInfo(
                    calories_per_100g=208, protein_g=25, carbs_g=0,
                    fat_g=12, fiber_g=0, sugar_g=0, sodium_mg=70
                ),
                'allergens': ['fish'],
                'description': 'Omega-3 rich fatty fish'
            },
            {
                'name': 'Greek Yogurt',
                'category': 'Dairy',
                'nutrition': NutritionInfo(
                    calories_per_100g=59, protein_g=10, carbs_g=3.6,
                    fat_g=0.4, fiber_g=0, sugar_g=3.6, sodium_mg=36
                ),
                'allergens': ['milk'],
                'description': 'High-protein fermented dairy'
            }
        ]
        
        for food_data in sample_foods:
            food_id = str(uuid.uuid4())
            food = FoodItem(
                food_id=food_id,
                name=food_data['name'],
                category=food_data['category'],
                nutrition=food_data['nutrition'],
                allergens=food_data['allergens'],
                description=food_data['description']
            )
            
            self.foods[food_id] = food
            self._add_food_to_vector_db(food)
        
        # Sample recipes
        sample_recipes = [
            {
                'name': 'Grilled Chicken with Brown Rice',
                'ingredients': [
                    {'name': 'Chicken Breast', 'quantity_g': 150},
                    {'name': 'Brown Rice', 'quantity_g': 80},
                    {'name': 'Broccoli', 'quantity_g': 100}
                ],
                'instructions': [
                    'Season chicken breast with herbs and spices',
                    'Grill chicken for 6-8 minutes per side',
                    'Cook brown rice according to package instructions',
                    'Steam broccoli until tender'
                ],
                'prep_time_minutes': 15,
                'cook_time_minutes': 25,
                'servings': 1,
                'meal_type': [MealType.LUNCH, MealType.DINNER],
                'cuisine_type': 'healthy',
                'difficulty_level': 'easy'
            }
        ]
        
        for recipe_data in sample_recipes:
            recipe_id = str(uuid.uuid4())
            recipe = Recipe(
                recipe_id=recipe_id,
                name=recipe_data['name'],
                ingredients=recipe_data['ingredients'],
                instructions=recipe_data['instructions'],
                prep_time_minutes=recipe_data['prep_time_minutes'],
                cook_time_minutes=recipe_data['cook_time_minutes'],
                servings=recipe_data['servings'],
                meal_type=recipe_data['meal_type'],
                cuisine_type=recipe_data['cuisine_type'],
                difficulty_level=recipe_data['difficulty_level']
            )
            
            recipe.total_nutrition = self._calculate_recipe_nutrition(recipe)
            self.recipes[recipe_id] = recipe
    
    def _add_food_to_vector_db(self, food: FoodItem):
        """Add food to vector database for semantic search."""
        try:
            search_text = f"{food.name} {food.category} {food.description}"
            
            self.collection.add(
                documents=[search_text],
                metadatas=[{
                    'food_id': food.food_id,
                    'name': food.name,
                    'category': food.category
                }],
                ids=[food.food_id]
            )
        except Exception as e:
            logger.error(f"Error adding food to vector DB: {e}")
    
    def search_foods(self, query: str, top_k: int = 10) -> List[FoodItem]:
        """Search foods using semantic similarity."""
        try:
            results = self.collection.query(
                query_texts=[query],
                n_results=top_k
            )
            
            found_foods = []
            if results['metadatas'] and results['metadatas'][0]:
                for metadata in results['metadatas'][0]:
                    food_id = metadata['food_id']
                    if food_id in self.foods:
                        found_foods.append(self.foods[food_id])
            
            return found_foods
            
        except Exception as e:
            logger.error(f"Error searching foods: {e}")
            return list(self.foods.values())[:top_k]
    
    def _calculate_recipe_nutrition(self, recipe: Recipe) -> NutritionInfo:
        """Calculate total nutrition for a recipe."""
        total_calories = 0
        total_protein = 0
        total_carbs = 0
        total_fat = 0
        total_fiber = 0
        total_sugar = 0
        total_sodium = 0
        
        for ingredient in recipe.ingredients:
            # Find matching food
            matching_foods = [f for f in self.foods.values() 
                            if f.name.lower() in ingredient['name'].lower()]
            
            if matching_foods:
                food = matching_foods[0]
                quantity_ratio = ingredient['quantity_g'] / 100.0
                
                total_calories += food.nutrition.calories_per_100g * quantity_ratio
                total_protein += food.nutrition.protein_g * quantity_ratio
                total_carbs += food.nutrition.carbs_g * quantity_ratio
                total_fat += food.nutrition.fat_g * quantity_ratio
                total_fiber += food.nutrition.fiber_g * quantity_ratio
                total_sugar += food.nutrition.sugar_g * quantity_ratio
                total_sodium += food.nutrition.sodium_mg * quantity_ratio
        
        return NutritionInfo(
            calories_per_100g=total_calories,
            protein_g=total_protein,
            carbs_g=total_carbs,
            fat_g=total_fat,
            fiber_g=total_fiber,
            sugar_g=total_sugar,
            sodium_mg=total_sodium
        )

class MealPlanGenerator:
    """Generates personalized meal plans."""
    
    def __init__(self, food_db: FoodDatabase, nutrition_calc: NutritionCalculator, openai_api_key: str = None):
        self.food_db = food_db
        self.nutrition_calc = nutrition_calc
        
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.7,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        else:
            self.llm = None
        
        self.meal_generation_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are a professional nutritionist and meal planning expert. Create healthy, 
            balanced meal suggestions based on user requirements.
            
            Guidelines:
            1. Ensure nutritional balance and variety
            2. Consider dietary restrictions and allergies
            3. Suggest practical, achievable meals
            4. Include cooking tips and preparation advice
            5. Focus on whole foods and balanced nutrition
            
            Provide meal suggestions that are delicious, nutritious, and realistic.
            """),
            ("human", """
            User Profile:
            - Calorie Target: {calorie_target} calories
            - Dietary Goal: {dietary_goal}
            - Restrictions: {restrictions}
            - Allergies: {allergies}
            - Preferred Cuisines: {cuisines}
            
            Macro Targets:
            - Protein: {protein_target}g
            - Carbohydrates: {carb_target}g
            - Fat: {fat_target}g
            
            Generate a {meal_type} suggestion that:
            1. Fits within the calorie and macro targets
            2. Respects dietary restrictions and allergies
            3. Is practical to prepare
            4. Includes specific ingredients and portions
            
            Response format:
            Meal Name: [name]
            Ingredients: [list with quantities]
            Instructions: [brief preparation steps]
            Nutritional Highlights: [key benefits]
            """)
        ])
    
    def generate_daily_meal_plan(self, user: UserProfile) -> MealPlan:
        """Generate a complete daily meal plan."""
        calorie_target = self.nutrition_calc.calculate_calorie_target(user)
        macro_targets = self.nutrition_calc.calculate_macro_targets(user, calorie_target)
        
        # Distribute calories across meals
        meal_calorie_distribution = {
            MealType.BREAKFAST: 0.25,
            MealType.LUNCH: 0.35,
            MealType.DINNER: 0.35,
            MealType.SNACK: 0.05
        }
        
        meals = {}
        total_nutrition = NutritionInfo(
            calories_per_100g=0, protein_g=0, carbs_g=0,
            fat_g=0, fiber_g=0, sugar_g=0, sodium_mg=0
        )
        
        for meal_type in [MealType.BREAKFAST, MealType.LUNCH, MealType.DINNER]:
            meal_calories = calorie_target * meal_calorie_distribution[meal_type]
            
            # Generate meal for this type
            recipe = self._generate_meal_for_type(user, meal_type, meal_calories, macro_targets)
            meals[meal_type] = recipe
            
            # Add to total nutrition
            if recipe and recipe.total_nutrition:
                total_nutrition.calories_per_100g += recipe.total_nutrition.calories_per_100g
                total_nutrition.protein_g += recipe.total_nutrition.protein_g
                total_nutrition.carbs_g += recipe.total_nutrition.carbs_g
                total_nutrition.fat_g += recipe.total_nutrition.fat_g
        
        # Check if plan meets goals
        meets_goals = self._evaluate_meal_plan(total_nutrition, calorie_target, macro_targets)
        
        return MealPlan(
            plan_id=str(uuid.uuid4()),
            user_id=user.user_id,
            date=datetime.now(),
            meals=meals,
            daily_nutrition=total_nutrition,
            calorie_target=calorie_target,
            meets_goals=meets_goals
        )
    
    def _generate_meal_for_type(self, user: UserProfile, meal_type: MealType, 
                               target_calories: float, macro_targets: Dict[str, float]) -> Optional[Recipe]:
        """Generate a meal for specific meal type."""
        # Find suitable recipes from database
        suitable_recipes = [r for r in self.food_db.recipes.values() 
                          if meal_type in r.meal_type]
        
        if suitable_recipes:
            # Simple selection based on calorie proximity
            best_recipe = min(suitable_recipes, 
                            key=lambda r: abs(r.total_nutrition.calories_per_100g - target_calories))
            return best_recipe
        
        # If no suitable recipe found, create basic meal suggestion
        return self._create_basic_meal(meal_type, target_calories)
    
    def _create_basic_meal(self, meal_type: MealType, target_calories: float) -> Recipe:
        """Create a basic meal when no recipes are available."""
        if meal_type == MealType.BREAKFAST:
            ingredients = [
                {'name': 'Greek Yogurt', 'quantity_g': 150},
                {'name': 'Berries', 'quantity_g': 100}
            ]
            instructions = ['Combine yogurt and berries in a bowl', 'Enjoy fresh']
            
        elif meal_type == MealType.LUNCH:
            ingredients = [
                {'name': 'Chicken Breast', 'quantity_g': 120},
                {'name': 'Brown Rice', 'quantity_g': 60},
                {'name': 'Broccoli', 'quantity_g': 100}
            ]
            instructions = ['Grill chicken', 'Cook rice', 'Steam vegetables', 'Combine and serve']
            
        else:  # DINNER
            ingredients = [
                {'name': 'Salmon', 'quantity_g': 130},
                {'name': 'Sweet Potato', 'quantity_g': 150}
            ]
            instructions = ['Bake salmon at 400F for 15 minutes', 'Roast sweet potato', 'Serve together']
        
        recipe_id = str(uuid.uuid4())
        recipe = Recipe(
            recipe_id=recipe_id,
            name=f"Healthy {meal_type.value.title()}",
            ingredients=ingredients,
            instructions=instructions,
            prep_time_minutes=10,
            cook_time_minutes=20,
            servings=1,
            meal_type=[meal_type],
            cuisine_type="healthy",
            difficulty_level="easy"
        )
        
        recipe.total_nutrition = self.food_db._calculate_recipe_nutrition(recipe)
        return recipe
    
    def _evaluate_meal_plan(self, nutrition: NutritionInfo, calorie_target: float, 
                           macro_targets: Dict[str, float]) -> bool:
        """Evaluate if meal plan meets nutritional goals."""
        calorie_diff = abs(nutrition.calories_per_100g - calorie_target) / calorie_target
        protein_diff = abs(nutrition.protein_g - macro_targets['protein_g']) / macro_targets['protein_g']
        
        # Plan is good if within 15% of targets
        return calorie_diff < 0.15 and protein_diff < 0.15

class NutritionAdvisor:
    """Main nutrition advisor system."""
    
    def __init__(self, openai_api_key: str = None):
        self.nutrition_calc = NutritionCalculator()
        self.food_db = FoodDatabase()
        self.meal_generator = MealPlanGenerator(self.food_db, self.nutrition_calc, openai_api_key)
        
        # User profiles and meal plans storage
        self.user_profiles = {}
        self.meal_plans = {}
        
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.3,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        else:
            self.llm = None
    
    def create_user_profile(self, age: int, gender: str, height_cm: float, weight_kg: float,
                           activity_level: ActivityLevel, dietary_goal: DietaryGoal,
                           restrictions: List[str] = None, allergies: List[str] = None) -> str:
        """Create a new user profile."""
        user_id = str(uuid.uuid4())
        
        profile = UserProfile(
            user_id=user_id,
            age=age,
            gender=gender,
            height_cm=height_cm,
            weight_kg=weight_kg,
            activity_level=activity_level,
            dietary_goal=dietary_goal,
            dietary_restrictions=restrictions or [],
            allergies=allergies or []
        )
        
        # Calculate calorie target
        profile.daily_calorie_target = self.nutrition_calc.calculate_calorie_target(profile)
        
        self.user_profiles[user_id] = profile
        logger.info(f"Created user profile: {user_id}")
        
        return user_id
    
    def generate_meal_plan(self, user_id: str) -> Optional[MealPlan]:
        """Generate meal plan for user."""
        if user_id not in self.user_profiles:
            logger.error(f"User profile not found: {user_id}")
            return None
        
        user = self.user_profiles[user_id]
        meal_plan = self.meal_generator.generate_daily_meal_plan(user)
        
        # Store meal plan
        self.meal_plans[meal_plan.plan_id] = meal_plan
        
        return meal_plan
    
    def analyze_nutrition_intake(self, user_id: str, food_log: List[Dict]) -> NutritionAnalysis:
        """Analyze nutrition intake from food log."""
        if user_id not in self.user_profiles:
            raise ValueError("User profile not found")
        
        user = self.user_profiles[user_id]
        
        # Calculate totals from food log
        total_calories = sum(entry.get('calories', 0) for entry in food_log)
        total_protein = sum(entry.get('protein', 0) for entry in food_log)
        total_carbs = sum(entry.get('carbs', 0) for entry in food_log)
        total_fat = sum(entry.get('fat', 0) for entry in food_log)
        
        # Calculate macro distribution
        macro_distribution = {
            'protein': (total_protein * 4) / max(total_calories, 1) * 100,
            'carbs': (total_carbs * 4) / max(total_calories, 1) * 100,
            'fat': (total_fat * 9) / max(total_calories, 1) * 100
        }
        
        # Generate recommendations
        recommendations = self._generate_nutrition_recommendations(user, total_calories, macro_distribution)
        
        # Calculate adherence score
        calorie_target = user.daily_calorie_target or 2000
        adherence_score = max(0, 100 - abs(total_calories - calorie_target) / calorie_target * 100)
        
        return NutritionAnalysis(
            analysis_id=str(uuid.uuid4()),
            user_id=user_id,
            date_range=(datetime.now() - timedelta(days=1), datetime.now()),
            avg_daily_calories=total_calories,
            macro_distribution=macro_distribution,
            micronutrient_gaps=[],
            recommendations=recommendations,
            adherence_score=adherence_score
        )
    
    def _generate_nutrition_recommendations(self, user: UserProfile, calories: float, 
                                          macros: Dict[str, float]) -> List[str]:
        """Generate personalized nutrition recommendations."""
        recommendations = []
        
        calorie_target = user.daily_calorie_target or 2000
        
        if calories < calorie_target * 0.8:
            recommendations.append("Consider increasing calorie intake to meet your energy needs")
        elif calories > calorie_target * 1.2:
            recommendations.append("Consider reducing calorie intake to align with your goals")
        
        if macros['protein'] < 15:
            recommendations.append("Increase protein intake with lean meats, legumes, or dairy")
        
        if macros['carbs'] > 65:
            recommendations.append("Consider reducing refined carbohydrates and focus on complex carbs")
        
        if macros['fat'] > 35:
            recommendations.append("Moderate fat intake and focus on healthy fats like nuts and olive oil")
        
        # Goal-specific recommendations
        if user.dietary_goal == DietaryGoal.WEIGHT_LOSS:
            recommendations.append("Focus on high-protein, high-fiber foods to maintain satiety")
        elif user.dietary_goal == DietaryGoal.MUSCLE_GAIN:
            recommendations.append("Ensure adequate protein post-workout for muscle recovery")
        
        return recommendations

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="AI Nutrition Advisor",
        page_icon="ü•ó",
        layout="wide"
    )
    
    st.title("ü•ó AI Nutrition Advisor & Meal Generator")
    st.markdown("Personalized nutrition guidance powered by AI")
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        openai_api_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        st.header("üë§ User Profile")
        if st.button("Create New Profile"):
            st.session_state['show_profile_form'] = True
    
    # Initialize nutrition advisor
    if 'advisor' not in st.session_state:
        with st.spinner("Initializing nutrition advisor..."):
            st.session_state['advisor'] = NutritionAdvisor(openai_api_key)
            st.success("Nutrition advisor ready!")
    
    advisor = st.session_state['advisor']
    
    # Profile creation form
    if st.session_state.get('show_profile_form', False):
        with st.form("profile_form"):
            st.subheader("Create Your Profile")
            
            col1, col2 = st.columns(2)
            
            with col1:
                age = st.number_input("Age", min_value=1, max_value=120, value=30)
                gender = st.selectbox("Gender", ["male", "female"])
                height = st.number_input("Height (cm)", min_value=100, max_value=250, value=170)
                weight = st.number_input("Weight (kg)", min_value=30, max_value=300, value=70)
            
            with col2:
                activity = st.selectbox("Activity Level", [
                    "sedentary", "lightly_active", "moderately_active", "very_active", "extremely_active"
                ])
                goal = st.selectbox("Dietary Goal", [
                    "weight_loss", "weight_gain", "muscle_gain", "maintain_weight", 
                    "general_health", "diabetes_management", "heart_health"
                ])
                
                restrictions = st.multiselect("Dietary Restrictions", [
                    "vegetarian", "vegan", "gluten-free", "dairy-free", "low-carb", "keto"
                ])
                
                allergies = st.multiselect("Allergies", [
                    "nuts", "shellfish", "eggs", "milk", "soy", "wheat"
                ])
            
            if st.form_submit_button("Create Profile"):
                user_id = advisor.create_user_profile(
                    age=age,
                    gender=gender,
                    height_cm=height,
                    weight_kg=weight,
                    activity_level=ActivityLevel(activity),
                    dietary_goal=DietaryGoal(goal),
                    restrictions=restrictions,
                    allergies=allergies
                )
                
                st.session_state['current_user_id'] = user_id
                st.session_state['show_profile_form'] = False
                st.success("Profile created successfully!")
                st.rerun()
    
    # Main tabs
    tab1, tab2, tab3, tab4 = st.tabs([
        "üçΩÔ∏è Meal Planning",
        "üìä Nutrition Analysis", 
        "üîç Food Database",
        "üìà Progress Tracking"
    ])
    
    with tab1:
        st.header("üçΩÔ∏è Daily Meal Planning")
        
        if 'current_user_id' in st.session_state:
            user_id = st.session_state['current_user_id']
            user = advisor.user_profiles[user_id]
            
            # Display user info
            st.subheader("üë§ Your Profile")
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Daily Calories", f"{user.daily_calorie_target:.0f}")
            with col2:
                st.metric("Goal", user.dietary_goal.value.replace('_', ' ').title())
            with col3:
                bmr = advisor.nutrition_calc.calculate_bmr(user)
                st.metric("BMR", f"{bmr:.0f}")
            with col4:
                bmi = user.weight_kg / (user.height_cm/100)**2
                st.metric("BMI", f"{bmi:.1f}")
            
            # Generate meal plan
            if st.button("üéØ Generate Today's Meal Plan", type="primary"):
                with st.spinner("Creating your personalized meal plan..."):
                    meal_plan = advisor.generate_meal_plan(user_id)
                    st.session_state['current_meal_plan'] = meal_plan
                    st.success("Meal plan generated!")
            
            # Display meal plan
            if 'current_meal_plan' in st.session_state:
                meal_plan = st.session_state['current_meal_plan']
                
                st.subheader("üìÖ Today's Meal Plan")
                
                for meal_type in [MealType.BREAKFAST, MealType.LUNCH, MealType.DINNER]:
                    if meal_type in meal_plan.meals and meal_plan.meals[meal_type]:
                        recipe = meal_plan.meals[meal_type]
                        
                        with st.expander(f"üç≥ {meal_type.value.title()}: {recipe.name}"):
                            col1, col2 = st.columns(2)
                            
                            with col1:
                                st.write("**Ingredients:**")
                                for ingredient in recipe.ingredients:
                                    st.write(f"‚Ä¢ {ingredient['quantity_g']}g {ingredient['name']}")
                                
                                st.write(f"**Prep Time:** {recipe.prep_time_minutes} minutes")
                                st.write(f"**Cook Time:** {recipe.cook_time_minutes} minutes")
                            
                            with col2:
                                if recipe.total_nutrition:
                                    nutrition = recipe.total_nutrition
                                    st.write("**Nutrition per serving:**")
                                    st.write(f"‚Ä¢ Calories: {nutrition.calories_per_100g:.0f}")
                                    st.write(f"‚Ä¢ Protein: {nutrition.protein_g:.1f}g")
                                    st.write(f"‚Ä¢ Carbs: {nutrition.carbs_g:.1f}g")
                                    st.write(f"‚Ä¢ Fat: {nutrition.fat_g:.1f}g")
                            
                            st.write("**Instructions:**")
                            for i, instruction in enumerate(recipe.instructions, 1):
                                st.write(f"{i}. {instruction}")
                
                # Daily nutrition summary
                st.subheader("üìä Daily Nutrition Summary")
                
                if meal_plan.daily_nutrition:
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("Total Calories", f"{meal_plan.daily_nutrition.calories_per_100g:.0f}")
                    with col2:
                        st.metric("Protein", f"{meal_plan.daily_nutrition.protein_g:.0f}g")
                    with col3:
                        st.metric("Carbs", f"{meal_plan.daily_nutrition.carbs_g:.0f}g")
                    with col4:
                        st.metric("Fat", f"{meal_plan.daily_nutrition.fat_g:.0f}g")
                    
                    # Macro distribution chart
                    macros = {
                        'Protein': meal_plan.daily_nutrition.protein_g * 4,
                        'Carbs': meal_plan.daily_nutrition.carbs_g * 4,
                        'Fat': meal_plan.daily_nutrition.fat_g * 9
                    }
                    
                    fig = px.pie(values=list(macros.values()), names=list(macros.keys()),
                               title="Macro Distribution (by calories)")
                    st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Please create a user profile to get started with meal planning.")
    
    with tab2:
        st.header("üìä Nutrition Analysis")
        
        if 'current_user_id' in st.session_state:
            st.subheader("üìù Food Log Entry")
            
            # Simple food logging
            with st.form("food_log"):
                food_name = st.text_input("Food Item")
                quantity = st.number_input("Quantity (grams)", min_value=1, value=100)
                calories = st.number_input("Calories", min_value=0, value=0)
                protein = st.number_input("Protein (g)", min_value=0.0, value=0.0)
                carbs = st.number_input("Carbs (g)", min_value=0.0, value=0.0)
                fat = st.number_input("Fat (g)", min_value=0.0, value=0.0)
                
                if st.form_submit_button("Add to Food Log"):
                    if 'food_log' not in st.session_state:
                        st.session_state['food_log'] = []
                    
                    st.session_state['food_log'].append({
                        'food': food_name,
                        'quantity': quantity,
                        'calories': calories,
                        'protein': protein,
                        'carbs': carbs,
                        'fat': fat,
                        'timestamp': datetime.now()
                    })
                    
                    st.success(f"Added {food_name} to your food log!")
            
            # Display food log
            if 'food_log' in st.session_state and st.session_state['food_log']:
                st.subheader("üìã Today's Food Log")
                
                food_df = pd.DataFrame(st.session_state['food_log'])
                st.dataframe(food_df, use_container_width=True)
                
                # Analyze nutrition
                if st.button("üîç Analyze Nutrition"):
                    user_id = st.session_state['current_user_id']
                    analysis = advisor.analyze_nutrition_intake(user_id, st.session_state['food_log'])
                    
                    st.subheader("üìä Nutrition Analysis Results")
                    
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.metric("Daily Calories", f"{analysis.avg_daily_calories:.0f}")
                    with col2:
                        st.metric("Adherence Score", f"{analysis.adherence_score:.0f}%")
                    with col3:
                        target = advisor.user_profiles[user_id].daily_calorie_target
                        variance = ((analysis.avg_daily_calories - target) / target) * 100
                        st.metric("Calorie Variance", f"{variance:+.0f}%")
                    
                    # Macro distribution
                    macro_fig = px.bar(
                        x=['Protein', 'Carbs', 'Fat'],
                        y=[analysis.macro_distribution['protein'], 
                           analysis.macro_distribution['carbs'],
                           analysis.macro_distribution['fat']],
                        title="Macro Distribution (%)",
                        color=['Protein', 'Carbs', 'Fat']
                    )
                    st.plotly_chart(macro_fig, use_container_width=True)
                    
                    # Recommendations
                    if analysis.recommendations:
                        st.subheader("üí° Personalized Recommendations")
                        for rec in analysis.recommendations:
                            st.write(f"‚Ä¢ {rec}")
        else:
            st.info("Please create a user profile to access nutrition analysis.")
    
    with tab3:
        st.header("üîç Food Database")
        
        # Food search
        search_query = st.text_input("Search for foods:", placeholder="e.g., chicken breast, broccoli")
        
        if search_query:
            search_results = advisor.food_db.search_foods(search_query)
            
            st.subheader(f"üîç Search Results for '{search_query}'")
            
            for food in search_results[:10]:
                with st.expander(f"ü•ó {food.name} ({food.category})"):
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.write(f"**Category:** {food.category}")
                        st.write(f"**Description:** {food.description}")
                        if food.allergens:
                            st.write(f"**Allergens:** {', '.join(food.allergens)}")
                    
                    with col2:
                        st.write("**Nutrition per 100g:**")
                        st.write(f"‚Ä¢ Calories: {food.nutrition.calories_per_100g:.0f}")
                        st.write(f"‚Ä¢ Protein: {food.nutrition.protein_g:.1f}g")
                        st.write(f"‚Ä¢ Carbs: {food.nutrition.carbs_g:.1f}g")
                        st.write(f"‚Ä¢ Fat: {food.nutrition.fat_g:.1f}g")
                        st.write(f"‚Ä¢ Fiber: {food.nutrition.fiber_g:.1f}g")
        
        # Food database stats
        st.subheader("üìä Database Statistics")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Total Foods", len(advisor.food_db.foods))
        with col2:
            st.metric("Total Recipes", len(advisor.food_db.recipes))
        with col3:
            categories = set(food.category for food in advisor.food_db.foods.values())
            st.metric("Categories", len(categories))
    
    with tab4:
        st.header("üìà Progress Tracking")
        
        if 'current_user_id' in st.session_state:
            # Simulated progress data
            dates = pd.date_range('2024-01-01', periods=30, freq='D')
            progress_data = {
                'Date': dates,
                'Weight': 70 + np.cumsum(np.random.normal(-0.02, 0.1, 30)),
                'Calories': np.random.normal(2000, 200, 30),
                'Adherence': np.random.uniform(60, 95, 30)
            }
            
            df = pd.DataFrame(progress_data)
            
            # Weight progress
            st.subheader("‚öñÔ∏è Weight Progress")
            weight_fig = px.line(df, x='Date', y='Weight', title='Weight Trend')
            st.plotly_chart(weight_fig, use_container_width=True)
            
            # Calorie tracking
            st.subheader("üî• Calorie Tracking")
            calorie_fig = px.line(df, x='Date', y='Calories', title='Daily Calorie Intake')
            calorie_fig.add_hline(y=2000, line_dash="dash", line_color="red", 
                                 annotation_text="Target")
            st.plotly_chart(calorie_fig, use_container_width=True)
            
            # Adherence score
            st.subheader("üéØ Goal Adherence")
            adherence_fig = px.bar(df.tail(7), x='Date', y='Adherence', 
                                 title='Weekly Adherence Score (%)')
            st.plotly_chart(adherence_fig, use_container_width=True)
            
            # Progress metrics
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Current Weight", f"{df['Weight'].iloc[-1]:.1f} kg", 
                         f"{df['Weight'].iloc[-1] - df['Weight'].iloc[0]:+.1f}")
            with col2:
                st.metric("Avg Daily Calories", f"{df['Calories'].mean():.0f}")
            with col3:
                st.metric("Avg Adherence", f"{df['Adherence'].mean():.0f}%")
            with col4:
                days_tracked = len(df)
                st.metric("Days Tracked", days_tracked)
        else:
            st.info("Please create a user profile to access progress tracking.")

if __name__ == "__main__":
    main()
````

## Project Summary

The Nutrition Advisor with Meal Generator represents a comprehensive AI-powered nutrition platform that combines personalized dietary analysis, intelligent meal planning, and evidence-based nutritional guidance to promote sustainable healthy eating habits.

### Key Value Propositions:
- **Personalized Nutrition Calculation**: BMR/TDEE-based calorie targeting with macro distribution optimization for individual goals and activity levels
- **AI-Powered Meal Generation**: LLM-enhanced meal planning that considers dietary restrictions, preferences, and nutritional targets with practical recipe suggestions
- **Intelligent Food Database**: Vector-embedded nutrition database enabling semantic food search, ingredient substitution, and comprehensive nutritional analysis
- **Health-Aware Recommendations**: Evidence-based nutritional guidance that adapts to specific dietary goals, medical conditions, and lifestyle factors
- **Progress Tracking Integration**: Long-term adherence monitoring with visual analytics and behavioral pattern recognition

### Technical Highlights:
- Comprehensive nutrition calculation engine using scientifically-validated BMR formulas and activity multipliers
- ChromaDB vector database for semantic food search with SentenceTransformers embeddings
- LangChain-powered meal generation with structured prompting for practical, nutritionally-balanced recipes
- Real-time macro/micronutrient analysis with visual reporting using Plotly charts
- Streamlit interface providing intuitive meal planning, food logging, and progress visualization
- Modular architecture supporting easy integration of additional nutrition APIs and health monitoring devices

This system demonstrates how AI can make personalized nutrition guidance accessible and practical, helping users make informed dietary choices while maintaining flexibility and enjoyment in their eating patterns.