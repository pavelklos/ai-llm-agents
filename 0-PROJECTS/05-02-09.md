<small>Claude Sonnet 4 **(Social Media Manager Agent)**</small>
# Social Media Manager Agent

## Key Concepts Explanation

### Content Generation
Automated creation of engaging social media posts using AI language models, incorporating brand voice, trending topics, and audience preferences to produce diverse content formats including text posts, captions, hashtags, and multimedia descriptions.

### Intelligent Scheduling
Strategic timing optimization for social media posts based on audience analytics, platform algorithms, engagement patterns, and optimal posting windows to maximize reach, engagement, and conversion rates across multiple platforms.

### Sentiment Tracking
Real-time monitoring and analysis of audience reactions, comments, mentions, and brand sentiment using natural language processing to track engagement quality, identify trends, and measure campaign effectiveness.

### Multi-Platform Management
Unified management system for posting, monitoring, and analyzing content across multiple social media platforms with platform-specific optimization, formatting, and audience targeting capabilities.

### Engagement Analytics
Comprehensive tracking of likes, shares, comments, reach, impressions, and conversion metrics with intelligent insights for content performance optimization and strategy refinement.

## Comprehensive Project Explanation

### Objectives
The Social Media Manager Agent automates content creation, scheduling, and performance monitoring across social platforms, providing intelligent insights and optimization recommendations to maximize engagement and brand growth.

### Key Features
- **AI-Powered Content Creation**: Generate platform-specific posts with brand consistency
- **Smart Scheduling**: Optimal timing based on audience behavior analytics
- **Real-time Sentiment Analysis**: Monitor brand mentions and audience reactions
- **Multi-Platform Management**: Unified dashboard for all social media accounts
- **Performance Analytics**: Comprehensive metrics and optimization insights

### Challenges
- **Platform API Limitations**: Managing rate limits and changing API requirements
- **Content Quality Control**: Ensuring AI-generated content meets brand standards
- **Real-time Processing**: Handling large volumes of social data efficiently
- **Sentiment Accuracy**: Achieving reliable sentiment analysis across contexts

### Potential Impact
This system can significantly reduce social media management workload, improve content consistency, optimize engagement rates, and provide valuable insights for marketing strategy development.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
transformers==4.35.0
tweepy==4.14.0
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
textblob==0.17.1
vaderSentiment==3.3.2
schedule==1.2.0
requests==2.31.0
pillow==10.1.0
datetime
logging
typing
dataclasses
enum
json
re
````

### Core Implementation

````python
import pandas as pd
import numpy as np
import json
import re
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import schedule

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go

# NLP and sentiment analysis
from textblob import TextBlob
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from transformers import pipeline

# LLM integration
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate

# Social media APIs (mock implementations for demo)
import requests

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Platform(Enum):
    TWITTER = "twitter"
    FACEBOOK = "facebook"
    INSTAGRAM = "instagram"
    LINKEDIN = "linkedin"
    TIKTOK = "tiktok"

class ContentType(Enum):
    TEXT_POST = "text_post"
    IMAGE_POST = "image_post"
    VIDEO_POST = "video_post"
    STORY = "story"
    REEL = "reel"
    CAROUSEL = "carousel"

class PostStatus(Enum):
    DRAFT = "draft"
    SCHEDULED = "scheduled"
    PUBLISHED = "published"
    FAILED = "failed"

class SentimentScore(Enum):
    VERY_POSITIVE = "very_positive"
    POSITIVE = "positive"
    NEUTRAL = "neutral"
    NEGATIVE = "negative"
    VERY_NEGATIVE = "very_negative"

@dataclass
class SocialMediaAccount:
    platform: Platform
    username: str
    access_token: str
    follower_count: int = 0
    is_active: bool = True
    last_post_time: Optional[datetime] = None

@dataclass
class ContentPost:
    post_id: str
    platform: Platform
    content_type: ContentType
    text: str
    hashtags: List[str] = field(default_factory=list)
    media_urls: List[str] = field(default_factory=list)
    scheduled_time: Optional[datetime] = None
    published_time: Optional[datetime] = None
    status: PostStatus = PostStatus.DRAFT
    engagement_metrics: Dict[str, int] = field(default_factory=dict)

@dataclass
class EngagementMetrics:
    likes: int = 0
    shares: int = 0
    comments: int = 0
    views: int = 0
    clicks: int = 0
    saves: int = 0
    reach: int = 0
    impressions: int = 0

@dataclass
class SentimentAnalysis:
    text: str
    sentiment_score: float
    sentiment_label: SentimentScore
    confidence: float
    keywords: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)

@dataclass
class BrandVoice:
    tone: str  # professional, casual, friendly, authoritative
    style: str  # formal, informal, conversational
    personality_traits: List[str]
    forbidden_words: List[str] = field(default_factory=list)
    preferred_hashtags: List[str] = field(default_factory=list)

class ContentGenerator:
    """AI-powered content generation system."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.8,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self._initialize_prompts()
        self.trending_topics = []
    
    def _initialize_prompts(self):
        """Initialize content generation prompts."""
        self.content_prompt = ChatPromptTemplate.from_template("""
        Create a {content_type} for {platform} with the following requirements:
        
        Brand Voice:
        - Tone: {tone}
        - Style: {style}
        - Personality: {personality}
        
        Content Guidelines:
        - Topic: {topic}
        - Target Audience: {audience}
        - Content Length: {length_guide}
        - Include relevant hashtags
        
        Platform-specific requirements:
        {platform_requirements}
        
        Generate engaging content that:
        1. Matches the brand voice
        2. Is optimized for the platform
        3. Includes appropriate hashtags
        4. Encourages engagement
        
        Format the response as:
        TEXT: [main content]
        HASHTAGS: [hashtag list]
        """)
        
        self.hashtag_prompt = ChatPromptTemplate.from_template("""
        Generate 10-15 relevant hashtags for this social media post:
        
        Content: {content}
        Platform: {platform}
        Industry: {industry}
        Target Audience: {audience}
        
        Mix of:
        - Popular trending hashtags
        - Niche-specific hashtags
        - Branded hashtags
        - Community hashtags
        
        Return hashtags without the # symbol, separated by commas.
        """)
    
    def generate_content(self, platform: Platform, content_type: ContentType,
                        topic: str, brand_voice: BrandVoice,
                        target_audience: str = "general") -> Dict[str, Any]:
        """Generate content for specific platform and type."""
        try:
            # Platform-specific requirements
            platform_reqs = self._get_platform_requirements(platform, content_type)
            
            if self.llm:
                response = self.llm.invoke(
                    self.content_prompt.format(
                        content_type=content_type.value,
                        platform=platform.value,
                        tone=brand_voice.tone,
                        style=brand_voice.style,
                        personality=", ".join(brand_voice.personality_traits),
                        topic=topic,
                        audience=target_audience,
                        length_guide=platform_reqs["length_guide"],
                        platform_requirements=platform_reqs["requirements"]
                    )
                )
                
                content_data = self._parse_generated_content(response.content)
            else:
                content_data = self._generate_fallback_content(platform, topic, brand_voice)
            
            # Enhance with additional elements
            content_data["platform"] = platform
            content_data["content_type"] = content_type
            content_data["topic"] = topic
            
            return content_data
        
        except Exception as e:
            logger.error(f"Content generation error: {e}")
            return self._generate_fallback_content(platform, topic, brand_voice)
    
    def _get_platform_requirements(self, platform: Platform, content_type: ContentType) -> Dict[str, str]:
        """Get platform-specific content requirements."""
        requirements = {
            Platform.TWITTER: {
                "length_guide": "280 characters max",
                "requirements": "Concise, engaging, use trending hashtags, encourage retweets"
            },
            Platform.FACEBOOK: {
                "length_guide": "125 characters for optimal engagement",
                "requirements": "Conversational tone, ask questions, use emojis"
            },
            Platform.INSTAGRAM: {
                "length_guide": "2200 characters max, first 125 most important",
                "requirements": "Visual-focused, storytelling, use 5-10 hashtags"
            },
            Platform.LINKEDIN: {
                "length_guide": "1300 characters for optimal engagement",
                "requirements": "Professional tone, industry insights, business value"
            },
            Platform.TIKTOK: {
                "length_guide": "100 characters max",
                "requirements": "Trendy, fun, use popular sounds/effects"
            }
        }
        
        return requirements.get(platform, {
            "length_guide": "Keep it concise",
            "requirements": "Engaging and platform-appropriate"
        })
    
    def _parse_generated_content(self, response: str) -> Dict[str, Any]:
        """Parse LLM response into structured content."""
        content_data = {"text": "", "hashtags": []}
        
        lines = response.split("\n")
        current_section = None
        
        for line in lines:
            line = line.strip()
            if line.startswith("TEXT:"):
                current_section = "text"
                content_data["text"] = line.replace("TEXT:", "").strip()
            elif line.startswith("HASHTAGS:"):
                current_section = "hashtags"
                hashtag_text = line.replace("HASHTAGS:", "").strip()
                content_data["hashtags"] = [tag.strip() for tag in hashtag_text.split(",")]
            elif current_section == "text" and line:
                content_data["text"] += " " + line
            elif current_section == "hashtags" and line:
                content_data["hashtags"].extend([tag.strip() for tag in line.split(",")])
        
        # Clean hashtags
        content_data["hashtags"] = [tag.replace("#", "").strip() for tag in content_data["hashtags"] if tag.strip()]
        
        return content_data
    
    def _generate_fallback_content(self, platform: Platform, topic: str, brand_voice: BrandVoice) -> Dict[str, Any]:
        """Generate basic content without LLM."""
        templates = {
            Platform.TWITTER: f"Excited to share insights about {topic}! What are your thoughts?",
            Platform.FACEBOOK: f"Let's discuss {topic}. Share your experiences below!",
            Platform.INSTAGRAM: f"Exploring {topic} today. Swipe for more insights! ‚ú®",
            Platform.LINKEDIN: f"Key insights on {topic} for industry professionals.",
            Platform.TIKTOK: f"Quick tips on {topic}! Follow for more! üöÄ"
        }
        
        text = templates.get(platform, f"Great content about {topic}!")
        hashtags = [topic.lower().replace(" ", ""), platform.value, "content"]
        
        return {"text": text, "hashtags": hashtags}
    
    def generate_hashtags(self, content: str, platform: Platform, 
                         industry: str = "general") -> List[str]:
        """Generate relevant hashtags for content."""
        if self.llm:
            try:
                response = self.llm.invoke(
                    self.hashtag_prompt.format(
                        content=content,
                        platform=platform.value,
                        industry=industry,
                        audience="general"
                    )
                )
                
                hashtags = [tag.strip().replace("#", "") for tag in response.content.split(",")]
                return [tag for tag in hashtags if tag]
            
            except Exception as e:
                logger.error(f"Hashtag generation error: {e}")
        
        # Fallback hashtag generation
        return self._generate_basic_hashtags(content, platform)
    
    def _generate_basic_hashtags(self, content: str, platform: Platform) -> List[str]:
        """Generate basic hashtags from content."""
        words = re.findall(r'\b\w+\b', content.lower())
        
        # Filter common words
        common_words = {'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were'}
        keywords = [word for word in words if len(word) > 3 and word not in common_words]
        
        # Add platform-specific hashtags
        hashtags = keywords[:5] + [platform.value, "content", "social"]
        
        return list(set(hashtags))[:10]

class SentimentAnalyzer:
    """Advanced sentiment analysis for social media content."""
    
    def __init__(self):
        self.vader_analyzer = SentimentIntensityAnalyzer()
        
        # Try to load advanced sentiment model
        try:
            self.sentiment_pipeline = pipeline(
                "sentiment-analysis",
                model="cardiffnlp/twitter-roberta-base-sentiment-latest"
            )
            self.advanced_model_available = True
        except:
            self.sentiment_pipeline = None
            self.advanced_model_available = False
            logger.warning("Advanced sentiment model not available, using VADER only")
    
    def analyze_sentiment(self, text: str) -> SentimentAnalysis:
        """Comprehensive sentiment analysis."""
        try:
            # VADER analysis
            vader_scores = self.vader_analyzer.polarity_scores(text)
            
            # TextBlob analysis
            blob = TextBlob(text)
            textblob_polarity = blob.sentiment.polarity
            
            # Advanced model analysis if available
            if self.advanced_model_available and self.sentiment_pipeline:
                try:
                    advanced_result = self.sentiment_pipeline(text[:512])[0]  # Truncate for model limits
                    advanced_score = advanced_result['score'] if advanced_result['label'] == 'POSITIVE' else -advanced_result['score']
                except:
                    advanced_score = 0
            else:
                advanced_score = 0
            
            # Combine scores
            final_score = (vader_scores['compound'] + textblob_polarity + advanced_score) / 3
            
            # Determine sentiment label
            if final_score >= 0.6:
                sentiment_label = SentimentScore.VERY_POSITIVE
            elif final_score >= 0.2:
                sentiment_label = SentimentScore.POSITIVE
            elif final_score >= -0.2:
                sentiment_label = SentimentScore.NEUTRAL
            elif final_score >= -0.6:
                sentiment_label = SentimentScore.NEGATIVE
            else:
                sentiment_label = SentimentScore.VERY_NEGATIVE
            
            # Calculate confidence
            confidence = min(abs(final_score) + 0.1, 1.0)
            
            # Extract keywords
            keywords = self._extract_keywords(text)
            
            return SentimentAnalysis(
                text=text,
                sentiment_score=final_score,
                sentiment_label=sentiment_label,
                confidence=confidence,
                keywords=keywords
            )
        
        except Exception as e:
            logger.error(f"Sentiment analysis error: {e}")
            return SentimentAnalysis(
                text=text,
                sentiment_score=0.0,
                sentiment_label=SentimentScore.NEUTRAL,
                confidence=0.5
            )
    
    def _extract_keywords(self, text: str) -> List[str]:
        """Extract keywords from text."""
        # Simple keyword extraction
        words = re.findall(r'\b\w+\b', text.lower())
        
        # Filter common words and short words
        stop_words = {'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'}
        keywords = [word for word in words if len(word) > 3 and word not in stop_words]
        
        # Return top keywords by frequency
        from collections import Counter
        keyword_counts = Counter(keywords)
        return [word for word, _ in keyword_counts.most_common(5)]
    
    def batch_analyze(self, texts: List[str]) -> List[SentimentAnalysis]:
        """Analyze sentiment for multiple texts."""
        return [self.analyze_sentiment(text) for text in texts]

class PostScheduler:
    """Intelligent post scheduling system."""
    
    def __init__(self):
        self.scheduled_posts = {}
        self.optimal_times = {}
        self.running = False
        
    def schedule_post(self, post: ContentPost, publish_time: datetime) -> bool:
        """Schedule a post for future publishing."""
        try:
            post.scheduled_time = publish_time
            post.status = PostStatus.SCHEDULED
            
            schedule_key = f"{post.post_id}_{publish_time.isoformat()}"
            self.scheduled_posts[schedule_key] = post
            
            logger.info(f"Post {post.post_id} scheduled for {publish_time}")
            return True
        
        except Exception as e:
            logger.error(f"Scheduling error: {e}")
            return False
    
    def get_optimal_posting_times(self, platform: Platform, 
                                 audience_timezone: str = "UTC") -> List[datetime]:
        """Get optimal posting times based on platform and audience."""
        # Platform-specific optimal times (simplified)
        optimal_hours = {
            Platform.TWITTER: [9, 12, 15, 18],
            Platform.FACEBOOK: [13, 15, 19],
            Platform.INSTAGRAM: [11, 14, 17, 20],
            Platform.LINKEDIN: [8, 12, 16],
            Platform.TIKTOK: [15, 18, 21]
        }
        
        today = datetime.now().date()
        platform_hours = optimal_hours.get(platform, [12, 15, 18])
        
        optimal_times = []
        for i in range(7):  # Next 7 days
            date = today + timedelta(days=i)
            for hour in platform_hours:
                optimal_times.append(datetime.combine(date, datetime.min.time().replace(hour=hour)))
        
        return optimal_times
    
    def start_scheduler(self):
        """Start the post scheduler."""
        if not self.running:
            self.running = True
            schedule.every(1).minutes.do(self._check_scheduled_posts)
            
            def run_scheduler():
                while self.running:
                    schedule.run_pending()
                    time.sleep(60)
            
            scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
            scheduler_thread.start()
            logger.info("Post scheduler started")
    
    def stop_scheduler(self):
        """Stop the post scheduler."""
        self.running = False
        schedule.clear()
        logger.info("Post scheduler stopped")
    
    def _check_scheduled_posts(self):
        """Check and publish scheduled posts."""
        current_time = datetime.now()
        posts_to_publish = []
        
        for schedule_key, post in self.scheduled_posts.items():
            if post.scheduled_time and post.scheduled_time <= current_time:
                posts_to_publish.append((schedule_key, post))
        
        for schedule_key, post in posts_to_publish:
            success = self._publish_post(post)
            if success:
                post.status = PostStatus.PUBLISHED
                post.published_time = current_time
            else:
                post.status = PostStatus.FAILED
            
            del self.scheduled_posts[schedule_key]
    
    def _publish_post(self, post: ContentPost) -> bool:
        """Publish a post to the platform."""
        try:
            # Mock publishing logic - in reality would use platform APIs
            logger.info(f"Publishing post {post.post_id} to {post.platform.value}")
            
            # Simulate API call
            time.sleep(1)
            
            # Mock success (90% success rate)
            return np.random.random() > 0.1
        
        except Exception as e:
            logger.error(f"Publishing error for post {post.post_id}: {e}")
            return False

class EngagementTracker:
    """Track and analyze social media engagement."""
    
    def __init__(self):
        self.engagement_data = {}
        self.sentiment_analyzer = SentimentAnalyzer()
    
    def track_post_engagement(self, post_id: str, platform: Platform) -> EngagementMetrics:
        """Track engagement metrics for a specific post."""
        try:
            # Mock engagement data - in reality would fetch from platform APIs
            metrics = self._generate_mock_engagement(platform)
            
            self.engagement_data[post_id] = {
                'metrics': metrics,
                'platform': platform,
                'last_updated': datetime.now()
            }
            
            return metrics
        
        except Exception as e:
            logger.error(f"Engagement tracking error: {e}")
            return EngagementMetrics()
    
    def _generate_mock_engagement(self, platform: Platform) -> EngagementMetrics:
        """Generate realistic mock engagement data."""
        # Platform-specific engagement patterns
        base_engagement = {
            Platform.TWITTER: {'likes': 50, 'shares': 10, 'comments': 5, 'views': 1000},
            Platform.FACEBOOK: {'likes': 30, 'shares': 8, 'comments': 12, 'views': 800},
            Platform.INSTAGRAM: {'likes': 100, 'shares': 5, 'comments': 15, 'views': 1500},
            Platform.LINKEDIN: {'likes': 25, 'shares': 15, 'comments': 8, 'views': 600},
            Platform.TIKTOK: {'likes': 200, 'shares': 50, 'comments': 30, 'views': 5000}
        }
        
        base = base_engagement.get(platform, {'likes': 50, 'shares': 10, 'comments': 8, 'views': 1000})
        
        # Add randomness
        return EngagementMetrics(
            likes=max(0, int(base['likes'] * np.random.normal(1, 0.3))),
            shares=max(0, int(base['shares'] * np.random.normal(1, 0.4))),
            comments=max(0, int(base['comments'] * np.random.normal(1, 0.5))),
            views=max(0, int(base['views'] * np.random.normal(1, 0.2))),
            clicks=max(0, int(base['views'] * 0.05 * np.random.normal(1, 0.3))),
            saves=max(0, int(base['likes'] * 0.1 * np.random.normal(1, 0.4))),
            reach=max(0, int(base['views'] * 0.8 * np.random.normal(1, 0.2))),
            impressions=max(0, int(base['views'] * 1.5 * np.random.normal(1, 0.2)))
        )
    
    def analyze_engagement_trends(self, post_ids: List[str]) -> Dict[str, Any]:
        """Analyze engagement trends across multiple posts."""
        if not post_ids:
            return {}
        
        # Collect engagement data
        all_metrics = []
        platforms = []
        
        for post_id in post_ids:
            if post_id in self.engagement_data:
                data = self.engagement_data[post_id]
                all_metrics.append(data['metrics'])
                platforms.append(data['platform'])
        
        if not all_metrics:
            return {}
        
        # Calculate trends
        total_engagement = sum(
            metric.likes + metric.shares + metric.comments
            for metric in all_metrics
        )
        
        avg_engagement_rate = np.mean([
            (metric.likes + metric.shares + metric.comments) / max(metric.views, 1)
            for metric in all_metrics
        ])
        
        best_performing_platform = max(set(platforms), key=platforms.count) if platforms else None
        
        return {
            'total_posts': len(all_metrics),
            'total_engagement': total_engagement,
            'average_engagement_rate': avg_engagement_rate,
            'best_platform': best_performing_platform.value if best_performing_platform else None,
            'metrics_summary': {
                'avg_likes': np.mean([m.likes for m in all_metrics]),
                'avg_shares': np.mean([m.shares for m in all_metrics]),
                'avg_comments': np.mean([m.comments for m in all_metrics]),
                'avg_views': np.mean([m.views for m in all_metrics])
            }
        }

class SocialMediaManager:
    """Main social media management system."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.content_generator = ContentGenerator(openai_api_key)
        self.sentiment_analyzer = SentimentAnalyzer()
        self.post_scheduler = PostScheduler()
        self.engagement_tracker = EngagementTracker()
        
        self.accounts = {}
        self.posts = {}
        self.brand_voice = None
        
    def add_social_account(self, account: SocialMediaAccount):
        """Add a social media account."""
        account_key = f"{account.platform.value}_{account.username}"
        self.accounts[account_key] = account
        logger.info(f"Added {account.platform.value} account: {account.username}")
    
    def set_brand_voice(self, brand_voice: BrandVoice):
        """Set the brand voice for content generation."""
        self.brand_voice = brand_voice
        logger.info(f"Brand voice set: {brand_voice.tone}, {brand_voice.style}")
    
    def create_content(self, platform: Platform, content_type: ContentType,
                      topic: str, target_audience: str = "general") -> ContentPost:
        """Create new content for a platform."""
        if not self.brand_voice:
            raise ValueError("Brand voice must be set before creating content")
        
        # Generate content
        content_data = self.content_generator.generate_content(
            platform, content_type, topic, self.brand_voice, target_audience
        )
        
        # Create post object
        post = ContentPost(
            post_id=f"post_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{platform.value}",
            platform=platform,
            content_type=content_type,
            text=content_data["text"],
            hashtags=content_data["hashtags"]
        )
        
        self.posts[post.post_id] = post
        return post
    
    def schedule_content(self, post_id: str, publish_time: datetime) -> bool:
        """Schedule content for publishing."""
        if post_id not in self.posts:
            return False
        
        post = self.posts[post_id]
        return self.post_scheduler.schedule_post(post, publish_time)
    
    def analyze_content_sentiment(self, text: str) -> SentimentAnalysis:
        """Analyze sentiment of content or comments."""
        return self.sentiment_analyzer.analyze_sentiment(text)
    
    def get_engagement_analytics(self, post_ids: List[str] = None) -> Dict[str, Any]:
        """Get comprehensive engagement analytics."""
        if post_ids is None:
            post_ids = list(self.posts.keys())
        
        # Update engagement data for posts
        for post_id in post_ids:
            if post_id in self.posts:
                post = self.posts[post_id]
                if post.status == PostStatus.PUBLISHED:
                    metrics = self.engagement_tracker.track_post_engagement(
                        post_id, post.platform
                    )
                    post.engagement_metrics = {
                        'likes': metrics.likes,
                        'shares': metrics.shares,
                        'comments': metrics.comments,
                        'views': metrics.views
                    }
        
        # Analyze trends
        trends = self.engagement_tracker.analyze_engagement_trends(post_ids)
        
        return trends
    
    def get_optimal_posting_schedule(self, platform: Platform, 
                                   num_posts: int = 7) -> List[datetime]:
        """Get optimal posting schedule for a platform."""
        return self.post_scheduler.get_optimal_posting_times(platform)[:num_posts]
    
    def start_automation(self):
        """Start automated posting and monitoring."""
        self.post_scheduler.start_scheduler()
        logger.info("Social media automation started")
    
    def stop_automation(self):
        """Stop automated posting and monitoring."""
        self.post_scheduler.stop_scheduler()
        logger.info("Social media automation stopped")

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Social Media Manager Agent",
        page_icon="üì±",
        layout="wide"
    )
    
    st.title("üì± AI Social Media Manager")
    st.markdown("Intelligent content creation, scheduling, and analytics")
    
    # Initialize session state
    if 'manager' not in st.session_state:
        st.session_state['manager'] = None
    if 'generated_content' not in st.session_state:
        st.session_state['generated_content'] = []
    
    # Sidebar for configuration
    with st.sidebar:
        st.header("üîß Configuration")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Manager") or st.session_state['manager'] is None:
            st.session_state['manager'] = SocialMediaManager(openai_key)
            st.success("Social Media Manager ready!")
        
        st.header("üéØ Brand Voice")
        
        tone = st.selectbox("Brand Tone", ["Professional", "Casual", "Friendly", "Authoritative"])
        style = st.selectbox("Brand Style", ["Formal", "Informal", "Conversational"])
        
        personality_traits = st.multiselect("Personality Traits", [
            "Innovative", "Trustworthy", "Fun", "Expert", "Helpful", "Creative"
        ])
        
        if st.button("Set Brand Voice"):
            brand_voice = BrandVoice(
                tone=tone.lower(),
                style=style.lower(),
                personality_traits=personality_traits
            )
            st.session_state['manager'].set_brand_voice(brand_voice)
            st.success("Brand voice configured!")
    
    if not st.session_state['manager']:
        st.info("üëà Please initialize the Social Media Manager")
        return
    
    manager = st.session_state['manager']
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["‚úçÔ∏è Content Creation", "üìÖ Scheduling", "üìä Analytics", "üòä Sentiment", "‚öôÔ∏è Accounts"])
    
    with tab1:
        st.header("‚úçÔ∏è Content Creation")
        
        col1, col2 = st.columns(2)
        
        with col1:
            platform = st.selectbox("Platform", [
                "Twitter", "Facebook", "Instagram", "LinkedIn", "TikTok"
            ])
            
            content_type = st.selectbox("Content Type", [
                "Text Post", "Image Post", "Video Post", "Story", "Reel"
            ])
            
            topic = st.text_input("Topic/Theme", placeholder="e.g., AI technology trends")
            
            target_audience = st.text_input("Target Audience", value="general")
        
        with col2:
            if st.button("Generate Content") and topic:
                with st.spinner("Creating content..."):
                    try:
                        # Map selections to enums
                        platform_enum = Platform[platform.upper()]
                        content_type_enum = ContentType[content_type.upper().replace(" ", "_")]
                        
                        post = manager.create_content(
                            platform_enum, content_type_enum, topic, target_audience
                        )
                        
                        st.session_state['generated_content'].append(post)
                        st.success("Content generated!")
                    
                    except Exception as e:
                        st.error(f"Error generating content: {e}")
        
        # Display generated content
        if st.session_state['generated_content']:
            st.subheader("üìù Generated Content")
            
            for i, post in enumerate(st.session_state['generated_content'][-5:]):  # Show last 5
                with st.expander(f"{post.platform.value.title()} - {post.post_id}"):
                    st.write(f"**Platform:** {post.platform.value}")
                    st.write(f"**Type:** {post.content_type.value}")
                    st.write(f"**Content:** {post.text}")
                    st.write(f"**Hashtags:** {', '.join(['#' + tag for tag in post.hashtags])}")
                    st.write(f"**Status:** {post.status.value}")
                    
                    # Action buttons
                    col_a, col_b, col_c = st.columns(3)
                    
                    with col_a:
                        if st.button(f"Edit {i}", key=f"edit_{i}"):
                            st.info("Edit functionality would open editor")
                    
                    with col_b:
                        if st.button(f"Schedule {i}", key=f"schedule_{i}"):
                            st.info("Scheduling options would appear")
                    
                    with col_c:
                        if st.button(f"Analyze {i}", key=f"analyze_{i}"):
                            sentiment = manager.analyze_content_sentiment(post.text)
                            st.write(f"Sentiment: {sentiment.sentiment_label.value}")
                            st.write(f"Score: {sentiment.sentiment_score:.2f}")
    
    with tab2:
        st.header("üìÖ Content Scheduling")
        
        if st.session_state['generated_content']:
            st.subheader("üìã Schedule Posts")
            
            # Post selection
            post_options = [f"{p.post_id} ({p.platform.value})" for p in st.session_state['generated_content']]
            selected_post = st.selectbox("Select Post to Schedule", post_options)
            
            if selected_post:
                # Extract post ID
                post_id = selected_post.split(" (")[0]
                
                # Schedule options
                col1, col2 = st.columns(2)
                
                with col1:
                    schedule_date = st.date_input("Schedule Date")
                    schedule_time = st.time_input("Schedule Time")
                
                with col2:
                    if st.button("Schedule Post"):
                        schedule_datetime = datetime.combine(schedule_date, schedule_time)
                        
                        if manager.schedule_content(post_id, schedule_datetime):
                            st.success(f"Post scheduled for {schedule_datetime}")
                        else:
                            st.error("Failed to schedule post")
            
            # Optimal timing suggestions
            st.subheader("‚è∞ Optimal Posting Times")
            
            platform_for_timing = st.selectbox("Platform for Timing Analysis", [
                "Twitter", "Facebook", "Instagram", "LinkedIn", "TikTok"
            ], key="timing_platform")
            
            if st.button("Get Optimal Times"):
                platform_enum = Platform[platform_for_timing.upper()]
                optimal_times = manager.get_optimal_posting_schedule(platform_enum)
                
                st.write("**Recommended posting times for next 7 days:**")
                for time in optimal_times[:10]:  # Show first 10
                    st.write(f"‚Ä¢ {time.strftime('%Y-%m-%d %H:%M')}")
        else:
            st.info("Create some content first to schedule posts")
    
    with tab3:
        st.header("üìä Engagement Analytics")
        
        if st.session_state['generated_content']:
            # Mock some published posts for demo
            published_posts = [p for p in st.session_state['generated_content'] if np.random.random() > 0.7]
            for post in published_posts:
                post.status = PostStatus.PUBLISHED
                post.published_time = datetime.now() - timedelta(hours=np.random.randint(1, 48))
            
            if published_posts:
                # Get analytics
                post_ids = [p.post_id for p in published_posts]
                analytics = manager.get_engagement_analytics(post_ids)
                
                if analytics:
                    # Display metrics
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("Total Posts", analytics.get('total_posts', 0))
                    with col2:
                        st.metric("Total Engagement", analytics.get('total_engagement', 0))
                    with col3:
                        st.metric("Avg Engagement Rate", f"{analytics.get('average_engagement_rate', 0):.2%}")
                    with col4:
                        st.metric("Best Platform", analytics.get('best_platform', 'N/A'))
                    
                    # Engagement breakdown
                    if 'metrics_summary' in analytics:
                        st.subheader("üìà Engagement Breakdown")
                        
                        metrics_data = analytics['metrics_summary']
                        
                        # Create engagement chart
                        categories = ['Likes', 'Shares', 'Comments', 'Views']
                        values = [
                            metrics_data.get('avg_likes', 0),
                            metrics_data.get('avg_shares', 0),
                            metrics_data.get('avg_comments', 0),
                            metrics_data.get('avg_views', 0)
                        ]
                        
                        fig = px.bar(x=categories, y=values, title="Average Engagement by Type")
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # Platform performance
                    st.subheader("üèÜ Platform Performance")
                    
                    platform_data = {}
                    for post in published_posts:
                        platform = post.platform.value
                        if platform not in platform_data:
                            platform_data[platform] = []
                        
                        # Mock engagement for visualization
                        engagement = sum(post.engagement_metrics.values()) if post.engagement_metrics else np.random.randint(50, 500)
                        platform_data[platform].append(engagement)
                    
                    # Calculate averages
                    platform_averages = {
                        platform: np.mean(engagements)
                        for platform, engagements in platform_data.items()
                    }
                    
                    fig_platform = px.bar(
                        x=list(platform_averages.keys()),
                        y=list(platform_averages.values()),
                        title="Average Engagement by Platform"
                    )
                    st.plotly_chart(fig_platform, use_container_width=True)
            else:
                st.info("No published posts to analyze yet")
        else:
            st.info("Create and publish content to see analytics")
    
    with tab4:
        st.header("üòä Sentiment Analysis")
        
        st.subheader("üìù Analyze Text Sentiment")
        
        text_to_analyze = st.text_area("Enter text to analyze", 
                                     placeholder="Enter social media content, comments, or mentions...")
        
        if st.button("Analyze Sentiment") and text_to_analyze:
            with st.spinner("Analyzing sentiment..."):
                sentiment = manager.analyze_content_sentiment(text_to_analyze)
                
                # Display results
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("Sentiment Score", f"{sentiment.sentiment_score:.2f}")
                
                with col2:
                    st.metric("Sentiment Label", sentiment.sentiment_label.value.replace('_', ' ').title())
                
                with col3:
                    st.metric("Confidence", f"{sentiment.confidence:.1%}")
                
                # Keywords
                if sentiment.keywords:
                    st.write("**Key Topics:**")
                    st.write(", ".join(sentiment.keywords))
                
                # Sentiment visualization
                sentiment_colors = {
                    SentimentScore.VERY_POSITIVE: "green",
                    SentimentScore.POSITIVE: "lightgreen", 
                    SentimentScore.NEUTRAL: "yellow",
                    SentimentScore.NEGATIVE: "orange",
                    SentimentScore.VERY_NEGATIVE: "red"
                }
                
                fig = go.Figure(go.Indicator(
                    mode = "gauge+number",
                    value = sentiment.sentiment_score,
                    domain = {'x': [0, 1], 'y': [0, 1]},
                    title = {'text': "Sentiment Score"},
                    gauge = {
                        'axis': {'range': [-1, 1]},
                        'bar': {'color': sentiment_colors.get(sentiment.sentiment_label, "blue")},
                        'steps': [
                            {'range': [-1, -0.6], 'color': "red"},
                            {'range': [-0.6, -0.2], 'color': "orange"},
                            {'range': [-0.2, 0.2], 'color': "yellow"},
                            {'range': [0.2, 0.6], 'color': "lightgreen"},
                            {'range': [0.6, 1], 'color': "green"}
                        ]
                    }
                ))
                
                st.plotly_chart(fig, use_container_width=True)
        
        # Batch sentiment analysis
        st.subheader("üìä Batch Sentiment Analysis")
        
        if st.session_state['generated_content']:
            if st.button("Analyze All Content Sentiment"):
                with st.spinner("Analyzing sentiment for all content..."):
                    sentiment_results = []
                    
                    for post in st.session_state['generated_content']:
                        sentiment = manager.analyze_content_sentiment(post.text)
                        sentiment_results.append({
                            'Post ID': post.post_id,
                            'Platform': post.platform.value,
                            'Sentiment': sentiment.sentiment_label.value,
                            'Score': sentiment.sentiment_score,
                            'Confidence': sentiment.confidence
                        })
                    
                    # Display results table
                    sentiment_df = pd.DataFrame(sentiment_results)
                    st.dataframe(sentiment_df, use_container_width=True)
                    
                    # Sentiment distribution
                    sentiment_counts = sentiment_df['Sentiment'].value_counts()
                    
                    fig_dist = px.pie(
                        values=sentiment_counts.values,
                        names=sentiment_counts.index,
                        title="Sentiment Distribution"
                    )
                    st.plotly_chart(fig_dist, use_container_width=True)
        else:
            st.info("Create some content first to analyze sentiment")
    
    with tab5:
        st.header("‚öôÔ∏è Social Media Accounts")
        
        st.subheader("‚ûï Add Social Media Account")
        
        col1, col2 = st.columns(2)
        
        with col1:
            account_platform = st.selectbox("Platform", [
                "Twitter", "Facebook", "Instagram", "LinkedIn", "TikTok"
            ], key="account_platform")
            
            username = st.text_input("Username/Handle")
            
        with col2:
            access_token = st.text_input("Access Token", type="password")
            follower_count = st.number_input("Follower Count", min_value=0, value=1000)
        
        if st.button("Add Account") and username and access_token:
            platform_enum = Platform[account_platform.upper()]
            
            account = SocialMediaAccount(
                platform=platform_enum,
                username=username,
                access_token=access_token,
                follower_count=follower_count
            )
            
            manager.add_social_account(account)
            st.success(f"Added {account_platform} account: @{username}")
        
        # Display connected accounts
        st.subheader("üîó Connected Accounts")
        
        if manager.accounts:
            accounts_data = []
            for account_key, account in manager.accounts.items():
                accounts_data.append({
                    'Platform': account.platform.value.title(),
                    'Username': account.username,
                    'Followers': f"{account.follower_count:,}",
                    'Status': "Active" if account.is_active else "Inactive",
                    'Last Post': account.last_post_time.strftime('%Y-%m-%d') if account.last_post_time else "Never"
                })
            
            accounts_df = pd.DataFrame(accounts_data)
            st.dataframe(accounts_df, use_container_width=True)
        else:
            st.info("No accounts connected yet")
        
        # Automation controls
        st.subheader("ü§ñ Automation Controls")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("Start Automation"):
                manager.start_automation()
                st.success("Automation started!")
        
        with col2:
            if st.button("Stop Automation"):
                manager.stop_automation()
                st.info("Automation stopped")

if __name__ == "__main__":
    main()
````

## Project Summary

The Social Media Manager Agent provides comprehensive automation for social media management, combining AI-powered content generation, intelligent scheduling, and real-time sentiment analysis to optimize social media presence and engagement across multiple platforms.

### Key Value Propositions:
- **AI Content Generation**: LLM-powered creation of platform-specific content with brand voice consistency
- **Smart Scheduling**: Optimal timing algorithms based on audience behavior and platform analytics  
- **Sentiment Monitoring**: Real-time analysis of content and audience reactions for brand reputation management
- **Multi-Platform Integration**: Unified management across Twitter, Facebook, Instagram, LinkedIn, and TikTok

### Technical Architecture:
The system leverages LangChain for content generation, advanced NLP models for sentiment analysis, intelligent scheduling algorithms, and mock social media APIs, creating a scalable platform for comprehensive social media management with automated posting, engagement tracking, and performance optimization capabilities.