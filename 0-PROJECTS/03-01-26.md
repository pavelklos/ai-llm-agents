<small>Claude Sonnet 4 **(Genealogy and Family History Research with RAG)**</small>
# Genealogy and Family History Research

## Key Concepts Explanation

### Retrieval-Augmented Generation (RAG)
A technique that combines information retrieval with generative AI to provide accurate genealogical insights by first retrieving relevant historical records, census data, and family information from databases, then using an LLM to generate comprehensive family histories and research guidance.

### Historical Records
Primary source documents including birth certificates, marriage records, death certificates, immigration documents, military service records, and other official documents that provide verifiable information about individuals and families throughout history.

### Census Data
Government population surveys conducted periodically that record household compositions, occupations, birthplaces, and demographic information, serving as crucial snapshots of families at specific points in time.

### DNA Analysis
Genetic testing results that reveal ancestral origins, ethnicity estimates, and potential family connections through shared DNA segments, providing scientific evidence to support or challenge traditional genealogical research.

### Family Trees
Visual representations of family relationships across generations, showing lineage connections, marriages, and descendants in a hierarchical structure that helps understand family history and inheritance patterns.

### Geographic Migration
The study of how families and individuals moved across regions and countries over time, including immigration patterns, settlement histories, and the historical contexts that drove population movements.

### Cultural Heritage
The traditions, customs, languages, and cultural practices passed down through family lines, including understanding of ancestral homelands, religious practices, and cultural identities that shaped family experiences.

## Comprehensive Project Explanation

The Genealogy and Family History Research platform is an AI-powered system that revolutionizes how people discover and understand their family heritage. By leveraging RAG technology, this platform combines vast historical databases with intelligent analysis to help users build comprehensive family trees, uncover ancestral stories, and understand their cultural heritage.

### Objectives
- **Comprehensive Research**: Integrate multiple data sources including historical records, census data, and DNA results to build complete family narratives
- **Intelligent Discovery**: Use AI to identify potential family connections, suggest research directions, and resolve genealogical mysteries
- **Cultural Context**: Provide rich historical and cultural background for ancestors' lives, including migration patterns and social conditions
- **Research Guidance**: Offer personalized research strategies and highlight gaps in family history that need investigation
- **Heritage Preservation**: Help families preserve their stories, traditions, and cultural knowledge for future generations

### Challenges
- **Data Quality and Accuracy**: Managing inconsistent historical records, name variations, and potential errors in genealogical databases
- **Privacy and Sensitivity**: Handling personal family information and DNA data with appropriate security and privacy protections
- **Record Accessibility**: Navigating varying availability of historical records across different countries, time periods, and jurisdictions
- **Name Standardization**: Dealing with spelling variations, name changes, and translation issues across different languages and cultures
- **Conflicting Information**: Resolving discrepancies between different sources and determining the most reliable information

### Potential Impact
- **Family Connection**: Helping millions of people discover their roots and connect with living relatives they never knew existed
- **Historical Preservation**: Contributing to the digital preservation of genealogical records and family stories for future generations
- **Cultural Understanding**: Fostering appreciation for diverse cultural backgrounds and immigration experiences
- **Medical Insights**: Providing family medical history information that can inform healthcare decisions
- **Educational Value**: Teaching history through personal family narratives and making historical events more relatable

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
langchain==0.1.0
openai==1.3.0
chromadb==0.4.18
pandas==2.1.4
numpy==1.24.3
requests==2.31.0
python-dotenv==1.0.0
pydantic==2.5.0
fastapi==0.104.1
uvicorn==0.24.0
networkx==3.2.1
matplotlib==3.8.2
plotly==5.17.0
seaborn==0.13.0
streamlit==1.28.1
sqlalchemy==2.0.23
geopy==2.4.0
folium==0.15.0
beautifulsoup4==4.12.2
aiohttp==3.9.1
fuzzywuzzy==0.18.0
python-levenshtein==0.20.9
datetime==5.3
dateutil==2.8.2
````

### Core Implementation

````python
# main.py
import os
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple, Set
from dataclasses import dataclass, asdict
from pydantic import BaseModel
import asyncio
import logging
from pathlib import Path
import networkx as nx
from fuzzywuzzy import fuzz
import re

from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import Document
import chromadb
import openai
from dotenv import load_dotenv

from geopy.geocoders import Nominatim
from geopy.distance import geodesic

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class Person:
    person_id: str
    first_name: str
    last_name: str
    birth_date: Optional[str]
    death_date: Optional[str]
    birth_place: Optional[str]
    death_place: Optional[str]
    gender: str
    occupation: Optional[str]
    father_id: Optional[str]
    mother_id: Optional[str]
    spouse_ids: List[str]
    children_ids: List[str]
    sources: List[str]
    confidence_score: float

@dataclass
class HistoricalRecord:
    record_id: str
    record_type: str  # birth, death, marriage, census, immigration, military
    person_id: str
    date: str
    location: str
    details: Dict[str, str]
    source: str
    reliability_score: float
    transcription: str
    original_language: Optional[str]

@dataclass
class CensusRecord:
    census_id: str
    year: int
    location: str
    household_head: str
    household_members: List[Dict[str, str]]
    occupations: List[str]
    birthplaces: List[str]
    ages: List[int]
    relationships: List[str]
    source_page: str

@dataclass
class DNAMatch:
    match_id: str
    person1_id: str
    person2_id: str
    shared_cm: float
    estimated_relationship: str
    confidence_level: str
    shared_segments: int
    largest_segment: float
    predicted_generation: int

@dataclass
class MigrationEvent:
    event_id: str
    person_id: str
    from_location: str
    to_location: str
    date: str
    reason: str
    transportation_method: str
    source_document: str
    historical_context: str

@dataclass
class CulturalHeritage:
    heritage_id: str
    family_line: str
    ethnicity: str
    country_of_origin: str
    traditions: List[str]
    languages: List[str]
    religions: List[str]
    cultural_practices: Dict[str, str]
    historical_background: str

class GenealogyDataCollector:
    """Collects and processes genealogical data from various sources"""
    
    def __init__(self):
        self.sample_people = self._generate_sample_people()
        self.sample_records = self._generate_sample_records()
        self.sample_census = self._generate_sample_census()
        self.sample_dna_matches = self._generate_sample_dna()
        self.sample_migrations = self._generate_sample_migrations()
        self.sample_heritage = self._generate_sample_heritage()
        self.geocoder = Nominatim(user_agent="genealogy_research")
    
    def _generate_sample_people(self) -> List[Person]:
        """Generate sample family members across multiple generations"""
        people = [
            Person(
                person_id="p001",
                first_name="William",
                last_name="Johnson",
                birth_date="1890-03-15",
                death_date="1965-08-22",
                birth_place="County Cork, Ireland",
                death_place="Boston, Massachusetts, USA",
                gender="Male",
                occupation="Railroad worker",
                father_id="p004",
                mother_id="p005",
                spouse_ids=["p002"],
                children_ids=["p003", "p006"],
                sources=["Birth Certificate", "Census 1920", "Death Certificate"],
                confidence_score=0.95
            ),
            Person(
                person_id="p002",
                first_name="Mary",
                last_name="O'Sullivan",
                birth_date="1895-07-08",
                death_date="1972-12-10",
                birth_place="County Kerry, Ireland",
                death_place="Boston, Massachusetts, USA",
                gender="Female",
                occupation="Seamstress",
                father_id="p007",
                mother_id="p008",
                spouse_ids=["p001"],
                children_ids=["p003", "p006"],
                sources=["Marriage Certificate", "Census 1920", "Death Certificate"],
                confidence_score=0.92
            ),
            Person(
                person_id="p003",
                first_name="James",
                last_name="Johnson",
                birth_date="1920-11-30",
                death_date="1995-05-14",
                birth_place="Boston, Massachusetts, USA",
                death_place="Boston, Massachusetts, USA",
                gender="Male",
                occupation="Police Officer",
                father_id="p001",
                mother_id="p002",
                spouse_ids=["p009"],
                children_ids=["p010", "p011"],
                sources=["Birth Certificate", "Military Records", "Census 1940"],
                confidence_score=0.98
            ),
            Person(
                person_id="p004",
                first_name="Patrick",
                last_name="Johnson",
                birth_date="1860-02-20",
                death_date="1920-01-15",
                birth_place="County Cork, Ireland",
                death_place="County Cork, Ireland",
                gender="Male",
                occupation="Farmer",
                father_id=None,
                mother_id=None,
                spouse_ids=["p005"],
                children_ids=["p001"],
                sources=["Parish Records", "Census 1901"],
                confidence_score=0.85
            ),
            Person(
                person_id="p005",
                first_name="Bridget",
                last_name="Murphy",
                birth_date="1865-09-12",
                death_date="1925-03-08",
                birth_place="County Cork, Ireland",
                death_place="County Cork, Ireland",
                gender="Female",
                occupation="Housewife",
                father_id=None,
                mother_id=None,
                spouse_ids=["p004"],
                children_ids=["p001"],
                sources=["Parish Records", "Census 1901"],
                confidence_score=0.83
            )
        ]
        return people
    
    def _generate_sample_records(self) -> List[HistoricalRecord]:
        """Generate sample historical records"""
        records = [
            HistoricalRecord(
                record_id="rec001",
                record_type="birth",
                person_id="p001",
                date="1890-03-15",
                location="County Cork, Ireland",
                details={
                    "father_name": "Patrick Johnson",
                    "mother_name": "Bridget Murphy",
                    "witnesses": "John Murphy, Ellen Johnson"
                },
                source="St. Finbarr's Parish Register",
                reliability_score=0.9,
                transcription="William Johnson, son of Patrick Johnson and Bridget Murphy, born March 15, 1890",
                original_language="English"
            ),
            HistoricalRecord(
                record_id="rec002",
                record_type="immigration",
                person_id="p001",
                date="1912-04-20",
                location="Ellis Island, New York",
                details={
                    "ship_name": "RMS Celtic",
                    "manifest_line": "15",
                    "destination": "Boston, Massachusetts",
                    "sponsor": "Michael O'Sullivan"
                },
                source="Ellis Island Immigration Records",
                reliability_score=0.95,
                transcription="William Johnson, age 22, Irish, destined for Boston",
                original_language="English"
            ),
            HistoricalRecord(
                record_id="rec003",
                record_type="marriage",
                person_id="p001",
                date="1915-06-12",
                location="Boston, Massachusetts",
                details={
                    "spouse_name": "Mary O'Sullivan",
                    "witness1": "John Johnson",
                    "witness2": "Catherine O'Sullivan",
                    "officiant": "Rev. Timothy Murphy"
                },
                source="St. Patrick's Church Marriage Register",
                reliability_score=0.92,
                transcription="William Johnson married Mary O'Sullivan on June 12, 1915",
                original_language="English"
            )
        ]
        return records
    
    def _generate_sample_census(self) -> List[CensusRecord]:
        """Generate sample census records"""
        census_records = [
            CensusRecord(
                census_id="cen001",
                year=1920,
                location="Boston, Massachusetts",
                household_head="William Johnson",
                household_members=[
                    {"name": "William Johnson", "age": "30", "relation": "Head", "occupation": "Railroad worker"},
                    {"name": "Mary Johnson", "age": "25", "relation": "Wife", "occupation": "Seamstress"},
                    {"name": "James Johnson", "age": "0", "relation": "Son", "occupation": "None"}
                ],
                occupations=["Railroad worker", "Seamstress"],
                birthplaces=["Ireland", "Ireland", "Massachusetts"],
                ages=[30, 25, 0],
                relationships=["Head", "Wife", "Son"],
                source_page="ED 123, Sheet 15, Line 42"
            ),
            CensusRecord(
                census_id="cen002",
                year=1940,
                location="Boston, Massachusetts",
                household_head="James Johnson",
                household_members=[
                    {"name": "James Johnson", "age": "19", "relation": "Head", "occupation": "Student"},
                    {"name": "William Johnson", "age": "50", "relation": "Father", "occupation": "Railroad worker"},
                    {"name": "Mary Johnson", "age": "45", "relation": "Mother", "occupation": "Housewife"}
                ],
                occupations=["Student", "Railroad worker", "Housewife"],
                birthplaces=["Massachusetts", "Ireland", "Ireland"],
                ages=[19, 50, 45],
                relationships=["Head", "Father", "Mother"],
                source_page="ED 456, Sheet 8, Line 23"
            )
        ]
        return census_records
    
    def _generate_sample_dna(self) -> List[DNAMatch]:
        """Generate sample DNA match data"""
        dna_matches = [
            DNAMatch(
                match_id="dna001",
                person1_id="p003",
                person2_id="p012",
                shared_cm=1750.5,
                estimated_relationship="1st cousin",
                confidence_level="very high",
                shared_segments=35,
                largest_segment=85.2,
                predicted_generation=2
            ),
            DNAMatch(
                match_id="dna002",
                person1_id="p003",
                person2_id="p013",
                shared_cm=890.3,
                estimated_relationship="2nd cousin",
                confidence_level="high",
                shared_segments=28,
                largest_segment=45.7,
                predicted_generation=3
            )
        ]
        return dna_matches
    
    def _generate_sample_migrations(self) -> List[MigrationEvent]:
        """Generate sample migration events"""
        migrations = [
            MigrationEvent(
                event_id="mig001",
                person_id="p001",
                from_location="County Cork, Ireland",
                to_location="Boston, Massachusetts, USA",
                date="1912-04-20",
                reason="Economic opportunity",
                transportation_method="Ship - RMS Celtic",
                source_document="Ellis Island Immigration Record",
                historical_context="Part of the Great Irish Migration due to economic hardship and limited opportunities in rural Ireland"
            ),
            MigrationEvent(
                event_id="mig002",
                person_id="p002",
                from_location="County Kerry, Ireland",
                to_location="Boston, Massachusetts, USA",
                date="1914-08-15",
                reason="Marriage and family reunification",
                transportation_method="Ship - SS Cymric",
                source_document="Ship Manifest",
                historical_context="Irish women often emigrated to join spouses or fiancés who had established themselves in America"
            )
        ]
        return migrations
    
    def _generate_sample_heritage(self) -> List[CulturalHeritage]:
        """Generate sample cultural heritage information"""
        heritage = [
            CulturalHeritage(
                heritage_id="her001",
                family_line="Johnson/O'Sullivan",
                ethnicity="Irish",
                country_of_origin="Ireland",
                traditions=["St. Patrick's Day celebration", "Irish step dancing", "Traditional music sessions"],
                languages=["Irish Gaelic", "English"],
                religions=["Roman Catholic"],
                cultural_practices={
                    "music": "Traditional Irish folk music and instruments",
                    "food": "Irish stew, soda bread, shepherd's pie",
                    "customs": "Wake traditions, storytelling, community gatherings"
                },
                historical_background="Descendants of rural Irish farmers who emigrated during the late 19th and early 20th centuries due to economic hardship and the search for better opportunities in America."
            )
        ]
        return heritage

    async def search_historical_records(self, person_name: str, location: str = None, date_range: Tuple[str, str] = None) -> List[HistoricalRecord]:
        """Search for historical records matching criteria"""
        logger.info(f"Searching historical records for {person_name}")
        
        matching_records = []
        search_name = person_name.lower()
        
        for record in self.sample_records:
            # Find person by name (simplified matching)
            person = next((p for p in self.sample_people if p.person_id == record.person_id), None)
            if person:
                full_name = f"{person.first_name} {person.last_name}".lower()
                if fuzz.ratio(search_name, full_name) > 80:
                    matching_records.append(record)
        
        return matching_records
    
    def calculate_relationship(self, person1_id: str, person2_id: str) -> str:
        """Calculate the relationship between two people"""
        # Build family tree graph
        G = nx.DiGraph()
        
        for person in self.sample_people:
            G.add_node(person.person_id, **asdict(person))
            
            if person.father_id:
                G.add_edge(person.father_id, person.person_id, relationship="parent")
            if person.mother_id:
                G.add_edge(person.mother_id, person.person_id, relationship="parent")
        
        try:
            path = nx.shortest_path(G.to_undirected(), person1_id, person2_id)
            generations = len(path) - 1
            
            if generations == 1:
                return "parent/child"
            elif generations == 2:
                return "grandparent/grandchild or sibling"
            elif generations == 3:
                return "great-grandparent/great-grandchild or aunt/uncle/niece/nephew"
            elif generations == 4:
                return "1st cousin or great-great-grandparent/great-great-grandchild"
            else:
                return f"distant relative ({generations} degrees of separation)"
        except nx.NetworkXNoPath:
            return "no direct relationship found"

class GenealogyRAG:
    """RAG system for genealogy research and family history"""
    
    def __init__(self):
        # Initialize OpenAI
        openai.api_key = os.getenv("OPENAI_API_KEY")
        
        # Initialize components
        self.embeddings = OpenAIEmbeddings()
        self.llm = ChatOpenAI(model="gpt-4", temperature=0.3)
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        
        # Initialize vector store
        self.client = chromadb.PersistentClient(path="./genealogy_db")
        self.vectorstore = Chroma(
            client=self.client,
            collection_name="genealogy_knowledge",
            embedding_function=self.embeddings
        )
        
        self.data_collector = GenealogyDataCollector()
    
    async def initialize_knowledge_base(self):
        """Initialize the knowledge base with genealogical data"""
        logger.info("Initializing genealogy knowledge base...")
        
        documents = []
        
        # Add person records
        for person in self.data_collector.sample_people:
            doc_content = f"""
            Person: {person.first_name} {person.last_name}
            Birth Date: {person.birth_date or 'Unknown'}
            Death Date: {person.death_date or 'Living/Unknown'}
            Birth Place: {person.birth_place or 'Unknown'}
            Death Place: {person.death_place or 'Unknown'}
            Gender: {person.gender}
            Occupation: {person.occupation or 'Unknown'}
            Sources: {'; '.join(person.sources)}
            Confidence Score: {person.confidence_score}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "person",
                    "person_id": person.person_id,
                    "name": f"{person.first_name} {person.last_name}",
                    "birth_year": person.birth_date[:4] if person.birth_date else None,
                    "birth_place": person.birth_place,
                    "occupation": person.occupation
                }
            ))
        
        # Add historical records
        for record in self.data_collector.sample_records:
            doc_content = f"""
            Record Type: {record.record_type}
            Date: {record.date}
            Location: {record.location}
            Source: {record.source}
            Details: {json.dumps(record.details)}
            Transcription: {record.transcription}
            Reliability Score: {record.reliability_score}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "historical_record",
                    "record_id": record.record_id,
                    "record_type": record.record_type,
                    "person_id": record.person_id,
                    "date": record.date,
                    "location": record.location
                }
            ))
        
        # Add census records
        for census in self.data_collector.sample_census:
            household_info = []
            for member in census.household_members:
                household_info.append(f"{member['name']} (age {member['age']}, {member['relation']})")
            
            doc_content = f"""
            Census Year: {census.year}
            Location: {census.location}
            Household Head: {census.household_head}
            Household Members: {'; '.join(household_info)}
            Occupations: {'; '.join(census.occupations)}
            Birthplaces: {'; '.join(census.birthplaces)}
            Source Page: {census.source_page}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "census_record",
                    "census_id": census.census_id,
                    "year": census.year,
                    "location": census.location,
                    "household_head": census.household_head
                }
            ))
        
        # Add migration events
        for migration in self.data_collector.sample_migrations:
            doc_content = f"""
            Migration Event
            Person: {migration.person_id}
            From: {migration.from_location}
            To: {migration.to_location}
            Date: {migration.date}
            Reason: {migration.reason}
            Transportation: {migration.transportation_method}
            Source: {migration.source_document}
            Historical Context: {migration.historical_context}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "migration",
                    "event_id": migration.event_id,
                    "person_id": migration.person_id,
                    "from_location": migration.from_location,
                    "to_location": migration.to_location,
                    "date": migration.date
                }
            ))
        
        # Add cultural heritage
        for heritage in self.data_collector.sample_heritage:
            doc_content = f"""
            Cultural Heritage: {heritage.family_line}
            Ethnicity: {heritage.ethnicity}
            Country of Origin: {heritage.country_of_origin}
            Traditions: {'; '.join(heritage.traditions)}
            Languages: {'; '.join(heritage.languages)}
            Religions: {'; '.join(heritage.religions)}
            Cultural Practices: {json.dumps(heritage.cultural_practices)}
            Historical Background: {heritage.historical_background}
            """
            documents.append(Document(
                page_content=doc_content,
                metadata={
                    "type": "cultural_heritage",
                    "heritage_id": heritage.heritage_id,
                    "family_line": heritage.family_line,
                    "ethnicity": heritage.ethnicity,
                    "country_of_origin": heritage.country_of_origin
                }
            ))
        
        # Add documents to vector store
        if documents:
            self.vectorstore.add_documents(documents)
        
        logger.info(f"Added {len(documents)} documents to knowledge base")
    
    def retrieve_relevant_information(self, query: str, k: int = 8) -> List[Document]:
        """Retrieve relevant genealogical information"""
        return self.vectorstore.similarity_search(query, k=k)
    
    async def research_person(self, person_name: str, additional_info: str = "") -> Dict[str, any]:
        """Research a specific person and provide comprehensive information"""
        
        # Find matching person
        target_person = None
        for person in self.data_collector.sample_people:
            full_name = f"{person.first_name} {person.last_name}"
            if fuzz.ratio(person_name.lower(), full_name.lower()) > 80:
                target_person = person
                break
        
        if not target_person:
            return {"error": "Person not found in database"}
        
        # Retrieve relevant information
        query = f"{person_name} {additional_info} biography family history records"
        relevant_docs = self.retrieve_relevant_information(query, k=10)
        
        # Get related records
        related_records = [r for r in self.data_collector.sample_records if r.person_id == target_person.person_id]
        
        # Get family members
        family_members = []
        if target_person.father_id:
            father = next((p for p in self.data_collector.sample_people if p.person_id == target_person.father_id), None)
            if father:
                family_members.append(f"Father: {father.first_name} {father.last_name}")
        
        if target_person.mother_id:
            mother = next((p for p in self.data_collector.sample_people if p.person_id == target_person.mother_id), None)
            if mother:
                family_members.append(f"Mother: {mother.first_name} {mother.last_name}")
        
        # Create context
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        prompt = ChatPromptTemplate.from_template("""
        Create a comprehensive biographical report for this person based on available genealogical information:
        
        Person: {person_name}
        Birth Date: {birth_date}
        Death Date: {death_date}
        Birth Place: {birth_place}
        Death Place: {death_place}
        Occupation: {occupation}
        
        Family Members: {family_members}
        
        Available Records and Context:
        {context}
        
        Create a detailed biography including:
        1. Personal information and vital statistics
        2. Family relationships and connections
        3. Life events and milestones
        4. Migration and residence history
        5. Occupation and social status
        6. Historical context of their time period
        7. Cultural background and heritage
        8. Research gaps and suggested next steps
        
        Format as an engaging narrative suitable for family history documentation.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "person_name": f"{target_person.first_name} {target_person.last_name}",
            "birth_date": target_person.birth_date or "Unknown",
            "death_date": target_person.death_date or "Living/Unknown",
            "birth_place": target_person.birth_place or "Unknown",
            "death_place": target_person.death_place or "Unknown",
            "occupation": target_person.occupation or "Unknown",
            "family_members": "; ".join(family_members) if family_members else "No family information available",
            "context": context
        })
        
        return {
            "person_info": asdict(target_person),
            "biography": response.content,
            "related_records": [asdict(r) for r in related_records],
            "confidence_score": target_person.confidence_score,
            "research_date": datetime.now().isoformat()
        }
    
    async def trace_migration_patterns(self, family_line: str) -> Dict[str, any]:
        """Trace migration patterns for a family line"""
        
        # Get migration events for the family
        family_migrations = []
        for migration in self.data_collector.sample_migrations:
            person = next((p for p in self.data_collector.sample_people if p.person_id == migration.person_id), None)
            if person and family_line.lower() in f"{person.first_name} {person.last_name}".lower():
                family_migrations.append(migration)
        
        if not family_migrations:
            return {"error": "No migration patterns found for this family line"}
        
        # Retrieve contextual information
        query = f"migration {family_line} immigration patterns historical context"
        relevant_docs = self.retrieve_relevant_information(query, k=8)
        
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Create migration summary
        migration_summary = []
        for migration in family_migrations:
            person = next((p for p in self.data_collector.sample_people if p.person_id == migration.person_id), None)
            migration_summary.append(f"{person.first_name} {person.last_name}: {migration.from_location} → {migration.to_location} ({migration.date})")
        
        prompt = ChatPromptTemplate.from_template("""
        Analyze the migration patterns for this family line and provide comprehensive insights:
        
        Family Line: {family_line}
        
        Migration Events:
        {migration_events}
        
        Historical Context:
        {context}
        
        Provide analysis including:
        1. Timeline of family migrations
        2. Geographic patterns and routes taken
        3. Historical reasons for migration
        4. Social and economic factors driving movement
        5. Cultural impact of migration on the family
        6. Settlement patterns and community formation
        7. Connections to broader migration trends
        8. Impact on subsequent generations
        
        Create an engaging narrative that places family migration in historical context.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "family_line": family_line,
            "migration_events": "\n".join(migration_summary),
            "context": context
        })
        
        return {
            "family_line": family_line,
            "migration_analysis": response.content,
            "migration_events": [asdict(m) for m in family_migrations],
            "analysis_date": datetime.now().isoformat()
        }
    
    async def analyze_cultural_heritage(self, ethnicity: str) -> Dict[str, any]:
        """Analyze cultural heritage and traditions"""
        
        # Find heritage information
        heritage_info = None
        for heritage in self.data_collector.sample_heritage:
            if ethnicity.lower() in heritage.ethnicity.lower():
                heritage_info = heritage
                break
        
        if not heritage_info:
            return {"error": "Cultural heritage information not found"}
        
        # Retrieve relevant cultural context
        query = f"cultural heritage {ethnicity} traditions customs history"
        relevant_docs = self.retrieve_relevant_information(query, k=6)
        
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        prompt = ChatPromptTemplate.from_template("""
        Provide a comprehensive analysis of this cultural heritage:
        
        Ethnicity: {ethnicity}
        Country of Origin: {country_of_origin}
        Traditions: {traditions}
        Languages: {languages}
        Religions: {religions}
        
        Additional Context:
        {context}
        
        Create detailed cultural analysis including:
        1. Historical background of the culture
        2. Traditional customs and practices
        3. Language and communication patterns
        4. Religious and spiritual beliefs
        5. Cultural values and worldview
        6. Impact of immigration on cultural preservation
        7. Modern cultural adaptations
        8. Ways to connect with and preserve heritage
        
        Make it informative and respectful, suitable for family heritage education.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "ethnicity": heritage_info.ethnicity,
            "country_of_origin": heritage_info.country_of_origin,
            "traditions": "; ".join(heritage_info.traditions),
            "languages": "; ".join(heritage_info.languages),
            "religions": "; ".join(heritage_info.religions),
            "context": context
        })
        
        return {
            "heritage_info": asdict(heritage_info),
            "cultural_analysis": response.content,
            "generated_at": datetime.now().isoformat()
        }
    
    async def suggest_research_directions(self, person_name: str) -> Dict[str, any]:
        """Suggest research directions and potential sources"""
        
        # Find person and analyze existing information
        target_person = None
        for person in self.data_collector.sample_people:
            full_name = f"{person.first_name} {person.last_name}"
            if fuzz.ratio(person_name.lower(), full_name.lower()) > 80:
                target_person = person
                break
        
        if not target_person:
            return {"error": "Person not found for research suggestions"}
        
        # Analyze data gaps
        data_gaps = []
        if not target_person.birth_date:
            data_gaps.append("birth date")
        if not target_person.birth_place:
            data_gaps.append("birth place")
        if not target_person.father_id:
            data_gaps.append("father information")
        if not target_person.mother_id:
            data_gaps.append("mother information")
        if not target_person.occupation:
            data_gaps.append("occupation details")
        
        # Get existing records
        existing_records = [r.record_type for r in self.data_collector.sample_records if r.person_id == target_person.person_id]
        
        prompt = ChatPromptTemplate.from_template("""
        Based on the current genealogical information, suggest research directions and strategies:
        
        Person: {person_name}
        Current Information:
        - Birth Date: {birth_date}
        - Birth Place: {birth_place}
        - Death Date: {death_date}
        - Occupation: {occupation}
        - Existing Records: {existing_records}
        
        Data Gaps: {data_gaps}
        Confidence Score: {confidence_score}
        
        Provide research suggestions including:
        1. Priority research targets based on gaps
        2. Recommended record types to search
        3. Suggested archives and databases
        4. DNA testing recommendations
        5. Geographic areas to investigate
        6. Time periods to focus on
        7. Potential family connections to explore
        8. Alternative name spellings to consider
        
        Format as actionable research plan with specific steps.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "person_name": f"{target_person.first_name} {target_person.last_name}",
            "birth_date": target_person.birth_date or "Unknown",
            "birth_place": target_person.birth_place or "Unknown",
            "death_date": target_person.death_date or "Unknown",
            "occupation": target_person.occupation or "Unknown",
            "existing_records": ", ".join(existing_records) if existing_records else "None",
            "data_gaps": ", ".join(data_gaps) if data_gaps else "None identified",
            "confidence_score": target_person.confidence_score
        })
        
        return {
            "person": f"{target_person.first_name} {target_person.last_name}",
            "research_suggestions": response.content,
            "data_gaps": data_gaps,
            "confidence_score": target_person.confidence_score,
            "generated_at": datetime.now().isoformat()
        }
    
    async def analyze_dna_matches(self, person_id: str) -> Dict[str, any]:
        """Analyze DNA matches and suggest family connections"""
        
        # Get DNA matches for the person
        person_matches = [m for m in self.data_collector.sample_dna_matches if m.person1_id == person_id or m.person2_id == person_id]
        
        if not person_matches:
            return {"error": "No DNA matches found for this person"}
        
        # Retrieve relevant genetic genealogy context
        query = f"DNA matches genetic genealogy shared segments relationship estimation"
        relevant_docs = self.retrieve_relevant_information(query, k=5)
        
        context = "\n".join([doc.page_content for doc in relevant_docs])
        
        # Create match summary
        match_summary = []
        for match in person_matches:
            match_summary.append(f"Match {match.match_id}: {match.shared_cm}cM shared, estimated {match.estimated_relationship}")
        
        prompt = ChatPromptTemplate.from_template("""
        Analyze DNA matches and provide genealogical insights:
        
        Person ID: {person_id}
        
        DNA Matches:
        {match_summary}
        
        Genetic Context:
        {context}
        
        Provide analysis including:
        1. Relationship estimations and confidence levels
        2. Shared DNA segment analysis
        3. Most likely family connections
        4. Suggestions for confirming relationships
        5. Research strategies using DNA evidence
        6. Potential family tree connections
        7. Geographic patterns in matches
        8. Next steps for DNA genealogy research
        
        Format as practical guidance for genealogy research.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "person_id": person_id,
            "match_summary": "\n".join(match_summary),
            "context": context
        })
        
        return {
            "person_id": person_id,
            "dna_analysis": response.content,
            "matches": [asdict(m) for m in person_matches],
            "analysis_date": datetime.now().isoformat()
        }

class GenealogyResearchAssistant:
    """Main assistant orchestrating genealogy research and family history"""
    
    def __init__(self):
        self.rag_system = GenealogyRAG()
        self.initialized = False
    
    async def initialize(self):
        """Initialize the research assistant"""
        if not self.initialized:
            await self.rag_system.initialize_knowledge_base()
            self.initialized = True
            logger.info("Genealogy Research Assistant initialized successfully")
    
    async def research_family_member(self, name: str, additional_info: str = "") -> Dict[str, any]:
        """Comprehensive research on a family member"""
        
        if not self.initialized:
            await self.initialize()
        
        # Get person research
        person_research = await self.rag_system.research_person(name, additional_info)
        
        if "error" in person_research:
            return person_research
        
        # Get research suggestions
        research_suggestions = await self.rag_system.suggest_research_directions(name)
        
        return {
            "person_research": person_research,
            "research_suggestions": research_suggestions,
            "timestamp": datetime.now().isoformat()
        }
    
    async def trace_family_migrations(self, family_surname: str) -> Dict[str, any]:
        """Trace migration patterns for a family"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.trace_migration_patterns(family_surname)
    
    async def explore_cultural_background(self, ethnicity: str) -> Dict[str, any]:
        """Explore cultural heritage and background"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.analyze_cultural_heritage(ethnicity)
    
    async def analyze_genetic_connections(self, person_id: str) -> Dict[str, any]:
        """Analyze DNA matches and genetic connections"""
        
        if not self.initialized:
            await self.initialize()
        
        return await self.rag_system.analyze_dna_matches(person_id)
    
    async def create_family_timeline(self, family_members: List[str]) -> Dict[str, any]:
        """Create a chronological timeline of family events"""
        
        if not self.initialized:
            await self.initialize()
        
        # Collect events for family members
        family_events = []
        
        for member_name in family_members:
            # Find person
            for person in self.rag_system.data_collector.sample_people:
                full_name = f"{person.first_name} {person.last_name}"
                if fuzz.ratio(member_name.lower(), full_name.lower()) > 80:
                    if person.birth_date:
                        family_events.append({
                            "date": person.birth_date,
                            "event": f"Birth of {full_name}",
                            "location": person.birth_place or "Unknown",
                            "person": full_name
                        })
                    if person.death_date:
                        family_events.append({
                            "date": person.death_date,
                            "event": f"Death of {full_name}",
                            "location": person.death_place or "Unknown",
                            "person": full_name
                        })
        
        # Add migration events
        for migration in self.rag_system.data_collector.sample_migrations:
            person = next((p for p in self.rag_system.data_collector.sample_people if p.person_id == migration.person_id), None)
            if person:
                full_name = f"{person.first_name} {person.last_name}"
                if any(fuzz.ratio(member.lower(), full_name.lower()) > 80 for member in family_members):
                    family_events.append({
                        "date": migration.date,
                        "event": f"Migration: {migration.from_location} to {migration.to_location}",
                        "location": migration.to_location,
                        "person": full_name
                    })
        
        # Sort events chronologically
        family_events.sort(key=lambda x: x["date"])
        
        # Generate narrative timeline
        prompt = ChatPromptTemplate.from_template("""
        Create a comprehensive family timeline narrative based on these chronological events:
        
        Family Members: {family_members}
        
        Timeline Events:
        {events}
        
        Create an engaging timeline that:
        1. Places events in historical context
        2. Explains connections between family events
        3. Highlights significant patterns or trends
        4. Discusses the historical periods involved
        5. Notes geographic movements and their significance
        6. Identifies key family milestones
        7. Suggests areas for further research
        
        Format as a narrative timeline suitable for family history documentation.
        """)
        
        events_text = "\n".join([f"{event['date']}: {event['event']} ({event['location']})" for event in family_events])
        
        chain = prompt | self.rag_system.llm
        response = await chain.ainvoke({
            "family_members": ", ".join(family_members),
            "events": events_text
        })
        
        return {
            "family_members": family_members,
            "timeline_narrative": response.content,
            "chronological_events": family_events,
            "total_events": len(family_events),
            "date_range": f"{family_events[0]['date']} to {family_events[-1]['date']}" if family_events else "No events found",
            "created_at": datetime.now().isoformat()
        }

# Example usage and testing
async def main():
    """Main function demonstrating the Genealogy Research Assistant"""
    
    print("🌳 Initializing Genealogy and Family History Research Assistant...")
    assistant = GenealogyResearchAssistant()
    
    try:
        # Initialize the system
        await assistant.initialize()
        print("✅ Genealogy Research Assistant initialized successfully")
        
        # Research family member
        print("\n👤 Researching family member...")
        person_research = await assistant.research_family_member(
            name="William Johnson",
            additional_info="Irish immigrant to Boston"
        )
        
        print("✅ Person Research Complete:")
        if "person_research" in person_research:
            print(f"Person: {person_research['person_research']['person_info']['first_name']} {person_research['person_research']['person_info']['last_name']}")
            print(f"Birth: {person_research['person_research']['person_info']['birth_date']} in {person_research['person_research']['person_info']['birth_place']}")
            print(f"Biography preview: {person_research['person_research']['biography'][:200]}...")
        
        # Trace migration patterns
        print("\n🗺️ Tracing migration patterns...")
        migration_analysis = await assistant.trace_family_migrations("Johnson")
        
        print("✅ Migration Analysis Complete:")
        if "migration_analysis" in migration_analysis:
            print(f"Family line: {migration_analysis['family_line']}")
            print(f"Migration events: {len(migration_analysis['migration_events'])}")
            print(f"Analysis preview: {migration_analysis['migration_analysis'][:200]}...")
        
        # Explore cultural heritage
        print("\n🎭 Exploring cultural heritage...")
        cultural_analysis = await assistant.explore_cultural_background("Irish")
        
        print("✅ Cultural Analysis Complete:")
        if "heritage_info" in cultural_analysis:
            print(f"Ethnicity: {cultural_analysis['heritage_info']['ethnicity']}")
            print(f"Country of origin: {cultural_analysis['heritage_info']['country_of_origin']}")
            print(f"Cultural analysis preview: {cultural_analysis['cultural_analysis'][:200]}...")
        
        # Analyze DNA matches
        print("\n🧬 Analyzing DNA matches...")
        dna_analysis = await assistant.analyze_genetic_connections("p003")
        
        print("✅ DNA Analysis Complete:")
        if "dna_analysis" in dna_analysis:
            print(f"Person ID: {dna_analysis['person_id']}")
            print(f"Matches found: {len(dna_analysis['matches'])}")
            print(f"DNA analysis preview: {dna_analysis['dna_analysis'][:200]}...")
        
        # Create family timeline
        print("\n📅 Creating family timeline...")
        timeline = await assistant.create_family_timeline(
            family_members=["William Johnson", "Mary O'Sullivan", "James Johnson"]
        )
        
        print("✅ Family Timeline Created:")
        print(f"Family members: {len(timeline['family_members'])}")
        print(f"Total events: {timeline['total_events']}")
        print(f"Date range: {timeline['date_range']}")
        print(f"Timeline preview: {timeline['timeline_narrative'][:200]}...")
        
        print("\n🌳 Genealogy and Family History Research demonstration completed successfully!")
        
    except Exception as e:
        logger.error(f"Error in main execution: {str(e)}")
        print(f"❌ Error: {str(e)}")

if __name__ == "__main__":
    # Set up environment variables
    os.environ.setdefault("OPENAI_API_KEY", "your-openai-api-key-here")
    
    # Run the main function
    asyncio.run(main())
````

### Family Tree Visualization Module

````python
# family_tree_viz.py
import networkx as nx
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List
import pandas as pd

class FamilyTreeVisualizer:
    """Visualize family trees and genealogical data"""
    
    def __init__(self, genealogy_data):
        self.data = genealogy_data
        self.family_graph = self._build_family_graph()
    
    def _build_family_graph(self) -> nx.DiGraph:
        """Build a directed graph representing family relationships"""
        G = nx.DiGraph()
        
        for person in self.data.sample_people:
            # Add person as node
            G.add_node(person.person_id, 
                      name=f"{person.first_name} {person.last_name}",
                      birth_year=person.birth_date[:4] if person.birth_date else None,
                      death_year=person.death_date[:4] if person.death_date else None,
                      gender=person.gender,
                      birth_place=person.birth_place)
            
            # Add parent relationships
            if person.father_id:
                G.add_edge(person.father_id, person.person_id, relationship="father")
            if person.mother_id:
                G.add_edge(person.mother_id, person.person_id, relationship="mother")
        
        return G
    
    def create_interactive_family_tree(self) -> go.Figure:
        """Create an interactive family tree visualization"""
        
        # Use hierarchical layout
        pos = nx.spring_layout(self.family_graph, k=3, iterations=50)
        
        # Extract node information
        node_x = []
        node_y = []
        node_text = []
        node_info = []
        
        for node in self.family_graph.nodes():
            x, y = pos[node]
            node_x.append(x)
            node_y.append(y)
            
            node_data = self.family_graph.nodes[node]
            name = node_data.get('name', 'Unknown')
            birth_year = node_data.get('birth_year', 'Unknown')
            death_year = node_data.get('death_year', 'Living')
            birth_place = node_data.get('birth_place', 'Unknown')
            
            node_text.append(name)
            node_info.append(f"{name}<br>Born: {birth_year}<br>Died: {death_year}<br>Place: {birth_place}")
        
        # Extract edge information
        edge_x = []
        edge_y = []
        
        for edge in self.family_graph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])
        
        # Create traces
        edge_trace = go.Scatter(x=edge_x, y=edge_y,
                              line=dict(width=2, color='#888'),
                              hoverinfo='none',
                              mode='lines')
        
        node_trace = go.Scatter(x=node_x, y=node_y,
                              mode='markers+text',
                              hoverinfo='text',
                              text=node_text,
                              hovertext=node_info,
                              textposition="middle center",
                              marker=dict(size=30,
                                        color='lightblue',
                                        line=dict(width=2, color='black')))
        
        # Create figure
        fig = go.Figure(data=[edge_trace, node_trace],
                       layout=go.Layout(
                        title='Interactive Family Tree',
                        titlefont_size=16,
                        showlegend=False,
                        hovermode='closest',
                        margin=dict(b=20,l=5,r=5,t=40),
                        annotations=[ dict(
                            text="Click and drag to explore the family tree",
                            showarrow=False,
                            xref="paper", yref="paper",
                            x=0.005, y=-0.002,
                            xanchor="left", yanchor="bottom",
                            font=dict(color="#888", size=12)
                        )],
                        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
                        ))
        
        return fig
    
    def create_migration_map(self) -> go.Figure:
        """Create a map showing family migration patterns"""
        
        # Sample coordinates for demonstration
        location_coords = {
            "County Cork, Ireland": (51.8985, -8.4756),
            "County Kerry, Ireland": (52.1368, -9.5184),
            "Boston, Massachusetts, USA": (42.3601, -71.0589)
        }
        
        # Extract migration data
        migration_data = []
        for migration in self.data.sample_migrations:
            person = next((p for p in self.data.sample_people if p.person_id == migration.person_id), None)
            if person:
                from_coords = location_coords.get(migration.from_location)
                to_coords = location_coords.get(migration.to_location)
                
                if from_coords and to_coords:
                    migration_data.append({
                        'person': f"{person.first_name} {person.last_name}",
                        'from_lat': from_coords[0],
                        'from_lon': from_coords[1],
                        'to_lat': to_coords[0],
                        'to_lon': to_coords[1],
                        'from_location': migration.from_location,
                        'to_location': migration.to_location,
                        'date': migration.date,
                        'reason': migration.reason
                    })
        
        fig = go.Figure()
        
        # Add migration paths
        for migration in migration_data:
            fig.add_trace(go.Scattergeo(
                lon=[migration['from_lon'], migration['to_lon']],
                lat=[migration['from_lat'], migration['to_lat']],
                mode='lines+markers',
                line=dict(width=2, color='red'),
                marker=dict(size=8, color='blue'),
                text=[migration['from_location'], migration['to_location']],
                hovertemplate=f"<b>{migration['person']}</b><br>" +
                             f"From: {migration['from_location']}<br>" +
                             f"To: {migration['to_location']}<br>" +
                             f"Date: {migration['date']}<br>" +
                             f"Reason: {migration['reason']}<extra></extra>",
                name=migration['person']
            ))
        
        fig.update_geos(
            projection_type="natural earth",
            showland=True,
            landcolor='lightgray',
            showocean=True,
            oceancolor='lightblue'
        )
        
        fig.update_layout(
            title="Family Migration Patterns",
            geo=dict(
                showframe=False,
                showcoastlines=True,
                projection_type='equirectangular'
            )
        )
        
        return fig
    
    def create_timeline_chart(self) -> go.Figure:
        """Create a timeline chart of family events"""
        
        # Collect timeline events
        events = []
        
        for person in self.data.sample_people:
            if person.birth_date:
                events.append({
                    'date': person.birth_date,
                    'event': f"Birth of {person.first_name} {person.last_name}",
                    'person': f"{person.first_name} {person.last_name}",
                    'type': 'birth',
                    'location': person.birth_place or 'Unknown'
                })
            
            if person.death_date:
                events.append({
                    'date': person.death_date,
                    'event': f"Death of {person.first_name} {person.last_name}",
                    'person': f"{person.first_name} {person.last_name}",
                    'type': 'death',
                    'location': person.death_place or 'Unknown'
                })
        
        # Add migration events
        for migration in self.data.sample_migrations:
            person = next((p for p in self.data.sample_people if p.person_id == migration.person_id), None)
            if person:
                events.append({
                    'date': migration.date,
                    'event': f"Migration: {migration.from_location} to {migration.to_location}",
                    'person': f"{person.first_name} {person.last_name}",
                    'type': 'migration',
                    'location': migration.to_location
                })
        
        # Sort events by date
        events.sort(key=lambda x: x['date'])
        
        # Create DataFrame
        df = pd.DataFrame(events)
        df['date'] = pd.to_datetime(df['date'])
        
        # Create timeline chart
        fig = px.timeline(df, x_start='date', x_end='date', y='person', 
                         color='type', text='event',
                         title="Family Timeline")
        
        fig.update_traces(textposition='middle center')
        fig.update_layout(
            xaxis_title="Date",
            yaxis_title="Family Member",
            height=600
        )
        
        return fig
````

## Project Summary

The **Genealogy and Family History Research** platform represents a transformative approach to family heritage discovery, combining RAG technology with comprehensive genealogical databases to create intelligent, personalized research experiences. This system revolutionizes how people connect with their ancestry by providing AI-powered insights that make complex genealogical research accessible to everyone.

### Key Value Propositions

**Intelligent Research Guidance**: Leverages AI to analyze existing family information, identify research gaps, and suggest specific strategies for uncovering ancestral records, dramatically accelerating the genealogy research process.

**Comprehensive Heritage Understanding**: Goes beyond basic family trees to provide rich cultural context, migration patterns, and historical background that helps users understand their ancestors' lives and experiences within broader historical narratives.

**DNA-Enhanced Discovery**: Integrates genetic genealogy data with traditional records to identify potential family connections, resolve genealogical mysteries, and provide scientific validation for family relationships.

**Cultural Preservation**: Helps families preserve their unique stories, traditions, and cultural heritage for future generations through intelligent documentation and narrative generation.

### Technical Excellence

The implementation showcases advanced AI engineering with **LangChain** for RAG orchestration, **ChromaDB** for genealogical knowledge storage, **NetworkX** for family relationship modeling, and **Plotly** for interactive visualizations. The system architecture supports multi-source data integration, fuzzy name matching, and scalable family tree management.

### Impact and Applications

This platform serves genealogists, family historians, cultural organizations, and millions of individuals seeking to understand their heritage. Applications include family reunion planning, cultural education, medical family history compilation, and academic genealogical research.

The project demonstrates how AI can democratize access to genealogical research, making professional-level family history investigation available to anyone while preserving and connecting diverse cultural narratives across generations. Through intelligent automation and comprehensive analysis, this system contributes to the vital work of family heritage preservation and cultural understanding.