<small>Claude Sonnet 4 **(Medical Diagnosis Assistant)**</small>
# Medical Diagnosis Assistant

## Key Concepts Explanation

### Symptom Checker
AI-powered symptom analysis system that collects, categorizes, and evaluates patient-reported symptoms through structured questionnaires and natural language processing to identify potential medical conditions while considering symptom severity, duration, and co-occurrence patterns.

### LLM Reasoning
Large Language Model-based clinical reasoning engine that applies medical knowledge and diagnostic protocols to analyze symptom combinations, consider differential diagnoses, and provide evidence-based reasoning chains while maintaining medical accuracy and appropriate uncertainty quantification.

### Medical RAG (Retrieval-Augmented Generation)
Advanced knowledge retrieval system combining medical literature, clinical guidelines, drug databases, and diagnostic criteria with large language models to provide contextually relevant medical information while ensuring accuracy through authoritative medical source integration.

### Clinical Decision Support
Intelligent assistance for healthcare decision-making that processes patient data, symptoms, and medical history to suggest diagnostic pathways, recommend tests, and highlight critical conditions requiring immediate attention while maintaining medical ethics and safety protocols.

### Medical Knowledge Base
Comprehensive repository of medical information including disease databases, symptom-condition mappings, drug interactions, clinical guidelines, and evidence-based medical literature structured for efficient retrieval and clinical application.

## Comprehensive Project Explanation

### Objectives
The Medical Diagnosis Assistant aims to provide intelligent clinical decision support by analyzing symptoms, reasoning through medical knowledge, and offering evidence-based diagnostic suggestions while maintaining strict medical safety standards and emphasizing the importance of professional medical consultation.

### Key Features
- **Intelligent Symptom Analysis**: Natural language processing of patient symptoms with structured data collection
- **Evidence-Based Reasoning**: LLM-powered diagnostic reasoning with medical literature integration
- **Comprehensive Medical Database**: RAG-enabled access to medical knowledge and clinical guidelines
- **Risk Stratification**: Automated identification of emergency conditions and severity assessment
- **Drug Interaction Checking**: Medication safety analysis and contraindication detection
- **Professional Referral System**: Appropriate healthcare provider recommendations based on findings

### Challenges
- **Medical Accuracy**: Ensuring diagnostic suggestions are medically sound and evidence-based
- **Safety and Liability**: Avoiding misdiagnosis while providing helpful guidance
- **Regulatory Compliance**: Adhering to medical device regulations and privacy standards
- **Knowledge Currency**: Maintaining up-to-date medical information and guidelines
- **Bias Mitigation**: Preventing diagnostic bias and ensuring equitable healthcare suggestions

### Potential Impact
This system can improve healthcare accessibility, provide preliminary diagnostic guidance, enhance medical education, support healthcare providers in resource-limited settings, and enable early identification of serious medical conditions requiring immediate attention.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
openai==1.6.1
langchain==0.1.0
langchain-openai==0.0.5
chromadb==0.4.18
sentence-transformers==2.2.2
pandas==2.1.4
numpy==1.24.3
scikit-learn==1.3.2
plotly==5.17.0
requests==2.31.0
beautifulsoup4==4.12.2
python-dateutil==2.8.2
fuzzywuzzy==0.18.0
python-levenshtein==0.21.1
nltk==3.8.1
spacy==3.7.2
networkx==3.2.1
datetime
logging
json
uuid
re
typing
dataclasses
enum
warnings
````

### Core Implementation

````python
import os
import json
import uuid
import logging
import re
import warnings
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import networkx as nx

# NLP libraries
import nltk
import spacy
from fuzzywuzzy import fuzz, process

# Vector storage and embeddings
import chromadb
from sentence_transformers import SentenceTransformer

# LangChain components
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma

# Web scraping
import requests
from bs4 import BeautifulSoup

# Suppress warnings
warnings.filterwarnings('ignore')

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SeverityLevel(Enum):
    LOW = "low"
    MODERATE = "moderate"
    HIGH = "high"
    EMERGENCY = "emergency"

class SymptomCategory(Enum):
    GENERAL = "general"
    NEUROLOGICAL = "neurological"
    CARDIOVASCULAR = "cardiovascular"
    RESPIRATORY = "respiratory"
    GASTROINTESTINAL = "gastrointestinal"
    MUSCULOSKELETAL = "musculoskeletal"
    DERMATOLOGICAL = "dermatological"
    PSYCHIATRIC = "psychiatric"

class UrgencyLevel(Enum):
    ROUTINE = "routine"
    URGENT = "urgent"
    EMERGENCY = "emergency"
    IMMEDIATE = "immediate"

@dataclass
class Symptom:
    name: str
    description: str
    category: SymptomCategory
    severity: SeverityLevel
    duration_days: Optional[int] = None
    frequency: Optional[str] = None
    triggers: List[str] = field(default_factory=list)
    associated_symptoms: List[str] = field(default_factory=list)

@dataclass
class MedicalCondition:
    name: str
    description: str
    icd_code: Optional[str] = None
    symptoms: List[str] = field(default_factory=list)
    risk_factors: List[str] = field(default_factory=list)
    prevalence: float = 0.0
    urgency: UrgencyLevel = UrgencyLevel.ROUTINE
    specialist_required: Optional[str] = None
    diagnostic_tests: List[str] = field(default_factory=list)

@dataclass
class Medication:
    name: str
    generic_name: str
    drug_class: str
    indications: List[str] = field(default_factory=list)
    contraindications: List[str] = field(default_factory=list)
    side_effects: List[str] = field(default_factory=list)
    interactions: List[str] = field(default_factory=list)

@dataclass
class DiagnosticSuggestion:
    condition: MedicalCondition
    confidence_score: float
    reasoning: str
    supporting_symptoms: List[str]
    missing_symptoms: List[str]
    recommended_tests: List[str]
    urgency_level: UrgencyLevel
    specialist_referral: Optional[str] = None

@dataclass
class PatientProfile:
    age: int
    gender: str
    medical_history: List[str] = field(default_factory=list)
    current_medications: List[str] = field(default_factory=list)
    allergies: List[str] = field(default_factory=list)
    family_history: List[str] = field(default_factory=list)
    lifestyle_factors: Dict[str, Any] = field(default_factory=dict)

class MedicalKnowledgeBase:
    """Comprehensive medical knowledge repository."""
    
    def __init__(self, embedding_model: str = "all-MiniLM-L6-v2"):
        self.embedding_model = SentenceTransformer(embedding_model)
        
        # Initialize ChromaDB for medical knowledge
        self.chroma_client = chromadb.Client()
        try:
            self.symptoms_collection = self.chroma_client.get_collection("medical_symptoms")
            self.conditions_collection = self.chroma_client.get_collection("medical_conditions")
            self.medications_collection = self.chroma_client.get_collection("medications")
        except:
            self.symptoms_collection = self.chroma_client.create_collection("medical_symptoms")
            self.conditions_collection = self.chroma_client.create_collection("medical_conditions")
            self.medications_collection = self.chroma_client.create_collection("medications")
        
        # Load medical data
        self._initialize_medical_data()
        
        # Text splitter for documents
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=500,
            chunk_overlap=50
        )
    
    def _initialize_medical_data(self):
        """Initialize comprehensive medical database."""
        
        # Sample symptoms database
        symptoms_data = [
            {
                "name": "Headache",
                "description": "Pain in the head or upper neck region",
                "category": "neurological",
                "common_causes": ["tension", "migraine", "cluster headache", "sinusitis"],
                "red_flags": ["sudden severe onset", "fever", "neck stiffness", "vision changes"]
            },
            {
                "name": "Chest Pain",
                "description": "Discomfort or pain in the chest area",
                "category": "cardiovascular",
                "common_causes": ["heart attack", "angina", "pneumonia", "acid reflux"],
                "red_flags": ["crushing pain", "shortness of breath", "radiation to arm", "sweating"]
            },
            {
                "name": "Fever",
                "description": "Elevated body temperature above normal",
                "category": "general",
                "common_causes": ["infection", "inflammation", "heat exhaustion", "medication reaction"],
                "red_flags": ["high fever", "persistent fever", "rash", "difficulty breathing"]
            },
            {
                "name": "Shortness of Breath",
                "description": "Difficulty breathing or feeling breathless",
                "category": "respiratory",
                "common_causes": ["asthma", "pneumonia", "heart failure", "pulmonary embolism"],
                "red_flags": ["sudden onset", "chest pain", "leg swelling", "blue lips"]
            },
            {
                "name": "Abdominal Pain",
                "description": "Pain in the stomach or belly area",
                "category": "gastrointestinal",
                "common_causes": ["gastritis", "appendicitis", "gallstones", "bowel obstruction"],
                "red_flags": ["severe pain", "vomiting", "fever", "rigid abdomen"]
            }
        ]
        
        # Sample conditions database
        conditions_data = [
            {
                "name": "Myocardial Infarction",
                "description": "Heart attack caused by blocked coronary artery",
                "icd_code": "I21.9",
                "symptoms": ["chest pain", "shortness of breath", "sweating", "nausea"],
                "urgency": "emergency",
                "specialist": "cardiologist"
            },
            {
                "name": "Migraine",
                "description": "Severe recurring headache with neurological symptoms",
                "icd_code": "G43.9",
                "symptoms": ["headache", "nausea", "light sensitivity", "visual disturbances"],
                "urgency": "routine",
                "specialist": "neurologist"
            },
            {
                "name": "Pneumonia",
                "description": "Infection causing inflammation in lung air sacs",
                "icd_code": "J18.9",
                "symptoms": ["fever", "cough", "shortness of breath", "chest pain"],
                "urgency": "urgent",
                "specialist": "pulmonologist"
            },
            {
                "name": "Appendicitis",
                "description": "Inflammation of the appendix",
                "icd_code": "K37",
                "symptoms": ["abdominal pain", "nausea", "vomiting", "fever"],
                "urgency": "emergency",
                "specialist": "surgeon"
            },
            {
                "name": "Gastroesophageal Reflux Disease",
                "description": "Chronic acid reflux condition",
                "icd_code": "K21.9",
                "symptoms": ["heartburn", "chest pain", "difficulty swallowing", "regurgitation"],
                "urgency": "routine",
                "specialist": "gastroenterologist"
            }
        ]
        
        # Sample medications database
        medications_data = [
            {
                "name": "Aspirin",
                "generic_name": "acetylsalicylic acid",
                "drug_class": "NSAID",
                "indications": ["pain relief", "fever reduction", "heart attack prevention"],
                "contraindications": ["bleeding disorders", "severe kidney disease"],
                "interactions": ["warfarin", "methotrexate"]
            },
            {
                "name": "Lisinopril",
                "generic_name": "lisinopril",
                "drug_class": "ACE inhibitor",
                "indications": ["hypertension", "heart failure", "post-MI"],
                "contraindications": ["pregnancy", "angioedema history"],
                "interactions": ["potassium supplements", "lithium"]
            },
            {
                "name": "Metformin",
                "generic_name": "metformin",
                "drug_class": "biguanide",
                "indications": ["type 2 diabetes", "PCOS"],
                "contraindications": ["kidney disease", "liver disease"],
                "interactions": ["alcohol", "contrast agents"]
            }
        ]
        
        # Store in vector database
        self._store_medical_data(symptoms_data, self.symptoms_collection, "symptom")
        self._store_medical_data(conditions_data, self.conditions_collection, "condition")
        self._store_medical_data(medications_data, self.medications_collection, "medication")
    
    def _store_medical_data(self, data: List[Dict], collection, data_type: str):
        """Store medical data in ChromaDB."""
        for i, item in enumerate(data):
            item_id = f"{data_type}_{i}"
            text_content = f"{item['name']} {item['description']}"
            
            # Add additional searchable content
            if 'symptoms' in item:
                text_content += " " + " ".join(item['symptoms'])
            if 'common_causes' in item:
                text_content += " " + " ".join(item['common_causes'])
            
            embedding = self.embedding_model.encode(text_content).tolist()
            
            try:
                collection.add(
                    documents=[text_content],
                    embeddings=[embedding],
                    metadatas=[item],
                    ids=[item_id]
                )
            except Exception as e:
                logger.warning(f"Could not add {item_id}: {e}")
    
    def search_symptoms(self, query: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Search symptom database."""
        return self._search_collection(self.symptoms_collection, query, n_results)
    
    def search_conditions(self, query: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Search conditions database."""
        return self._search_collection(self.conditions_collection, query, n_results)
    
    def search_medications(self, query: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Search medications database."""
        return self._search_collection(self.medications_collection, query, n_results)
    
    def _search_collection(self, collection, query: str, n_results: int) -> List[Dict[str, Any]]:
        """Generic search function for collections."""
        try:
            query_embedding = self.embedding_model.encode(query).tolist()
            
            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results
            )
            
            search_results = []
            if results['metadatas']:
                for i, metadata in enumerate(results['metadatas'][0]):
                    search_results.append({
                        'data': metadata,
                        'similarity': 1 - results['distances'][0][i] if 'distances' in results else 0.0
                    })
            
            return search_results
            
        except Exception as e:
            logger.error(f"Search error: {e}")
            return []

class SymptomChecker:
    """Intelligent symptom analysis and checking system."""
    
    def __init__(self, knowledge_base: MedicalKnowledgeBase):
        self.knowledge_base = knowledge_base
        self.symptom_network = self._build_symptom_network()
    
    def _build_symptom_network(self) -> nx.Graph:
        """Build network of symptom relationships."""
        G = nx.Graph()
        
        # Sample symptom relationships
        symptom_pairs = [
            ("fever", "headache", 0.7),
            ("chest pain", "shortness of breath", 0.8),
            ("nausea", "vomiting", 0.9),
            ("headache", "light sensitivity", 0.6),
            ("abdominal pain", "nausea", 0.5),
            ("fever", "cough", 0.6),
            ("dizziness", "headache", 0.4)
        ]
        
        for symptom1, symptom2, weight in symptom_pairs:
            G.add_edge(symptom1, symptom2, weight=weight)
        
        return G
    
    def analyze_symptoms(self, symptoms: List[str], patient_profile: PatientProfile) -> Dict[str, Any]:
        """Comprehensive symptom analysis."""
        try:
            # Normalize symptom names
            normalized_symptoms = [self._normalize_symptom(s) for s in symptoms]
            
            # Find related symptoms
            related_symptoms = self._find_related_symptoms(normalized_symptoms)
            
            # Calculate symptom clusters
            symptom_clusters = self._cluster_symptoms(normalized_symptoms)
            
            # Assess severity and urgency
            urgency_assessment = self._assess_urgency(normalized_symptoms, patient_profile)
            
            # Search for matching conditions
            potential_conditions = self._match_conditions(normalized_symptoms)
            
            analysis = {
                "primary_symptoms": normalized_symptoms,
                "related_symptoms": related_symptoms,
                "symptom_clusters": symptom_clusters,
                "urgency_assessment": urgency_assessment,
                "potential_conditions": potential_conditions,
                "risk_factors": self._assess_risk_factors(patient_profile),
                "red_flags": self._identify_red_flags(normalized_symptoms)
            }
            
            return analysis
            
        except Exception as e:
            logger.error(f"Symptom analysis error: {e}")
            return {"error": str(e)}
    
    def _normalize_symptom(self, symptom: str) -> str:
        """Normalize symptom description."""
        # Simple normalization - in practice, use medical ontologies
        symptom = symptom.lower().strip()
        
        # Common mappings
        mappings = {
            "stomach ache": "abdominal pain",
            "trouble breathing": "shortness of breath",
            "feeling sick": "nausea",
            "temperature": "fever",
            "sore throat": "throat pain"
        }
        
        return mappings.get(symptom, symptom)
    
    def _find_related_symptoms(self, symptoms: List[str]) -> List[str]:
        """Find symptoms commonly associated with given symptoms."""
        related = set()
        
        for symptom in symptoms:
            if symptom in self.symptom_network:
                neighbors = list(self.symptom_network.neighbors(symptom))
                related.update(neighbors)
        
        # Remove symptoms already in the list
        related = related - set(symptoms)
        return list(related)
    
    def _cluster_symptoms(self, symptoms: List[str]) -> Dict[str, List[str]]:
        """Group symptoms by body system."""
        clusters = {
            "neurological": [],
            "cardiovascular": [],
            "respiratory": [],
            "gastrointestinal": [],
            "general": []
        }
        
        # Simple clustering - in practice, use medical classification
        mappings = {
            "headache": "neurological",
            "dizziness": "neurological",
            "chest pain": "cardiovascular",
            "shortness of breath": "respiratory",
            "cough": "respiratory",
            "abdominal pain": "gastrointestinal",
            "nausea": "gastrointestinal",
            "fever": "general"
        }
        
        for symptom in symptoms:
            category = mappings.get(symptom, "general")
            clusters[category].append(symptom)
        
        # Remove empty clusters
        return {k: v for k, v in clusters.items() if v}
    
    def _assess_urgency(self, symptoms: List[str], patient_profile: PatientProfile) -> Dict[str, Any]:
        """Assess urgency level of symptom combination."""
        emergency_symptoms = [
            "chest pain", "severe headache", "difficulty breathing",
            "severe abdominal pain", "loss of consciousness"
        ]
        
        urgent_symptoms = [
            "high fever", "persistent vomiting", "severe pain"
        ]
        
        urgency_score = 0
        urgency_reasons = []
        
        # Check for emergency symptoms
        for symptom in symptoms:
            if any(emergency in symptom for emergency in emergency_symptoms):
                urgency_score += 3
                urgency_reasons.append(f"Emergency symptom: {symptom}")
            elif any(urgent in symptom for urgent in urgent_symptoms):
                urgency_score += 2
                urgency_reasons.append(f"Urgent symptom: {symptom}")
        
        # Consider patient age
        if patient_profile.age > 65:
            urgency_score += 1
            urgency_reasons.append("Advanced age increases risk")
        
        # Determine urgency level
        if urgency_score >= 3:
            level = UrgencyLevel.EMERGENCY
        elif urgency_score >= 2:
            level = UrgencyLevel.URGENT
        else:
            level = UrgencyLevel.ROUTINE
        
        return {
            "level": level,
            "score": urgency_score,
            "reasons": urgency_reasons
        }
    
    def _match_conditions(self, symptoms: List[str]) -> List[Dict[str, Any]]:
        """Match symptoms to potential medical conditions."""
        potential_conditions = []
        
        # Search knowledge base for conditions
        symptom_query = " ".join(symptoms)
        condition_results = self.knowledge_base.search_conditions(symptom_query, 10)
        
        for result in condition_results:
            condition_data = result['data']
            similarity = result['similarity']
            
            # Calculate symptom match score
            condition_symptoms = condition_data.get('symptoms', [])
            match_score = self._calculate_symptom_match(symptoms, condition_symptoms)
            
            # Combined score
            combined_score = (similarity + match_score) / 2
            
            potential_conditions.append({
                "condition": condition_data,
                "confidence": combined_score,
                "symptom_overlap": len(set(symptoms) & set(condition_symptoms)),
                "missing_symptoms": list(set(condition_symptoms) - set(symptoms))
            })
        
        # Sort by confidence
        potential_conditions.sort(key=lambda x: x['confidence'], reverse=True)
        
        return potential_conditions[:5]
    
    def _calculate_symptom_match(self, patient_symptoms: List[str], 
                               condition_symptoms: List[str]) -> float:
        """Calculate how well patient symptoms match condition symptoms."""
        if not condition_symptoms:
            return 0.0
        
        matches = len(set(patient_symptoms) & set(condition_symptoms))
        return matches / len(condition_symptoms)
    
    def _assess_risk_factors(self, patient_profile: PatientProfile) -> List[str]:
        """Assess patient risk factors."""
        risk_factors = []
        
        # Age-related risks
        if patient_profile.age > 65:
            risk_factors.append("Advanced age")
        
        # Medical history risks
        cardiovascular_conditions = ["hypertension", "diabetes", "heart disease"]
        if any(condition in " ".join(patient_profile.medical_history) 
               for condition in cardiovascular_conditions):
            risk_factors.append("Cardiovascular risk factors")
        
        # Lifestyle risks
        if patient_profile.lifestyle_factors.get("smoking"):
            risk_factors.append("Smoking history")
        
        return risk_factors
    
    def _identify_red_flags(self, symptoms: List[str]) -> List[str]:
        """Identify concerning symptom combinations."""
        red_flags = []
        
        # Cardiovascular red flags
        if "chest pain" in symptoms and "shortness of breath" in symptoms:
            red_flags.append("Chest pain with breathing difficulty - possible cardiac event")
        
        # Neurological red flags
        if "headache" in symptoms and "fever" in symptoms:
            red_flags.append("Headache with fever - possible meningitis")
        
        # Abdominal red flags
        if "abdominal pain" in symptoms and "vomiting" in symptoms:
            red_flags.append("Abdominal pain with vomiting - possible obstruction")
        
        return red_flags

class LLMDiagnosticReasoner:
    """LLM-powered medical reasoning engine."""
    
    def __init__(self, llm: Optional[ChatOpenAI] = None):
        self.llm = llm
        self._initialize_prompts()
    
    def _initialize_prompts(self):
        """Initialize medical reasoning prompts."""
        self.diagnostic_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are a medical AI assistant providing diagnostic support. 
            You MUST include the following disclaimer with every response:
            
            "‚ö†Ô∏è MEDICAL DISCLAIMER: This is for educational purposes only. 
            Always consult qualified healthcare professionals for medical advice. 
            In case of emergency, call emergency services immediately."
            
            Given the patient information and symptoms, provide:
            1. Differential diagnosis considerations
            2. Clinical reasoning
            3. Recommended next steps
            4. Urgency assessment
            
            Patient Information:
            Age: {age}
            Gender: {gender}
            Medical History: {medical_history}
            Current Medications: {medications}
            
            Symptoms: {symptoms}
            Duration: {duration}
            
            Provide thoughtful medical reasoning while emphasizing the need for professional evaluation.
            """),
            ("human", "Please provide diagnostic reasoning for this case.")
        ])
        
        self.treatment_prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template("""
            You are providing general medical information. Always include this disclaimer:
            
            "‚ö†Ô∏è MEDICAL DISCLAIMER: This information is for educational purposes only. 
            Always consult healthcare professionals before starting any treatment."
            
            For the condition: {condition}
            Patient profile: {patient_profile}
            
            Provide general information about:
            1. Common treatment approaches
            2. Lifestyle modifications
            3. When to seek immediate care
            4. Follow-up recommendations
            
            Emphasize the importance of professional medical care.
            """),
            ("human", "What general treatment information can you provide?")
        ])
    
    def reason_diagnosis(self, symptoms: List[str], patient_profile: PatientProfile,
                        symptom_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Generate diagnostic reasoning using LLM."""
        try:
            if not self.llm:
                return self._rule_based_reasoning(symptoms, patient_profile, symptom_analysis)
            
            # Prepare patient data
            medical_history = ", ".join(patient_profile.medical_history) or "None reported"
            medications = ", ".join(patient_profile.current_medications) or "None reported"
            symptoms_text = ", ".join(symptoms)
            
            # Generate LLM reasoning
            response = self.llm.invoke(
                self.diagnostic_prompt.format(
                    age=patient_profile.age,
                    gender=patient_profile.gender,
                    medical_history=medical_history,
                    medications=medications,
                    symptoms=symptoms_text,
                    duration="As reported"
                )
            )
            
            reasoning_result = {
                "llm_reasoning": response.content,
                "confidence_level": self._assess_reasoning_confidence(symptoms, patient_profile),
                "recommendations": self._generate_recommendations(symptom_analysis),
                "urgency_assessment": symptom_analysis.get("urgency_assessment", {}),
                "disclaimer": "This analysis is for educational purposes only. Consult healthcare professionals."
            }
            
            return reasoning_result
            
        except Exception as e:
            logger.error(f"LLM reasoning error: {e}")
            return self._rule_based_reasoning(symptoms, patient_profile, symptom_analysis)
    
    def _rule_based_reasoning(self, symptoms: List[str], patient_profile: PatientProfile,
                            symptom_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Fallback rule-based reasoning."""
        potential_conditions = symptom_analysis.get("potential_conditions", [])
        urgency = symptom_analysis.get("urgency_assessment", {})
        
        reasoning = "Based on the reported symptoms and patient profile:\n\n"
        
        if potential_conditions:
            top_condition = potential_conditions[0]
            reasoning += f"Primary consideration: {top_condition['condition']['name']}\n"
            reasoning += f"Confidence: {top_condition['confidence']:.2%}\n"
            reasoning += f"Symptom overlap: {top_condition['symptom_overlap']} symptoms match\n\n"
        
        if urgency.get("level") == UrgencyLevel.EMERGENCY:
            reasoning += "‚ö†Ô∏è URGENT: These symptoms may require immediate medical attention.\n"
        elif urgency.get("level") == UrgencyLevel.URGENT:
            reasoning += "‚ö†Ô∏è These symptoms should be evaluated promptly by a healthcare provider.\n"
        
        reasoning += "\n‚ö†Ô∏è MEDICAL DISCLAIMER: This analysis is for educational purposes only. Always consult qualified healthcare professionals for medical advice."
        
        return {
            "rule_based_reasoning": reasoning,
            "confidence_level": "moderate" if potential_conditions else "low",
            "recommendations": self._generate_recommendations(symptom_analysis),
            "urgency_assessment": urgency,
            "disclaimer": "This analysis is for educational purposes only."
        }
    
    def _assess_reasoning_confidence(self, symptoms: List[str], 
                                   patient_profile: PatientProfile) -> str:
        """Assess confidence level of diagnostic reasoning."""
        factors = 0
        
        # More symptoms generally increase confidence
        if len(symptoms) >= 3:
            factors += 1
        
        # Clear medical history helps
        if patient_profile.medical_history:
            factors += 1
        
        # Age provides context
        if 18 <= patient_profile.age <= 65:
            factors += 1
        
        if factors >= 3:
            return "moderate"
        elif factors >= 2:
            return "low-moderate"
        else:
            return "low"
    
    def _generate_recommendations(self, symptom_analysis: Dict[str, Any]) -> List[str]:
        """Generate clinical recommendations."""
        recommendations = []
        
        urgency = symptom_analysis.get("urgency_assessment", {})
        red_flags = symptom_analysis.get("red_flags", [])
        
        # Urgency-based recommendations
        if urgency.get("level") == UrgencyLevel.EMERGENCY:
            recommendations.append("Seek immediate emergency medical care")
            recommendations.append("Call emergency services if symptoms are severe")
        elif urgency.get("level") == UrgencyLevel.URGENT:
            recommendations.append("Schedule urgent appointment with healthcare provider")
            recommendations.append("Consider urgent care if primary care unavailable")
        else:
            recommendations.append("Schedule routine appointment with healthcare provider")
        
        # Red flag recommendations
        if red_flags:
            recommendations.append("Inform healthcare provider of concerning symptom combinations")
        
        # General recommendations
        recommendations.extend([
            "Keep track of symptom progression",
            "Note any new or worsening symptoms",
            "Bring list of current medications to appointment"
        ])
        
        return recommendations

class MedicalDiagnosisAssistant:
    """Main medical diagnosis assistant orchestrating all components."""
    
    def __init__(self, openai_api_key: str = None):
        self.knowledge_base = MedicalKnowledgeBase()
        self.symptom_checker = SymptomChecker(self.knowledge_base)
        
        # Initialize LLM
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.2,  # Lower temperature for medical accuracy
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self.diagnostic_reasoner = LLMDiagnosticReasoner(self.llm)
        
        # Initialize NLP components
        try:
            self.nlp = spacy.load("en_core_web_sm")
        except OSError:
            logger.warning("Spacy model not found. Using basic NLP.")
            self.nlp = None
    
    def analyze_patient_case(self, symptoms: List[str], patient_profile: PatientProfile) -> Dict[str, Any]:
        """Comprehensive patient case analysis."""
        try:
            # Input validation
            if not symptoms:
                return {"error": "No symptoms provided"}
            
            # Symptom analysis
            symptom_analysis = self.symptom_checker.analyze_symptoms(symptoms, patient_profile)
            
            if "error" in symptom_analysis:
                return symptom_analysis
            
            # LLM diagnostic reasoning
            diagnostic_reasoning = self.diagnostic_reasoner.reason_diagnosis(
                symptoms, patient_profile, symptom_analysis
            )
            
            # Drug interaction checking
            drug_interactions = self._check_drug_interactions(patient_profile.current_medications)
            
            # Generate comprehensive assessment
            assessment = {
                "patient_profile": patient_profile,
                "symptom_analysis": symptom_analysis,
                "diagnostic_reasoning": diagnostic_reasoning,
                "drug_interactions": drug_interactions,
                "recommendations": self._generate_comprehensive_recommendations(
                    symptom_analysis, diagnostic_reasoning
                ),
                "disclaimer": self._get_medical_disclaimer(),
                "timestamp": datetime.now().isoformat()
            }
            
            return assessment
            
        except Exception as e:
            logger.error(f"Patient case analysis error: {e}")
            return {"error": f"Analysis failed: {str(e)}"}
    
    def _check_drug_interactions(self, medications: List[str]) -> Dict[str, Any]:
        """Check for potential drug interactions."""
        interactions = {
            "potential_interactions": [],
            "warnings": [],
            "recommendations": []
        }
        
        if len(medications) < 2:
            return interactions
        
        # Simple interaction checking (in practice, use comprehensive drug database)
        known_interactions = {
            ("aspirin", "warfarin"): "Increased bleeding risk",
            ("lisinopril", "potassium"): "Risk of hyperkalemia",
            ("metformin", "alcohol"): "Risk of lactic acidosis"
        }
        
        for i, med1 in enumerate(medications):
            for med2 in medications[i+1:]:
                med1_lower = med1.lower()
                med2_lower = med2.lower()
                
                # Check both directions
                interaction = (known_interactions.get((med1_lower, med2_lower)) or 
                             known_interactions.get((med2_lower, med1_lower)))
                
                if interaction:
                    interactions["potential_interactions"].append({
                        "drug1": med1,
                        "drug2": med2,
                        "interaction": interaction
                    })
        
        if interactions["potential_interactions"]:
            interactions["warnings"].append("Potential drug interactions found")
            interactions["recommendations"].append("Consult pharmacist or physician about drug interactions")
        
        return interactions
    
    def _generate_comprehensive_recommendations(self, symptom_analysis: Dict[str, Any],
                                              diagnostic_reasoning: Dict[str, Any]) -> List[str]:
        """Generate comprehensive clinical recommendations."""
        recommendations = []
        
        # Start with diagnostic reasoning recommendations
        if "recommendations" in diagnostic_reasoning:
            recommendations.extend(diagnostic_reasoning["recommendations"])
        
        # Add symptom-specific recommendations
        urgency = symptom_analysis.get("urgency_assessment", {})
        
        if urgency.get("level") == UrgencyLevel.EMERGENCY:
            recommendations.insert(0, "üö® SEEK IMMEDIATE EMERGENCY CARE")
        
        # Red flag recommendations
        red_flags = symptom_analysis.get("red_flags", [])
        if red_flags:
            recommendations.append("Inform healthcare provider of concerning symptom combinations")
        
        # General health recommendations
        recommendations.extend([
            "Maintain detailed symptom diary",
            "Stay hydrated and get adequate rest",
            "Follow up as recommended by healthcare provider"
        ])
        
        return list(set(recommendations))  # Remove duplicates
    
    def _get_medical_disclaimer(self) -> str:
        """Get comprehensive medical disclaimer."""
        return """
        ‚ö†Ô∏è IMPORTANT MEDICAL DISCLAIMER:
        
        This tool is for educational and informational purposes only and is not intended to:
        - Replace professional medical advice, diagnosis, or treatment
        - Provide definitive medical diagnoses
        - Recommend specific treatments or medications
        - Be used in medical emergencies
        
        ALWAYS:
        - Consult qualified healthcare professionals for medical advice
        - Seek immediate emergency care for serious symptoms
        - Follow your healthcare provider's recommendations
        - Report any concerning symptoms promptly
        
        In case of emergency, contact emergency services immediately.
        """
    
    def get_medical_information(self, query: str) -> Dict[str, Any]:
        """Retrieve medical information from knowledge base."""
        try:
            # Search across all collections
            symptom_results = self.knowledge_base.search_symptoms(query, 3)
            condition_results = self.knowledge_base.search_conditions(query, 3)
            medication_results = self.knowledge_base.search_medications(query, 3)
            
            return {
                "symptoms": symptom_results,
                "conditions": condition_results,
                "medications": medication_results,
                "disclaimer": self._get_medical_disclaimer()
            }
            
        except Exception as e:
            logger.error(f"Medical information retrieval error: {e}")
            return {"error": str(e)}

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Medical Diagnosis Assistant",
        page_icon="üè•",
        layout="wide"
    )
    
    # Medical disclaimer at the top
    st.warning("""
    ‚ö†Ô∏è **MEDICAL DISCLAIMER**: This tool is for educational purposes only. 
    It does not replace professional medical advice. 
    In case of emergency, call emergency services immediately.
    """)
    
    st.title("üè• Medical Diagnosis Assistant")
    st.markdown("AI-powered symptom analysis and diagnostic support")
    
    # Initialize session state
    if 'assistant' not in st.session_state:
        st.session_state['assistant'] = None
    if 'patient_profile' not in st.session_state:
        st.session_state['patient_profile'] = None
    if 'current_analysis' not in st.session_state:
        st.session_state['current_analysis'] = None
    
    # Sidebar configuration
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password",
                                 help="Required for advanced AI diagnostic reasoning")
        
        if st.button("Initialize Assistant") or st.session_state['assistant'] is None:
            with st.spinner("Initializing medical assistant..."):
                st.session_state['assistant'] = MedicalDiagnosisAssistant(openai_key)
                st.success("Medical assistant ready!")
        
        st.header("üë§ Patient Profile")
        
        if st.session_state['patient_profile'] is None:
            age = st.number_input("Age", min_value=0, max_value=120, value=30)
            gender = st.selectbox("Gender", ["Male", "Female", "Other", "Prefer not to say"])
            
            # Medical history
            st.subheader("Medical History")
            medical_history = st.multiselect("Known Conditions", [
                "Hypertension", "Diabetes", "Heart Disease", "Asthma", 
                "Depression", "Anxiety", "Arthritis", "Cancer History"
            ])
            
            custom_conditions = st.text_input("Other conditions (comma-separated)")
            if custom_conditions:
                medical_history.extend([c.strip() for c in custom_conditions.split(',') if c.strip()])
            
            # Current medications
            current_medications = st.text_area("Current Medications (one per line)")
            medications_list = [m.strip() for m in current_medications.split('\n') if m.strip()]
            
            # Allergies
            allergies = st.text_input("Known Allergies (comma-separated)")
            allergies_list = [a.strip() for a in allergies.split(',') if a.strip()]
            
            if st.button("Save Patient Profile"):
                profile = PatientProfile(
                    age=age,
                    gender=gender,
                    medical_history=medical_history,
                    current_medications=medications_list,
                    allergies=allergies_list
                )
                
                st.session_state['patient_profile'] = profile
                st.success("Patient profile saved!")
                st.rerun()
        else:
            profile = st.session_state['patient_profile']
            st.write(f"**Age:** {profile.age}")
            st.write(f"**Gender:** {profile.gender}")
            if profile.medical_history:
                st.write(f"**Medical History:** {', '.join(profile.medical_history)}")
            if profile.current_medications:
                st.write(f"**Medications:** {', '.join(profile.current_medications)}")
            
            if st.button("Reset Profile"):
                st.session_state['patient_profile'] = None
                st.rerun()
    
    # Main interface
    if not st.session_state['assistant']:
        st.info("üëà Please initialize the assistant using the sidebar")
        return
    
    if not st.session_state['patient_profile']:
        st.info("üëà Please create a patient profile using the sidebar")
        return
    
    assistant = st.session_state['assistant']
    
    # Create tabs
    tab1, tab2, tab3, tab4 = st.tabs(["üîç Symptom Analysis", "üìã Medical Information", "üíä Drug Interactions", "üìä Health Insights"])
    
    with tab1:
        st.header("üîç Symptom Analysis")
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader("Report Your Symptoms")
            
            # Symptom input methods
            input_method = st.radio("How would you like to report symptoms?", 
                                   ["Select from list", "Type symptoms", "Both"])
            
            symptoms = []
            
            if input_method in ["Select from list", "Both"]:
                st.write("**Select common symptoms:**")
                
                symptom_categories = {
                    "General": ["Fever", "Fatigue", "Loss of appetite", "Weight loss"],
                    "Head/Neck": ["Headache", "Dizziness", "Sore throat", "Neck stiffness"],
                    "Chest/Heart": ["Chest pain", "Shortness of breath", "Palpitations", "Cough"],
                    "Abdomen": ["Abdominal pain", "Nausea", "Vomiting", "Diarrhea"],
                    "Muscles/Joints": ["Joint pain", "Muscle aches", "Back pain", "Stiffness"]
                }
                
                for category, symptoms_list in symptom_categories.items():
                    with st.expander(f"{category} Symptoms"):
                        selected = st.multiselect(f"Select {category.lower()} symptoms:", 
                                                symptoms_list, key=f"{category}_symptoms")
                        symptoms.extend(selected)
            
            if input_method in ["Type symptoms", "Both"]:
                st.write("**Describe your symptoms:**")
                typed_symptoms = st.text_area("Describe what you're experiencing...", 
                                            placeholder="e.g., I have a severe headache with nausea that started yesterday")
                
                if typed_symptoms:
                    # Simple symptom extraction (in practice, use NLP)
                    typed_symptoms_list = [s.strip() for s in typed_symptoms.split(',')]
                    symptoms.extend(typed_symptoms_list)
            
            # Symptom details
            if symptoms:
                st.subheader("Symptom Details")
                
                duration = st.selectbox("How long have you had these symptoms?", [
                    "Less than 1 day", "1-3 days", "4-7 days", "1-2 weeks", "More than 2 weeks"
                ])
                
                severity = st.slider("Overall symptom severity (1-10)", 1, 10, 5)
                
                triggers = st.text_input("Any triggers or patterns you've noticed?")
            
            # Analyze symptoms
            if st.button("üîç Analyze Symptoms") and symptoms:
                with st.spinner("Analyzing symptoms..."):
                    try:
                        analysis = assistant.analyze_patient_case(
                            symptoms, st.session_state['patient_profile']
                        )
                        
                        if "error" in analysis:
                            st.error(analysis["error"])
                        else:
                            st.session_state['current_analysis'] = analysis
                            st.success("Analysis complete!")
                            st.rerun()
                    
                    except Exception as e:
                        st.error(f"Analysis failed: {str(e)}")
        
        with col2:
            if symptoms:
                st.subheader("üéØ Current Symptoms")
                for i, symptom in enumerate(symptoms, 1):
                    st.write(f"{i}. {symptom}")
            
            # Quick emergency check
            st.subheader("üö® Emergency Symptoms")
            emergency_symptoms = [
                "Severe chest pain",
                "Difficulty breathing",
                "Loss of consciousness",
                "Severe bleeding",
                "Severe allergic reaction"
            ]
            
            st.error("If experiencing any of these, seek immediate emergency care:")
            for symptom in emergency_symptoms:
                st.write(f"‚Ä¢ {symptom}")
        
        # Display analysis results
        if st.session_state['current_analysis']:
            st.subheader("üìä Analysis Results")
            
            analysis = st.session_state['current_analysis']
            symptom_analysis = analysis.get('symptom_analysis', {})
            diagnostic_reasoning = analysis.get('diagnostic_reasoning', {})
            
            # Urgency assessment
            urgency = symptom_analysis.get('urgency_assessment', {})
            if urgency:
                urgency_level = urgency.get('level', UrgencyLevel.ROUTINE)
                
                if urgency_level == UrgencyLevel.EMERGENCY:
                    st.error(f"üö® EMERGENCY: {urgency.get('score', 0)} urgency points")
                elif urgency_level == UrgencyLevel.URGENT:
                    st.warning(f"‚ö†Ô∏è URGENT: {urgency.get('score', 0)} urgency points")
                else:
                    st.info(f"‚ÑπÔ∏è ROUTINE: {urgency.get('score', 0)} urgency points")
                
                if urgency.get('reasons'):
                    st.write("**Urgency factors:**")
                    for reason in urgency['reasons']:
                        st.write(f"‚Ä¢ {reason}")
            
            # Potential conditions
            potential_conditions = symptom_analysis.get('potential_conditions', [])
            if potential_conditions:
                st.subheader("üîç Potential Conditions to Consider")
                
                for i, condition_match in enumerate(potential_conditions[:3], 1):
                    condition = condition_match['condition']
                    confidence = condition_match['confidence']
                    
                    with st.expander(f"{i}. {condition['name']} (Confidence: {confidence:.1%})"):
                        st.write(f"**Description:** {condition['description']}")
                        
                        if condition.get('urgency'):
                            st.write(f"**Urgency Level:** {condition['urgency']}")
                        
                        if condition.get('specialist'):
                            st.write(f"**Specialist:** {condition['specialist']}")
                        
                        overlap = condition_match.get('symptom_overlap', 0)
                        st.write(f"**Matching symptoms:** {overlap}")
                        
                        missing = condition_match.get('missing_symptoms', [])
                        if missing:
                            st.write(f"**Additional symptoms to watch for:** {', '.join(missing)}")
            
            # AI reasoning
            if 'llm_reasoning' in diagnostic_reasoning:
                st.subheader("ü§ñ AI Diagnostic Reasoning")
                st.write(diagnostic_reasoning['llm_reasoning'])
            elif 'rule_based_reasoning' in diagnostic_reasoning:
                st.subheader("üìã Clinical Analysis")
                st.write(diagnostic_reasoning['rule_based_reasoning'])
            
            # Recommendations
            recommendations = analysis.get('recommendations', [])
            if recommendations:
                st.subheader("üí° Recommendations")
                for rec in recommendations:
                    st.write(f"‚Ä¢ {rec}")
            
            # Red flags
            red_flags = symptom_analysis.get('red_flags', [])
            if red_flags:
                st.subheader("üö© Important Considerations")
                for flag in red_flags:
                    st.warning(f"‚ö†Ô∏è {flag}")
    
    with tab2:
        st.header("üìã Medical Information Search")
        
        search_query = st.text_input("Search medical information:", 
                                   placeholder="e.g., migraine, blood pressure, aspirin")
        
        if search_query:
            with st.spinner("Searching medical database..."):
                results = assistant.get_medical_information(search_query)
                
                if "error" in results:
                    st.error(results["error"])
                else:
                    # Display results by category
                    categories = [
                        ("Symptoms", results.get("symptoms", [])),
                        ("Conditions", results.get("conditions", [])),
                        ("Medications", results.get("medications", []))
                    ]
                    
                    for category_name, category_results in categories:
                        if category_results:
                            st.subheader(f"üîç {category_name}")
                            
                            for result in category_results:
                                data = result['data']
                                similarity = result['similarity']
                                
                                with st.expander(f"{data['name']} (Relevance: {similarity:.1%})"):
                                    st.write(f"**Description:** {data['description']}")
                                    
                                    # Category-specific information
                                    if category_name == "Symptoms" and 'common_causes' in data:
                                        st.write(f"**Common causes:** {', '.join(data['common_causes'])}")
                                    
                                    elif category_name == "Conditions":
                                        if 'symptoms' in data:
                                            st.write(f"**Associated symptoms:** {', '.join(data['symptoms'])}")
                                        if 'urgency' in data:
                                            st.write(f"**Urgency level:** {data['urgency']}")
                                    
                                    elif category_name == "Medications":
                                        if 'indications' in data:
                                            st.write(f"**Used for:** {', '.join(data['indications'])}")
                                        if 'contraindications' in data:
                                            st.write(f"**Contraindications:** {', '.join(data['contraindications'])}")
    
    with tab3:
        st.header("üíä Drug Interaction Checker")
        
        if st.session_state['patient_profile'].current_medications:
            st.subheader("Current Medications")
            
            for i, med in enumerate(st.session_state['patient_profile'].current_medications, 1):
                st.write(f"{i}. {med}")
            
            # Check interactions
            if st.button("üîç Check Drug Interactions"):
                with st.spinner("Checking drug interactions..."):
                    interactions = assistant._check_drug_interactions(
                        st.session_state['patient_profile'].current_medications
                    )
                    
                    if interactions['potential_interactions']:
                        st.subheader("‚ö†Ô∏è Potential Interactions Found")
                        
                        for interaction in interactions['potential_interactions']:
                            st.warning(f"**{interaction['drug1']}** + **{interaction['drug2']}**: {interaction['interaction']}")
                        
                        if interactions['recommendations']:
                            st.subheader("üí° Recommendations")
                            for rec in interactions['recommendations']:
                                st.write(f"‚Ä¢ {rec}")
                    else:
                        st.success("‚úÖ No known interactions found between current medications")
        else:
            st.info("No current medications listed in patient profile")
        
        # Add new medication check
        st.subheader("üÜï Check New Medication")
        
        new_medication = st.text_input("Enter medication name to check against current medications:")
        
        if new_medication and st.button("Check New Medication"):
            current_meds = st.session_state['patient_profile'].current_medications
            test_meds = current_meds + [new_medication]
            
            interactions = assistant._check_drug_interactions(test_meds)
            
            if interactions['potential_interactions']:
                st.warning(f"‚ö†Ô∏è Potential interactions found with {new_medication}")
                for interaction in interactions['potential_interactions']:
                    if new_medication.lower() in [interaction['drug1'].lower(), interaction['drug2'].lower()]:
                        st.write(f"‚Ä¢ {interaction['drug1']} + {interaction['drug2']}: {interaction['interaction']}")
            else:
                st.success(f"‚úÖ No known interactions found with {new_medication}")
    
    with tab4:
        st.header("üìä Health Insights")
        
        if st.session_state['current_analysis']:
            analysis = st.session_state['current_analysis']
            
            # Health metrics
            col1, col2, col3, col4 = st.columns(4)
            
            symptom_count = len(analysis.get('patient_profile', {}).get('medical_history', []))
            urgency_score = analysis.get('symptom_analysis', {}).get('urgency_assessment', {}).get('score', 0)
            potential_conditions = len(analysis.get('symptom_analysis', {}).get('potential_conditions', []))
            
            with col1:
                st.metric("Medical History Items", symptom_count)
            with col2:
                st.metric("Urgency Score", urgency_score)
            with col3:
                st.metric("Potential Conditions", potential_conditions)
            with col4:
                confidence = analysis.get('diagnostic_reasoning', {}).get('confidence_level', 'low')
                st.metric("Analysis Confidence", confidence)
            
            # Symptom distribution
            symptom_analysis = analysis.get('symptom_analysis', {})
            symptom_clusters = symptom_analysis.get('symptom_clusters', {})
            
            if symptom_clusters:
                st.subheader("üìä Symptom Distribution by Body System")
                
                # Create pie chart
                systems = list(symptom_clusters.keys())
                counts = [len(symptoms) for symptoms in symptom_clusters.values()]
                
                fig = px.pie(values=counts, names=systems, title="Symptoms by Body System")
                st.plotly_chart(fig, use_container_width=True)
            
            # Risk factors visualization
            profile = analysis.get('patient_profile')
            if profile:
                st.subheader("üéØ Risk Factor Analysis")
                
                risk_factors = []
                
                # Age risk
                if profile.age > 65:
                    risk_factors.append("Advanced age")
                elif profile.age < 18:
                    risk_factors.append("Pediatric considerations")
                
                # Medical history risks
                if profile.medical_history:
                    risk_factors.extend(profile.medical_history)
                
                if risk_factors:
                    for factor in risk_factors:
                        st.write(f"‚Ä¢ {factor}")
                else:
                    st.write("No significant risk factors identified")
        else:
            st.info("Complete a symptom analysis to view health insights")
        
        # Educational content
        st.subheader("üìö Health Education")
        
        health_tips = [
            "Regular check-ups can help detect health issues early",
            "Maintain a healthy lifestyle with proper diet and exercise",
            "Keep an updated list of medications and allergies",
            "Know your family medical history",
            "Don't ignore persistent or worsening symptoms"
        ]
        
        for tip in health_tips:
            st.info(f"üí° {tip}")

if __name__ == "__main__":
    main()
````

## Project Summary

The Medical Diagnosis Assistant represents a comprehensive AI-powered healthcare support system that combines intelligent symptom analysis, evidence-based medical reasoning, and extensive medical knowledge retrieval to provide preliminary diagnostic insights while emphasizing the critical importance of professional medical consultation and maintaining strict safety protocols.

### Key Value Propositions:
- **Intelligent Symptom Analysis**: Advanced symptom categorization, severity assessment, and pattern recognition using medical knowledge graphs and clinical decision trees for comprehensive symptom evaluation
- **LLM-Powered Medical Reasoning**: GPT-4 integration with specialized medical prompts providing evidence-based diagnostic reasoning, differential diagnosis considerations, and clinical decision support with appropriate uncertainty quantification
- **Comprehensive Medical RAG System**: ChromaDB-powered medical knowledge base with semantic search across symptoms, conditions, medications, and clinical guidelines enabling contextual medical information retrieval
- **Safety-First Architecture**: Built-in medical disclaimers, emergency symptom detection, urgency assessment, and appropriate healthcare referral recommendations ensuring responsible AI-assisted healthcare guidance
- **Professional Integration Support**: Drug interaction checking, specialist referral suggestions, and clinical recommendation generation designed to enhance rather than replace professional medical care

### Technical Highlights:
- Advanced medical knowledge modeling using vector embeddings and semantic search with ChromaDB for accurate medical information retrieval and symptom-condition mapping
- LangChain integration with specialized medical prompting strategies ensuring medically appropriate responses with built-in safety disclaimers and uncertainty management
- Comprehensive symptom analysis engine using NetworkX for symptom relationship modeling, fuzzy matching for symptom recognition, and clinical decision trees for urgency assessment
- Interactive Streamlit interface with patient profile management, real-time analysis capabilities, and educational health insights promoting informed healthcare decision-making
- Scalable architecture supporting medical knowledge base expansion, clinical guideline integration, and regulatory compliance frameworks for healthcare AI applications

This system enhances healthcare accessibility by providing intelligent preliminary diagnostic support while maintaining the highest standards of medical safety, ethical AI practices, and professional healthcare integration, ultimately serving as a bridge between patients and healthcare providers rather than a replacement for professional medical care.