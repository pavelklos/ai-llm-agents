<small>Claude Sonnet 4 **(AI-Powered Research Paper Summarization (MCP-Driven) - Intelligent Academic Analysis System)**</small>
# AI-Powered Research Paper Summarization (MCP-Driven)

## Key Concepts Explanation

### Model Context Protocol (MCP) for Academic Research
Advanced research context management framework that maintains comprehensive academic paper relationships, citation networks, author collaborations, research evolution patterns, and domain-specific knowledge across complex academic workflows, enabling persistent research continuity and intelligent paper analysis that adapts to scholarly research patterns and academic domain expertise.

### Academic Natural Language Processing (NLP)
Specialized NLP techniques designed for scholarly content analysis including scientific terminology extraction, methodology identification, results interpretation, hypothesis tracking, and academic writing pattern recognition, enabling sophisticated understanding of research papers, technical documentation, and scholarly communications within specific academic domains.

### Abstractive Summarization
Advanced AI technique that generates concise, coherent summaries by understanding content meaning and creating new text that captures essential information, key findings, methodologies, and conclusions rather than simply extracting existing sentences, enabling comprehensive research paper summarization that maintains scientific accuracy and academic rigor.

### Citation Graphs and Academic Networks
Mathematical representations of academic paper relationships through citation patterns, author collaborations, and research influence networks that enable analysis of knowledge flow, research impact assessment, collaboration discovery, and academic trend identification across research domains and temporal patterns.

### BERTopic for Research Classification
Advanced topic modeling technique using transformer embeddings to identify, cluster, and analyze research themes, methodological approaches, and academic trends within large collections of research papers, enabling automatic research categorization, trend analysis, and knowledge domain mapping for comprehensive academic intelligence.

## Comprehensive Project Explanation

The AI-Powered Research Paper Summarization system revolutionizes academic research workflows by creating intelligent, context-aware research analysis ecosystems that understand scholarly content, maintain comprehensive research relationships, and provide instant access to critical research insights through sophisticated AI-powered summarization and knowledge extraction capabilities.

### Objectives
- **Intelligent Research Understanding**: Develop advanced NLP systems that comprehend complex academic content including methodologies, findings, implications, and research contributions while maintaining scientific accuracy and domain-specific terminology understanding
- **Context-Aware Summarization**: Create sophisticated abstractive summarization systems that generate comprehensive, accurate, and contextually relevant research summaries tailored to different audiences and research purposes while preserving critical scientific information
- **Academic Network Analysis**: Build intelligent citation graph analysis systems that identify research trends, collaboration patterns, influential papers, and knowledge evolution across academic domains while enabling research discovery and impact assessment
- **Research Intelligence Platform**: Implement comprehensive academic intelligence systems that support research discovery, literature review automation, and scholarly knowledge management while maintaining research integrity and academic standards
- **Scalable Academic Processing**: Design robust systems that handle massive academic paper volumes, multiple research domains, and complex scholarly relationships while maintaining processing speed and analytical accuracy

### Challenges
- **Scientific Accuracy Preservation**: Maintaining precise scientific meaning, technical terminology, and research integrity while generating summaries that accurately represent complex methodologies, findings, and academic contributions without introducing errors or misinterpretations
- **Domain-Specific Understanding**: Processing diverse academic disciplines with specialized vocabularies, methodological approaches, and domain-specific conventions while ensuring accurate interpretation across different research fields and maintaining scholarly rigor
- **Citation Network Complexity**: Managing complex academic relationships including forward and backward citations, author networks, institutional collaborations, and temporal research evolution while providing meaningful insights into research impact and influence patterns
- **Summarization Quality Balance**: Creating summaries that balance comprehensiveness with conciseness while ensuring critical research information is preserved and accessible to different audiences including researchers, students, and practitioners
- **Scalability and Performance**: Processing thousands of research papers efficiently while maintaining high-quality analysis, real-time processing capabilities, and system responsiveness across large academic databases and research collections

### Potential Impact
This system could transform academic research by dramatically accelerating literature review processes, improving research discovery, enabling cross-disciplinary knowledge transfer, and providing intelligent research insights that support scientific advancement and scholarly productivity across all academic disciplines.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import logging
import re
import uuid
import arxiv
import requests
from typing import Dict, List, Optional, Any, Union, Tuple, Set
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
import numpy as np
import pandas as pd
from collections import defaultdict, Counter
import networkx as nx

# Core NLP and ML libraries
import spacy
import nltk
from sentence_transformers import SentenceTransformer
from transformers import pipeline, AutoTokenizer, AutoModel
import torch

# Topic modeling and clustering
from bertopic import BERTopic
from umap import UMAP
from hdbscan import HDBSCAN
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.metrics.pairwise import cosine_similarity

# Research paper processing
import fitz  # PyMuPDF for PDF processing
from bs4 import BeautifulSoup
import xml.etree.ElementTree as ET

# LangChain for advanced LLM operations
from langchain.chat_models import ChatOpenAI
from langchain.embeddings import OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chains.summarize import load_summarize_chain
from langchain.schema import Document
from langchain.prompts import PromptTemplate

# Vector storage and search
import faiss
import chromadb
from chromadb.config import Settings

# Database and persistence
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, DateTime, Text, JSON, Integer, Boolean, Float, LargeBinary

# Web framework and API
from fastapi import FastAPI, HTTPException, BackgroundTasks, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, StreamingResponse
import uvicorn

# Visualization and analytics
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
import seaborn as sns

# Citation parsing and academic utilities
import bibtexparser
from crossref.restful import Works
import scholarly

# Utilities
import warnings
warnings.filterwarnings('ignore')

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Download required NLTK data
try:
    nltk.download('punkt', quiet=True)
    nltk.download('stopwords', quiet=True)
    nltk.download('wordnet', quiet=True)
except:
    pass

# Database Models
Base = declarative_base()

class ResearchPaper(Base):
    __tablename__ = "research_papers"
    
    id = Column(String, primary_key=True)
    title = Column(Text, nullable=False)
    authors = Column(JSON)
    abstract = Column(Text)
    full_text = Column(Text)
    arxiv_id = Column(String, unique=True)
    doi = Column(String)
    publication_date = Column(DateTime)
    journal = Column(String)
    categories = Column(JSON)
    keywords = Column(JSON)
    citations_count = Column(Integer, default=0)
    references = Column(JSON)
    metadata = Column(JSON)
    processed_at = Column(DateTime, default=datetime.utcnow)
    embedding_vector = Column(LargeBinary)

class PaperSummary(Base):
    __tablename__ = "paper_summaries"
    
    id = Column(String, primary_key=True)
    paper_id = Column(String, nullable=False)
    summary_type = Column(String)  # abstract, detailed, technical, layman
    summary_content = Column(Text, nullable=False)
    key_findings = Column(JSON)
    methodology = Column(Text)
    implications = Column(Text)
    limitations = Column(Text)
    confidence_score = Column(Float)
    generated_at = Column(DateTime, default=datetime.utcnow)
    model_version = Column(String)

class CitationNetwork(Base):
    __tablename__ = "citation_network"
    
    id = Column(String, primary_key=True)
    citing_paper = Column(String, nullable=False)
    cited_paper = Column(String, nullable=False)
    citation_context = Column(Text)
    citation_type = Column(String)  # methodology, background, comparison, result
    influence_score = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)

class ResearchTopic(Base):
    __tablename__ = "research_topics"
    
    id = Column(String, primary_key=True)
    topic_name = Column(String, nullable=False)
    keywords = Column(JSON)
    description = Column(Text)
    papers_count = Column(Integer, default=0)
    trend_score = Column(Float)
    emergence_date = Column(DateTime)
    related_topics = Column(JSON)
    topic_embedding = Column(LargeBinary)

class AuthorProfile(Base):
    __tablename__ = "author_profiles"
    
    id = Column(String, primary_key=True)
    author_name = Column(String, nullable=False)
    affiliations = Column(JSON)
    research_interests = Column(JSON)
    papers_count = Column(Integer, default=0)
    citations_count = Column(Integer, default=0)
    h_index = Column(Float)
    collaboration_network = Column(JSON)
    expertise_areas = Column(JSON)
    career_timeline = Column(JSON)

# Data Classes
@dataclass
class PaperMetadata:
    title: str
    authors: List[str]
    publication_date: datetime
    journal: str = ""
    doi: str = ""
    arxiv_id: str = ""
    categories: List[str] = field(default_factory=list)
    keywords: List[str] = field(default_factory=list)

@dataclass
class SummaryRequest:
    paper_id: str
    summary_type: str = "detailed"
    target_audience: str = "academic"
    max_length: int = 500
    focus_areas: List[str] = field(default_factory=list)

@dataclass
class ResearchInsight:
    insight_type: str
    description: str
    supporting_papers: List[str]
    confidence: float
    implications: List[str]
    trend_direction: str

class MCPResearchManager:
    """MCP-based research context management"""
    
    def __init__(self, session_factory):
        self.session_factory = session_factory
        self.research_contexts = {}
        self.citation_graph = nx.DiGraph()
        self.author_networks = nx.Graph()
        self.topic_evolution = defaultdict(list)
        self.research_trends = {}
        
    async def create_research_context(self, researcher_id: str, 
                                    research_profile: Dict[str, Any]) -> str:
        """Create comprehensive research context"""
        try:
            context_id = str(uuid.uuid4())
            
            # Initialize research context
            self.research_contexts[researcher_id] = {
                "context_id": context_id,
                "profile": research_profile,
                "research_interests": research_profile.get("interests", []),
                "reading_history": [],
                "citation_patterns": defaultdict(int),
                "collaboration_network": set(),
                "expertise_evolution": [],
                "research_trajectory": [],
                "paper_recommendations": [],
                "topic_preferences": defaultdict(float)
            }
            
            logger.info(f"Created research context for {researcher_id}")
            return context_id
            
        except Exception as e:
            logger.error(f"Research context creation failed: {e}")
            raise
    
    async def update_research_context(self, researcher_id: str, 
                                    interaction_data: Dict[str, Any]):
        """Update research context based on interaction"""
        try:
            if researcher_id not in self.research_contexts:
                return
            
            context = self.research_contexts[researcher_id]
            
            # Update reading history
            if "paper_id" in interaction_data:
                context["reading_history"].append({
                    "paper_id": interaction_data["paper_id"],
                    "timestamp": datetime.utcnow(),
                    "interaction_type": interaction_data.get("type", "read"),
                    "engagement_score": interaction_data.get("engagement", 0.5)
                })
            
            # Update topic preferences
            if "topics" in interaction_data:
                for topic in interaction_data["topics"]:
                    context["topic_preferences"][topic] += interaction_data.get("relevance", 0.5)
            
            # Update citation patterns
            if "citations" in interaction_data:
                for citation in interaction_data["citations"]:
                    context["citation_patterns"][citation] += 1
            
            # Maintain history size
            if len(context["reading_history"]) > 1000:
                context["reading_history"] = context["reading_history"][-1000:]
                
        except Exception as e:
            logger.error(f"Research context update failed: {e}")
    
    async def build_citation_network(self, papers: List[Dict[str, Any]]):
        """Build comprehensive citation network"""
        try:
            for paper in papers:
                paper_id = paper["id"]
                self.citation_graph.add_node(paper_id, **paper)
                
                # Add citation edges
                references = paper.get("references", [])
                for ref in references:
                    if ref in [p["id"] for p in papers]:  # Only internal citations
                        self.citation_graph.add_edge(paper_id, ref)
            
            logger.info(f"Built citation network with {len(self.citation_graph.nodes)} papers")
            
        except Exception as e:
            logger.error(f"Citation network building failed: {e}")
    
    def get_research_context(self, researcher_id: str) -> Dict[str, Any]:
        """Get comprehensive research context"""
        if researcher_id not in self.research_contexts:
            return {}
        
        context = self.research_contexts[researcher_id]
        
        # Generate insights
        recent_papers = context["reading_history"][-20:]
        top_topics = sorted(context["topic_preferences"].items(), 
                          key=lambda x: x[1], reverse=True)[:10]
        
        return {
            "profile": context["profile"],
            "recent_papers": recent_papers,
            "top_topics": [topic[0] for topic in top_topics],
            "research_trajectory": context["research_trajectory"],
            "collaboration_network": list(context["collaboration_network"]),
            "expertise_areas": context.get("expertise_areas", [])
        }

class AcademicNLPProcessor:
    """Advanced NLP processing for academic content"""
    
    def __init__(self):
        # Load models
        self.nlp = spacy.load("en_core_web_sm")
        self.sentence_model = SentenceTransformer('all-MiniLM-L6-v2')
        
        # Initialize academic summarization pipeline
        self.summarizer = pipeline(
            "summarization",
            model="facebook/bart-large-cnn",
            tokenizer="facebook/bart-large-cnn"
        )
        
        # Academic text patterns
        self.methodology_patterns = [
            r"we (propose|present|introduce|develop|implement)",
            r"our (method|approach|algorithm|framework)",
            r"(methodology|experimental setup|data collection)"
        ]
        
        self.finding_patterns = [
            r"(results show|findings indicate|we found|observed that)",
            r"(significant|substantial|notable) (improvement|increase|decrease)",
            r"(outperforms|achieves|demonstrates)"
        ]
        
        self.limitation_patterns = [
            r"(limitation|constraint|drawback|weakness)",
            r"(however|nevertheless|despite)",
            r"(future work|further research|additional studies)"
        ]
    
    async def process_paper(self, paper_text: str, metadata: PaperMetadata) -> Dict[str, Any]:
        """Process academic paper with comprehensive analysis"""
        try:
            # Extract sections
            sections = await self._extract_paper_sections(paper_text)
            
            # Analyze content
            analysis = {
                "sections": sections,
                "methodology": await self._extract_methodology(sections),
                "key_findings": await self._extract_key_findings(sections),
                "contributions": await self._extract_contributions(sections),
                "limitations": await self._extract_limitations(sections),
                "citations": await self._extract_citations(paper_text),
                "keywords": await self._extract_keywords(paper_text),
                "technical_terms": await self._extract_technical_terms(paper_text),
                "research_type": await self._classify_research_type(sections),
                "novelty_score": await self._calculate_novelty_score(sections)
            }
            
            return analysis
            
        except Exception as e:
            logger.error(f"Paper processing failed: {e}")
            return {}
    
    async def _extract_paper_sections(self, text: str) -> Dict[str, str]:
        """Extract standard academic paper sections"""
        sections = {}
        
        # Common section headers
        section_patterns = {
            "abstract": r"abstract\s*\n(.*?)(?=\n\s*(?:introduction|keywords|\d+\.))",
            "introduction": r"(?:1\.|introduction)\s*\n(.*?)(?=\n\s*(?:2\.|related work|methodology))",
            "methodology": r"(?:methodology|methods|approach)\s*\n(.*?)(?=\n\s*(?:results|experiments|evaluation))",
            "results": r"(?:results|experiments|evaluation)\s*\n(.*?)(?=\n\s*(?:discussion|conclusion))",
            "conclusion": r"(?:conclusion|conclusions)\s*\n(.*?)(?=\n\s*(?:references|acknowledgments|$))"
        }
        
        for section_name, pattern in section_patterns.items():
            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)
            if match:
                sections[section_name] = match.group(1).strip()
        
        return sections
    
    async def _extract_methodology(self, sections: Dict[str, str]) -> str:
        """Extract methodology description"""
        methodology_text = ""
        
        # Look in methodology section first
        if "methodology" in sections:
            methodology_text = sections["methodology"]
        elif "introduction" in sections:
            # Look for methodology mentions in introduction
            intro_doc = self.nlp(sections["introduction"])
            for sent in intro_doc.sents:
                if any(re.search(pattern, sent.text, re.IGNORECASE) 
                      for pattern in self.methodology_patterns):
                    methodology_text += sent.text + " "
        
        return methodology_text.strip()
    
    async def _extract_key_findings(self, sections: Dict[str, str]) -> List[str]:
        """Extract key research findings"""
        findings = []
        
        # Look in results and conclusion sections
        search_sections = ["results", "conclusion", "abstract"]
        
        for section_name in search_sections:
            if section_name in sections:
                doc = self.nlp(sections[section_name])
                for sent in doc.sents:
                    if any(re.search(pattern, sent.text, re.IGNORECASE) 
                          for pattern in self.finding_patterns):
                        findings.append(sent.text.strip())
        
        return findings[:5]  # Limit to top 5 findings
    
    async def _extract_technical_terms(self, text: str) -> List[str]:
        """Extract technical terms and concepts"""
        doc = self.nlp(text)
        
        # Extract noun phrases and named entities
        technical_terms = set()
        
        # Noun phrases
        for chunk in doc.noun_chunks:
            if len(chunk.text.split()) <= 4 and len(chunk.text) > 3:
                technical_terms.add(chunk.text.lower())
        
        # Named entities (focus on technical ones)
        for ent in doc.ents:
            if ent.label_ in ["ORG", "PRODUCT", "EVENT"] and len(ent.text) > 3:
                technical_terms.add(ent.text.lower())
        
        return list(technical_terms)[:20]
    
    async def generate_abstractive_summary(self, paper_text: str, 
                                         summary_request: SummaryRequest) -> Dict[str, Any]:
        """Generate abstractive summary using advanced NLP"""
        try:
            # Split text into manageable chunks
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=1024,
                chunk_overlap=100
            )
            chunks = text_splitter.split_text(paper_text)
            
            # Generate summaries for each chunk
            chunk_summaries = []
            for chunk in chunks[:5]:  # Limit to first 5 chunks
                if len(chunk) > 100:
                    summary = self.summarizer(
                        chunk,
                        max_length=150,
                        min_length=50,
                        do_sample=False
                    )
                    chunk_summaries.append(summary[0]['summary_text'])
            
            # Combine chunk summaries
            combined_summary = " ".join(chunk_summaries)
            
            # Generate final summary based on type
            final_summary = await self._generate_typed_summary(
                combined_summary, summary_request
            )
            
            # Calculate confidence score
            confidence = await self._calculate_summary_confidence(
                paper_text, final_summary["content"]
            )
            
            return {
                "content": final_summary["content"],
                "type": summary_request.summary_type,
                "key_points": final_summary["key_points"],
                "confidence": confidence,
                "methodology_summary": final_summary.get("methodology", ""),
                "findings_summary": final_summary.get("findings", ""),
                "implications": final_summary.get("implications", "")
            }
            
        except Exception as e:
            logger.error(f"Abstractive summarization failed: {e}")
            return {"error": str(e)}
    
    async def _generate_typed_summary(self, content: str, 
                                    request: SummaryRequest) -> Dict[str, Any]:
        """Generate summary based on specific type and audience"""
        
        prompts = {
            "detailed": """
            Create a comprehensive academic summary that includes:
            1. Main research objectives and hypotheses
            2. Methodology and experimental design
            3. Key findings and results
            4. Implications and significance
            5. Limitations and future work
            """,
            "technical": """
            Create a technical summary focusing on:
            1. Technical methodology and algorithms
            2. Experimental setup and parameters
            3. Quantitative results and metrics
            4. Technical contributions and innovations
            """,
            "layman": """
            Create an accessible summary for general audience:
            1. What problem does this research solve?
            2. How did researchers approach the problem?
            3. What did they discover?
            4. Why does this matter for society?
            """
        }
        
        prompt = prompts.get(request.summary_type, prompts["detailed"])
        
        # Use LLM for sophisticated summarization
        llm = ChatOpenAI(model_name="gpt-4", temperature=0.3)
        
        summary_prompt = f"""
        {prompt}
        
        Original content: {content}
        
        Target length: {request.max_length} words
        Target audience: {request.target_audience}
        
        Generate a well-structured summary:
        """
        
        response = await llm.agenerate([[{"role": "user", "content": summary_prompt}]])
        summary_content = response.generations[0][0].text
        
        # Extract key components
        return {
            "content": summary_content,
            "key_points": await self._extract_key_points(summary_content),
            "methodology": await self._extract_methodology_summary(content),
            "findings": await self._extract_findings_summary(content),
            "implications": await self._extract_implications(content)
        }

class CitationGraphAnalyzer:
    """Advanced citation network analysis"""
    
    def __init__(self, mcp_manager: MCPResearchManager):
        self.mcp_manager = mcp_manager
        self.citation_graph = nx.DiGraph()
        self.influence_scores = {}
        self.research_clusters = {}
        
    async def build_citation_graph(self, papers: List[Dict[str, Any]]):
        """Build comprehensive citation network"""
        try:
            # Create nodes for all papers
            for paper in papers:
                self.citation_graph.add_node(
                    paper["id"],
                    title=paper.get("title", ""),
                    authors=paper.get("authors", []),
                    year=paper.get("publication_date", datetime.now()).year,
                    categories=paper.get("categories", [])
                )
            
            # Add citation edges
            for paper in papers:
                paper_id = paper["id"]
                references = paper.get("references", [])
                
                for ref_id in references:
                    if self.citation_graph.has_node(ref_id):
                        self.citation_graph.add_edge(ref_id, paper_id)  # ref cites paper
            
            logger.info(f"Built citation graph: {len(self.citation_graph.nodes)} nodes, {len(self.citation_graph.edges)} edges")
            
        except Exception as e:
            logger.error(f"Citation graph building failed: {e}")
    
    async def analyze_paper_influence(self, paper_id: str) -> Dict[str, Any]:
        """Analyze paper's influence in research community"""
        try:
            if not self.citation_graph.has_node(paper_id):
                return {}
            
            # Calculate various influence metrics
            in_degree = self.citation_graph.in_degree(paper_id)  # Citations received
            out_degree = self.citation_graph.out_degree(paper_id)  # References made
            
            # PageRank score
            pagerank_scores = nx.pagerank(self.citation_graph)
            pagerank_score = pagerank_scores.get(paper_id, 0.0)
            
            # Betweenness centrality
            betweenness_scores = nx.betweenness_centrality(self.citation_graph)
            betweenness_score = betweenness_scores.get(paper_id, 0.0)
            
            # Find influential citing papers
            citing_papers = list(self.citation_graph.successors(paper_id))
            influential_citing = sorted(
                citing_papers,
                key=lambda p: pagerank_scores.get(p, 0.0),
                reverse=True
            )[:5]
            
            # Calculate temporal influence
            paper_year = self.citation_graph.nodes[paper_id].get("year", 2000)
            current_year = datetime.now().year
            age_factor = max(0.1, 1.0 - (current_year - paper_year) * 0.05)
            
            influence_score = (
                in_degree * 0.4 +
                pagerank_score * 1000 * 0.3 +
                betweenness_score * 100 * 0.2 +
                age_factor * 0.1
            )
            
            return {
                "paper_id": paper_id,
                "citations_received": in_degree,
                "references_made": out_degree,
                "pagerank_score": pagerank_score,
                "betweenness_centrality": betweenness_score,
                "influence_score": influence_score,
                "influential_citing_papers": influential_citing,
                "research_impact": self._categorize_impact(influence_score)
            }
            
        except Exception as e:
            logger.error(f"Influence analysis failed: {e}")
            return {}
    
    def _categorize_impact(self, influence_score: float) -> str:
        """Categorize research impact based on influence score"""
        if influence_score > 10:
            return "high_impact"
        elif influence_score > 5:
            return "moderate_impact"
        elif influence_score > 1:
            return "emerging_impact"
        else:
            return "limited_impact"
    
    async def identify_research_clusters(self) -> Dict[str, List[str]]:
        """Identify research clusters and communities"""
        try:
            # Use community detection algorithm
            communities = nx.community.greedy_modularity_communities(
                self.citation_graph.to_undirected()
            )
            
            clusters = {}
            for i, community in enumerate(communities):
                cluster_name = f"cluster_{i}"
                clusters[cluster_name] = list(community)
            
            self.research_clusters = clusters
            return clusters
            
        except Exception as e:
            logger.error(f"Cluster identification failed: {e}")
            return {}
    
    async def analyze_research_trends(self, time_window: int = 5) -> Dict[str, Any]:
        """Analyze temporal research trends"""
        try:
            current_year = datetime.now().year
            recent_papers = [
                (node, data) for node, data in self.citation_graph.nodes(data=True)
                if data.get("year", 0) >= current_year - time_window
            ]
            
            # Analyze category trends
            category_trends = defaultdict(int)
            for _, data in recent_papers:
                for category in data.get("categories", []):
                    category_trends[category] += 1
            
            # Find emerging topics
            emerging_topics = sorted(
                category_trends.items(),
                key=lambda x: x[1],
                reverse=True
            )[:10]
            
            # Analyze citation patterns
            citation_growth = {}
            for year in range(current_year - time_window, current_year + 1):
                year_papers = [
                    node for node, data in self.citation_graph.nodes(data=True)
                    if data.get("year", 0) == year
                ]
                citation_growth[year] = len(year_papers)
            
            return {
                "time_window": time_window,
                "emerging_topics": emerging_topics,
                "citation_growth": citation_growth,
                "total_recent_papers": len(recent_papers),
                "research_velocity": len(recent_papers) / time_window
            }
            
        except Exception as e:
            logger.error(f"Trend analysis failed: {e}")
            return {}

class BERTopicAnalyzer:
    """BERTopic-based topic modeling for research papers"""
    
    def __init__(self):
        # Initialize UMAP and HDBSCAN for BERTopic
        umap_model = UMAP(
            n_neighbors=15,
            n_components=5,
            min_dist=0.0,
            metric='cosine',
            random_state=42
        )
        
        hdbscan_model = HDBSCAN(
            min_cluster_size=5,
            metric='euclidean',
            cluster_selection_method='eom'
        )
        
        # Initialize BERTopic
        self.topic_model = BERTopic(
            umap_model=umap_model,
            hdbscan_model=hdbscan_model,
            vectorizer_model=CountVectorizer(
                stop_words="english",
                ngram_range=(1, 3),
                min_df=5
            ),
            representation_model=None,
            verbose=True
        )
        
        self.topics_fitted = False
        self.topic_evolution = {}
    
    async def analyze_research_topics(self, papers: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze research topics using BERTopic"""
        try:
            # Prepare documents
            documents = []
            paper_metadata = []
            
            for paper in papers:
                # Combine title and abstract for topic modeling
                doc_text = f"{paper.get('title', '')} {paper.get('abstract', '')}"
                if len(doc_text.strip()) > 50:  # Minimum length check
                    documents.append(doc_text)
                    paper_metadata.append({
                        "id": paper["id"],
                        "year": paper.get("publication_date", datetime.now()).year,
                        "authors": paper.get("authors", [])
                    })
            
            if len(documents) < 10:
                logger.warning("Insufficient documents for topic modeling")
                return {}
            
            # Fit BERTopic model
            topics, probabilities = self.topic_model.fit_transform(documents)
            self.topics_fitted = True
            
            # Get topic information
            topic_info = self.topic_model.get_topic_info()
            
            # Analyze topic evolution over time
            timestamps = [meta["year"] for meta in paper_metadata]
            topics_over_time = self.topic_model.topics_over_time(
                documents, timestamps, nr_bins=10
            )
            
            # Find representative papers for each topic
            topic_papers = defaultdict(list)
            for i, topic in enumerate(topics):
                if topic != -1:  # Exclude noise topic
                    topic_papers[topic].append(paper_metadata[i])
            
            # Generate topic summaries
            topic_summaries = {}
            for topic_id in topic_info['Topic'].unique():
                if topic_id != -1:
                    topic_words = self.topic_model.get_topic(topic_id)
                    topic_summaries[topic_id] = {
                        "keywords": [word for word, _ in topic_words[:10]],
                        "paper_count": len(topic_papers[topic_id]),
                        "representative_papers": [
                            paper["id"] for paper in topic_papers[topic_id][:5]
                        ]
                    }
            
            return {
                "total_topics": len(topic_info) - 1,  # Exclude noise topic
                "topic_summaries": topic_summaries,
                "topic_evolution": topics_over_time.to_dict(),
                "noise_papers": sum(1 for t in topics if t == -1),
                "topic_distribution": dict(Counter(topics))
            }
            
        except Exception as e:
            logger.error(f"Topic analysis failed: {e}")
            return {}
    
    async def get_paper_topics(self, paper_text: str) -> Dict[str, Any]:
        """Get topic assignments for a specific paper"""
        try:
            if not self.topics_fitted:
                logger.warning("Topic model not fitted yet")
                return {}
            
            # Transform new document
            topics, probabilities = self.topic_model.transform([paper_text])
            
            topic_id = topics[0]
            confidence = probabilities[0][topic_id] if topic_id != -1 else 0.0
            
            if topic_id != -1:
                topic_words = self.topic_model.get_topic(topic_id)
                return {
                    "topic_id": topic_id,
                    "confidence": confidence,
                    "keywords": [word for word, _ in topic_words[:10]],
                    "topic_label": f"Topic_{topic_id}"
                }
            else:
                return {
                    "topic_id": -1,
                    "confidence": 0.0,
                    "keywords": [],
                    "topic_label": "Unassigned"
                }
                
        except Exception as e:
            logger.error(f"Paper topic assignment failed: {e}")
            return {}

class ResearchPaperAPI:
    """FastAPI application for research paper analysis"""
    
    def __init__(self, nlp_processor: AcademicNLPProcessor, 
                 citation_analyzer: CitationGraphAnalyzer,
                 topic_analyzer: BERTopicAnalyzer,
                 mcp_manager: MCPResearchManager,
                 session_factory):
        self.app = FastAPI(title="AI-Powered Research Paper Summarization API")
        self.nlp_processor = nlp_processor
        self.citation_analyzer = citation_analyzer
        self.topic_analyzer = topic_analyzer
        self.mcp_manager = mcp_manager
        self.session_factory = session_factory
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """Setup CORS middleware"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def setup_routes(self):
        """Setup API routes"""
        
        from pydantic import BaseModel
        
        class PaperUpload(BaseModel):
            title: str
            authors: List[str] = []
            abstract: str = ""
            full_text: str = ""
            arxiv_id: str = ""
            doi: str = ""
            
        class SummaryRequestModel(BaseModel):
            paper_id: str
            summary_type: str = "detailed"
            target_audience: str = "academic"
            max_length: int = 500
            focus_areas: List[str] = []
        
        @self.app.post("/papers/upload")
        async def upload_paper(paper: PaperUpload, background_tasks: BackgroundTasks):
            try:
                paper_id = str(uuid.uuid4())
                
                # Store paper in database
                async with self.session_factory() as session:
                    research_paper = ResearchPaper(
                        id=paper_id,
                        title=paper.title,
                        authors=paper.authors,
                        abstract=paper.abstract,
                        full_text=paper.full_text,
                        arxiv_id=paper.arxiv_id,
                        doi=paper.doi,
                        publication_date=datetime.utcnow(),
                        metadata={"uploaded": True}
                    )
                    session.add(research_paper)
                    await session.commit()
                
                # Process paper in background
                background_tasks.add_task(
                    self._process_paper_background, paper_id, paper.dict()
                )
                
                return {"paper_id": paper_id, "status": "uploaded"}
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/papers/summarize")
        async def summarize_paper(request: SummaryRequestModel):
            try:
                # Get paper from database
                async with self.session_factory() as session:
                    result = await session.execute(
                        "SELECT * FROM research_papers WHERE id = ?", (request.paper_id,)
                    )
                    paper = result.fetchone()
                
                if not paper:
                    raise HTTPException(status_code=404, detail="Paper not found")
                
                # Generate summary
                paper_text = f"{paper.title} {paper.abstract} {paper.full_text}"
                summary_request = SummaryRequest(
                    paper_id=request.paper_id,
                    summary_type=request.summary_type,
                    target_audience=request.target_audience,
                    max_length=request.max_length,
                    focus_areas=request.focus_areas
                )
                
                summary = await self.nlp_processor.generate_abstractive_summary(
                    paper_text, summary_request
                )
                
                # Store summary
                summary_id = str(uuid.uuid4())
                async with self.session_factory() as session:
                    paper_summary = PaperSummary(
                        id=summary_id,
                        paper_id=request.paper_id,
                        summary_type=request.summary_type,
                        summary_content=summary["content"],
                        key_findings=summary.get("key_points", []),
                        methodology=summary.get("methodology_summary", ""),
                        implications=summary.get("implications", ""),
                        confidence_score=summary.get("confidence", 0.0),
                        model_version="v1.0"
                    )
                    session.add(paper_summary)
                    await session.commit()
                
                return {
                    "summary_id": summary_id,
                    "summary": summary
                }
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/papers/{paper_id}/analysis")
        async def get_paper_analysis(paper_id: str):
            try:
                # Get influence analysis
                influence = await self.citation_analyzer.analyze_paper_influence(paper_id)
                
                # Get topic analysis
                async with self.session_factory() as session:
                    result = await session.execute(
                        "SELECT full_text FROM research_papers WHERE id = ?", (paper_id,)
                    )
                    paper = result.fetchone()
                
                topics = {}
                if paper and paper.full_text:
                    topics = await self.topic_analyzer.get_paper_topics(paper.full_text)
                
                return {
                    "paper_id": paper_id,
                    "influence_analysis": influence,
                    "topic_analysis": topics
                }
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/research/trends")
        async def get_research_trends():
            try:
                trends = await self.citation_analyzer.analyze_research_trends()
                return trends
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/research/topics")
        async def get_research_topics():
            try:
                # Get all papers for topic analysis
                async with self.session_factory() as session:
                    result = await session.execute("SELECT * FROM research_papers")
                    papers = [dict(row._mapping) for row in result.fetchall()]
                
                topic_analysis = await self.topic_analyzer.analyze_research_topics(papers)
                return topic_analysis
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
    
    async def _process_paper_background(self, paper_id: str, paper_data: Dict[str, Any]):
        """Process paper in background"""
        try:
            # Create metadata
            metadata = PaperMetadata(
                title=paper_data["title"],
                authors=paper_data["authors"],
                publication_date=datetime.utcnow(),
                arxiv_id=paper_data.get("arxiv_id", ""),
                doi=paper_data.get("doi", "")
            )
            
            # Process with NLP
            full_text = f"{paper_data['title']} {paper_data['abstract']} {paper_data['full_text']}"
            analysis = await self.nlp_processor.process_paper(full_text, metadata)
            
            # Update database with analysis
            async with self.session_factory() as session:
                await session.execute(
                    "UPDATE research_papers SET metadata = ? WHERE id = ?",
                    (json.dumps(analysis), paper_id)
                )
                await session.commit()
            
            logger.info(f"Processed paper {paper_id}")
            
        except Exception as e:
            logger.error(f"Background paper processing failed: {e}")

async def demo():
    """Demo of the AI-Powered Research Paper Summarization System"""
    
    print("📚 AI-Powered Research Paper Summarization (MCP-Driven) Demo\n")
    
    try:
        # Initialize database
        engine = create_async_engine('sqlite+aiosqlite:///./research_papers.db')
        session_factory = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
        
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        
        # Initialize components
        mcp_manager = MCPResearchManager(session_factory)
        nlp_processor = AcademicNLPProcessor()
        citation_analyzer = CitationGraphAnalyzer(mcp_manager)
        topic_analyzer = BERTopicAnalyzer()
        
        print("✅ AI-Powered Research Summarization System initialized")
        print("✅ MCP research context management configured")
        print("✅ Academic NLP processing pipeline ready")
        print("✅ Citation graph analysis enabled")
        print("✅ BERTopic modeling configured")
        
        # Create sample research papers
        sample_papers = [
            {
                "title": "Attention Is All You Need",
                "authors": ["Ashish Vaswani", "Noam Shazeer", "Niki Parmar"],
                "abstract": "The dominant sequence transduction models are based on complex recurrent or convolutional neural networks. We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely.",
                "full_text": """
                INTRODUCTION
                Recurrent neural networks, long short-term memory and gated recurrent networks, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation.
                
                METHODOLOGY
                The Transformer follows this overall architecture using stacked self-attention and point-wise, fully connected layers for both the encoder and decoder. We employ multi-head attention mechanisms and position encodings.
                
                RESULTS
                On the WMT 2014 English-to-German translation task, our model achieves 28.4 BLEU, improving over existing best results. On the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.8.
                
                CONCLUSION
                We presented the Transformer, the first sequence transduction model based entirely on attention, replacing the recurrent layers most commonly used in encoder-decoder architectures with multi-headed self-attention.
                """,
                "categories": ["machine learning", "natural language processing", "neural networks"],
                "publication_date": datetime(2017, 6, 12)
            },
            {
                "title": "BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding",
                "authors": ["Jacob Devlin", "Ming-Wei Chang", "Kenton Lee"],
                "abstract": "We introduce a new language representation model called BERT, which stands for Bidirectional Encoder Representations from Transformers. BERT is designed to pre-train deep bidirectional representations from unlabeled text.",
                "full_text": """
                INTRODUCTION
                Language model pre-training has been shown to be effective for improving many natural language processing tasks. We introduce BERT (Bidirectional Encoder Representations from Transformers).
                
                METHODOLOGY
                BERT is designed to pre-train deep bidirectional representations from unlabeled text by jointly conditioning on both left and right context in all layers. We use a masked language model pre-training objective.
                
                RESULTS
                BERT obtains new state-of-the-art results on eleven natural language processing tasks, including pushing the GLUE score to 80.5%, MultiNLI accuracy to 86.7%, and SQuAD v1.1 F1 to 93.2.
                
                CONCLUSION
                BERT advances the state of the art for eleven NLP tasks. The pre-trained BERT model and code are available at github.com/google-research/bert.
                """,
                "categories": ["natural language processing", "transformers", "pre-training"],
                "publication_date": datetime(2018, 10, 11)
            },
            {
                "title": "GPT-3: Language Models are Few-Shot Learners",
                "authors": ["Tom B. Brown", "Benjamin Mann", "Nick Ryder"],
                "abstract": "We demonstrate that scaling up language models greatly improves task-agnostic, few-shot performance. We train GPT-3, an autoregressive language model with 175 billion parameters.",
                "full_text": """
                INTRODUCTION
                Recent work has demonstrated substantial gains on many NLP tasks by pre-training on a large corpus of text followed by fine-tuning on a specific task. We study the behavior of this approach as we scale up model size.
                
                METHODOLOGY
                We train GPT-3, an autoregressive language model with 175 billion parameters, 10x more than any previous non-sparse language model. We test its performance in the few-shot setting.
                
                RESULTS
                GPT-3 achieves strong performance on many NLP datasets, including translation, question-answering, and cloze tasks, as well as several tasks that require on-the-fly reasoning.
                
                CONCLUSION
                Our results show that scaling up language models greatly improves task-agnostic, few-shot performance, sometimes even reaching competitiveness with prior state-of-the-art fine-tuning approaches.
                """,
                "categories": ["language models", "few-shot learning", "large scale"],
                "publication_date": datetime(2020, 5, 28)
            }
        ]
        
        # Add papers to system
        print(f"\n📄 Adding Sample Research Papers...")
        paper_ids = []
        for paper_data in sample_papers:
            paper_id = str(uuid.uuid4())
            paper_ids.append(paper_id)
            
            # Store in database
            async with session_factory() as session:
                research_paper = ResearchPaper(
                    id=paper_id,
                    title=paper_data["title"],
                    authors=paper_data["authors"],
                    abstract=paper_data["abstract"],
                    full_text=paper_data["full_text"],
                    categories=paper_data["categories"],
                    publication_date=paper_data["publication_date"],
                    metadata={"sample": True}
                )
                session.add(research_paper)
                await session.commit()
            
            print(f"  ✅ Added: {paper_data['title'][:50]}... (ID: {paper_id[:8]})")
        
        # Build citation network
        print(f"\n🔗 Building Citation Network...")
        papers_for_graph = []
        async with session_factory() as session:
            result = await session.execute("SELECT * FROM research_papers")
            papers_for_graph = [dict(row._mapping) for row in result.fetchall()]
        
        await citation_analyzer.build_citation_graph(papers_for_graph)
        
        # Analyze topics
        print(f"\n🎯 Analyzing Research Topics...")
        topic_analysis = await topic_analyzer.analyze_research_topics(papers_for_graph)
        
        if topic_analysis:
            print(f"  📊 Identified {topic_analysis.get('total_topics', 0)} main topics")
            print(f"  🔍 Noise papers: {topic_analysis.get('noise_papers', 0)}")
        
        # Generate summaries
        print(f"\n📝 Generating Research Summaries...")
        
        summary_types = ["detailed", "technical", "layman"]
        
        for i, paper_id in enumerate(paper_ids[:2]):  # Limit to first 2 papers
            paper_data = sample_papers[i]
            print(f"\n--- Paper: {paper_data['title'][:40]}... ---")
            
            paper_text = f"{paper_data['title']} {paper_data['abstract']} {paper_data['full_text']}"
            
            for summary_type in summary_types:
                summary_request = SummaryRequest(
                    paper_id=paper_id,
                    summary_type=summary_type,
                    target_audience="academic" if summary_type != "layman" else "general",
                    max_length=300
                )
                
                summary = await nlp_processor.generate_abstractive_summary(
                    paper_text, summary_request
                )
                
                if "error" not in summary:
                    print(f"\n  📄 {summary_type.upper()} Summary:")
                    print(f"     {summary['content'][:200]}...")
                    print(f"     Confidence: {summary.get('confidence', 0):.2f}")
                    print(f"     Key Points: {len(summary.get('key_points', []))}")
        
        # Analyze paper influence
        print(f"\n📈 Analyzing Paper Influence...")
        for i, paper_id in enumerate(paper_ids):
            influence = await citation_analyzer.analyze_paper_influence(paper_id)
            if influence:
                paper_title = sample_papers[i]['title'][:40]
                print(f"  📊 {paper_title}...")
                print(f"     Impact: {influence.get('research_impact', 'unknown')}")
                print(f"     Citations: {influence.get('citations_received', 0)}")
                print(f"     Influence Score: {influence.get('influence_score', 0):.2f}")
        
        # Create researcher context
        print(f"\n👨‍🔬 Creating Researcher Context...")
        researcher_profile = {
            "interests": ["natural language processing", "machine learning", "transformers"],
            "department": "Computer Science",
            "research_focus": "deep learning",
            "collaboration_preference": "interdisciplinary"
        }
        
        context_id = await mcp_manager.create_research_context(
            "researcher_demo", researcher_profile
        )
        print(f"  👤 Created researcher context: {context_id[:8]}")
        
        # Simulate research interactions
        for paper_id in paper_ids[:2]:
            interaction_data = {
                "paper_id": paper_id,
                "type": "detailed_read",
                "engagement": 0.8,
                "topics": ["nlp", "transformers"],
                "relevance": 0.9
            }
            await mcp_manager.update_research_context("researcher_demo", interaction_data)
        
        research_context = mcp_manager.get_research_context("researcher_demo")
        print(f"  📚 Reading history: {len(research_context.get('recent_papers', []))} papers")
        print(f"  🎯 Top interests: {research_context.get('top_topics', [])[:3]}")
        
        # System capabilities
        print(f"\n🛠️ System Capabilities:")
        print(f"  ✅ Multi-type abstractive summarization")
        print(f"  ✅ Academic NLP with domain understanding")
        print(f"  ✅ Citation network analysis")
        print(f"  ✅ Research influence assessment")
        print(f"  ✅ BERTopic modeling for trend analysis")
        print(f"  ✅ MCP-driven researcher context")
        print(f"  ✅ Research paper relationship mapping")
        print(f"  ✅ Academic knowledge extraction")
        
        print(f"\n🎯 Research Applications:")
        print(f"  • Automated literature reviews")
        print(f"  • Research trend identification")
        print(f"  • Citation impact analysis")
        print(f"  • Academic collaboration discovery")
        print(f"  • Cross-disciplinary knowledge transfer")
        print(f"  • Research recommendation systems")
        
        print(f"\n📚 AI-Powered Research Paper Summarization demo completed!")
        
    except Exception as e:
        print(f"❌ Demo error: {e}")
        logger.error(f"Demo failed: {e}")

# Dependencies information
dependencies_info = """
# Install required dependencies:
pip install openai langchain
pip install transformers torch
pip install sentence-transformers
pip install bertopic umap-learn hdbscan
pip install spacy
pip install nltk
pip install networkx
pip install arxiv scholarly crossref
pip install PyMuPDF  # for PDF processing
pip install bibtexparser
pip install pandas numpy scikit-learn
pip install fastapi uvicorn
pip install sqlalchemy aiosqlite
pip install plotly matplotlib seaborn
pip install faiss-cpu chromadb

# Download spaCy model:
python -m spacy download en_core_web_sm

# Environment variables:
export OPENAI_API_KEY="your-openai-api-key"
export DATABASE_URL="sqlite+aiosqlite:///./research_papers.db"

# Optional for advanced features:
pip install torch-geometric  # For graph neural networks
pip install pyvis  # For interactive network visualization
pip install gensim  # For additional topic modeling
pip install textstat  # For readability analysis

# For production deployment:
pip install gunicorn redis celery
pip install prometheus-client  # For monitoring
pip install elasticsearch  # For search capabilities
"""

if __name__ == "__main__":
    print(dependencies_info)
    asyncio.run(demo())
````

## Project Summary

The AI-Powered Research Paper Summarization (MCP-Driven) system represents a revolutionary advancement in academic research intelligence that combines sophisticated natural language processing, citation network analysis, and contextual understanding to create comprehensive research ecosystems where scholarly knowledge is instantly accessible, intelligently summarized, and continuously organized for optimal research productivity and scientific discovery.

### Key Value Propositions

1. **Intelligent Academic Understanding**: Advanced MCP-driven system that comprehends complex scholarly content including methodologies, findings, and research contributions while maintaining scientific accuracy and domain-specific terminology understanding across diverse academic disciplines and research domains.

2. **Context-Aware Research Summarization**: Sophisticated abstractive summarization system that generates accurate, comprehensive summaries tailored to different audiences and research purposes while preserving critical scientific information and adapting to researcher preferences and academic contexts.

3. **Comprehensive Citation Intelligence**: Advanced citation graph analysis that identifies research trends, collaboration patterns, influential papers, and knowledge evolution while providing meaningful insights into research impact, academic influence, and scholarly network dynamics.

4. **Research Discovery Acceleration**: Intelligent topic modeling and trend analysis using BERTopic that enables automatic research categorization, emerging trend identification, and cross-disciplinary knowledge discovery while supporting comprehensive academic intelligence and research recommendation systems.

### Key Takeaways

- **Academic Productivity Revolution**: Dramatically reduces literature review time from weeks to hours while improving research quality through intelligent summarization, trend analysis, and comprehensive paper understanding that adapts to individual researcher needs and academic contexts
- **Scientific Knowledge Democratization**: Enables researchers at all levels to access expert-level insights and comprehensive research understanding regardless of their experience or domain expertise, potentially accelerating scientific discovery and interdisciplinary collaboration
- **Research Intelligence Enhancement**: Transforms passive paper repositories into active knowledge systems that understand research relationships, identify influential work, and provide predictive insights into emerging scientific trends and collaboration opportunities
- **Scalable Academic Innovation**: Provides sophisticated AI capabilities that support large-scale research analysis while maintaining scientific rigor, accuracy, and academic integrity required for scholarly research and scientific advancement

This AI-Powered Research Paper Summarization system empowers researchers and academic institutions by providing comprehensive research intelligence that dramatically improves literature review efficiency, research discovery quality, and scholarly productivity while maintaining the accuracy and rigor essential for scientific advancement and academic excellence.