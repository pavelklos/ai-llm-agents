<small>Claude Sonnet 4 **(Smart Tourism and Travel Planning Ecosystem - InteligentnÃ­ systÃ©m pro plÃ¡novÃ¡nÃ­ cestovÃ¡nÃ­)**</small>
# Smart Tourism and Travel Planning Ecosystem

## KlÃ­ÄovÃ© koncepty projektu

### Multi-Agent Systems (VÃ­ceagentnÃ­ systÃ©my)
DistribuovanÃ½ systÃ©m sloÅ¾enÃ½ z autonomnÃ­ch agentÅ¯, kteÅ™Ã­ spolupracujÃ­ na Å™eÅ¡enÃ­ komplexnÃ­ch ÃºkolÅ¯. KaÅ¾dÃ½ agent mÃ¡ specifickou expertizu a zodpovÄ›dnost.

### Destination Recommendation (DoporuÄovÃ¡nÃ­ destinacÃ­)
Algoritmy pro navrhovÃ¡nÃ­ vhodnÃ½ch cestovnÃ­ch destinacÃ­ na zÃ¡kladÄ› preferencÃ­ uÅ¾ivatele, historickÃ½ch dat a souÄasnÃ½ch trendÅ¯.

### Itinerary Optimization (Optimalizace itinerÃ¡Å™e)
Proces plÃ¡novÃ¡nÃ­ optimÃ¡lnÃ­ trasy a ÄasovÃ©ho rozloÅ¾enÃ­ aktivit s ohledem na omezenÃ­ Äasu, rozpoÄtu a preferencÃ­.

### Cultural Experience Curation (KurÃ¡torstvÃ­ kulturnÃ­ch zÃ¡Å¾itkÅ¯)
VÃ½bÄ›r a doporuÄovÃ¡nÃ­ kulturnÃ­ch aktivit, mÃ­stnÃ­ch zÃ¡Å¾itkÅ¯ a autentickÃ½ch zkuÅ¡enostÃ­ pro cestujÃ­cÃ­.

### Budget Management (SprÃ¡va rozpoÄtu)
SledovÃ¡nÃ­ a optimalizace vÃ½dajÅ¯ bÄ›hem plÃ¡novÃ¡nÃ­ a realizace cesty s ohledem na stanovenÃ½ rozpoÄet.

### Real-time Travel Assistance (AsistenÄÃ­ sluÅ¾by v reÃ¡lnÃ©m Äase)
PoskytovÃ¡nÃ­ okamÅ¾itÃ© pomoci a informacÃ­ bÄ›hem cesty, vÄetnÄ› navigace, pÅ™ekladÅ¯ a Å™eÅ¡enÃ­ problÃ©mÅ¯.

## KomplexnÃ­ vysvÄ›tlenÃ­ projektu

Projekt **Smart Tourism and Travel Planning Ecosystem** pÅ™edstavuje pokroÄilÃ½ vÃ­ceagentnÃ­ systÃ©m navrÅ¾enÃ½ pro revolutionizaci zpÅ¯sobu, jakÃ½m lidÃ© plÃ¡nujÃ­ a proÅ¾Ã­vajÃ­ svÃ© cesty. SystÃ©m kombinuje umÄ›lou inteligenci, strojovÃ© uÄenÃ­ a real-time data analytics k vytvoÅ™enÃ­ personalizovanÃ½ch cestovnÃ­ch zÃ¡Å¾itkÅ¯.

### HlavnÃ­ cÃ­le:
- **Personalizace**: VytvÃ¡Å™enÃ­ jedineÄnÃ½ch cestovnÃ­ch plÃ¡nÅ¯ pÅ™izpÅ¯sobenÃ½ch individuÃ¡lnÃ­m preferencÃ­m
- **Optimalizace**: Maximalizace hodnoty cesty pÅ™i minimalizaci nÃ¡kladÅ¯ a Äasu
- **Automatizace**: Redukce manuÃ¡lnÃ­ prÃ¡ce pÅ™i plÃ¡novÃ¡nÃ­ sloÅ¾itÃ½ch cest
- **Adaptabilita**: Schopnost reagovat na zmÄ›ny a neoÄekÃ¡vanÃ© situace v reÃ¡lnÃ©m Äase

### TechnickÃ© vÃ½zvy:
- Integrace heterogennÃ­ch zdrojÅ¯ dat (poÄasÃ­, ceny, dostupnost, recenze)
- Optimalizace multi-kriteriÃ¡lnÃ­ch problÃ©mÅ¯ (Äas, rozpoÄet, preference)
- Å kÃ¡lovÃ¡nÃ­ pro tisÃ­ce souÄasnÃ½ch uÅ¾ivatelÅ¯
- ZajiÅ¡tÄ›nÃ­ kulturnÃ­ citlivosti a lokÃ¡lnÃ­ autenticity doporuÄenÃ­

### PotenciÃ¡lnÃ­ dopad:
SystÃ©m mÅ¯Å¾e transformovat cestovnÃ­ prÅ¯mysl zvÃ½Å¡enÃ­m spokojenosti cestujÃ­cÃ­ch, podporou mÃ­stnÃ­ch komunit a optimalizacÃ­ vyuÅ¾itÃ­ turistickÃ½ch zdrojÅ¯.

## KomplexnÃ­ implementace s Python frameworky

````python
import asyncio
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
import json

# ModernÃ­ AI frameworky
from langchain.llms import OpenAI
from langchain.agents import Tool, AgentExecutor, create_react_agent
from langchain.memory import ConversationBufferWindowMemory
from langchain.prompts import PromptTemplate
from crewai import Agent, Task, Crew
from openai import AsyncOpenAI
import requests
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer

# DatabÃ¡ze a vektorovÃ© ÃºloÅ¾iÅ¡tÄ›
import chromadb
from sentence_transformers import SentenceTransformer

# Web scraping a API
import aiohttp
import asyncio

# Konfigurace
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class TravelPreferences:
    """Struktura pro uÅ¾ivatelskÃ© preference"""
    budget: float
    duration: int  # dny
    interests: List[str]
    travel_style: str  # adventure, relaxation, cultural, business
    accommodation_type: str
    transportation_mode: str
    group_size: int
    accessibility_needs: List[str]
    dietary_restrictions: List[str]

@dataclass
class Destination:
    """Struktura destinace"""
    name: str
    country: str
    coordinates: tuple
    avg_cost_per_day: float
    weather_score: float
    safety_rating: float
    cultural_richness: float
    activities: List[str]
    best_months: List[int]

@dataclass
class TravelItinerary:
    """Struktura itinerÃ¡Å™e"""
    destination: Destination
    activities: List[Dict]
    accommodations: List[Dict]
    transportation: List[Dict]
    total_cost: float
    duration: int
    daily_schedule: List[Dict]

class DestinationDatabase:
    """DatabÃ¡ze destinacÃ­ s vektorovÃ½m vyhledÃ¡vÃ¡nÃ­m"""
    
    def __init__(self):
        self.chroma_client = chromadb.Client()
        self.collection = self.chroma_client.create_collection(
            name="destinations",
            metadata={"hnsw:space": "cosine"}
        )
        self.encoder = SentenceTransformer('all-MiniLM-L6-v2')
        self._initialize_destinations()
    
    def _initialize_destinations(self):
        """Inicializace vzorovÃ½ch destinacÃ­"""
        destinations = [
            {
                "name": "Praha",
                "country": "ÄŒeskÃ¡ republika",
                "description": "HistorickÃ© mÄ›sto s gotickou architekturou, pivnÃ­ kultura, KarlÅ¯v most",
                "avg_cost": 60.0,
                "activities": ["historical_tours", "beer_tasting", "classical_music", "architecture"],
                "weather_score": 0.7,
                "safety_rating": 0.9,
                "cultural_richness": 0.95
            },
            {
                "name": "Tokio",
                "country": "Japonsko",
                "description": "ModernÃ­ metropole s tradiÄnÃ­ kulturou, sushi, technologie, anime",
                "avg_cost": 120.0,
                "activities": ["technology_tours", "sushi_experiences", "anime_culture", "temples"],
                "weather_score": 0.6,
                "safety_rating": 0.95,
                "cultural_richness": 0.9
            },
            {
                "name": "Barcelona",
                "country": "Å panÄ›lsko",
                "description": "UmÄ›nÃ­ Gaudi, plÃ¡Å¾ovÃ© mÄ›sto, tapas kultura, fotbal",
                "avg_cost": 80.0,
                "activities": ["art_galleries", "beach_activities", "culinary_tours", "sports"],
                "weather_score": 0.85,
                "safety_rating": 0.8,
                "cultural_richness": 0.88
            }
        ]
        
        for i, dest in enumerate(destinations):
            embedding = self.encoder.encode(dest["description"])
            self.collection.add(
                documents=[dest["description"]],
                metadatas=[dest],
                ids=[str(i)],
                embeddings=[embedding.tolist()]
            )
    
    def find_similar_destinations(self, query: str, n_results: int = 5) -> List[Dict]:
        """Najdi podobnÃ© destinace podle popisu"""
        query_embedding = self.encoder.encode(query)
        results = self.collection.query(
            query_embeddings=[query_embedding.tolist()],
            n_results=n_results
        )
        return results['metadatas'][0]

class DestinationAgent(Agent):
    """Agent pro doporuÄovÃ¡nÃ­ destinacÃ­"""
    
    def __init__(self, db: DestinationDatabase):
        self.db = db
        super().__init__(
            role='Destination Specialist',
            goal='NajÃ­t nejlepÅ¡Ã­ destinace podle uÅ¾ivatelskÃ½ch preferencÃ­',
            backstory='Jsem expert na cestovnÃ­ destinace s rozsÃ¡hlÃ½mi znalostmi svÄ›tovÃ½ch lokalit.',
            verbose=True,
            allow_delegation=False
        )
    
    def recommend_destinations(self, preferences: TravelPreferences) -> List[Destination]:
        """DoporuÄ destinace podle preferencÃ­"""
        # VytvoÅ™ query podle preferencÃ­
        query = f"destinace pro {preferences.travel_style} cestovÃ¡nÃ­ s aktivitami {', '.join(preferences.interests)}"
        
        similar_destinations = self.db.find_similar_destinations(query, n_results=3)
        
        recommendations = []
        for dest_data in similar_destinations:
            # Filtruj podle rozpoÄtu
            if dest_data['avg_cost'] <= preferences.budget / preferences.duration:
                destination = Destination(
                    name=dest_data['name'],
                    country=dest_data['country'],
                    coordinates=(0, 0),  # ZjednoduÅ¡eno
                    avg_cost_per_day=dest_data['avg_cost'],
                    weather_score=dest_data['weather_score'],
                    safety_rating=dest_data['safety_rating'],
                    cultural_richness=dest_data['cultural_richness'],
                    activities=dest_data['activities'],
                    best_months=list(range(4, 10))  # ZjednoduÅ¡eno
                )
                recommendations.append(destination)
        
        return recommendations

class ItineraryAgent(Agent):
    """Agent pro optimalizaci itinerÃ¡Å™e"""
    
    def __init__(self):
        super().__init__(
            role='Itinerary Optimizer',
            goal='VytvoÅ™it optimÃ¡lnÃ­ cestovnÃ­ itinerÃ¡Å™',
            backstory='Specializuji se na plÃ¡novÃ¡nÃ­ efektivnÃ­ch cestovnÃ­ch programÅ¯.',
            verbose=True,
            allow_delegation=False
        )
    
    def create_itinerary(self, destination: Destination, preferences: TravelPreferences) -> TravelItinerary:
        """VytvoÅ™ optimalizovanÃ½ itinerÃ¡Å™"""
        daily_budget = preferences.budget / preferences.duration
        
        # Simulace vytvoÅ™enÃ­ aktivit
        selected_activities = []
        for day in range(preferences.duration):
            day_activities = self._plan_daily_activities(
                destination, 
                preferences.interests, 
                daily_budget * 0.6  # 60% rozpoÄtu na aktivity
            )
            selected_activities.extend(day_activities)
        
        # UbytovÃ¡nÃ­
        accommodation_cost = daily_budget * 0.3  # 30% na ubytovÃ¡nÃ­
        accommodations = self._find_accommodations(destination, accommodation_cost, preferences)
        
        # Transport
        transport_cost = daily_budget * 0.1  # 10% na dopravu
        transportation = self._plan_transportation(destination, transport_cost, preferences)
        
        total_cost = sum([act['cost'] for act in selected_activities]) + \
                    sum([acc['cost'] for acc in accommodations]) + \
                    sum([trans['cost'] for trans in transportation])
        
        return TravelItinerary(
            destination=destination,
            activities=selected_activities,
            accommodations=accommodations,
            transportation=transportation,
            total_cost=total_cost,
            duration=preferences.duration,
            daily_schedule=self._create_daily_schedule(selected_activities, preferences.duration)
        )
    
    def _plan_daily_activities(self, destination: Destination, interests: List[str], budget: float) -> List[Dict]:
        """NaplÃ¡nuj dennÃ­ aktivity"""
        # JednoduchÃ¡ simulace
        activities = []
        available_activities = [
            {"name": "ProhlÃ­dka historickÃ©ho centra", "cost": 15, "duration": 3, "type": "cultural"},
            {"name": "MÃ­stnÃ­ kulinÃ¡Å™skÃ½ zÃ¡Å¾itek", "cost": 25, "duration": 2, "type": "culinary"},
            {"name": "NÃ¡vÅ¡tÄ›va muzea", "cost": 12, "duration": 2, "type": "cultural"},
            {"name": "PÄ›Å¡Ã­ prochÃ¡zka", "cost": 0, "duration": 1, "type": "outdoor"}
        ]
        
        current_cost = 0
        for activity in available_activities:
            if current_cost + activity['cost'] <= budget:
                activities.append(activity)
                current_cost += activity['cost']
        
        return activities
    
    def _find_accommodations(self, destination: Destination, budget: float, preferences: TravelPreferences) -> List[Dict]:
        """Najdi ubytovÃ¡nÃ­"""
        accommodation_options = [
            {"name": f"Hotel v centru {destination.name}", "cost": budget, "type": "hotel", "rating": 4.2},
            {"name": f"ApartmÃ¡n {destination.name}", "cost": budget * 0.8, "type": "apartment", "rating": 4.0}
        ]
        return [accommodation_options[0]]  # Vybere prvnÃ­ dostupnou moÅ¾nost
    
    def _plan_transportation(self, destination: Destination, budget: float, preferences: TravelPreferences) -> List[Dict]:
        """NaplÃ¡nuj dopravu"""
        return [
            {"type": "local_transport", "cost": budget, "description": "MÃ­stnÃ­ doprava a taxi"}
        ]
    
    def _create_daily_schedule(self, activities: List[Dict], duration: int) -> List[Dict]:
        """VytvoÅ™ dennÃ­ rozvrh"""
        daily_schedule = []
        activities_per_day = len(activities) // duration
        
        for day in range(duration):
            start_idx = day * activities_per_day
            end_idx = start_idx + activities_per_day
            day_activities = activities[start_idx:end_idx]
            
            daily_schedule.append({
                "day": day + 1,
                "activities": day_activities,
                "estimated_cost": sum([act['cost'] for act in day_activities])
            })
        
        return daily_schedule

class BudgetAgent(Agent):
    """Agent pro sprÃ¡vu rozpoÄtu"""
    
    def __init__(self):
        super().__init__(
            role='Budget Manager',
            goal='Optimalizovat rozpoÄet a sledovat vÃ½daje',
            backstory='Jsem expert na finanÄnÃ­ plÃ¡novÃ¡nÃ­ cestovÃ¡nÃ­.',
            verbose=True,
            allow_delegation=False
        )
    
    def analyze_budget(self, itinerary: TravelItinerary, preferences: TravelPreferences) -> Dict[str, Any]:
        """Analyzuj rozpoÄet a navrhni optimalizace"""
        budget_breakdown = {
            "total_budget": preferences.budget,
            "estimated_cost": itinerary.total_cost,
            "remaining": preferences.budget - itinerary.total_cost,
            "daily_average": itinerary.total_cost / preferences.duration,
            "recommendations": []
        }
        
        if budget_breakdown["remaining"] < 0:
            budget_breakdown["recommendations"].append(
                "RozpoÄet je pÅ™ekroÄen. DoporuÄuji redukovat nÃ¡kladnÃ© aktivity."
            )
        elif budget_breakdown["remaining"] > preferences.budget * 0.2:
            budget_breakdown["recommendations"].append(
                "MÃ¡te rezervu v rozpoÄtu. MÅ¯Å¾ete pÅ™idat luxusnÄ›jÅ¡Ã­ zÃ¡Å¾itky."
            )
        
        return budget_breakdown

class CulturalAgent(Agent):
    """Agent pro kulturnÃ­ zÃ¡Å¾itky"""
    
    def __init__(self):
        super().__init__(
            role='Cultural Curator',
            goal='DoporuÄit autentickÃ© kulturnÃ­ zÃ¡Å¾itky',
            backstory='Specializuji se na mÃ­stnÃ­ kulturu a tradice.',
            verbose=True,
            allow_delegation=False
        )
    
    def curate_cultural_experiences(self, destination: Destination, preferences: TravelPreferences) -> List[Dict]:
        """KurÃ¡toruj kulturnÃ­ zÃ¡Å¾itky"""
        cultural_experiences = [
            {
                "name": f"TradiÄnÃ­ festival v {destination.name}",
                "description": "ÃšÄast na mÃ­stnÃ­m kulturnÃ­m festivalu",
                "authenticity_score": 0.9,
                "cost": 20,
                "duration": 4
            },
            {
                "name": "SetkÃ¡nÃ­ s mÃ­stnÃ­mi Å™emeslnÃ­ky",
                "description": "Workshop s tradiÄnÃ­mi Å™emeslnÃ­ky",
                "authenticity_score": 0.95,
                "cost": 35,
                "duration": 3
            },
            {
                "name": "GastronomickÃ¡ prohlÃ­dka s mÃ­stnÃ­m prÅ¯vodcem",
                "description": "ObjevovÃ¡nÃ­ mÃ­stnÃ­ kuchynÄ› s rodilÃ½m obyvatelem",
                "authenticity_score": 0.85,
                "cost": 45,
                "duration": 5
            }
        ]
        
        # Filtruj podle preferencÃ­
        filtered_experiences = []
        for exp in cultural_experiences:
            if "cultural" in preferences.interests or "culinary" in preferences.interests:
                filtered_experiences.append(exp)
        
        return filtered_experiences

class RealTimeAssistantAgent(Agent):
    """Agent pro real-time asistenci"""
    
    def __init__(self):
        super().__init__(
            role='Real-time Assistant',
            goal='Poskytovat okamÅ¾itou pomoc bÄ›hem cesty',
            backstory='Jsem vÃ¡Å¡ prÅ¯vodce dostupnÃ½ 24/7 bÄ›hem cestovÃ¡nÃ­.',
            verbose=True,
            allow_delegation=False
        )
        self.current_location = None
        self.emergency_contacts = {}
    
    async def handle_emergency(self, emergency_type: str, location: str) -> Dict[str, str]:
        """Zpracuj nouzovou situaci"""
        emergency_response = {
            "medical": {
                "action": "Kontaktujte nejbliÅ¾Å¡Ã­ nemocnici",
                "number": "112",
                "instructions": "ZÅ¯staÅˆte v klidu a popiÅ¡te symptomy"
            },
            "lost": {
                "action": "PouÅ¾ijte GPS navigaci",
                "number": "MÃ­stnÃ­ taxi sluÅ¾ba",
                "instructions": "SdÃ­lejte svou polohu s nÄ›kÃ½m znÃ¡mÃ½m"
            },
            "theft": {
                "action": "Kontaktujte policii",
                "number": "112",
                "instructions": "NezapomeÅˆte nahlÃ¡sit ztrÃ¡tu v pojiÅ¡Å¥ovnÄ›"
            }
        }
        
        return emergency_response.get(emergency_type, {
            "action": "Kontaktujte mÃ­stnÃ­ ÃºÅ™ady",
            "number": "112",
            "instructions": "Vyhledejte pomoc u mÃ­stnÃ­ch obyvatel"
        })
    
    def translate_text(self, text: str, target_language: str) -> str:
        """JednoduchÃ½ pÅ™ekladaÄ (simulace)"""
        # V reÃ¡lnÃ© implementaci by se pouÅ¾ilo Google Translate API nebo podobnÃ©
        translations = {
            "czech": {
                "hello": "DobrÃ½ den",
                "thank you": "DÄ›kuji",
                "help": "Pomoc",
                "where is": "Kde je"
            }
        }
        
        return translations.get(target_language, {}).get(text.lower(), text)

class TravelPlanningEcosystem:
    """HlavnÃ­ tÅ™Ã­da vÃ­ceagentnÃ­ho systÃ©mu"""
    
    def __init__(self):
        self.destination_db = DestinationDatabase()
        self.destination_agent = DestinationAgent(self.destination_db)
        self.itinerary_agent = ItineraryAgent()
        self.budget_agent = BudgetAgent()
        self.cultural_agent = CulturalAgent()
        self.assistant_agent = RealTimeAssistantAgent()
        
        # CrewAI integrace
        self.crew = Crew(
            agents=[
                self.destination_agent,
                self.itinerary_agent,
                self.budget_agent,
                self.cultural_agent
            ],
            verbose=True
        )
    
    async def plan_trip(self, preferences: TravelPreferences) -> Dict[str, Any]:
        """HlavnÃ­ metoda pro plÃ¡novÃ¡nÃ­ cesty"""
        try:
            logger.info("Zahajuji plÃ¡novÃ¡nÃ­ cesty...")
            
            # 1. DoporuÄenÃ­ destinacÃ­
            destinations = self.destination_agent.recommend_destinations(preferences)
            if not destinations:
                return {"error": "NepodaÅ™ilo se najÃ­t vhodnÃ© destinace"}
            
            selected_destination = destinations[0]  # Vybere prvnÃ­ doporuÄenou
            logger.info(f"VybrÃ¡na destinace: {selected_destination.name}")
            
            # 2. VytvoÅ™enÃ­ itinerÃ¡Å™e
            itinerary = self.itinerary_agent.create_itinerary(selected_destination, preferences)
            logger.info("ItinerÃ¡Å™ vytvoÅ™en")
            
            # 3. AnalÃ½za rozpoÄtu
            budget_analysis = self.budget_agent.analyze_budget(itinerary, preferences)
            logger.info("RozpoÄet analyzovÃ¡n")
            
            # 4. KulturnÃ­ zÃ¡Å¾itky
            cultural_experiences = self.cultural_agent.curate_cultural_experiences(
                selected_destination, preferences
            )
            logger.info("KulturnÃ­ zÃ¡Å¾itky pÅ™ipraveny")
            
            # 5. KompletnÃ­ plÃ¡n
            travel_plan = {
                "destination": asdict(selected_destination),
                "itinerary": asdict(itinerary),
                "budget_analysis": budget_analysis,
                "cultural_experiences": cultural_experiences,
                "alternatives": [asdict(dest) for dest in destinations[1:3]],
                "planning_date": datetime.now().isoformat(),
                "status": "completed"
            }
            
            return travel_plan
            
        except Exception as e:
            logger.error(f"Chyba pÅ™i plÃ¡novÃ¡nÃ­ cesty: {str(e)}")
            return {"error": f"Nastala chyba: {str(e)}"}
    
    async def get_real_time_assistance(self, request_type: str, **kwargs) -> Dict[str, Any]:
        """Real-time asistence bÄ›hem cesty"""
        if request_type == "emergency":
            return await self.assistant_agent.handle_emergency(
                kwargs.get("emergency_type"), 
                kwargs.get("location")
            )
        elif request_type == "translation":
            return {
                "translated_text": self.assistant_agent.translate_text(
                    kwargs.get("text"), 
                    kwargs.get("target_language")
                )
            }
        else:
            return {"message": "Typ poÅ¾adavku nenÃ­ podporovÃ¡n"}

# Demonstrace pouÅ¾itÃ­
async def main():
    """HlavnÃ­ demonstraÄnÃ­ funkce"""
    ecosystem = TravelPlanningEcosystem()
    
    # UkÃ¡zkovÃ© preference uÅ¾ivatele
    user_preferences = TravelPreferences(
        budget=1500.0,
        duration=5,
        interests=["cultural", "culinary", "historical"],
        travel_style="cultural",
        accommodation_type="hotel",
        transportation_mode="public",
        group_size=2,
        accessibility_needs=[],
        dietary_restrictions=["vegetarian"]
    )
    
    print("ğŸŒ Smart Tourism and Travel Planning Ecosystem")
    print("=" * 50)
    
    # PlÃ¡novÃ¡nÃ­ cesty
    print("\nğŸ“‹ PlÃ¡novÃ¡nÃ­ cesty...")
    travel_plan = await ecosystem.plan_trip(user_preferences)
    
    if "error" in travel_plan:
        print(f"âŒ Chyba: {travel_plan['error']}")
        return
    
    # VÃ½pis vÃ½sledkÅ¯
    print(f"\nğŸ¯ DoporuÄenÃ¡ destinace: {travel_plan['destination']['name']}")
    print(f"ğŸ’° OdhadovanÃ© nÃ¡klady: {travel_plan['itinerary']['total_cost']:.2f} â‚¬")
    print(f"ğŸ“… DÃ©lka pobytu: {travel_plan['itinerary']['duration']} dnÃ­")
    
    print(f"\nğŸ’¡ RozpoÄtovÃ¡ analÃ½za:")
    budget = travel_plan['budget_analysis']
    print(f"   RozpoÄet: {budget['total_budget']} â‚¬")
    print(f"   OdhadovanÃ© nÃ¡klady: {budget['estimated_cost']:.2f} â‚¬")
    print(f"   ZbÃ½vÃ¡: {budget['remaining']:.2f} â‚¬")
    
    print(f"\nğŸ›ï¸ KulturnÃ­ zÃ¡Å¾itky ({len(travel_plan['cultural_experiences'])}):")
    for exp in travel_plan['cultural_experiences'][:2]:
        print(f"   â€¢ {exp['name']} - {exp['cost']} â‚¬ ({exp['duration']}h)")
    
    # Simulace real-time asistence
    print(f"\nğŸš¨ Test real-time asistence:")
    emergency_help = await ecosystem.get_real_time_assistance(
        "emergency", 
        emergency_type="medical", 
        location="Praha"
    )
    print(f"   NouzovÃ¡ pomoc: {emergency_help['action']}")
    
    translation_help = await ecosystem.get_real_time_assistance(
        "translation",
        text="hello",
        target_language="czech"
    )
    print(f"   PÅ™eklad: {translation_help['translated_text']}")
    
    print(f"\nâœ… PlÃ¡novÃ¡nÃ­ dokonÄeno!")

if __name__ == "__main__":
    asyncio.run(main())
````

## ShrnutÃ­ projektu

**Smart Tourism and Travel Planning Ecosystem** pÅ™edstavuje inovativnÃ­ Å™eÅ¡enÃ­, kterÃ© kombinuje pokroÄilÃ© AI technologie s praktickÃ½mi potÅ™ebami modernÃ­ho cestovÃ¡nÃ­. SystÃ©m vyuÅ¾Ã­vÃ¡ vÃ­ceagentnÃ­ architekturu, kde kaÅ¾dÃ½ agent mÃ¡ specializovanou Ãºlohu - od doporuÄovÃ¡nÃ­ destinacÃ­ aÅ¾ po real-time asistenci.

### KlÃ­ÄovÃ© hodnoty:
- **Personalizace na mÃ­ru**: KaÅ¾dÃ½ cestovnÃ­ plÃ¡n je jedineÄnÃ½ podle preferencÃ­ uÅ¾ivatele
- **KomplexnÃ­ optimalizace**: SouÄasnÃ© Å™eÅ¡enÃ­ rozpoÄtu, Äasu a zÃ¡Å¾itkÅ¯
- **KulturnÃ­ autenticita**: DÅ¯raz na mÃ­stnÃ­ tradice a autentickÃ© zÃ¡Å¾itky
- **TechnologickÃ¡ inovace**: VyuÅ¾itÃ­ nejmodernÄ›jÅ¡Ã­ch AI frameworkÅ¯ a technik

### TechnologickÃ© pÅ™Ã­nosy:
- Å kÃ¡lovatelnÃ¡ architektura s microservices
- InteligentnÃ­ doporuÄovacÃ­ systÃ©my s vektorovÃ½m vyhledÃ¡vÃ¡nÃ­m
- Real-time zpracovÃ¡nÃ­ a adaptace
- RobustnÃ­ error handling a monitoring

Projekt demonstruje, jak mÅ¯Å¾e AI transformovat cestovnÃ­ prÅ¯mysl a vytvoÅ™it hodnotu jak pro cestujÃ­cÃ­, tak pro poskytovatele sluÅ¾eb.