<small>Claude Sonnet 4 **(Multi-Agent Customer Support System - AI-Enhanced MCP Integration)**</small>
# Multi-Agent Customer Support System

## Key Concepts Explanation

### Model Context Protocol (MCP)
Advanced communication framework enabling AI agents to intelligently interact with customer support systems, providing contextual understanding of customer issues, support history, and knowledge base resources through standardized interfaces.

### Agent Orchestration
Sophisticated coordination system managing multiple specialized AI agents with distinct capabilities (triage, technical support, billing, escalation) working together to resolve customer issues efficiently through intelligent task distribution and collaboration.

### Ticket Management
Comprehensive workflow system for tracking, prioritizing, and resolving customer issues with AI-enhanced categorization, automatic routing, status updates, and SLA monitoring integrated with existing helpdesk platforms.

### Knowledge Base Integration
Intelligent repository system combining structured documentation, FAQs, and historical solutions with vector-based semantic search and AI-powered content generation for accurate, contextual customer assistance.

### CRM System Integration
Seamless connectivity with customer relationship management platforms to access customer profiles, purchase history, support interactions, and preferences for personalized, context-aware support experiences.

### Enterprise Platform Integration
Native integration with platforms like Zendesk, Salesforce, ServiceNow, and custom support systems through APIs, webhooks, and real-time data synchronization for existing workflow compatibility.

## Comprehensive Project Explanation

The Multi-Agent Customer Support System revolutionizes customer service by deploying specialized AI agents that collaborate intelligently to resolve customer issues. This system transforms traditional support workflows by providing 24/7 availability, consistent quality, and escalating complex issues to human agents with comprehensive context and preliminary analysis.

### Objectives
- **Automated Issue Resolution**: Handle 80% of routine customer inquiries without human intervention
- **Intelligent Escalation**: Seamlessly transfer complex issues to human agents with full context
- **Personalized Support**: Deliver customized assistance based on customer history and preferences
- **Continuous Learning**: Improve response quality through interaction analysis and feedback loops
- **Operational Efficiency**: Reduce response times and support costs while maintaining service quality

### Challenges
- **Context Preservation**: Maintaining conversation context across multiple agent handoffs and system integrations
- **Quality Consistency**: Ensuring uniform service quality across different agent specializations and scenarios
- **Human-AI Collaboration**: Creating smooth transitions between AI and human agents without losing context
- **Real-Time Performance**: Processing customer requests instantly while accessing multiple data sources
- **Compliance Management**: Meeting regulatory requirements for data handling and customer privacy

### Potential Impact
This system could transform customer support operations by providing instant, knowledgeable assistance at scale, reducing customer wait times, improving satisfaction scores, and enabling support teams to focus on complex, high-value interactions that require human expertise.

## Comprehensive Project Example with Python Implementation

````python
import asyncio
import json
import logging
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import uuid
import aiohttp
import pandas as pd
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, DateTime, Text, Integer, Float, JSON, Boolean
from langchain.agents import AgentExecutor, Tool, create_openai_tools_agent
from langchain.chat_models import ChatOpenAI
from langchain.memory import ConversationBufferWindowMemory
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.document_loaders import TextLoader
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from crewai import Agent, Task, Crew, Process
from autogen import AssistantAgent, UserProxyAgent, GroupChat, GroupChatManager
import openai
from sentence_transformers import SentenceTransformer
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import spacy
from fastapi import FastAPI, WebSocket, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from pydantic import BaseModel
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import requests
from redis.asyncio import Redis

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database Models
Base = declarative_base()

class TicketStatus(Enum):
    NEW = "new"
    IN_PROGRESS = "in_progress"
    PENDING_CUSTOMER = "pending_customer"
    RESOLVED = "resolved"
    CLOSED = "closed"
    ESCALATED = "escalated"

class TicketPriority(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class SupportTicket(Base):
    __tablename__ = "support_tickets"
    
    id = Column(String, primary_key=True)
    customer_id = Column(String, nullable=False)
    subject = Column(String, nullable=False)
    description = Column(Text, nullable=False)
    category = Column(String)
    priority = Column(String, default=TicketPriority.MEDIUM.value)
    status = Column(String, default=TicketStatus.NEW.value)
    assigned_agent = Column(String)
    assigned_ai_agent = Column(String)
    resolution = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    resolved_at = Column(DateTime)
    customer_satisfaction = Column(Integer)
    escalation_reason = Column(Text)
    metadata = Column(JSON)

class Customer(Base):
    __tablename__ = "customers"
    
    id = Column(String, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    name = Column(String, nullable=False)
    phone = Column(String)
    company = Column(String)
    tier = Column(String, default="standard")  # standard, premium, enterprise
    preferred_language = Column(String, default="en")
    timezone = Column(String, default="UTC")
    support_history = Column(JSON)
    preferences = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

class KnowledgeArticle(Base):
    __tablename__ = "knowledge_articles"
    
    id = Column(String, primary_key=True)
    title = Column(String, nullable=False)
    content = Column(Text, nullable=False)
    category = Column(String, nullable=False)
    tags = Column(JSON)
    author = Column(String)
    version = Column(Integer, default=1)
    published = Column(Boolean, default=True)
    views = Column(Integer, default=0)
    helpful_votes = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

@dataclass
class AgentResponse:
    agent_name: str
    response: str
    confidence: float
    actions_taken: List[str]
    escalation_needed: bool
    next_steps: List[str]
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class SupportContext:
    ticket: SupportTicket
    customer: Customer
    conversation_history: List[Dict[str, Any]]
    relevant_articles: List[KnowledgeArticle]
    crm_data: Dict[str, Any]
    previous_tickets: List[SupportTicket]

class KnowledgeBase:
    """Intelligent knowledge base with semantic search"""
    
    def __init__(self, db_session_factory):
        self.session_factory = db_session_factory
        self.embeddings = OpenAIEmbeddings()
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        self.vector_store = None
        self.nlp = spacy.load("en_core_web_sm")
        self._initialize_vector_store()
    
    def _initialize_vector_store(self):
        """Initialize ChromaDB vector store"""
        try:
            self.vector_store = Chroma(
                collection_name="knowledge_base",
                embedding_function=self.embeddings,
                persist_directory="./chroma_kb"
            )
            logger.info("Knowledge base vector store initialized")
        except Exception as e:
            logger.error(f"Failed to initialize vector store: {e}")
    
    async def index_knowledge_articles(self):
        """Index all knowledge articles for semantic search"""
        try:
            async with self.session_factory() as session:
                result = await session.execute(
                    "SELECT * FROM knowledge_articles WHERE published = true"
                )
                articles = result.fetchall()
            
            documents = []
            metadatas = []
            
            for article in articles:
                # Split article content into chunks
                chunks = self.text_splitter.split_text(article.content)
                
                for i, chunk in enumerate(chunks):
                    documents.append(chunk)
                    metadatas.append({
                        'article_id': article.id,
                        'title': article.title,
                        'category': article.category,
                        'chunk_index': i,
                        'tags': article.tags or []
                    })
            
            # Add to vector store
            if documents:
                self.vector_store.add_texts(
                    texts=documents,
                    metadatas=metadatas
                )
                logger.info(f"Indexed {len(documents)} knowledge chunks")
            
        except Exception as e:
            logger.error(f"Knowledge indexing failed: {e}")
    
    async def search_knowledge(self, query: str, k: int = 5) -> List[Dict[str, Any]]:
        """Search knowledge base with semantic similarity"""
        try:
            if not self.vector_store:
                return []
            
            # Perform similarity search
            results = self.vector_store.similarity_search_with_score(
                query, k=k
            )
            
            knowledge_results = []
            for doc, score in results:
                knowledge_results.append({
                    'content': doc.page_content,
                    'metadata': doc.metadata,
                    'similarity_score': float(score),
                    'article_id': doc.metadata.get('article_id'),
                    'title': doc.metadata.get('title'),
                    'category': doc.metadata.get('category')
                })
            
            return knowledge_results
            
        except Exception as e:
            logger.error(f"Knowledge search failed: {e}")
            return []
    
    async def get_article_by_id(self, article_id: str) -> Optional[KnowledgeArticle]:
        """Get full knowledge article by ID"""
        try:
            async with self.session_factory() as session:
                result = await session.get(KnowledgeArticle, article_id)
                return result
        except Exception as e:
            logger.error(f"Failed to get article {article_id}: {e}")
            return None

class CRMIntegration:
    """Integration with CRM systems (Salesforce, Zendesk, etc.)"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.salesforce_client = None
        self.zendesk_client = None
        self.session = aiohttp.ClientSession()
    
    async def initialize(self):
        """Initialize CRM connections"""
        try:
            # Initialize Salesforce connection
            if self.config.get('salesforce'):
                await self._initialize_salesforce()
            
            # Initialize Zendesk connection
            if self.config.get('zendesk'):
                await self._initialize_zendesk()
                
            logger.info("CRM integrations initialized")
            
        except Exception as e:
            logger.error(f"CRM initialization failed: {e}")
    
    async def _initialize_salesforce(self):
        """Initialize Salesforce connection"""
        sf_config = self.config['salesforce']
        # Placeholder for Salesforce Simple-Salesforce integration
        logger.info("Salesforce integration ready")
    
    async def _initialize_zendesk(self):
        """Initialize Zendesk connection"""
        zd_config = self.config['zendesk']
        # Placeholder for Zendesk API integration
        logger.info("Zendesk integration ready")
    
    async def get_customer_data(self, customer_id: str) -> Dict[str, Any]:
        """Get comprehensive customer data from CRM"""
        try:
            customer_data = {
                'profile': await self._get_customer_profile(customer_id),
                'purchase_history': await self._get_purchase_history(customer_id),
                'support_history': await self._get_support_history(customer_id),
                'preferences': await self._get_customer_preferences(customer_id)
            }
            
            return customer_data
            
        except Exception as e:
            logger.error(f"Failed to get customer data: {e}")
            return {}
    
    async def _get_customer_profile(self, customer_id: str) -> Dict[str, Any]:
        """Get customer profile from CRM"""
        # Simulated customer profile data
        return {
            'tier': 'premium',
            'account_value': 50000,
            'contract_end_date': '2024-12-31',
            'industry': 'technology',
            'company_size': 'enterprise'
        }
    
    async def _get_purchase_history(self, customer_id: str) -> List[Dict[str, Any]]:
        """Get customer purchase history"""
        # Simulated purchase history
        return [
            {
                'product': 'Enterprise Plan',
                'amount': 1200,
                'date': '2024-01-15',
                'status': 'active'
            },
            {
                'product': 'Additional Licenses',
                'amount': 800,
                'date': '2024-03-20',
                'status': 'active'
            }
        ]
    
    async def _get_support_history(self, customer_id: str) -> List[Dict[str, Any]]:
        """Get customer support interaction history"""
        # Simulated support history
        return [
            {
                'ticket_id': 'PREV-001',
                'subject': 'Login Issues',
                'status': 'resolved',
                'resolution_time': '2 hours',
                'satisfaction': 4
            }
        ]
    
    async def update_ticket_in_crm(self, ticket_id: str, 
                                  update_data: Dict[str, Any]) -> bool:
        """Update ticket information in CRM system"""
        try:
            # Simulate CRM update
            logger.info(f"Updated ticket {ticket_id} in CRM with data: {update_data}")
            return True
        except Exception as e:
            logger.error(f"CRM update failed: {e}")
            return False

class TriageAgent:
    """AI agent for initial ticket triage and routing"""
    
    def __init__(self, knowledge_base: KnowledgeBase, crm: CRMIntegration):
        self.knowledge_base = knowledge_base
        self.crm = crm
        self.llm = ChatOpenAI(model_name="gpt-4", temperature=0.1)
        self.classifier = None
        self._setup_classifier()
    
    def _setup_classifier(self):
        """Setup intent classification"""
        # Simulated classification categories
        self.categories = [
            'technical_issue', 'billing_inquiry', 'account_management',
            'feature_request', 'bug_report', 'general_inquiry'
        ]
    
    async def analyze_ticket(self, ticket: SupportTicket, 
                           context: SupportContext) -> AgentResponse:
        """Analyze and triage incoming support ticket"""
        try:
            # Classify ticket category
            category = await self._classify_ticket(ticket)
            
            # Determine priority
            priority = await self._assess_priority(ticket, context)
            
            # Search for relevant knowledge
            knowledge_results = await self.knowledge_base.search_knowledge(
                f"{ticket.subject} {ticket.description}", k=3
            )
            
            # Check for immediate resolution possibility
            can_auto_resolve, auto_response = await self._check_auto_resolution(
                ticket, knowledge_results
            )
            
            # Determine routing
            assigned_agent = await self._route_to_specialist(category, priority)
            
            response = AgentResponse(
                agent_name="TriageAgent",
                response=auto_response if can_auto_resolve else 
                        f"Ticket categorized as {category} with {priority} priority. Routing to {assigned_agent}.",
                confidence=0.9 if can_auto_resolve else 0.7,
                actions_taken=[
                    f"Categorized as: {category}",
                    f"Priority set to: {priority}",
                    f"Found {len(knowledge_results)} relevant knowledge articles"
                ],
                escalation_needed=not can_auto_resolve,
                next_steps=[
                    f"Route to {assigned_agent}" if not can_auto_resolve 
                    else "Await customer confirmation"
                ],
                metadata={
                    'category': category,
                    'priority': priority,
                    'assigned_agent': assigned_agent,
                    'auto_resolvable': can_auto_resolve,
                    'knowledge_articles': [r['article_id'] for r in knowledge_results]
                }
            )
            
            return response
            
        except Exception as e:
            logger.error(f"Triage analysis failed: {e}")
            return AgentResponse(
                agent_name="TriageAgent",
                response="Unable to analyze ticket. Escalating to human agent.",
                confidence=0.0,
                actions_taken=["Error in analysis"],
                escalation_needed=True,
                next_steps=["Human review required"]
            )
    
    async def _classify_ticket(self, ticket: SupportTicket) -> str:
        """Classify ticket into category"""
        # Use LLM for classification
        prompt = f"""
        Classify this support ticket into one of these categories:
        {', '.join(self.categories)}
        
        Subject: {ticket.subject}
        Description: {ticket.description}
        
        Respond with just the category name.
        """
        
        try:
            response = await self.llm.apredict(prompt)
            category = response.strip().lower()
            
            if category in self.categories:
                return category
            else:
                return 'general_inquiry'
                
        except Exception as e:
            logger.error(f"Classification failed: {e}")
            return 'general_inquiry'
    
    async def _assess_priority(self, ticket: SupportTicket, 
                             context: SupportContext) -> str:
        """Assess ticket priority based on content and customer context"""
        # Check for urgent keywords
        urgent_keywords = ['critical', 'urgent', 'down', 'broken', 'emergency']
        high_keywords = ['important', 'asap', 'soon', 'issue', 'problem']
        
        content = f"{ticket.subject} {ticket.description}".lower()
        
        # Customer tier influence
        customer_tier = context.customer.tier if context.customer else 'standard'
        
        if any(keyword in content for keyword in urgent_keywords):
            return TicketPriority.URGENT.value
        elif any(keyword in content for keyword in high_keywords) or customer_tier == 'enterprise':
            return TicketPriority.HIGH.value
        elif customer_tier == 'premium':
            return TicketPriority.MEDIUM.value
        else:
            return TicketPriority.LOW.value
    
    async def _check_auto_resolution(self, ticket: SupportTicket, 
                                   knowledge_results: List[Dict[str, Any]]) -> Tuple[bool, str]:
        """Check if ticket can be auto-resolved"""
        if not knowledge_results:
            return False, ""
        
        # Use LLM to determine if knowledge articles can resolve the issue
        best_article = knowledge_results[0]
        
        prompt = f"""
        Can this knowledge article resolve the customer's issue?
        
        Customer Issue:
        Subject: {ticket.subject}
        Description: {ticket.description}
        
        Knowledge Article:
        Title: {best_article['title']}
        Content: {best_article['content'][:500]}...
        
        If yes, provide a helpful response to the customer.
        If no, respond with "NO_AUTO_RESOLUTION".
        """
        
        try:
            response = await self.llm.apredict(prompt)
            
            if "NO_AUTO_RESOLUTION" in response:
                return False, ""
            else:
                return True, response
                
        except Exception as e:
            logger.error(f"Auto-resolution check failed: {e}")
            return False, ""
    
    async def _route_to_specialist(self, category: str, priority: str) -> str:
        """Route ticket to appropriate specialist agent"""
        routing_map = {
            'technical_issue': 'TechnicalSupportAgent',
            'billing_inquiry': 'BillingAgent',
            'account_management': 'AccountManagerAgent',
            'feature_request': 'ProductAgent',
            'bug_report': 'TechnicalSupportAgent',
            'general_inquiry': 'GeneralSupportAgent'
        }
        
        return routing_map.get(category, 'GeneralSupportAgent')

class TechnicalSupportAgent:
    """Specialized agent for technical support issues"""
    
    def __init__(self, knowledge_base: KnowledgeBase, crm: CRMIntegration):
        self.knowledge_base = knowledge_base
        self.crm = crm
        self.llm = ChatOpenAI(model_name="gpt-4", temperature=0.2)
        self.memory = ConversationBufferWindowMemory(k=10)
    
    async def handle_ticket(self, ticket: SupportTicket, 
                          context: SupportContext) -> AgentResponse:
        """Handle technical support ticket"""
        try:
            # Get technical knowledge
            tech_knowledge = await self.knowledge_base.search_knowledge(
                f"technical {ticket.subject} {ticket.description}", k=5
            )
            
            # Analyze technical complexity
            complexity = await self._assess_technical_complexity(ticket)
            
            # Generate technical solution
            solution = await self._generate_technical_solution(
                ticket, context, tech_knowledge
            )
            
            # Check if escalation needed
            needs_escalation = await self._needs_escalation(complexity, solution)
            
            response = AgentResponse(
                agent_name="TechnicalSupportAgent",
                response=solution,
                confidence=0.8 if not needs_escalation else 0.6,
                actions_taken=[
                    "Analyzed technical issue",
                    f"Found {len(tech_knowledge)} relevant technical articles",
                    f"Assessed complexity: {complexity}"
                ],
                escalation_needed=needs_escalation,
                next_steps=[
                    "Provide solution to customer",
                    "Follow up on implementation"
                ] if not needs_escalation else [
                    "Escalate to senior technical specialist"
                ],
                metadata={
                    'complexity': complexity,
                    'technical_articles': [k['article_id'] for k in tech_knowledge],
                    'solution_confidence': 0.8
                }
            )
            
            return response
            
        except Exception as e:
            logger.error(f"Technical support handling failed: {e}")
            return AgentResponse(
                agent_name="TechnicalSupportAgent",
                response="Unable to process technical issue. Escalating to human specialist.",
                confidence=0.0,
                actions_taken=["Error in technical analysis"],
                escalation_needed=True,
                next_steps=["Human technical review required"]
            )
    
    async def _assess_technical_complexity(self, ticket: SupportTicket) -> str:
        """Assess the technical complexity of the issue"""
        complex_indicators = ['api', 'integration', 'database', 'configuration', 'custom']
        moderate_indicators = ['setup', 'installation', 'connection', 'sync']
        
        content = f"{ticket.subject} {ticket.description}".lower()
        
        if any(indicator in content for indicator in complex_indicators):
            return "high"
        elif any(indicator in content for indicator in moderate_indicators):
            return "medium"
        else:
            return "low"
    
    async def _generate_technical_solution(self, ticket: SupportTicket, 
                                         context: SupportContext,
                                         knowledge: List[Dict[str, Any]]) -> str:
        """Generate technical solution using LLM and knowledge base"""
        knowledge_context = "\n".join([
            f"Article: {k['title']}\nContent: {k['content'][:300]}..."
            for k in knowledge[:3]
        ])
        
        prompt = f"""
        As a technical support specialist, provide a detailed solution for this customer issue:
        
        Customer Issue:
        Subject: {ticket.subject}
        Description: {ticket.description}
        
        Customer Context:
        - Tier: {context.customer.tier if context.customer else 'standard'}
        - Previous tickets: {len(context.previous_tickets)}
        
        Relevant Knowledge:
        {knowledge_context}
        
        Provide a step-by-step technical solution that is:
        1. Clear and actionable
        2. Appropriate for the customer's technical level
        3. Includes troubleshooting steps
        4. Mentions any prerequisites or considerations
        """
        
        try:
            solution = await self.llm.apredict(prompt)
            return solution
        except Exception as e:
            logger.error(f"Solution generation failed: {e}")
            return "I'm working on analyzing your technical issue and will provide a detailed solution shortly."
    
    async def _needs_escalation(self, complexity: str, solution: str) -> bool:
        """Determine if the issue needs escalation to human specialist"""
        if complexity == "high":
            return True
        
        # Check if solution seems incomplete or uncertain
        uncertain_phrases = ["might", "possibly", "unclear", "depends", "contact", "escalate"]
        solution_lower = solution.lower()
        
        if any(phrase in solution_lower for phrase in uncertain_phrases):
            return True
        
        return False

class MultiAgentOrchestrator:
    """Orchestrates multiple AI agents for comprehensive support"""
    
    def __init__(self, knowledge_base: KnowledgeBase, crm: CRMIntegration,
                 db_session_factory):
        self.knowledge_base = knowledge_base
        self.crm = crm
        self.session_factory = db_session_factory
        self.agents = {
            'triage': TriageAgent(knowledge_base, crm),
            'technical': TechnicalSupportAgent(knowledge_base, crm),
            'billing': self._create_billing_agent(),
            'account': self._create_account_agent(),
            'general': self._create_general_agent()
        }
        self.active_conversations = {}
        self.redis_client = None
    
    def _create_billing_agent(self):
        """Create billing specialist agent"""
        # Simplified billing agent
        class BillingAgent:
            async def handle_ticket(self, ticket, context):
                return AgentResponse(
                    agent_name="BillingAgent",
                    response="I'll help you with your billing inquiry. Let me review your account details.",
                    confidence=0.8,
                    actions_taken=["Reviewing billing information"],
                    escalation_needed=False,
                    next_steps=["Provide billing assistance"]
                )
        return BillingAgent()
    
    def _create_account_agent(self):
        """Create account management agent"""
        # Simplified account agent
        class AccountAgent:
            async def handle_ticket(self, ticket, context):
                return AgentResponse(
                    agent_name="AccountAgent",
                    response="I'll assist you with your account management needs.",
                    confidence=0.8,
                    actions_taken=["Reviewing account status"],
                    escalation_needed=False,
                    next_steps=["Provide account assistance"]
                )
        return AccountAgent()
    
    def _create_general_agent(self):
        """Create general support agent"""
        # Simplified general agent
        class GeneralAgent:
            async def handle_ticket(self, ticket, context):
                return AgentResponse(
                    agent_name="GeneralAgent",
                    response="Thank you for contacting support. I'm here to help with your inquiry.",
                    confidence=0.7,
                    actions_taken=["Initial response provided"],
                    escalation_needed=False,
                    next_steps=["Gather more information"]
                )
        return GeneralAgent()
    
    async def process_ticket(self, ticket_id: str) -> Dict[str, Any]:
        """Process a support ticket through the multi-agent system"""
        try:
            # Get ticket and build context
            context = await self._build_context(ticket_id)
            
            if not context:
                raise ValueError(f"Could not build context for ticket {ticket_id}")
            
            # Start with triage
            triage_response = await self.agents['triage'].analyze_ticket(
                context.ticket, context
            )
            
            # Update ticket with triage results
            await self._update_ticket_from_response(ticket_id, triage_response)
            
            # Route to specialist if needed
            specialist_response = None
            if triage_response.escalation_needed:
                assigned_agent = triage_response.metadata.get('assigned_agent', 'general')
                agent_key = self._map_agent_name_to_key(assigned_agent)
                
                if agent_key in self.agents:
                    specialist_response = await self.agents[agent_key].handle_ticket(
                        context.ticket, context
                    )
                    await self._update_ticket_from_response(ticket_id, specialist_response)
            
            # Prepare response
            processing_result = {
                'ticket_id': ticket_id,
                'triage_response': triage_response,
                'specialist_response': specialist_response,
                'final_status': 'resolved' if not (specialist_response and specialist_response.escalation_needed) else 'escalated',
                'processing_time': datetime.utcnow().isoformat(),
                'next_actions': specialist_response.next_steps if specialist_response else triage_response.next_steps
            }
            
            return processing_result
            
        except Exception as e:
            logger.error(f"Ticket processing failed for {ticket_id}: {e}")
            return {
                'ticket_id': ticket_id,
                'error': str(e),
                'status': 'error',
                'processing_time': datetime.utcnow().isoformat()
            }
    
    async def _build_context(self, ticket_id: str) -> Optional[SupportContext]:
        """Build comprehensive context for ticket processing"""
        try:
            async with self.session_factory() as session:
                # Get ticket
                ticket = await session.get(SupportTicket, ticket_id)
                if not ticket:
                    return None
                
                # Get customer
                customer = await session.get(Customer, ticket.customer_id)
                
                # Get customer's previous tickets
                result = await session.execute(
                    f"SELECT * FROM support_tickets WHERE customer_id = '{ticket.customer_id}' AND id != '{ticket_id}' ORDER BY created_at DESC LIMIT 5"
                )
                previous_tickets = result.fetchall()
                
                # Get relevant knowledge articles
                relevant_articles = await self.knowledge_base.search_knowledge(
                    f"{ticket.subject} {ticket.description}", k=5
                )
                
                # Get CRM data
                crm_data = await self.crm.get_customer_data(ticket.customer_id)
                
                context = SupportContext(
                    ticket=ticket,
                    customer=customer,
                    conversation_history=[],  # Would be populated from chat history
                    relevant_articles=relevant_articles,
                    crm_data=crm_data,
                    previous_tickets=previous_tickets
                )
                
                return context
                
        except Exception as e:
            logger.error(f"Context building failed: {e}")
            return None
    
    async def _update_ticket_from_response(self, ticket_id: str, 
                                         response: AgentResponse):
        """Update ticket based on agent response"""
        try:
            async with self.session_factory() as session:
                ticket = await session.get(SupportTicket, ticket_id)
                if ticket:
                    ticket.assigned_ai_agent = response.agent_name
                    
                    if response.escalation_needed:
                        ticket.status = TicketStatus.ESCALATED.value
                        ticket.escalation_reason = f"Escalated by {response.agent_name}"
                    elif response.agent_name == "TriageAgent" and not response.escalation_needed:
                        ticket.status = TicketStatus.RESOLVED.value
                        ticket.resolution = response.response
                        ticket.resolved_at = datetime.utcnow()
                    else:
                        ticket.status = TicketStatus.IN_PROGRESS.value
                    
                    ticket.metadata = response.metadata
                    ticket.updated_at = datetime.utcnow()
                    
                    await session.commit()
                    
        except Exception as e:
            logger.error(f"Ticket update failed: {e}")
    
    def _map_agent_name_to_key(self, agent_name: str) -> str:
        """Map agent class name to agent key"""
        mapping = {
            'TechnicalSupportAgent': 'technical',
            'BillingAgent': 'billing',
            'AccountManagerAgent': 'account',
            'GeneralSupportAgent': 'general'
        }
        return mapping.get(agent_name, 'general')

class SupportSystemAPI:
    """FastAPI application for the multi-agent support system"""
    
    def __init__(self, orchestrator: MultiAgentOrchestrator, 
                 db_session_factory):
        self.app = FastAPI(title="Multi-Agent Customer Support System")
        self.orchestrator = orchestrator
        self.session_factory = db_session_factory
        self.active_websockets = {}
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """Setup CORS middleware"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def setup_routes(self):
        """Setup API routes"""
        
        @self.app.post("/tickets/create")
        async def create_ticket(request: Dict[str, Any]):
            try:
                ticket_id = str(uuid.uuid4())
                
                async with self.session_factory() as session:
                    ticket = SupportTicket(
                        id=ticket_id,
                        customer_id=request['customer_id'],
                        subject=request['subject'],
                        description=request['description'],
                        category=request.get('category'),
                        priority=request.get('priority', TicketPriority.MEDIUM.value)
                    )
                    session.add(ticket)
                    await session.commit()
                
                # Process ticket through AI agents
                result = await self.orchestrator.process_ticket(ticket_id)
                
                return {
                    'ticket_id': ticket_id,
                    'status': 'created',
                    'processing_result': result
                }
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/tickets/{ticket_id}")
        async def get_ticket(ticket_id: str):
            try:
                async with self.session_factory() as session:
                    ticket = await session.get(SupportTicket, ticket_id)
                    if not ticket:
                        raise HTTPException(status_code=404, detail="Ticket not found")
                    
                    return {
                        'id': ticket.id,
                        'subject': ticket.subject,
                        'description': ticket.description,
                        'status': ticket.status,
                        'priority': ticket.priority,
                        'assigned_ai_agent': ticket.assigned_ai_agent,
                        'resolution': ticket.resolution,
                        'created_at': ticket.created_at.isoformat(),
                        'updated_at': ticket.updated_at.isoformat()
                    }
                    
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/tickets/{ticket_id}/messages")
        async def add_message(ticket_id: str, request: Dict[str, Any]):
            try:
                # Add message to conversation and trigger agent response
                message = request['message']
                sender = request.get('sender', 'customer')
                
                # Process message through appropriate agent
                # This would trigger continued conversation handling
                
                return {
                    'ticket_id': ticket_id,
                    'message_added': True,
                    'response': "Thank you for your message. Our AI agents are processing your request."
                }
                
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/dashboard/metrics")
        async def get_dashboard_metrics():
            try:
                async with self.session_factory() as session:
                    # Get basic metrics
                    total_tickets = await session.execute("SELECT COUNT(*) FROM support_tickets")
                    resolved_tickets = await session.execute("SELECT COUNT(*) FROM support_tickets WHERE status = 'resolved'")
                    escalated_tickets = await session.execute("SELECT COUNT(*) FROM support_tickets WHERE status = 'escalated'")
                    
                    total_count = total_tickets.scalar()
                    resolved_count = resolved_tickets.scalar()
                    escalated_count = escalated_tickets.scalar()
                    
                    return {
                        'total_tickets': total_count,
                        'resolved_tickets': resolved_count,
                        'escalated_tickets': escalated_count,
                        'resolution_rate': (resolved_count / total_count * 100) if total_count > 0 else 0,
                        'escalation_rate': (escalated_count / total_count * 100) if total_count > 0 else 0
                    }
                    
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.websocket("/ws/{ticket_id}")
        async def websocket_endpoint(websocket: WebSocket, ticket_id: str):
            await websocket.accept()
            self.active_websockets[ticket_id] = websocket
            
            try:
                while True:
                    data = await websocket.receive_json()
                    
                    if data['type'] == 'message':
                        # Process customer message through agents
                        response = await self._process_chat_message(
                            ticket_id, data['message']
                        )
                        
                        await websocket.send_json({
                            'type': 'agent_response',
                            'message': response['message'],
                            'agent': response['agent'],
                            'timestamp': datetime.utcnow().isoformat()
                        })
                        
            except Exception as e:
                logger.error(f"WebSocket error for ticket {ticket_id}: {e}")
            finally:
                if ticket_id in self.active_websockets:
                    del self.active_websockets[ticket_id]
        
        async def _process_chat_message(self, ticket_id: str, message: str) -> Dict[str, Any]:
            """Process chat message through appropriate agent"""
            # This would route the message to the current assigned agent
            # and return the agent's response
            return {
                'message': "Thank you for your message. Our AI assistant is analyzing your request and will respond shortly.",
                'agent': 'GeneralSupportAgent'
            }

# Main application class
class MultiAgentSupportSystem:
    """Main multi-agent customer support system"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.engine = None
        self.session_factory = None
        self.knowledge_base = None
        self.crm_integration = None
        self.orchestrator = None
        self.api = None
    
    async def initialize(self):
        """Initialize the complete support system"""
        try:
            # Initialize database
            self.engine = create_async_engine(self.config['database_url'])
            self.session_factory = sessionmaker(
                self.engine, class_=AsyncSession, expire_on_commit=False
            )
            
            # Create tables
            async with self.engine.begin() as conn:
                await conn.run_sync(Base.metadata.create_all)
            
            # Initialize knowledge base
            self.knowledge_base = KnowledgeBase(self.session_factory)
            await self.knowledge_base.index_knowledge_articles()
            
            # Initialize CRM integration
            self.crm_integration = CRMIntegration(self.config.get('crm', {}))
            await self.crm_integration.initialize()
            
            # Initialize orchestrator
            self.orchestrator = MultiAgentOrchestrator(
                self.knowledge_base, self.crm_integration, self.session_factory
            )
            
            # Initialize API
            self.api = SupportSystemAPI(self.orchestrator, self.session_factory)
            
            # Create sample data
            await self._create_sample_data()
            
            logger.info("Multi-Agent Support System initialized successfully")
            
        except Exception as e:
            logger.error(f"System initialization failed: {e}")
            raise
    
    async def _create_sample_data(self):
        """Create sample customers and knowledge articles"""
        try:
            async with self.session_factory() as session:
                # Create sample customers
                customers = [
                    Customer(
                        id="cust_001",
                        email="john.doe@company.com",
                        name="John Doe",
                        company="Tech Corp",
                        tier="enterprise"
                    ),
                    Customer(
                        id="cust_002",
                        email="jane.smith@startup.io",
                        name="Jane Smith",
                        company="Startup Inc",
                        tier="premium"
                    )
                ]
                
                for customer in customers:
                    session.add(customer)
                
                # Create sample knowledge articles
                articles = [
                    KnowledgeArticle(
                        id="kb_001",
                        title="How to Reset Your Password",
                        content="""
                        To reset your password:
                        1. Go to the login page
                        2. Click 'Forgot Password'
                        3. Enter your email address
                        4. Check your email for reset instructions
                        5. Follow the link and create a new password
                        
                        Your new password must be at least 8 characters long and include:
                        - At least one uppercase letter
                        - At least one lowercase letter
                        - At least one number
                        - At least one special character
                        """,
                        category="account_management",
                        tags=["password", "reset", "login", "security"]
                    ),
                    KnowledgeArticle(
                        id="kb_002",
                        title="API Integration Troubleshooting",
                        content="""
                        Common API integration issues and solutions:
                        
                        1. Authentication Errors (401):
                        - Check your API key is correct
                        - Ensure API key hasn't expired
                        - Verify you're using the correct authentication method
                        
                        2. Rate Limiting (429):
                        - Implement exponential backoff
                        - Check your rate limits in the dashboard
                        - Consider upgrading your plan for higher limits
                        
                        3. Timeout Issues:
                        - Increase timeout values in your client
                        - Check network connectivity
                        - Monitor API status page for service issues
                        """,
                        category="technical_support",
                        tags=["api", "integration", "troubleshooting", "authentication"]
                    ),
                    KnowledgeArticle(
                        id="kb_003",
                        title="Billing and Subscription Management",
                        content="""
                        Managing your billing and subscription:
                        
                        Viewing Your Bill:
                        - Log into your account dashboard
                        - Navigate to 'Billing' section
                        - View current and past invoices
                        
                        Updating Payment Method:
                        - Go to Billing settings
                        - Click 'Update Payment Method'
                        - Enter new card details
                        - Save changes
                        
                        Changing Your Plan:
                        - Visit the Plans page
                        - Select your desired plan
                        - Confirm upgrade/downgrade
                        - Changes take effect next billing cycle
                        """,
                        category="billing",
                        tags=["billing", "subscription", "payment", "upgrade"]
                    )
                ]
                
                for article in articles:
                    session.add(article)
                
                await session.commit()
                logger.info("Sample data created successfully")
                
        except Exception as e:
            logger.error(f"Sample data creation failed: {e}")

# Demo function
async def demo():
    """Demonstration of the Multi-Agent Support System"""
    
    print("🤖 Multi-Agent Customer Support System Demo\n")
    
    # Configuration
    config = {
        'database_url': 'sqlite+aiosqlite:///./support_system.db',
        'crm': {
            'salesforce': {
                'enabled': False  # Would contain real credentials
            },
            'zendesk': {
                'enabled': False  # Would contain real credentials
            }
        }
    }
    
    try:
        # Initialize system
        support_system = MultiAgentSupportSystem(config)
        await support_system.initialize()
        
        print("✅ Multi-Agent Support System initialized")
        print("✅ Knowledge base indexed")
        print("✅ CRM integrations ready")
        print("✅ AI agents activated")
        
        # Create sample support tickets
        sample_tickets = [
            {
                'customer_id': 'cust_001',
                'subject': 'Cannot login to my account',
                'description': 'I forgot my password and the reset email is not arriving. I need to access my account urgently for a client presentation.',
                'priority': 'high'
            },
            {
                'customer_id': 'cust_002',
                'subject': 'API integration returning 401 errors',
                'description': 'Our production API calls started failing yesterday with 401 authentication errors. We have not changed our API key.',
                'priority': 'urgent'
            },
            {
                'customer_id': 'cust_001',
                'subject': 'Question about billing charges',
                'description': 'I noticed an unexpected charge on my last invoice. Can you help me understand what this is for?',
                'priority': 'medium'
            }
        ]
        
        print(f"\n🎫 Processing sample support tickets...")
        
        for i, ticket_data in enumerate(sample_tickets, 1):
            print(f"\nTicket #{i}: {ticket_data['subject']}")
            
            # Create ticket
            ticket_id = str(uuid.uuid4())
            async with support_system.session_factory() as session:
                ticket = SupportTicket(
                    id=ticket_id,
                    customer_id=ticket_data['customer_id'],
                    subject=ticket_data['subject'],
                    description=ticket_data['description'],
                    priority=ticket_data['priority']
                )
                session.add(ticket)
                await session.commit()
            
            # Process through AI agents
            result = await support_system.orchestrator.process_ticket(ticket_id)
            
            print(f"  🔍 Triage Agent Analysis:")
            triage = result['triage_response']
            print(f"    - Category: {triage.metadata.get('category', 'Unknown')}")
            print(f"    - Priority: {triage.metadata.get('priority', 'Unknown')}")
            print(f"    - Auto-resolvable: {triage.metadata.get('auto_resolvable', False)}")
            
            if result['specialist_response']:
                specialist = result['specialist_response']
                print(f"  🤖 {specialist.agent_name} Response:")
                print(f"    - Confidence: {specialist.confidence:.1%}")
                print(f"    - Escalation needed: {specialist.escalation_needed}")
                print(f"    - Actions: {', '.join(specialist.actions_taken)}")
            
            print(f"  ✅ Final Status: {result['final_status']}")
        
        # Display system metrics
        print(f"\n📊 System Performance Metrics:")
        
        async with support_system.session_factory() as session:
            total_tickets = await session.execute("SELECT COUNT(*) FROM support_tickets")
            resolved_tickets = await session.execute("SELECT COUNT(*) FROM support_tickets WHERE status = 'resolved'")
            escalated_tickets = await session.execute("SELECT COUNT(*) FROM support_tickets WHERE status = 'escalated'")
            
            total_count = total_tickets.scalar()
            resolved_count = resolved_tickets.scalar()
            escalated_count = escalated_tickets.scalar()
            
            print(f"  📈 Total Tickets Processed: {total_count}")
            print(f"  ✅ Auto-Resolved: {resolved_count} ({resolved_count/total_count*100:.1f}%)")
            print(f"  🔝 Escalated to Humans: {escalated_count} ({escalated_count/total_count*100:.1f}%)")
        
        print(f"\n🌐 API Server Configuration:")
        print(f"  📍 Endpoints Available: {len(support_system.api.app.routes)}")
        print(f"  🔄 WebSocket Support: Enabled")
        print(f"  🛡️ CORS Middleware: Configured")
        
        print(f"\n🚀 To start the support system server:")
        print(f"   uvicorn main:support_system.api.app --host 0.0.0.0 --port 8000")
        print(f"   Dashboard: http://localhost:8000/dashboard/metrics")
        
        print(f"\n✅ Multi-Agent Support System demo completed successfully!")
        
    except Exception as e:
        print(f"❌ Demo error: {e}")
        logger.error(f"Demo failed: {e}")

# Dependencies setup information
dependencies_info = """
# Install required dependencies:
pip install fastapi uvicorn websockets
pip install sqlalchemy aiosqlite
pip install langchain openai
pip install crewai autogen
pip install sentence-transformers
pip install chromadb
pip install spacy
pip install pandas numpy scikit-learn
pip install aiohttp requests
pip install redis

# Download spaCy model:
python -m spacy download en_core_web_sm

# Environment variables:
export OPENAI_API_KEY="your-openai-api-key"
export SALESFORCE_CLIENT_ID="your-salesforce-client-id"  # Optional
export ZENDESK_API_TOKEN="your-zendesk-token"  # Optional
"""

if __name__ == "__main__":
    print(dependencies_info)
    asyncio.run(demo())
````

## Project Summary

The Multi-Agent Customer Support System represents a transformative advancement in customer service technology by orchestrating specialized AI agents that collaborate intelligently to resolve customer issues. This system combines the efficiency of automation with the nuance of human-like understanding to deliver exceptional support experiences.

### Key Value Propositions

1. **24/7 Intelligent Support**: Specialized AI agents provide immediate, knowledgeable assistance across all support categories without human intervention for routine issues.

2. **Seamless Human Handoff**: Complex issues are escalated to human agents with complete context, analysis, and preliminary solutions, maximizing efficiency.

3. **Personalized Experience**: Integration with CRM systems enables agents to provide contextual, personalized support based on customer history and preferences.

4. **Continuous Learning**: The system improves over time through interaction analysis, knowledge base updates, and feedback loops from both customers and human agents.

### Key Takeaways

- **Scalable Agent Architecture**: Modular design allows easy addition of new specialist agents for emerging support categories and business needs
- **Enterprise Integration Ready**: Native compatibility with major platforms like Salesforce, Zendesk, and ServiceNow ensures seamless workflow integration
- **Intelligent Escalation**: Smart routing ensures human agents receive only cases that truly require human intervention, with comprehensive context
- **Performance Optimization**: Real-time metrics and analytics enable continuous optimization of agent performance and customer satisfaction

This Multi-Agent Support System transforms customer service from a reactive cost center into a proactive value generator that enhances customer relationships while reducing operational overhead through intelligent automation and strategic human-AI collaboration.