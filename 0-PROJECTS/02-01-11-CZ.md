<small>Claude Sonnet 4 **(AutonomnÃ­ Studio pro VÃ½voj Her)**</small>
# Autonomous Game Development Studio

## KlÃ­ÄovÃ© Koncepty

### Multi-Agent Systems (MultiagentnÃ­ systÃ©my)
SystÃ©m sloÅ¾enÃ½ z vÃ­ce inteligentnÃ­ch agentÅ¯, kteÅ™Ã­ spolupracujÃ­ nebo soutÄ›Å¾Ã­ pÅ™i Å™eÅ¡enÃ­ komplexnÃ­ch Ãºloh. KaÅ¾dÃ½ agent mÃ¡ specifickou roli a schopnosti.

### Procedural Content Generation (ProcedurÃ¡lnÃ­ generovÃ¡nÃ­ obsahu)
AlgoritmickÃ¡ tvorba hernÃ­ho obsahu (mapy, ÃºrovnÄ›, pÅ™edmÄ›ty) mÃ­sto ruÄnÃ­ho vytvÃ¡Å™enÃ­. UmoÅ¾Åˆuje nekoneÄnou variabilitu a sniÅ¾uje nÃ¡klady na vÃ½voj.

### Game Balance Testing (TestovÃ¡nÃ­ hernÃ­ rovnovÃ¡hy)
Proces ovÄ›Å™ovÃ¡nÃ­, Å¾e hernÃ­ mechaniky poskytujÃ­ spravedlivou a zÃ¡bavnou zkuÅ¡enost. Zahrnuje analÃ½zu statistik, win-rate a hernÃ­ ekonomiky.

### Player Behavior Analysis (AnalÃ½za chovÃ¡nÃ­ hrÃ¡ÄÅ¯)
Studium hernÃ­ch dat pro pochopenÃ­, jak hrÃ¡Äi interagujÃ­ se hrou. PomÃ¡hÃ¡ optimalizovat hernÃ­ design a retenci hrÃ¡ÄÅ¯.

### Narrative Generation (GenerovÃ¡nÃ­ pÅ™Ã­bÄ›hu)
AI-Å™Ã­zenÃ¡ tvorba hernÃ­ch pÅ™Ã­bÄ›hÅ¯, dialogÅ¯ a narativnÃ­ch elementÅ¯. UmoÅ¾Åˆuje dynamickÃ© a personalizovanÃ© vyprÃ¡vÄ›nÃ­.

### Art Asset Creation (Tvorba umÄ›leckÃ½ch aktiv)
AutomatizovanÃ¡ nebo AI-asistovanÃ¡ tvorba vizuÃ¡lnÃ­ch a zvukovÃ½ch prvkÅ¯ hry.

## KomplexnÃ­ VysvÄ›tlenÃ­ Projektu

AutonomnÃ­ Studio pro VÃ½voj Her pÅ™edstavuje revoluÄnÃ­ pÅ™Ã­stup k tvorbÄ› videohier pomocÃ­ multiagentnÃ­ho systÃ©mu. Projekt kombinuje nÄ›kolik specialized AI agentÅ¯, z nichÅ¾ kaÅ¾dÃ½ je odpovÄ›dnÃ½ za specifickou oblast vÃ½voje hry.

### CÃ­le Projektu
- Automatizace celÃ©ho vÃ½vojovÃ©ho pipeline hry
- Redukce Äasu a nÃ¡kladÅ¯ na vÃ½voj
- UmoÅ¾nÄ›nÃ­ nekoneÄnÃ© variability obsahu
- KontinuÃ¡lnÃ­ optimalizace hernÃ­ zkuÅ¡enosti
- Personalizace her na zÃ¡kladÄ› chovÃ¡nÃ­ hrÃ¡ÄÅ¯

### TechnickÃ© VÃ½zvy
1. **Koordinace agentÅ¯**: Synchronizace prÃ¡ce rÅ¯znÃ½ch agentÅ¯
2. **KvalitnÃ­ vÃ½stup**: ZajiÅ¡tÄ›nÃ­ hernÃ­ kvality generovanÃ©ho obsahu
3. **Performance**: Optimalizace pro real-time generovÃ¡nÃ­
4. **Konzistence**: UdrÅ¾enÃ­ koherence napÅ™Ã­Ä rÅ¯znÃ½mi elementy hry

### PotenciÃ¡lnÃ­ Dopad
Demokratizace vÃ½voje her, umoÅ¾nÄ›nÃ­ indie vÃ½vojÃ¡Å™Å¯m tvoÅ™it AAA obsah, personalizovanÃ© hernÃ­ zÃ¡Å¾itky a novÃ© business modely v hernÃ­m prÅ¯myslu.

## KomplexnÃ­ PÅ™Ã­klad s Python ImplementacÃ­

````python
langchain==0.1.0
crewai==0.1.0
openai==1.0.0
pygame==2.5.0
numpy==1.24.0
pandas==2.0.0
matplotlib==3.7.0
requests==2.31.0
pydantic==2.5.0
````

````python
import asyncio
import json
import random
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
from crewai import Agent, Task, Crew
from langchain.llms import OpenAI
import numpy as np
import pandas as pd

@dataclass
class GameAsset:
    """TÅ™Ã­da pro reprezentaci hernÃ­ho aktiva"""
    asset_type: str
    name: str
    properties: Dict[str, Any]
    created_at: datetime
    
@dataclass
class GameLevel:
    """TÅ™Ã­da pro reprezentaci hernÃ­ ÃºrovnÄ›"""
    level_id: int
    layout: List[List[int]]
    difficulty: float
    objectives: List[str]
    assets: List[GameAsset]

@dataclass
class PlayerData:
    """TÅ™Ã­da pro data hrÃ¡Äe"""
    player_id: str
    playtime: float
    completed_levels: List[int]
    preferences: Dict[str, float]
    skill_level: float

class GameStudioOrchestrator:
    """HlavnÃ­ orchestrÃ¡tor hernÃ­ho studia"""
    
    def __init__(self, openai_api_key: str):
        self.api_key = openai_api_key
        self.llm = OpenAI(api_key=openai_api_key, temperature=0.7)
        
        # VytvoÅ™enÃ­ agentÅ¯
        self.content_generator = self._create_content_agent()
        self.balance_tester = self._create_balance_agent()
        self.narrative_writer = self._create_narrative_agent()
        self.asset_creator = self._create_asset_agent()
        self.behavior_analyst = self._create_analyst_agent()
        
        # Data storage
        self.game_assets: List[GameAsset] = []
        self.game_levels: List[GameLevel] = []
        self.player_data: List[PlayerData] = []
        
    def _create_content_agent(self) -> Agent:
        """VytvoÅ™Ã­ agenta pro generovÃ¡nÃ­ obsahu"""
        return Agent(
            role="Procedural Content Generator",
            goal="Generovat rozmanitÃ© a zÃ¡bavnÃ© hernÃ­ ÃºrovnÄ›",
            backstory="Jsem expert na procedurÃ¡lnÃ­ generovÃ¡nÃ­ obsahu s dÅ¯razem na hernÃ­ mechaniky a flow.",
            llm=self.llm,
            verbose=True
        )
    
    def _create_balance_agent(self) -> Agent:
        """VytvoÅ™Ã­ agenta pro testovÃ¡nÃ­ rovnovÃ¡hy"""
        return Agent(
            role="Game Balance Tester",
            goal="Analyzovat a optimalizovat hernÃ­ rovnovÃ¡hu",
            backstory="Specializuji se na hernÃ­ ekonomiku a zajiÅ¡Å¥ovÃ¡nÃ­ spravedlivÃ©ho gameplay.",
            llm=self.llm,
            verbose=True
        )
    
    def _create_narrative_agent(self) -> Agent:
        """VytvoÅ™Ã­ agenta pro vytvÃ¡Å™enÃ­ pÅ™Ã­bÄ›hu"""
        return Agent(
            role="Narrative Designer",
            goal="TvoÅ™it poutavÃ© hernÃ­ pÅ™Ã­bÄ›hy a dialogy",
            backstory="Jsem kreativnÃ­ spisovatel zamÄ›Å™enÃ½ na interaktivnÃ­ narativnÃ­ design.",
            llm=self.llm,
            verbose=True
        )
    
    def _create_asset_agent(self) -> Agent:
        """VytvoÅ™Ã­ agenta pro tvorbu aktiv"""
        return Agent(
            role="Asset Creator",
            goal="Navrhovat a specifikovat hernÃ­ aktiva",
            backstory="Specializuji se na hernÃ­ art design a technickÃ© specifikace aktiv.",
            llm=self.llm,
            verbose=True
        )
    
    def _create_analyst_agent(self) -> Agent:
        """VytvoÅ™Ã­ agenta pro analÃ½zu chovÃ¡nÃ­"""
        return Agent(
            role="Player Behavior Analyst",
            goal="Analyzovat chovÃ¡nÃ­ hrÃ¡ÄÅ¯ a doporuÄovat vylepÅ¡enÃ­",
            backstory="Jsem datovÃ½ analytik specializujÃ­cÃ­ se na hernÃ­ telemetrii a UX.",
            llm=self.llm,
            verbose=True
        )

class ProceduralGenerator:
    """GenerÃ¡tor procedurÃ¡lnÃ­ho obsahu"""
    
    @staticmethod
    def generate_level_layout(width: int, height: int, difficulty: float) -> List[List[int]]:
        """Generuje layout ÃºrovnÄ›"""
        layout = np.zeros((height, width), dtype=int)
        
        # ZÃ¡kladnÃ­ generace (0=prÃ¡zdnÃ©, 1=zeÄ, 2=nepÅ™Ã­tel, 3=poklad)
        for y in range(height):
            for x in range(width):
                if x == 0 or x == width-1 or y == 0 or y == height-1:
                    layout[y][x] = 1  # OkrajovÃ© zdi
                elif random.random() < difficulty * 0.3:
                    layout[y][x] = random.choice([1, 2])  # PÅ™ekÃ¡Å¾ky/nepÅ™Ã¡telÃ©
                elif random.random() < 0.1:
                    layout[y][x] = 3  # Poklady
        
        return layout.tolist()
    
    @staticmethod
    def generate_objectives(difficulty: float) -> List[str]:
        """Generuje cÃ­le ÃºrovnÄ›"""
        base_objectives = [
            "DostaÅˆ se do cÃ­le",
            "Poraz vÅ¡echny nepÅ™Ã¡tele",
            "SesbÃ­rej vÅ¡echny poklady"
        ]
        
        advanced_objectives = [
            "DokonÄi ÃºroveÅˆ pod ÄasovÃ½ limit",
            "NepouÅ¾ij vÃ­ce neÅ¾ 3 Å¾ivoty",
            "Najdi skrytÃ½ bonus"
        ]
        
        objectives = [base_objectives[0]]  # VÅ¾dy zÃ¡kladnÃ­ cÃ­l
        
        if difficulty > 0.3:
            objectives.extend(random.sample(base_objectives[1:], 
                                          min(2, len(base_objectives)-1)))
        
        if difficulty > 0.6:
            objectives.extend(random.sample(advanced_objectives, 
                                          min(2, len(advanced_objectives))))
        
        return objectives

class BalanceTester:
    """Tester hernÃ­ rovnovÃ¡hy"""
    
    def __init__(self):
        self.balance_metrics = {}
    
    def test_level_difficulty(self, level: GameLevel, 
                            simulated_players: int = 1000) -> Dict[str, float]:
        """Testuje obtÃ­Å¾nost ÃºrovnÄ› simulacÃ­"""
        success_rates = []
        completion_times = []
        
        for _ in range(simulated_players):
            # Simulace hrÃ¡Äe s rÅ¯znÃ½mi schopnostmi
            player_skill = random.uniform(0.1, 1.0)
            success_rate, completion_time = self._simulate_playthrough(level, player_skill)
            success_rates.append(success_rate)
            completion_times.append(completion_time)
        
        return {
            "average_success_rate": np.mean(success_rates),
            "average_completion_time": np.mean(completion_times),
            "difficulty_score": level.difficulty,
            "balance_rating": self._calculate_balance_rating(success_rates)
        }
    
    def _simulate_playthrough(self, level: GameLevel, player_skill: float) -> tuple:
        """Simuluje prÅ¯chod ÃºrovnÃ­"""
        # ZjednoduÅ¡enÃ¡ simulace
        base_success = 0.5 + (player_skill - level.difficulty) * 0.3
        success_rate = max(0.0, min(1.0, base_success))
        
        # ÄŒas dokonÄenÃ­ ovlivnÄ›nÃ½ obtÃ­Å¾nostÃ­ a schopnostmi
        base_time = 60  # zÃ¡kladnÃ­ Äas v sekundÃ¡ch
        time_modifier = (level.difficulty / player_skill) if player_skill > 0 else 2.0
        completion_time = base_time * time_modifier * random.uniform(0.8, 1.2)
        
        return success_rate, completion_time
    
    def _calculate_balance_rating(self, success_rates: List[float]) -> float:
        """VypoÄÃ­tÃ¡ rating rovnovÃ¡hy na zÃ¡kladÄ› rozloÅ¾enÃ­ ÃºspÄ›Å¡nosti"""
        mean_success = np.mean(success_rates)
        std_success = np.std(success_rates)
        
        # IdeÃ¡lnÃ­ ÃºspÄ›Å¡nost je kolem 0.7 s rozumnou variancÃ­
        ideal_mean = 0.7
        ideal_std = 0.2
        
        mean_score = 1.0 - abs(mean_success - ideal_mean) / ideal_mean
        std_score = 1.0 - abs(std_success - ideal_std) / ideal_std
        
        return (mean_score + std_score) / 2.0

class NarrativeGenerator:
    """GenerÃ¡tor hernÃ­ho pÅ™Ã­bÄ›hu"""
    
    def __init__(self, llm):
        self.llm = llm
        self.story_templates = {
            "fantasy": [
                "MladÃ½ hrdina se vydÃ¡vÃ¡ na cestu zachrÃ¡nit krÃ¡lovstvÃ­ pÅ™ed temnou silou.",
                "StarovÄ›kÃ© prokletÃ­ bylo probuzeno a pouze vyvolenÃ½ jej mÅ¯Å¾e zlomit."
            ],
            "sci-fi": [
                "KolonistÃ© objevili zÃ¡hadnou technologii na vzdÃ¡lenÃ© planetÄ›.",
                "AI se vzbouÅ™ila proti svÃ½m tvÅ¯rcÅ¯m a hrozÃ­ galaxii."
            ],
            "mystery": [
                "Detektiv musÃ­ vyÅ™eÅ¡it sÃ©rii zÃ¡hadnÃ½ch zloÄinÅ¯.",
                "StarÃ½ zÃ¡mek skrÃ½vÃ¡ tajemstvÃ­, kterÃ© zmÄ›nÃ­ vÅ¡e."
            ]
        }
    
    def generate_story(self, genre: str, level_count: int) -> Dict[str, Any]:
        """Generuje pÅ™Ã­bÄ›h pro hru"""
        if genre not in self.story_templates:
            genre = "fantasy"
        
        base_story = random.choice(self.story_templates[genre])
        
        story_structure = {
            "main_plot": base_story,
            "genre": genre,
            "chapters": self._generate_chapters(level_count),
            "characters": self._generate_characters(genre),
            "world_building": self._generate_world_info(genre)
        }
        
        return story_structure
    
    def _generate_chapters(self, count: int) -> List[Dict[str, str]]:
        """Generuje kapitoly pÅ™Ã­bÄ›hu"""
        chapters = []
        for i in range(count):
            chapter = {
                "title": f"Kapitola {i+1}",
                "summary": f"HrÃ¡Ä postupuje k {i+1}. ÄÃ¡sti svÃ© mise.",
                "objectives": f"DokonÄit ÃºroveÅˆ {i+1} a pokraÄovat v pÅ™Ã­bÄ›hu."
            }
            chapters.append(chapter)
        return chapters
    
    def _generate_characters(self, genre: str) -> List[Dict[str, str]]:
        """Generuje postavy"""
        character_archetypes = {
            "fantasy": ["KouzelnÃ­k", "VÃ¡leÄnÃ­k", "Elf", "TrpaslÃ­k"],
            "sci-fi": ["KapitÃ¡n", "InÅ¾enÃ½r", "Android", "Pilot"],
            "mystery": ["Detektiv", "SvÄ›dek", "PodezÅ™elÃ½", "ForenznÃ­ expert"]
        }
        
        archetypes = character_archetypes.get(genre, character_archetypes["fantasy"])
        characters = []
        
        for archetype in archetypes[:3]:  # Omezit na 3 hlavnÃ­ postavy
            character = {
                "name": f"{archetype} {random.randint(1, 100)}",
                "role": archetype,
                "description": f"DÅ¯leÅ¾itÃ¡ postava typu {archetype}"
            }
            characters.append(character)
        
        return characters
    
    def _generate_world_info(self, genre: str) -> Dict[str, str]:
        """Generuje informace o svÄ›tÄ›"""
        world_info = {
            "fantasy": {
                "setting": "MagickÃ© krÃ¡lovstvÃ­",
                "atmosphere": "MystickÃ© a dobrodruÅ¾nÃ©",
                "key_locations": "Hrad, Les, JeskynÄ›, VÄ›Å¾"
            },
            "sci-fi": {
                "setting": "VzdÃ¡lenÃ¡ budoucnost",
                "atmosphere": "TechnologickÃ© a futuristickÃ©",
                "key_locations": "VesmÃ­rnÃ¡ stanice, Planet, LoÄ, LaboratoÅ™"
            },
            "mystery": {
                "setting": "ModernÃ­ mÄ›sto",
                "atmosphere": "NapÃ­navÃ© a tajemnÃ©",
                "key_locations": "PolicejnÃ­ stanice, MÃ­sto Äinu, Archiv, Nemocnice"
            }
        }
        
        return world_info.get(genre, world_info["fantasy"])

class PlayerBehaviorAnalyzer:
    """AnalyzÃ¡tor chovÃ¡nÃ­ hrÃ¡ÄÅ¯"""
    
    def __init__(self):
        self.behavior_patterns = {}
    
    def analyze_player_data(self, players: List[PlayerData]) -> Dict[str, Any]:
        """Analyzuje data hrÃ¡ÄÅ¯ a identifikuje vzory"""
        if not players:
            return {"error": "Å½Ã¡dnÃ¡ data hrÃ¡ÄÅ¯"}
        
        df = pd.DataFrame([
            {
                "player_id": p.player_id,
                "playtime": p.playtime,
                "completed_levels": len(p.completed_levels),
                "skill_level": p.skill_level,
                **p.preferences
            }
            for p in players
        ])
        
        analysis = {
            "total_players": len(players),
            "average_playtime": df["playtime"].mean(),
            "average_levels_completed": df["completed_levels"].mean(),
            "skill_distribution": self._analyze_skill_distribution(df),
            "retention_rate": self._calculate_retention_rate(players),
            "preference_trends": self._analyze_preferences(df),
            "difficulty_recommendations": self._recommend_difficulty_adjustments(df)
        }
        
        return analysis
    
    def _analyze_skill_distribution(self, df: pd.DataFrame) -> Dict[str, float]:
        """Analyzuje rozloÅ¾enÃ­ dovednostÃ­ hrÃ¡ÄÅ¯"""
        skill_levels = df["skill_level"]
        return {
            "beginner": (skill_levels < 0.3).sum() / len(skill_levels),
            "intermediate": ((skill_levels >= 0.3) & (skill_levels < 0.7)).sum() / len(skill_levels),
            "advanced": (skill_levels >= 0.7).sum() / len(skill_levels)
        }
    
    def _calculate_retention_rate(self, players: List[PlayerData]) -> float:
        """VypoÄÃ­tÃ¡ mÃ­ru udrÅ¾enÃ­ hrÃ¡ÄÅ¯"""
        # ZjednoduÅ¡enÃ¡ kalkulace - hrÃ¡Äi s vÃ­ce neÅ¾ 1 hodinou hry
        retained_players = sum(1 for p in players if p.playtime > 60)
        return retained_players / len(players) if players else 0.0
    
    def _analyze_preferences(self, df: pd.DataFrame) -> Dict[str, float]:
        """Analyzuje preference hrÃ¡ÄÅ¯"""
        preference_cols = [col for col in df.columns if col.startswith("pref_")]
        if not preference_cols:
            return {"no_preferences": 1.0}
        
        preferences = {}
        for col in preference_cols:
            preferences[col] = df[col].mean()
        
        return preferences
    
    def _recommend_difficulty_adjustments(self, df: pd.DataFrame) -> Dict[str, str]:
        """DoporuÄuje Ãºpravy obtÃ­Å¾nosti"""
        avg_completion = df["completed_levels"].mean()
        avg_skill = df["skill_level"].mean()
        
        recommendations = {}
        
        if avg_completion < 3 and avg_skill < 0.5:
            recommendations["difficulty"] = "SniÅ¾te poÄÃ¡teÄnÃ­ obtÃ­Å¾nost"
        elif avg_completion > 10 and avg_skill > 0.7:
            recommendations["difficulty"] = "PÅ™idejte vÃ­ce vÃ½zev pro pokroÄilÃ© hrÃ¡Äe"
        else:
            recommendations["difficulty"] = "SouÄasnÃ¡ obtÃ­Å¾nost je vyvÃ¡Å¾enÃ¡"
        
        return recommendations

class GameStudio:
    """HlavnÃ­ tÅ™Ã­da hernÃ­ho studia"""
    
    def __init__(self, openai_api_key: str):
        self.orchestrator = GameStudioOrchestrator(openai_api_key)
        self.procedural_generator = ProceduralGenerator()
        self.balance_tester = BalanceTester()
        self.narrative_generator = NarrativeGenerator(self.orchestrator.llm)
        self.behavior_analyzer = PlayerBehaviorAnalyzer()
        
        # SimulovanÃ¡ data hrÃ¡ÄÅ¯ pro demonstraci
        self.sample_players = self._generate_sample_players()
    
    def _generate_sample_players(self) -> List[PlayerData]:
        """Generuje vzorovÃ¡ data hrÃ¡ÄÅ¯"""
        players = []
        for i in range(100):
            player = PlayerData(
                player_id=f"player_{i}",
                playtime=random.uniform(10, 300),  # minuty
                completed_levels=list(range(random.randint(1, 15))),
                preferences={
                    "pref_action": random.uniform(0, 1),
                    "pref_puzzle": random.uniform(0, 1),
                    "pref_story": random.uniform(0, 1)
                },
                skill_level=random.uniform(0.1, 1.0)
            )
            players.append(player)
        return players
    
    async def create_complete_game(self, game_config: Dict[str, Any]) -> Dict[str, Any]:
        """VytvoÅ™Ã­ kompletnÃ­ hru"""
        print("ğŸ® SpouÅ¡tÃ­m autonomnÃ­ studio pro vÃ½voj her...")
        
        try:
            # 1. GenerovÃ¡nÃ­ pÅ™Ã­bÄ›hu
            print("ğŸ“– Generuji pÅ™Ã­bÄ›h...")
            story = self.narrative_generator.generate_story(
                game_config.get("genre", "fantasy"),
                game_config.get("level_count", 5)
            )
            
            # 2. VytvoÅ™enÃ­ ÃºrovnÃ­
            print("ğŸ—ï¸ Generuji ÃºrovnÄ›...")
            levels = []
            for i in range(game_config.get("level_count", 5)):
                difficulty = min(0.1 + i * 0.2, 1.0)  # PostupnÄ› rostoucÃ­ obtÃ­Å¾nost
                
                level = GameLevel(
                    level_id=i + 1,
                    layout=self.procedural_generator.generate_level_layout(
                        game_config.get("level_width", 20),
                        game_config.get("level_height", 15),
                        difficulty
                    ),
                    difficulty=difficulty,
                    objectives=self.procedural_generator.generate_objectives(difficulty),
                    assets=[]
                )
                levels.append(level)
            
            # 3. TestovÃ¡nÃ­ rovnovÃ¡hy
            print("âš–ï¸ Testuji hernÃ­ rovnovÃ¡hu...")
            balance_results = []
            for level in levels:
                balance_result = self.balance_tester.test_level_difficulty(level)
                balance_results.append(balance_result)
            
            # 4. AnalÃ½za chovÃ¡nÃ­ hrÃ¡ÄÅ¯
            print("ğŸ“Š Analyzuji chovÃ¡nÃ­ hrÃ¡ÄÅ¯...")
            player_analysis = self.behavior_analyzer.analyze_player_data(self.sample_players)
            
            # 5. GenerovÃ¡nÃ­ aktiv
            print("ğŸ¨ Generuji hernÃ­ aktiva...")
            assets = self._generate_game_assets(story["genre"])
            
            # 6. Kompilace vÃ½sledkÅ¯
            game_result = {
                "metadata": {
                    "game_title": f"ProcedurÃ¡lnÃ­ {story['genre'].title()} Hra",
                    "created_at": datetime.now().isoformat(),
                    "total_levels": len(levels),
                    "estimated_playtime": f"{len(levels) * 10-15} minut"
                },
                "story": story,
                "levels": [
                    {
                        "level_id": level.level_id,
                        "difficulty": level.difficulty,
                        "objectives": level.objectives,
                        "layout_size": f"{len(level.layout[0])}x{len(level.layout)}"
                    }
                    for level in levels
                ],
                "balance_analysis": {
                    "overall_balance_rating": np.mean([r["balance_rating"] for r in balance_results]),
                    "average_success_rate": np.mean([r["average_success_rate"] for r in balance_results]),
                    "difficulty_curve": [r["difficulty_score"] for r in balance_results]
                },
                "player_insights": player_analysis,
                "assets": assets,
                "recommendations": self._generate_recommendations(balance_results, player_analysis)
            }
            
            print("âœ… Hra ÃºspÄ›Å¡nÄ› vytvoÅ™ena!")
            return game_result
            
        except Exception as e:
            print(f"âŒ Chyba pÅ™i vytvÃ¡Å™enÃ­ hry: {str(e)}")
            return {"error": str(e)}
    
    def _generate_game_assets(self, genre: str) -> List[Dict[str, Any]]:
        """Generuje hernÃ­ aktiva"""
        asset_templates = {
            "fantasy": [
                {"type": "character", "name": "Hrdina", "description": "HlavnÃ­ hrÃ¡ÄskÃ¡ postava"},
                {"type": "enemy", "name": "Goblin", "description": "ZÃ¡kladnÃ­ nepÅ™Ã­tel"},
                {"type": "item", "name": "MeÄ", "description": "ZÃ¡kladnÃ­ zbraÅˆ"},
                {"type": "environment", "name": "ZÃ¡mek", "description": "HernÃ­ prostÅ™edÃ­"}
            ],
            "sci-fi": [
                {"type": "character", "name": "Astronaut", "description": "HlavnÃ­ hrÃ¡ÄskÃ¡ postava"},
                {"type": "enemy", "name": "Robot", "description": "ZÃ¡kladnÃ­ nepÅ™Ã­tel"},
                {"type": "item", "name": "LaserovÃ¡ zbraÅˆ", "description": "FuturistickÃ¡ zbraÅˆ"},
                {"type": "environment", "name": "VesmÃ­rnÃ¡ stanice", "description": "HernÃ­ prostÅ™edÃ­"}
            ]
        }
        
        templates = asset_templates.get(genre, asset_templates["fantasy"])
        assets = []
        
        for template in templates:
            asset = {
                "asset_id": f"{template['type']}_{random.randint(1000, 9999)}",
                "type": template["type"],
                "name": template["name"],
                "description": template["description"],
                "properties": {
                    "rarity": random.choice(["common", "uncommon", "rare"]),
                    "level_requirement": random.randint(1, 10)
                }
            }
            assets.append(asset)
        
        return assets
    
    def _generate_recommendations(self, balance_results: List[Dict], 
                                player_analysis: Dict) -> List[str]:
        """Generuje doporuÄenÃ­ pro vylepÅ¡enÃ­ hry"""
        recommendations = []
        
        # AnalÃ½za rovnovÃ¡hy
        avg_balance = np.mean([r["balance_rating"] for r in balance_results])
        if avg_balance < 0.6:
            recommendations.append("DoporuÄuji upravit obtÃ­Å¾nost nÄ›kterÃ½ch ÃºrovnÃ­ pro lepÅ¡Ã­ rovnovÃ¡hu")
        
        # AnalÃ½za retence
        retention = player_analysis.get("retention_rate", 0)
        if retention < 0.5:
            recommendations.append("NÃ­zkÃ¡ retence hrÃ¡ÄÅ¯ - zvaÅ¾te pÅ™idÃ¡nÃ­ vÃ­ce motivaÄnÃ­ch prvkÅ¯")
        
        # AnalÃ½za dovednostÃ­
        skill_dist = player_analysis.get("skill_distribution", {})
        if skill_dist.get("beginner", 0) > 0.6:
            recommendations.append("VysokÃ© zastoupenÃ­ zaÄÃ¡teÄnÃ­kÅ¯ - pÅ™idejte tutoriÃ¡l a postupnÃ© zavedenÃ­ mechanik")
        
        if not recommendations:
            recommendations.append("Hra je dobÅ™e vyvÃ¡Å¾enÃ¡ a pÅ™ipravenÃ¡ k vydÃ¡nÃ­!")
        
        return recommendations

# DemonstraÄnÃ­ spuÅ¡tÄ›nÃ­
async def main():
    # Konfigurace (v reÃ¡lnÃ© aplikaci by byla API klÃ­Ä v environment variables)
    api_key = "your-openai-api-key-here"  # NahraÄte skuteÄnÃ½m klÃ­Äem
    
    studio = GameStudio(api_key)
    
    game_config = {
        "genre": "fantasy",
        "level_count": 5,
        "level_width": 20,
        "level_height": 15,
        "target_difficulty": "medium"
    }
    
    print("ğŸš€ SpouÅ¡tÃ­m autonomnÃ­ hernÃ­ studio...")
    result = await studio.create_complete_game(game_config)
    
    # VÃ½pis vÃ½sledkÅ¯
    if "error" in result:
        print(f"Chyba: {result['error']}")
    else:
        print("\n" + "="*50)
        print("ğŸ“‹ SHRNUTÃ VYTVOÅ˜ENÃ‰ HRY")
        print("="*50)
        print(f"NÃ¡zev: {result['metadata']['game_title']}")
        print(f"Å½Ã¡nr: {result['story']['genre']}")
        print(f"PoÄet ÃºrovnÃ­: {result['metadata']['total_levels']}")
        print(f"OdhadovanÃ½ Äas hranÃ­: {result['metadata']['estimated_playtime']}")
        
        print(f"\nğŸ¯ HernÃ­ rovnovÃ¡ha: {result['balance_analysis']['overall_balance_rating']:.2f}/1.0")
        print(f"ğŸ“Š PrÅ¯mÄ›rnÃ¡ ÃºspÄ›Å¡nost: {result['balance_analysis']['average_success_rate']:.1%}")
        print(f"ğŸ‘¥ Retence hrÃ¡ÄÅ¯: {result['player_insights']['retention_rate']:.1%}")
        
        print("\nğŸ’¡ DoporuÄenÃ­:")
        for rec in result['recommendations']:
            print(f"â€¢ {rec}")

if __name__ == "__main__":
    # Pro demonstraci bez OpenAI API
    print("Demo autonomnÃ­ho hernÃ­ho studia")
    print("Pro plnou funkÄnost nastavte OpenAI API klÃ­Ä")
    
    # VytvoÅ™enÃ­ ukÃ¡zkovÃ©ho studio objektu s dummy klÃ­Äem
    demo_studio = GameStudio("demo-key")
    
    # Demonstrace jednotlivÃ½ch komponent
    print("\nğŸ”§ TestovÃ¡nÃ­ komponent:")
    
    # Test procedurÃ¡lnÃ­ho generÃ¡toru
    layout = ProceduralGenerator.generate_level_layout(10, 8, 0.5)
    objectives = ProceduralGenerator.generate_objectives(0.5)
    print(f"âœ… GenerovÃ¡n layout {len(layout)}x{len(layout[0])}")
    print(f"âœ… GenerovÃ¡ny cÃ­le: {len(objectives)}")
    
    # Test balance testeru
    test_level = GameLevel(1, layout, 0.5, objectives, [])
    balance_tester = BalanceTester()
    balance_result = balance_tester.test_level_difficulty(test_level, 100)
    print(f"âœ… Balance rating: {balance_result['balance_rating']:.2f}")
    
    # Test analÃ½zy hrÃ¡ÄÅ¯
    analyzer = PlayerBehaviorAnalyzer()
    sample_players = demo_studio.sample_players[:10]  # Pouze vzorku
    analysis = analyzer.analyze_player_data(sample_players)
    print(f"âœ… AnalyzovÃ¡no {analysis['total_players']} hrÃ¡ÄÅ¯")
    
    print("\nğŸ® Demo dokonÄeno! Pro plnou funkÄnost spusÅ¥te s platnÃ½m OpenAI API klÃ­Äem.")
````

## ShrnutÃ­ Projektu

AutonomnÃ­ Studio pro VÃ½voj Her pÅ™edstavuje prÅ¯kopnickÃ½ projekt, kterÃ½ vyuÅ¾Ã­vÃ¡ multiagentnÃ­ systÃ©my k automatizaci celÃ©ho vÃ½vojovÃ©ho procesu videohry. Kombinuje pokroÄilÃ© AI technologie pro vytvoÅ™enÃ­ kompletnÃ­ho hernÃ­ho zÃ¡Å¾itku.

### KlÃ­ÄovÃ© Hodnoty
- **Automatizace**: Redukce manuÃ¡lnÃ­ prÃ¡ce vÃ½vojÃ¡Å™Å¯
- **Personalizace**: Hry pÅ™izpÅ¯sobenÃ© chovÃ¡nÃ­ hrÃ¡ÄÅ¯  
- **Å kÃ¡lovatelnost**: NekoneÄnÃ¡ variabilita obsahu
- **Optimalizace**: KontinuÃ¡lnÃ­ vylepÅ¡ovÃ¡nÃ­ na zÃ¡kladÄ› dat

### TechnologickÃ© Inovace
Projekt vyuÅ¾Ã­vÃ¡ nejmodernÄ›jÅ¡Ã­ frameworky jako CrewAI pro orchestraci agentÅ¯, LangChain pro jazykovÃ© modely a pokroÄilÃ© analytickÃ© nÃ¡stroje pro zpracovÃ¡nÃ­ hernÃ­ch dat.

### BudoucÃ­ PotenciÃ¡l
Tento pÅ™Ã­stup mÅ¯Å¾e revolucionalizovat hernÃ­ prÅ¯mysl umoÅ¾nÄ›nÃ­m rychlÃ© tvorby personalizovanÃ½ch her, snÃ­Å¾enÃ­m nÃ¡kladÅ¯ na vÃ½voj a otevÅ™enÃ­m novÃ½ch moÅ¾nostÃ­ pro interaktivnÃ­ zÃ¡bavu.

Projekt demonstruje sÃ­lu AI multiagentnÃ­ch systÃ©mÅ¯ v kreativnÃ­ch odvÄ›tvÃ­ch a ukazuje cestu k budoucnosti autonomnÃ­ho vÃ½voje digitÃ¡lnÃ­ho obsahu.