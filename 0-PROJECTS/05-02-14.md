<small>Claude Sonnet 4 **(Technical Documentation Generator Agent)**</small>
# Technical Documentation Generator Agent

## Key Concepts Explanation

### Code Parsing and AST Analysis
Advanced static code analysis system that parses source code into Abstract Syntax Trees (AST), extracts structural information, identifies functions, classes, and dependencies, and understands code relationships to generate comprehensive documentation from source code structure.

### Intelligent Code Explanation
AI-powered system that analyzes code patterns, algorithms, and logic flow to generate human-readable explanations of complex code functionality, including purpose, parameters, return values, and implementation details with contextual understanding.

### Automated Documentation Generation
Multi-format documentation system that creates API documentation, README files, user guides, and technical specifications automatically from code analysis, comments, and docstrings while maintaining consistency and completeness.

### Code Summarization and Pattern Recognition
Advanced analysis engine that identifies common design patterns, architectural decisions, code smells, and best practices to provide high-level summaries and recommendations for code improvement and documentation enhancement.

### Multi-Language Support
Extensible parsing framework that supports multiple programming languages including Python, JavaScript, Java, C++, and others through language-specific parsers and unified documentation generation templates.

## Comprehensive Project Explanation

### Objectives
The Technical Documentation Generator Agent automates the creation of comprehensive technical documentation from source code, reducing documentation debt, improving code maintainability, and ensuring consistent, up-to-date documentation across software projects.

### Key Features
- **Automated Code Analysis**: Deep parsing of source code with structural understanding
- **Multi-Format Output**: Generate README, API docs, user guides, and technical specs
- **Code Explanation**: AI-powered natural language explanations of complex logic
- **Documentation Templates**: Customizable templates for different documentation types
- **Version Control Integration**: Track documentation changes with code modifications

### Challenges
- **Code Complexity**: Handling complex codebases with intricate dependencies
- **Context Understanding**: Generating meaningful explanations beyond basic syntax
- **Documentation Quality**: Ensuring generated docs are accurate and useful
- **Multi-Language Support**: Managing different programming language paradigms

### Potential Impact
This system can reduce documentation time by 70-80%, improve code maintainability, accelerate developer onboarding, ensure documentation consistency, and enable better knowledge transfer across development teams.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
ast==3.11.0
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
requests==2.31.0
gitpython==3.1.40
markdown==3.5.1
jinja2==3.1.2
pygments==2.17.2
tree-sitter==0.20.4
pydantic==2.5.0
typing_extensions==4.8.0
datetime
logging
typing
dataclasses
enum
json
re
uuid
os
pathlib
inspect
````

### Core Implementation

````python
import ast
import inspect
import os
import re
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import uuid

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# LangChain components
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema import Document

# Markdown and templating
import markdown
from jinja2 import Template

# Syntax highlighting
from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter

# Git integration
try:
    import git
    GIT_AVAILABLE = True
except ImportError:
    GIT_AVAILABLE = False

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DocumentationType(Enum):
    API_REFERENCE = "api_reference"
    README = "readme"
    USER_GUIDE = "user_guide"
    TECHNICAL_SPEC = "technical_spec"
    CODE_COMMENTS = "code_comments"

class CodeElementType(Enum):
    CLASS = "class"
    FUNCTION = "function"
    METHOD = "method"
    VARIABLE = "variable"
    MODULE = "module"
    IMPORT = "import"

class LanguageType(Enum):
    PYTHON = "python"
    JAVASCRIPT = "javascript"
    JAVA = "java"
    CPP = "cpp"
    TYPESCRIPT = "typescript"

@dataclass
class CodeElement:
    element_id: str
    name: str
    element_type: CodeElementType
    line_number: int
    end_line: int
    docstring: Optional[str] = None
    parameters: List[Dict[str, Any]] = field(default_factory=list)
    return_type: Optional[str] = None
    complexity: int = 0
    dependencies: List[str] = field(default_factory=list)
    decorators: List[str] = field(default_factory=list)
    is_public: bool = True
    code_snippet: str = ""

@dataclass
class CodeFile:
    file_path: str
    language: LanguageType
    elements: List[CodeElement] = field(default_factory=list)
    imports: List[str] = field(default_factory=list)
    total_lines: int = 0
    complexity_score: float = 0.0
    last_modified: datetime = field(default_factory=datetime.now)

@dataclass
class DocumentationSection:
    section_id: str
    title: str
    content: str
    section_type: str
    code_elements: List[str] = field(default_factory=list)
    subsections: List['DocumentationSection'] = field(default_factory=list)

@dataclass
class GeneratedDocumentation:
    doc_id: str
    title: str
    doc_type: DocumentationType
    sections: List[DocumentationSection]
    metadata: Dict[str, Any] = field(default_factory=dict)
    generated_at: datetime = field(default_factory=datetime.now)

class PythonCodeParser:
    """Advanced Python code parser using AST."""
    
    def __init__(self):
        self.current_file = None
        self.parsed_elements = []
    
    def parse_file(self, file_path: str) -> CodeFile:
        """Parse a Python file and extract code elements."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parse AST
            tree = ast.parse(content)
            
            # Initialize code file
            code_file = CodeFile(
                file_path=file_path,
                language=LanguageType.PYTHON,
                total_lines=len(content.split('\n'))
            )
            
            # Extract elements
            self.parsed_elements = []
            self._extract_imports(tree, code_file)
            self._extract_classes(tree, content)
            self._extract_functions(tree, content)
            self._extract_variables(tree, content)
            
            code_file.elements = self.parsed_elements
            code_file.complexity_score = self._calculate_complexity(tree)
            
            return code_file
        
        except Exception as e:
            logger.error(f"Error parsing file {file_path}: {e}")
            return CodeFile(file_path=file_path, language=LanguageType.PYTHON)
    
    def _extract_imports(self, tree: ast.AST, code_file: CodeFile):
        """Extract import statements."""
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    code_file.imports.append(alias.name)
            elif isinstance(node, ast.ImportFrom):
                module = node.module or ""
                for alias in node.names:
                    import_name = f"{module}.{alias.name}" if module else alias.name
                    code_file.imports.append(import_name)
    
    def _extract_classes(self, tree: ast.AST, content: str):
        """Extract class definitions."""
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                class_element = CodeElement(
                    element_id=str(uuid.uuid4()),
                    name=node.name,
                    element_type=CodeElementType.CLASS,
                    line_number=node.lineno,
                    end_line=node.end_lineno or node.lineno,
                    docstring=ast.get_docstring(node),
                    decorators=[self._get_decorator_name(d) for d in node.decorator_list],
                    is_public=not node.name.startswith('_'),
                    code_snippet=self._extract_code_snippet(content, node.lineno, node.end_lineno)
                )
                
                # Extract methods
                for item in node.body:
                    if isinstance(item, ast.FunctionDef):
                        method_element = self._create_function_element(item, content, CodeElementType.METHOD)
                        self.parsed_elements.append(method_element)
                
                self.parsed_elements.append(class_element)
    
    def _extract_functions(self, tree: ast.AST, content: str):
        """Extract function definitions."""
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and not self._is_method(node, tree):
                function_element = self._create_function_element(node, content, CodeElementType.FUNCTION)
                self.parsed_elements.append(function_element)
    
    def _create_function_element(self, node: ast.FunctionDef, content: str, 
                               element_type: CodeElementType) -> CodeElement:
        """Create a CodeElement for a function or method."""
        # Extract parameters
        parameters = []
        for arg in node.args.args:
            param_info = {
                'name': arg.arg,
                'type': self._get_type_annotation(arg.annotation) if arg.annotation else None,
                'default': None
            }
            parameters.append(param_info)
        
        # Extract default values
        defaults = node.args.defaults
        if defaults:
            for i, default in enumerate(defaults):
                param_index = len(parameters) - len(defaults) + i
                if param_index >= 0:
                    parameters[param_index]['default'] = ast.unparse(default)
        
        return CodeElement(
            element_id=str(uuid.uuid4()),
            name=node.name,
            element_type=element_type,
            line_number=node.lineno,
            end_line=node.end_lineno or node.lineno,
            docstring=ast.get_docstring(node),
            parameters=parameters,
            return_type=self._get_type_annotation(node.returns) if node.returns else None,
            complexity=self._calculate_function_complexity(node),
            decorators=[self._get_decorator_name(d) for d in node.decorator_list],
            is_public=not node.name.startswith('_'),
            code_snippet=self._extract_code_snippet(content, node.lineno, node.end_lineno)
        )
    
    def _extract_variables(self, tree: ast.AST, content: str):
        """Extract global variables and constants."""
        for node in ast.walk(tree):
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        var_element = CodeElement(
                            element_id=str(uuid.uuid4()),
                            name=target.id,
                            element_type=CodeElementType.VARIABLE,
                            line_number=node.lineno,
                            end_line=node.lineno,
                            is_public=not target.id.startswith('_'),
                            code_snippet=self._extract_code_snippet(content, node.lineno, node.lineno)
                        )
                        self.parsed_elements.append(var_element)
    
    def _is_method(self, node: ast.FunctionDef, tree: ast.AST) -> bool:
        """Check if a function is a method inside a class."""
        for parent in ast.walk(tree):
            if isinstance(parent, ast.ClassDef):
                if node in parent.body:
                    return True
        return False
    
    def _get_decorator_name(self, decorator) -> str:
        """Extract decorator name."""
        if isinstance(decorator, ast.Name):
            return decorator.id
        elif isinstance(decorator, ast.Call):
            return ast.unparse(decorator)
        else:
            return ast.unparse(decorator)
    
    def _get_type_annotation(self, annotation) -> str:
        """Extract type annotation as string."""
        if annotation:
            return ast.unparse(annotation)
        return None
    
    def _calculate_complexity(self, tree: ast.AST) -> float:
        """Calculate cyclomatic complexity of the entire file."""
        complexity = 1  # Base complexity
        
        for node in ast.walk(tree):
            if isinstance(node, (ast.If, ast.While, ast.For, ast.ExceptHandler)):
                complexity += 1
            elif isinstance(node, ast.BoolOp):
                complexity += len(node.values) - 1
        
        return complexity
    
    def _calculate_function_complexity(self, node: ast.FunctionDef) -> int:
        """Calculate cyclomatic complexity of a function."""
        complexity = 1
        
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.While, ast.For, ast.ExceptHandler)):
                complexity += 1
            elif isinstance(child, ast.BoolOp):
                complexity += len(child.values) - 1
        
        return complexity
    
    def _extract_code_snippet(self, content: str, start_line: int, end_line: Optional[int]) -> str:
        """Extract code snippet from content."""
        lines = content.split('\n')
        if end_line is None:
            end_line = start_line
        
        snippet_lines = lines[start_line-1:end_line]
        return '\n'.join(snippet_lines)

class CodeExplainer:
    """AI-powered code explanation generator."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.3,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self._initialize_prompts()
    
    def _initialize_prompts(self):
        """Initialize explanation prompts."""
        self.function_explanation_prompt = ChatPromptTemplate.from_template("""
        Analyze this Python function and provide a comprehensive explanation.
        
        Function Name: {name}
        Function Code:
        ```python
        {code}
        ```
        
        Docstring: {docstring}
        Parameters: {parameters}
        Return Type: {return_type}
        
        Please provide:
        1. Purpose and functionality
        2. Parameter descriptions
        3. Return value explanation
        4. Algorithm or logic explanation
        5. Usage examples
        6. Any important notes or considerations
        
        Make the explanation clear and suitable for technical documentation.
        """)
        
        self.class_explanation_prompt = ChatPromptTemplate.from_template("""
        Analyze this Python class and provide a comprehensive explanation.
        
        Class Name: {name}
        Class Code:
        ```python
        {code}
        ```
        
        Docstring: {docstring}
        Methods: {methods}
        
        Please provide:
        1. Purpose and responsibility of the class
        2. Key attributes and their roles
        3. Important methods and their functions
        4. Usage patterns and examples
        5. Design patterns used (if any)
        6. Integration points with other components
        
        Make the explanation suitable for API documentation.
        """)
        
        self.code_summary_prompt = ChatPromptTemplate.from_template("""
        Analyze this code file and provide a high-level summary.
        
        File: {file_path}
        Language: {language}
        
        Code Elements:
        {elements_summary}
        
        Imports: {imports}
        
        Please provide:
        1. Overall purpose of the file
        2. Main components and their roles
        3. Key functionalities provided
        4. Dependencies and integrations
        5. Architecture patterns used
        
        Keep the summary concise but informative.
        """)
    
    def explain_function(self, element: CodeElement) -> str:
        """Generate explanation for a function."""
        try:
            if self.llm:
                response = self.llm.invoke(
                    self.function_explanation_prompt.format(
                        name=element.name,
                        code=element.code_snippet,
                        docstring=element.docstring or "No docstring provided",
                        parameters=self._format_parameters(element.parameters),
                        return_type=element.return_type or "Not specified"
                    )
                )
                return response.content
            else:
                return self._generate_basic_function_explanation(element)
        
        except Exception as e:
            logger.error(f"Error explaining function: {e}")
            return self._generate_basic_function_explanation(element)
    
    def explain_class(self, element: CodeElement, methods: List[CodeElement]) -> str:
        """Generate explanation for a class."""
        try:
            if self.llm:
                methods_summary = "\n".join([
                    f"- {method.name}: {method.docstring or 'No description'}"
                    for method in methods
                ])
                
                response = self.llm.invoke(
                    self.class_explanation_prompt.format(
                        name=element.name,
                        code=element.code_snippet,
                        docstring=element.docstring or "No docstring provided",
                        methods=methods_summary
                    )
                )
                return response.content
            else:
                return self._generate_basic_class_explanation(element, methods)
        
        except Exception as e:
            logger.error(f"Error explaining class: {e}")
            return self._generate_basic_class_explanation(element, methods)
    
    def summarize_file(self, code_file: CodeFile) -> str:
        """Generate high-level summary of a code file."""
        try:
            if self.llm:
                elements_summary = self._create_elements_summary(code_file.elements)
                
                response = self.llm.invoke(
                    self.code_summary_prompt.format(
                        file_path=code_file.file_path,
                        language=code_file.language.value,
                        elements_summary=elements_summary,
                        imports=", ".join(code_file.imports[:10])
                    )
                )
                return response.content
            else:
                return self._generate_basic_file_summary(code_file)
        
        except Exception as e:
            logger.error(f"Error summarizing file: {e}")
            return self._generate_basic_file_summary(code_file)
    
    def _format_parameters(self, parameters: List[Dict[str, Any]]) -> str:
        """Format parameter list for prompt."""
        if not parameters:
            return "No parameters"
        
        param_strs = []
        for param in parameters:
            param_str = f"{param['name']}"
            if param.get('type'):
                param_str += f": {param['type']}"
            if param.get('default'):
                param_str += f" = {param['default']}"
            param_strs.append(param_str)
        
        return ", ".join(param_strs)
    
    def _create_elements_summary(self, elements: List[CodeElement]) -> str:
        """Create summary of code elements."""
        summary_lines = []
        
        for element in elements:
            line = f"- {element.element_type.value}: {element.name}"
            if element.docstring:
                line += f" - {element.docstring.split('.')[0]}"
            summary_lines.append(line)
        
        return "\n".join(summary_lines[:20])  # Limit to 20 elements
    
    def _generate_basic_function_explanation(self, element: CodeElement) -> str:
        """Generate basic explanation without LLM."""
        explanation = f"**Function: {element.name}**\n\n"
        
        if element.docstring:
            explanation += f"Description: {element.docstring}\n\n"
        
        if element.parameters:
            explanation += "Parameters:\n"
            for param in element.parameters:
                explanation += f"- {param['name']}"
                if param.get('type'):
                    explanation += f" ({param['type']})"
                explanation += "\n"
            explanation += "\n"
        
        if element.return_type:
            explanation += f"Returns: {element.return_type}\n\n"
        
        explanation += f"Complexity: {element.complexity}\n"
        
        return explanation
    
    def _generate_basic_class_explanation(self, element: CodeElement, methods: List[CodeElement]) -> str:
        """Generate basic class explanation without LLM."""
        explanation = f"**Class: {element.name}**\n\n"
        
        if element.docstring:
            explanation += f"Description: {element.docstring}\n\n"
        
        if methods:
            explanation += "Methods:\n"
            for method in methods:
                explanation += f"- {method.name}"
                if method.docstring:
                    explanation += f": {method.docstring.split('.')[0]}"
                explanation += "\n"
        
        return explanation
    
    def _generate_basic_file_summary(self, code_file: CodeFile) -> str:
        """Generate basic file summary without LLM."""
        summary = f"**File: {code_file.file_path}**\n\n"
        summary += f"Language: {code_file.language.value}\n"
        summary += f"Total Lines: {code_file.total_lines}\n"
        summary += f"Complexity Score: {code_file.complexity_score:.2f}\n\n"
        
        if code_file.imports:
            summary += f"Key Imports: {', '.join(code_file.imports[:5])}\n\n"
        
        # Count elements by type
        element_counts = {}
        for element in code_file.elements:
            elem_type = element.element_type.value
            element_counts[elem_type] = element_counts.get(elem_type, 0) + 1
        
        if element_counts:
            summary += "Components:\n"
            for elem_type, count in element_counts.items():
                summary += f"- {count} {elem_type}(s)\n"
        
        return summary

class DocumentationTemplates:
    """Templates for different documentation types."""
    
    def __init__(self):
        self._initialize_templates()
    
    def _initialize_templates(self):
        """Initialize documentation templates."""
        
        self.readme_template = Template("""
# {{ project_name }}

{{ description }}

## Overview

{{ overview }}

## Installation

```bash
pip install {{ package_name }}
```

## Usage

{{ usage_examples }}

## API Reference

{{ api_reference }}

## Files Structure

{{ file_structure }}

## Dependencies

{{ dependencies }}

## Contributing

{{ contributing_info }}

## License

{{ license_info }}

Generated on {{ generated_date }}
        """)
        
        self.api_reference_template = Template("""
# API Reference

## Classes

{% for class_info in classes %}
### {{ class_info.name }}

{{ class_info.description }}

**Methods:**
{% for method in class_info.methods %}
- `{{ method.name }}({{ method.parameters }})`: {{ method.description }}
{% endfor %}

{% endfor %}

## Functions

{% for function in functions %}
### {{ function.name }}

{{ function.description }}

**Parameters:**
{% for param in function.parameters %}
- `{{ param.name }}` ({{ param.type }}): {{ param.description }}
{% endfor %}

**Returns:** {{ function.return_type }}

{% endfor %}
        """)
        
        self.technical_spec_template = Template("""
# Technical Specification

## Architecture Overview

{{ architecture }}

## Components

{% for component in components %}
### {{ component.name }}

{{ component.description }}

**Responsibilities:**
{% for responsibility in component.responsibilities %}
- {{ responsibility }}
{% endfor %}

**Dependencies:**
{% for dependency in component.dependencies %}
- {{ dependency }}
{% endfor %}

{% endfor %}

## Data Flow

{{ data_flow }}

## Performance Considerations

{{ performance }}

## Security Considerations

{{ security }}
        """)
    
    def render_readme(self, context: Dict[str, Any]) -> str:
        """Render README template."""
        return self.readme_template.render(**context)
    
    def render_api_reference(self, context: Dict[str, Any]) -> str:
        """Render API reference template."""
        return self.api_reference_template.render(**context)
    
    def render_technical_spec(self, context: Dict[str, Any]) -> str:
        """Render technical specification template."""
        return self.technical_spec_template.render(**context)

class DocumentationGenerator:
    """Main documentation generator orchestrator."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.parser = PythonCodeParser()
        self.explainer = CodeExplainer(openai_api_key)
        self.templates = DocumentationTemplates()
        
        self.parsed_files = {}
        self.generated_docs = {}
    
    def analyze_project(self, project_path: str) -> Dict[str, Any]:
        """Analyze entire project and generate documentation."""
        try:
            project_path = Path(project_path)
            
            if not project_path.exists():
                raise ValueError(f"Project path {project_path} does not exist")
            
            # Find Python files
            python_files = list(project_path.rglob("*.py"))
            
            analysis_results = {
                "project_path": str(project_path),
                "total_files": len(python_files),
                "parsed_files": [],
                "total_elements": 0,
                "complexity_distribution": {},
                "file_summaries": {}
            }
            
            # Parse each file
            for file_path in python_files:
                try:
                    code_file = self.parser.parse_file(str(file_path))
                    self.parsed_files[str(file_path)] = code_file
                    
                    analysis_results["parsed_files"].append({
                        "path": str(file_path),
                        "elements": len(code_file.elements),
                        "complexity": code_file.complexity_score,
                        "imports": len(code_file.imports)
                    })
                    
                    analysis_results["total_elements"] += len(code_file.elements)
                    
                    # Generate file summary
                    summary = self.explainer.summarize_file(code_file)
                    analysis_results["file_summaries"][str(file_path)] = summary
                
                except Exception as e:
                    logger.error(f"Error parsing {file_path}: {e}")
            
            return analysis_results
        
        except Exception as e:
            logger.error(f"Error analyzing project: {e}")
            return {"error": str(e)}
    
    def generate_documentation(self, doc_type: DocumentationType, 
                             project_info: Dict[str, Any] = None) -> GeneratedDocumentation:
        """Generate specific type of documentation."""
        try:
            if doc_type == DocumentationType.README:
                return self._generate_readme(project_info)
            elif doc_type == DocumentationType.API_REFERENCE:
                return self._generate_api_reference()
            elif doc_type == DocumentationType.TECHNICAL_SPEC:
                return self._generate_technical_spec()
            else:
                raise ValueError(f"Unsupported documentation type: {doc_type}")
        
        except Exception as e:
            logger.error(f"Error generating documentation: {e}")
            return GeneratedDocumentation(
                doc_id=str(uuid.uuid4()),
                title="Error",
                doc_type=doc_type,
                sections=[],
                metadata={"error": str(e)}
            )
    
    def _generate_readme(self, project_info: Dict[str, Any] = None) -> GeneratedDocumentation:
        """Generate README documentation."""
        project_info = project_info or {}
        
        # Collect project overview
        overview_section = DocumentationSection(
            section_id="overview",
            title="Project Overview",
            content=self._create_project_overview(),
            section_type="overview"
        )
        
        # Create file structure
        structure_section = DocumentationSection(
            section_id="structure",
            title="File Structure",
            content=self._create_file_structure(),
            section_type="structure"
        )
        
        # Usage examples
        usage_section = DocumentationSection(
            section_id="usage",
            title="Usage Examples",
            content=self._create_usage_examples(),
            section_type="usage"
        )
        
        return GeneratedDocumentation(
            doc_id=str(uuid.uuid4()),
            title="README",
            doc_type=DocumentationType.README,
            sections=[overview_section, structure_section, usage_section],
            metadata={"project_info": project_info}
        )
    
    def _generate_api_reference(self) -> GeneratedDocumentation:
        """Generate API reference documentation."""
        sections = []
        
        # Group elements by type
        all_elements = []
        for code_file in self.parsed_files.values():
            all_elements.extend(code_file.elements)
        
        # Classes section
        classes = [e for e in all_elements if e.element_type == CodeElementType.CLASS]
        if classes:
            class_content = self._create_classes_documentation(classes, all_elements)
            classes_section = DocumentationSection(
                section_id="classes",
                title="Classes",
                content=class_content,
                section_type="classes"
            )
            sections.append(classes_section)
        
        # Functions section
        functions = [e for e in all_elements if e.element_type == CodeElementType.FUNCTION]
        if functions:
            function_content = self._create_functions_documentation(functions)
            functions_section = DocumentationSection(
                section_id="functions",
                title="Functions",
                content=function_content,
                section_type="functions"
            )
            sections.append(functions_section)
        
        return GeneratedDocumentation(
            doc_id=str(uuid.uuid4()),
            title="API Reference",
            doc_type=DocumentationType.API_REFERENCE,
            sections=sections
        )
    
    def _generate_technical_spec(self) -> GeneratedDocumentation:
        """Generate technical specification."""
        # Architecture section
        arch_content = self._create_architecture_overview()
        arch_section = DocumentationSection(
            section_id="architecture",
            title="Architecture",
            content=arch_content,
            section_type="architecture"
        )
        
        # Components section
        comp_content = self._create_components_overview()
        comp_section = DocumentationSection(
            section_id="components",
            title="Components",
            content=comp_content,
            section_type="components"
        )
        
        return GeneratedDocumentation(
            doc_id=str(uuid.uuid4()),
            title="Technical Specification",
            doc_type=DocumentationType.TECHNICAL_SPEC,
            sections=[arch_section, comp_section]
        )
    
    def _create_project_overview(self) -> str:
        """Create project overview content."""
        total_files = len(self.parsed_files)
        total_elements = sum(len(cf.elements) for cf in self.parsed_files.values())
        
        overview = f"""
This project contains {total_files} Python files with a total of {total_elements} code elements.

**Key Statistics:**
- Total Python files: {total_files}
- Total code elements: {total_elements}
- Average complexity: {self._calculate_average_complexity():.2f}

**Main Components:**
{self._list_main_components()}
        """
        
        return overview.strip()
    
    def _create_file_structure(self) -> str:
        """Create file structure documentation."""
        structure_lines = ["```"]
        
        for file_path in sorted(self.parsed_files.keys()):
            # Simplify path display
            relative_path = Path(file_path).name
            code_file = self.parsed_files[file_path]
            
            structure_lines.append(f"{relative_path}")
            structure_lines.append(f"  ‚îú‚îÄ‚îÄ {len(code_file.elements)} code elements")
            structure_lines.append(f"  ‚îú‚îÄ‚îÄ {len(code_file.imports)} imports")
            structure_lines.append(f"  ‚îî‚îÄ‚îÄ {code_file.total_lines} lines")
            structure_lines.append("")
        
        structure_lines.append("```")
        return "\n".join(structure_lines)
    
    def _create_usage_examples(self) -> str:
        """Create usage examples."""
        examples = ["## Basic Usage\n"]
        
        # Find main classes and functions
        all_elements = []
        for code_file in self.parsed_files.values():
            all_elements.extend(code_file.elements)
        
        public_classes = [e for e in all_elements 
                         if e.element_type == CodeElementType.CLASS and e.is_public]
        
        if public_classes:
            main_class = public_classes[0]
            examples.append(f"```python")
            examples.append(f"from {Path(main_class.name).stem} import {main_class.name}")
            examples.append(f"")
            examples.append(f"# Create instance")
            examples.append(f"instance = {main_class.name}()")
            examples.append(f"```")
        
        return "\n".join(examples)
    
    def _create_classes_documentation(self, classes: List[CodeElement], 
                                    all_elements: List[CodeElement]) -> str:
        """Create classes documentation."""
        docs = []
        
        for class_element in classes:
            if not class_element.is_public:
                continue
            
            docs.append(f"## {class_element.name}")
            
            # Get class explanation
            methods = [e for e in all_elements 
                      if e.element_type == CodeElementType.METHOD]
            explanation = self.explainer.explain_class(class_element, methods)
            docs.append(explanation)
            
            docs.append("")
        
        return "\n".join(docs)
    
    def _create_functions_documentation(self, functions: List[CodeElement]) -> str:
        """Create functions documentation."""
        docs = []
        
        for function in functions:
            if not function.is_public:
                continue
            
            docs.append(f"## {function.name}")
            
            # Get function explanation
            explanation = self.explainer.explain_function(function)
            docs.append(explanation)
            
            docs.append("")
        
        return "\n".join(docs)
    
    def _create_architecture_overview(self) -> str:
        """Create architecture overview."""
        return """
## System Architecture

This system follows a modular architecture with clear separation of concerns:

### Core Components
- **Parser Layer**: Handles code parsing and AST analysis
- **Analysis Layer**: Performs code analysis and explanation generation
- **Documentation Layer**: Generates formatted documentation
- **Template Layer**: Manages documentation templates and formatting

### Design Patterns
- **Strategy Pattern**: Used for different documentation types
- **Template Pattern**: Used for documentation generation
- **Observer Pattern**: Used for tracking analysis progress
        """
    
    def _create_components_overview(self) -> str:
        """Create components overview."""
        components = []
        
        for file_path, code_file in self.parsed_files.items():
            file_name = Path(file_path).name
            
            # Count different element types
            classes = len([e for e in code_file.elements if e.element_type == CodeElementType.CLASS])
            functions = len([e for e in code_file.elements if e.element_type == CodeElementType.FUNCTION])
            
            component_info = f"""
### {file_name}

**Purpose**: {self._infer_file_purpose(code_file)}

**Components**:
- Classes: {classes}
- Functions: {functions}
- Complexity: {code_file.complexity_score:.2f}

**Key Dependencies**: {', '.join(code_file.imports[:5])}
            """
            
            components.append(component_info.strip())
        
        return "\n\n".join(components)
    
    def _calculate_average_complexity(self) -> float:
        """Calculate average complexity across all files."""
        if not self.parsed_files:
            return 0.0
        
        total_complexity = sum(cf.complexity_score for cf in self.parsed_files.values())
        return total_complexity / len(self.parsed_files)
    
    def _list_main_components(self) -> str:
        """List main components of the project."""
        component_lines = []
        
        for file_path, code_file in self.parsed_files.items():
            file_name = Path(file_path).stem
            classes = [e for e in code_file.elements if e.element_type == CodeElementType.CLASS]
            
            if classes:
                main_class = classes[0].name
                component_lines.append(f"- **{file_name}**: {main_class}")
        
        return "\n".join(component_lines) if component_lines else "- No major components identified"
    
    def _infer_file_purpose(self, code_file: CodeFile) -> str:
        """Infer the purpose of a file based on its contents."""
        classes = [e for e in code_file.elements if e.element_type == CodeElementType.CLASS]
        functions = [e for e in code_file.elements if e.element_type == CodeElementType.FUNCTION]
        
        if classes:
            return f"Defines {len(classes)} class(es) for {classes[0].name.lower()} functionality"
        elif functions:
            return f"Provides {len(functions)} utility function(s)"
        else:
            return "Configuration or data file"

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Technical Documentation Generator Agent",
        page_icon="üìö",
        layout="wide"
    )
    
    st.title("üìö Technical Documentation Generator Agent")
    st.markdown("**Automated code analysis and documentation generation**")
    
    # Initialize session state
    if 'generator' not in st.session_state:
        st.session_state['generator'] = None
    if 'analysis_results' not in st.session_state:
        st.session_state['analysis_results'] = None
    if 'generated_docs' not in st.session_state:
        st.session_state['generated_docs'] = {}
    
    # Sidebar configuration
    with st.sidebar:
        st.header("üîß Configuration")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Generator") or st.session_state['generator'] is None:
            with st.spinner("Initializing Documentation Generator..."):
                st.session_state['generator'] = DocumentationGenerator(openai_key)
                st.success("Generator ready!")
        
        st.header("üìÅ Project Analysis")
        
        # Project path input
        project_path = st.text_input(
            "Project Path",
            placeholder="/path/to/your/project",
            help="Enter the path to your Python project"
        )
        
        # For demo, create a sample project structure
        if st.button("Use Sample Project"):
            # Create sample files in memory for demo
            sample_project = {
                "main.py": '''
"""Main application module."""

class DocumentProcessor:
    """Process and analyze documents."""
    
    def __init__(self, config_path: str = None):
        """Initialize processor with optional config."""
        self.config = config_path
        self.documents = []
    
    def process_document(self, doc_path: str) -> dict:
        """Process a single document and return analysis."""
        # Processing logic here
        return {"status": "processed", "path": doc_path}
    
    def batch_process(self, doc_paths: list) -> list:
        """Process multiple documents."""
        results = []
        for path in doc_paths:
            result = self.process_document(path)
            results.append(result)
        return results

def analyze_text(text: str) -> dict:
    """Analyze text content and return insights."""
    word_count = len(text.split())
    char_count = len(text)
    
    return {
        "word_count": word_count,
        "char_count": char_count,
        "complexity": word_count / 10
    }
''',
                "utils.py": '''
"""Utility functions for the application."""

import os
import json
from typing import List, Dict, Any

def load_config(config_path: str) -> Dict[str, Any]:
    """Load configuration from JSON file."""
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Config file not found: {config_path}")
    
    with open(config_path, 'r') as f:
        return json.load(f)

def save_results(results: List[Dict], output_path: str) -> bool:
    """Save analysis results to file."""
    try:
        with open(output_path, 'w') as f:
            json.dump(results, f, indent=2)
        return True
    except Exception as e:
        print(f"Error saving results: {e}")
        return False

class Logger:
    """Simple logging utility."""
    
    def __init__(self, log_level: str = "INFO"):
        self.log_level = log_level
    
    def info(self, message: str) -> None:
        """Log info message."""
        print(f"INFO: {message}")
    
    def error(self, message: str) -> None:
        """Log error message."""
        print(f"ERROR: {message}")
'''
            }
            
            # Save sample files temporarily
            import tempfile
            temp_dir = tempfile.mkdtemp()
            
            for filename, content in sample_project.items():
                file_path = os.path.join(temp_dir, filename)
                with open(file_path, 'w') as f:
                    f.write(content)
            
            st.session_state['sample_project_path'] = temp_dir
            st.success(f"Sample project created at: {temp_dir}")
        
        if st.button("Analyze Project"):
            if st.session_state['generator']:
                analysis_path = project_path or st.session_state.get('sample_project_path')
                
                if analysis_path:
                    with st.spinner("Analyzing project..."):
                        results = st.session_state['generator'].analyze_project(analysis_path)
                        st.session_state['analysis_results'] = results
                        st.success("Project analysis completed!")
                else:
                    st.error("Please provide a project path")
            else:
                st.error("Please initialize the generator first")
    
    if not st.session_state['generator']:
        st.info("üëà Please initialize the Documentation Generator")
        return
    
    generator = st.session_state['generator']
    
    # Main interface tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üìä Analysis", "üìö Generate Docs", "üìÑ View Docs", "üîç Code Explorer", "‚öôÔ∏è Settings"])
    
    with tab1:
        st.header("üìä Project Analysis Results")
        
        if st.session_state['analysis_results']:
            results = st.session_state['analysis_results']
            
            if 'error' not in results:
                # Overview metrics
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Total Files", results.get('total_files', 0))
                with col2:
                    st.metric("Total Elements", results.get('total_elements', 0))
                with col3:
                    avg_elements = results['total_elements'] / max(results['total_files'], 1)
                    st.metric("Avg Elements/File", f"{avg_elements:.1f}")
                with col4:
                    st.metric("Project Path", "‚úì Analyzed")
                
                # File details
                st.subheader("üìÅ File Analysis")
                
                if results.get('parsed_files'):
                    files_df = pd.DataFrame(results['parsed_files'])
                    
                    # Display files table
                    st.dataframe(files_df, use_container_width=True)
                    
                    # Complexity distribution
                    if 'complexity' in files_df.columns:
                        st.subheader("üìà Complexity Distribution")
                        
                        fig = px.histogram(
                            files_df, 
                            x='complexity',
                            title="Code Complexity Distribution",
                            labels={'complexity': 'Complexity Score', 'count': 'Number of Files'}
                        )
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # Elements distribution
                    if 'elements' in files_df.columns:
                        st.subheader("üß© Elements Distribution")
                        
                        fig = px.bar(
                            files_df,
                            x='path',
                            y='elements',
                            title="Code Elements per File"
                        )
                        fig.update_xaxis(title="Files")
                        fig.update_yaxis(title="Number of Elements")
                        st.plotly_chart(fig, use_container_width=True)
                
                # File summaries
                if results.get('file_summaries'):
                    st.subheader("üìù File Summaries")
                    
                    for file_path, summary in results['file_summaries'].items():
                        with st.expander(f"üìÑ {Path(file_path).name}"):
                            st.markdown(summary)
            else:
                st.error(f"Analysis error: {results['error']}")
        else:
            st.info("No analysis results available. Please analyze a project first.")
    
    with tab2:
        st.header("üìö Generate Documentation")
        
        if st.session_state['analysis_results']:
            # Documentation type selection
            doc_type = st.selectbox(
                "Documentation Type",
                [
                    ("README", DocumentationType.README),
                    ("API Reference", DocumentationType.API_REFERENCE),
                    ("Technical Specification", DocumentationType.TECHNICAL_SPEC)
                ],
                format_func=lambda x: x[0]
            )[1]
            
            # Project information for README
            if doc_type == DocumentationType.README:
                st.subheader("üìã Project Information")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    project_name = st.text_input("Project Name", value="My Python Project")
                    package_name = st.text_input("Package Name", value="my_package")
                
                with col2:
                    version = st.text_input("Version", value="1.0.0")
                    license_type = st.text_input("License", value="MIT")
                
                description = st.text_area(
                    "Project Description",
                    value="A comprehensive Python project with automated documentation."
                )
                
                project_info = {
                    "name": project_name,
                    "package_name": package_name,
                    "version": version,
                    "license": license_type,
                    "description": description
                }
            else:
                project_info = {}
            
            # Generate documentation
            if st.button("üöÄ Generate Documentation"):
                with st.spinner(f"Generating {doc_type.value} documentation..."):
                    generated_doc = generator.generate_documentation(doc_type, project_info)
                    
                    doc_key = doc_type.value
                    st.session_state['generated_docs'][doc_key] = generated_doc
                    
                    st.success(f"{doc_type.value.title()} documentation generated!")
        else:
            st.info("Please analyze a project first before generating documentation.")
    
    with tab3:
        st.header("üìÑ View Generated Documentation")
        
        if st.session_state['generated_docs']:
            # Select documentation to view
            doc_keys = list(st.session_state['generated_docs'].keys())
            selected_doc = st.selectbox("Select Documentation", doc_keys)
            
            if selected_doc:
                doc = st.session_state['generated_docs'][selected_doc]
                
                # Display metadata
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.write(f"**Type:** {doc.doc_type.value.title()}")
                with col2:
                    st.write(f"**Generated:** {doc.generated_at.strftime('%Y-%m-%d %H:%M')}")
                with col3:
                    st.write(f"**Sections:** {len(doc.sections)}")
                
                st.divider()
                
                # Display sections
                for section in doc.sections:
                    st.subheader(section.title)
                    st.markdown(section.content)
                    st.divider()
                
                # Download option
                doc_content = f"# {doc.title}\n\n"
                for section in doc.sections:
                    doc_content += f"## {section.title}\n\n{section.content}\n\n"
                
                st.download_button(
                    label="üì• Download Documentation",
                    data=doc_content,
                    file_name=f"{selected_doc}.md",
                    mime="text/markdown"
                )
        else:
            st.info("No documentation generated yet.")
    
    with tab4:
        st.header("üîç Code Explorer")
        
        if st.session_state['analysis_results'] and generator.parsed_files:
            # File selection
            file_paths = list(generator.parsed_files.keys())
            selected_file = st.selectbox("Select File", file_paths)
            
            if selected_file:
                code_file = generator.parsed_files[selected_file]
                
                # File information
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Total Lines", code_file.total_lines)
                with col2:
                    st.metric("Elements", len(code_file.elements))
                with col3:
                    st.metric("Imports", len(code_file.imports))
                with col4:
                    st.metric("Complexity", f"{code_file.complexity_score:.2f}")
                
                # Elements exploration
                st.subheader("üß© Code Elements")
                
                # Filter by element type
                element_types = list(set(e.element_type.value for e in code_file.elements))
                selected_type = st.selectbox("Filter by Type", ["All"] + element_types)
                
                # Display elements
                filtered_elements = code_file.elements
                if selected_type != "All":
                    filtered_elements = [e for e in code_file.elements 
                                       if e.element_type.value == selected_type]
                
                for element in filtered_elements:
                    with st.expander(f"{element.element_type.value.title()}: {element.name}"):
                        col1, col2 = st.columns([2, 1])
                        
                        with col1:
                            if element.docstring:
                                st.write(f"**Description:** {element.docstring}")
                            
                            if element.parameters:
                                st.write("**Parameters:**")
                                for param in element.parameters:
                                    param_str = f"- {param['name']}"
                                    if param.get('type'):
                                        param_str += f" ({param['type']})"
                                    if param.get('default'):
                                        param_str += f" = {param['default']}"
                                    st.write(param_str)
                            
                            if element.return_type:
                                st.write(f"**Returns:** {element.return_type}")
                        
                        with col2:
                            st.write(f"**Line:** {element.line_number}")
                            st.write(f"**Complexity:** {element.complexity}")
                            st.write(f"**Public:** {'Yes' if element.is_public else 'No'}")
                        
                        # Code snippet
                        if element.code_snippet:
                            st.code(element.code_snippet, language="python")
                        
                        # AI explanation
                        if st.button(f"ü§ñ Explain {element.name}", key=f"explain_{element.element_id}"):
                            with st.spinner("Generating explanation..."):
                                if element.element_type == CodeElementType.FUNCTION:
                                    explanation = generator.explainer.explain_function(element)
                                elif element.element_type == CodeElementType.CLASS:
                                    methods = [e for e in code_file.elements 
                                             if e.element_type == CodeElementType.METHOD]
                                    explanation = generator.explainer.explain_class(element, methods)
                                else:
                                    explanation = f"**{element.element_type.value.title()}:** {element.name}"
                                
                                st.markdown(explanation)
        else:
            st.info("Please analyze a project first to explore code.")
    
    with tab5:
        st.header("‚öôÔ∏è Settings")
        
        st.subheader("üîß Generator Configuration")
        
        # Template customization
        st.write("**Documentation Templates**")
        
        template_type = st.selectbox(
            "Template Type",
            ["README", "API Reference", "Technical Specification"]
        )
        
        if template_type == "README":
            default_template = generator.templates.readme_template.source
        elif template_type == "API Reference":
            default_template = generator.templates.api_reference_template.source
        else:
            default_template = generator.templates.technical_spec_template.source
        
        # Show template (read-only for now)
        st.code(default_template, language="jinja2")
        
        st.subheader("üöÄ Export Options")
        
        # Export settings
        export_format = st.selectbox(
            "Export Format",
            ["Markdown", "HTML", "PDF"]
        )
        
        include_toc = st.checkbox("Include Table of Contents", value=True)
        include_code = st.checkbox("Include Code Snippets", value=True)
        include_diagrams = st.checkbox("Include Diagrams", value=False)
        
        st.subheader("üìä Analysis Settings")
        
        # Analysis configuration
        max_complexity = st.slider("Max Complexity Threshold", 1, 20, 10)
        min_doc_coverage = st.slider("Min Documentation Coverage %", 0, 100, 50)
        include_private = st.checkbox("Include Private Methods", value=False)

if __name__ == "__main__":
    main()
````

## Project Summary

The Technical Documentation Generator Agent automates comprehensive technical documentation creation through advanced code parsing, AI-powered explanation generation, and multi-format output capabilities, significantly reducing documentation debt while ensuring consistency and accuracy across software projects.

### Key Value Propositions:
- **Automated Code Analysis**: Deep AST parsing and structural understanding of source code with complexity analysis
- **AI-Powered Explanations**: Natural language generation of code functionality, purpose, and implementation details
- **Multi-Format Documentation**: Flexible template system supporting README, API references, and technical specifications
- **Intelligent Code Understanding**: Pattern recognition and architectural analysis for comprehensive documentation

### Technical Architecture:
The system integrates Python AST parsing for code analysis, LangChain for AI-powered explanations, Jinja2 for template rendering, and Streamlit for interactive documentation generation, creating a scalable documentation automation platform that transforms source code into comprehensive, maintainable technical documentation while preserving developer intent and architectural decisions.