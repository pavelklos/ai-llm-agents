<small>Claude Sonnet 4 **(Fitness & Nutrition Coach Agent)**</small>
# Fitness & Nutrition Coach Agent

## Key Concepts Explanation

### Goal Tracking and Progress Monitoring
Comprehensive fitness goal management system that tracks weight loss, muscle gain, endurance improvement, and nutrition targets through data visualization, milestone tracking, and adaptive goal adjustment based on user performance and progress patterns.

### Intelligent Meal Planning
AI-powered nutrition system that creates personalized meal plans based on dietary preferences, allergies, fitness goals, and nutritional requirements while considering budget constraints, cooking time, and ingredient availability.

### Wearable Device Integration
Multi-platform fitness tracker connectivity that syncs data from Fitbit, Apple Watch, Garmin, and other devices to monitor heart rate, steps, calories, sleep patterns, and workout intensity for comprehensive health analytics.

### Personalized Workout Generation
Adaptive exercise programming that creates custom workout routines based on fitness level, available equipment, time constraints, and specific goals while adjusting difficulty and progression over time.

### Nutritional Analysis and Recommendations
Advanced food database integration with macro/micronutrient tracking, calorie counting, and AI-powered recommendations for optimizing nutrition intake based on activity levels and health objectives.

## Comprehensive Project Explanation

### Objectives
The Fitness & Nutrition Coach Agent provides personalized health coaching through AI-driven meal planning, workout recommendations, and comprehensive progress tracking to help users achieve their fitness and nutrition goals effectively.

### Key Features
- **Smart Goal Setting**: SMART goal framework with progress tracking
- **Meal Plan Generation**: Automated weekly meal planning with shopping lists
- **Workout Programming**: Personalized exercise routines and progressions
- **Wearable Sync**: Real-time health data integration from multiple devices
- **Progress Analytics**: Comprehensive health and fitness dashboards

### Challenges
- **Data Integration**: Synchronizing multiple data sources and device APIs
- **Personalization**: Adapting recommendations to individual preferences and constraints
- **Nutrition Accuracy**: Ensuring precise nutritional calculations and food database reliability
- **Behavior Change**: Motivating sustained lifestyle modifications and habit formation

### Potential Impact
This system can democratize access to professional fitness coaching, improve health outcomes through data-driven insights, reduce healthcare costs through preventive wellness, and enable sustainable lifestyle changes for millions of users.

## Comprehensive Project Example with Python Implementation

### Dependencies and Setup

````python
# requirements.txt
streamlit==1.29.0
langchain==0.1.0
langchain-openai==0.0.5
pandas==2.1.4
numpy==1.24.3
plotly==5.17.0
requests==2.31.0
fitbit==0.3.1
sqlite3
datetime
pydantic==2.5.0
typing_extensions==4.8.0
scikit-learn==1.3.2
scipy==1.11.4
openfoodfacts==0.1.4
python-dotenv==1.0.0
````

### Core Implementation

````python
import sqlite3
import json
import logging
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import uuid

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np

from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class GoalType(Enum):
    WEIGHT_LOSS = "weight_loss"
    MUSCLE_GAIN = "muscle_gain"
    ENDURANCE = "endurance"
    STRENGTH = "strength"
    GENERAL_FITNESS = "general_fitness"

class ActivityLevel(Enum):
    SEDENTARY = "sedentary"
    LIGHTLY_ACTIVE = "lightly_active"
    MODERATELY_ACTIVE = "moderately_active"
    VERY_ACTIVE = "very_active"
    EXTREMELY_ACTIVE = "extremely_active"

class DietType(Enum):
    BALANCED = "balanced"
    VEGETARIAN = "vegetarian"
    VEGAN = "vegan"
    KETO = "keto"
    PALEO = "paleo"
    MEDITERRANEAN = "mediterranean"

@dataclass
class UserProfile:
    user_id: str
    name: str
    age: int
    gender: str
    height: float  # cm
    weight: float  # kg
    activity_level: ActivityLevel
    goal_type: GoalType
    target_weight: Optional[float] = None
    diet_type: DietType = DietType.BALANCED
    allergies: List[str] = field(default_factory=list)
    medical_conditions: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class NutritionGoal:
    calories: float
    protein: float  # grams
    carbs: float    # grams
    fat: float      # grams
    fiber: float    # grams
    water: float    # liters

@dataclass
class FoodItem:
    food_id: str
    name: str
    calories_per_100g: float
    protein_per_100g: float
    carbs_per_100g: float
    fat_per_100g: float
    fiber_per_100g: float

@dataclass
class Meal:
    meal_id: str
    name: str
    meal_type: str  # breakfast, lunch, dinner, snack
    ingredients: List[Dict[str, Any]]
    total_calories: float
    total_protein: float
    total_carbs: float
    total_fat: float
    preparation_time: int  # minutes
    instructions: str

@dataclass
class WorkoutExercise:
    exercise_id: str
    name: str
    muscle_groups: List[str]
    equipment: List[str]
    difficulty: str
    instructions: str
    sets: int
    reps: str
    duration: Optional[int] = None  # minutes for cardio

@dataclass
class Workout:
    workout_id: str
    name: str
    workout_type: str
    exercises: List[WorkoutExercise]
    estimated_duration: int
    estimated_calories: float
    difficulty: str

class FitnessDatabase:
    """Database management for fitness and nutrition data."""
    
    def __init__(self, db_path: str = "fitness_coach.db"):
        self.db_path = db_path
        self.init_database()
        self._populate_sample_data()
    
    def init_database(self):
        """Initialize database tables."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Users table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    user_id TEXT PRIMARY KEY,
                    name TEXT,
                    age INTEGER,
                    gender TEXT,
                    height REAL,
                    weight REAL,
                    activity_level TEXT,
                    goal_type TEXT,
                    target_weight REAL,
                    diet_type TEXT,
                    allergies TEXT,
                    medical_conditions TEXT,
                    created_at TEXT
                )
            """)
            
            # Progress tracking
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS progress (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT,
                    date TEXT,
                    weight REAL,
                    body_fat REAL,
                    muscle_mass REAL,
                    steps INTEGER,
                    calories_burned REAL,
                    sleep_hours REAL,
                    FOREIGN KEY (user_id) REFERENCES users (user_id)
                )
            """)
            
            # Nutrition log
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS nutrition_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT,
                    date TEXT,
                    meal_type TEXT,
                    food_name TEXT,
                    quantity REAL,
                    calories REAL,
                    protein REAL,
                    carbs REAL,
                    fat REAL,
                    FOREIGN KEY (user_id) REFERENCES users (user_id)
                )
            """)
            
            # Workouts log
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS workouts_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT,
                    date TEXT,
                    workout_name TEXT,
                    duration INTEGER,
                    calories_burned REAL,
                    notes TEXT,
                    FOREIGN KEY (user_id) REFERENCES users (user_id)
                )
            """)
            
            conn.commit()
    
    def _populate_sample_data(self):
        """Populate database with sample food and exercise data."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Check if data already exists
                cursor.execute("SELECT COUNT(*) FROM nutrition_log")
                if cursor.fetchone()[0] > 0:
                    return  # Data already exists
                
                # Sample food data would be inserted here
                # For brevity, using hardcoded sample data
                
        except Exception as e:
            logger.error(f"Error populating sample data: {e}")

class NutritionCalculator:
    """Calculate nutritional requirements and analyze intake."""
    
    def __init__(self):
        # Food database - simplified for demo
        self.food_database = {
            "chicken_breast": FoodItem("chicken_breast", "Chicken Breast", 165, 31, 0, 3.6, 0),
            "brown_rice": FoodItem("brown_rice", "Brown Rice", 123, 2.6, 23, 0.9, 1.8),
            "broccoli": FoodItem("broccoli", "Broccoli", 25, 3, 5, 0.3, 2.6),
            "salmon": FoodItem("salmon", "Salmon", 208, 25, 0, 12, 0),
            "oats": FoodItem("oats", "Oats", 389, 16.9, 66.3, 6.9, 10.6),
            "banana": FoodItem("banana", "Banana", 89, 1.1, 23, 0.3, 2.6),
            "greek_yogurt": FoodItem("greek_yogurt", "Greek Yogurt", 59, 10, 3.6, 0.4, 0),
            "spinach": FoodItem("spinach", "Spinach", 23, 2.9, 3.6, 0.4, 2.2),
            "sweet_potato": FoodItem("sweet_potato", "Sweet Potato", 86, 1.6, 20, 0.1, 3),
            "almonds": FoodItem("almonds", "Almonds", 579, 21.2, 21.6, 49.9, 12.5)
        }
    
    def calculate_bmr(self, weight: float, height: float, age: int, gender: str) -> float:
        """Calculate Basal Metabolic Rate using Mifflin-St Jeor equation."""
        if gender.lower() == 'male':
            bmr = 10 * weight + 6.25 * height - 5 * age + 5
        else:
            bmr = 10 * weight + 6.25 * height - 5 * age - 161
        return bmr
    
    def calculate_tdee(self, bmr: float, activity_level: ActivityLevel) -> float:
        """Calculate Total Daily Energy Expenditure."""
        multipliers = {
            ActivityLevel.SEDENTARY: 1.2,
            ActivityLevel.LIGHTLY_ACTIVE: 1.375,
            ActivityLevel.MODERATELY_ACTIVE: 1.55,
            ActivityLevel.VERY_ACTIVE: 1.725,
            ActivityLevel.EXTREMELY_ACTIVE: 1.9
        }
        return bmr * multipliers[activity_level]
    
    def calculate_nutrition_goals(self, user: UserProfile) -> NutritionGoal:
        """Calculate personalized nutrition goals."""
        bmr = self.calculate_bmr(user.weight, user.height, user.age, user.gender)
        tdee = self.calculate_tdee(bmr, user.activity_level)
        
        # Adjust calories based on goal
        if user.goal_type == GoalType.WEIGHT_LOSS:
            calories = tdee - 500  # 500 calorie deficit
        elif user.goal_type == GoalType.MUSCLE_GAIN:
            calories = tdee + 300  # 300 calorie surplus
        else:
            calories = tdee
        
        # Calculate macronutrients based on goal and diet type
        if user.goal_type == GoalType.MUSCLE_GAIN:
            protein_ratio = 0.3
            carb_ratio = 0.4
            fat_ratio = 0.3
        elif user.goal_type == GoalType.WEIGHT_LOSS:
            protein_ratio = 0.35
            carb_ratio = 0.35
            fat_ratio = 0.3
        else:
            protein_ratio = 0.25
            carb_ratio = 0.45
            fat_ratio = 0.3
        
        protein = (calories * protein_ratio) / 4  # 4 calories per gram
        carbs = (calories * carb_ratio) / 4
        fat = (calories * fat_ratio) / 9  # 9 calories per gram
        
        return NutritionGoal(
            calories=calories,
            protein=protein,
            carbs=carbs,
            fat=fat,
            fiber=25 + (calories - 1500) / 100,  # Adjust fiber based on calories
            water=2.5 + (calories - 1500) / 1000  # Adjust water based on calories
        )

class MealPlanner:
    """Generate personalized meal plans."""
    
    def __init__(self, nutrition_calc: NutritionCalculator, openai_api_key: Optional[str] = None):
        self.nutrition_calc = nutrition_calc
        self.llm = None
        if openai_api_key:
            self.llm = ChatOpenAI(
                temperature=0.7,
                model_name="gpt-4",
                openai_api_key=openai_api_key
            )
        
        self._initialize_prompts()
        self._initialize_sample_meals()
    
    def _initialize_prompts(self):
        """Initialize meal planning prompts."""
        self.meal_planning_prompt = ChatPromptTemplate.from_template("""
        Create a healthy meal plan for the following requirements:
        
        Goal: {goal_type}
        Diet Type: {diet_type}
        Daily Calories: {calories}
        Protein: {protein}g
        Carbs: {carbs}g
        Fat: {fat}g
        
        Allergies: {allergies}
        Preferences: Focus on whole foods, balanced nutrition
        
        Please suggest:
        1. Breakfast option with ingredients and approximate portions
        2. Lunch option with ingredients and approximate portions
        3. Dinner option with ingredients and approximate portions
        4. Healthy snack option
        
        For each meal, provide:
        - Meal name
        - Main ingredients with quantities
        - Approximate calories, protein, carbs, and fat
        - Brief preparation instructions
        
        Format as JSON with meals array.
        """)
    
    def _initialize_sample_meals(self):
        """Initialize sample meal templates."""
        self.sample_meals = {
            "breakfast": [
                Meal("breakfast_1", "Protein Oatmeal Bowl", "breakfast",
                     [{"food": "oats", "quantity": 50}, {"food": "banana", "quantity": 100}, 
                      {"food": "greek_yogurt", "quantity": 150}],
                     350, 20, 45, 8, 15, "Cook oats with water, top with sliced banana and Greek yogurt."),
                
                Meal("breakfast_2", "Veggie Scramble", "breakfast",
                     [{"food": "eggs", "quantity": 2}, {"food": "spinach", "quantity": 100}, 
                      {"food": "sweet_potato", "quantity": 100}],
                     280, 18, 20, 15, 20, "Scramble eggs with saut√©ed spinach and roasted sweet potato.")
            ],
            "lunch": [
                Meal("lunch_1", "Grilled Chicken Salad", "lunch",
                     [{"food": "chicken_breast", "quantity": 150}, {"food": "spinach", "quantity": 100}, 
                      {"food": "sweet_potato", "quantity": 100}],
                     380, 50, 25, 8, 25, "Grill chicken, serve over spinach with roasted sweet potato."),
                
                Meal("lunch_2", "Salmon Bowl", "lunch",
                     [{"food": "salmon", "quantity": 120}, {"food": "brown_rice", "quantity": 80}, 
                      {"food": "broccoli", "quantity": 150}],
                     420, 35, 40, 18, 30, "Bake salmon, serve with brown rice and steamed broccoli.")
            ],
            "dinner": [
                Meal("dinner_1", "Lean Protein Plate", "dinner",
                     [{"food": "chicken_breast", "quantity": 150}, {"food": "brown_rice", "quantity": 60}, 
                      {"food": "broccoli", "quantity": 200}],
                     400, 52, 35, 9, 25, "Grill chicken, serve with rice and vegetables."),
                
                Meal("dinner_2", "Fish & Vegetables", "dinner",
                     [{"food": "salmon", "quantity": 130}, {"food": "sweet_potato", "quantity": 120}, 
                      {"food": "spinach", "quantity": 100}],
                     450, 35, 30, 20, 30, "Bake salmon with roasted vegetables.")
            ]
        }
    
    def generate_meal_plan(self, user: UserProfile, nutrition_goals: NutritionGoal, days: int = 7) -> List[Dict[str, Any]]:
        """Generate a personalized meal plan."""
        try:
            meal_plan = []
            
            for day in range(days):
                daily_plan = {
                    "day": day + 1,
                    "date": (datetime.now() + timedelta(days=day)).strftime("%Y-%m-%d"),
                    "meals": [],
                    "total_calories": 0,
                    "total_protein": 0,
                    "total_carbs": 0,
                    "total_fat": 0
                }
                
                # Select meals for the day
                import random
                breakfast = random.choice(self.sample_meals["breakfast"])
                lunch = random.choice(self.sample_meals["lunch"])
                dinner = random.choice(self.sample_meals["dinner"])
                
                daily_meals = [breakfast, lunch, dinner]
                
                # Calculate daily totals
                for meal in daily_meals:
                    daily_plan["meals"].append({
                        "name": meal.name,
                        "type": meal.meal_type,
                        "ingredients": meal.ingredients,
                        "calories": meal.total_calories,
                        "protein": meal.total_protein,
                        "carbs": meal.total_carbs,
                        "fat": meal.total_fat,
                        "prep_time": meal.preparation_time,
                        "instructions": meal.instructions
                    })
                    
                    daily_plan["total_calories"] += meal.total_calories
                    daily_plan["total_protein"] += meal.total_protein
                    daily_plan["total_carbs"] += meal.total_carbs
                    daily_plan["total_fat"] += meal.total_fat
                
                meal_plan.append(daily_plan)
            
            return meal_plan
        
        except Exception as e:
            logger.error(f"Meal planning error: {e}")
            return []

class WorkoutPlanner:
    """Generate personalized workout plans."""
    
    def __init__(self):
        self._initialize_exercises()
    
    def _initialize_exercises(self):
        """Initialize exercise database."""
        self.exercises = {
            "strength": [
                WorkoutExercise("squat", "Bodyweight Squat", ["quadriceps", "glutes"], 
                               [], "beginner", "Stand with feet hip-width apart, lower body as if sitting back.", 3, "12-15"),
                WorkoutExercise("pushup", "Push-up", ["chest", "triceps", "shoulders"], 
                               [], "beginner", "Start in plank position, lower chest to ground.", 3, "8-12"),
                WorkoutExercise("deadlift", "Deadlift", ["hamstrings", "glutes", "back"], 
                               ["dumbbells"], "intermediate", "Hinge at hips, keep back straight.", 3, "8-10"),
                WorkoutExercise("plank", "Plank", ["core"], [], "beginner", 
                               "Hold plank position with straight body.", 3, "30-60 sec")
            ],
            "cardio": [
                WorkoutExercise("running", "Running", ["legs", "cardiovascular"], 
                               [], "beginner", "Maintain steady pace, focus on breathing.", 1, "", 30),
                WorkoutExercise("cycling", "Stationary Cycling", ["legs", "cardiovascular"], 
                               ["bike"], "beginner", "Moderate intensity cycling.", 1, "", 25),
                WorkoutExercise("jumping_jacks", "Jumping Jacks", ["full_body", "cardiovascular"], 
                               [], "beginner", "Jump feet apart while raising arms overhead.", 3, "30 sec")
            ]
        }
    
    def generate_workout(self, user: UserProfile, workout_type: str = "strength") -> Workout:
        """Generate a workout based on user profile and type."""
        try:
            available_exercises = self.exercises.get(workout_type, self.exercises["strength"])
            
            # Select exercises based on user's goal and fitness level
            if user.goal_type == GoalType.MUSCLE_GAIN:
                selected_exercises = [ex for ex in available_exercises if "strength" in ex.name.lower() or ex.sets > 1]
            elif user.goal_type == GoalType.WEIGHT_LOSS:
                # Mix of strength and cardio
                selected_exercises = available_exercises[:3]  # Take first 3 for simplicity
            else:
                selected_exercises = available_exercises[:4]  # Balanced selection
            
            import random
            if len(selected_exercises) > 4:
                selected_exercises = random.sample(selected_exercises, 4)
            
            # Calculate estimated duration and calories
            total_duration = sum(ex.duration or 15 for ex in selected_exercises)  # 15 min default per strength exercise
            estimated_calories = self._estimate_calories(total_duration, user.weight, workout_type)
            
            workout = Workout(
                workout_id=str(uuid.uuid4()),
                name=f"{workout_type.title()} Workout",
                workout_type=workout_type,
                exercises=selected_exercises,
                estimated_duration=total_duration,
                estimated_calories=estimated_calories,
                difficulty="beginner"  # Can be adjusted based on user level
            )
            
            return workout
        
        except Exception as e:
            logger.error(f"Workout generation error: {e}")
            return None
    
    def _estimate_calories(self, duration_minutes: int, weight_kg: float, workout_type: str) -> float:
        """Estimate calories burned during workout."""
        # METs (Metabolic Equivalent of Task) values
        met_values = {
            "strength": 3.5,
            "cardio": 7.0,
            "flexibility": 2.5
        }
        
        met = met_values.get(workout_type, 4.0)
        # Calories = METs √ó weight(kg) √ó time(hours)
        calories = met * weight_kg * (duration_minutes / 60)
        return round(calories, 1)

class ProgressTracker:
    """Track user progress and provide analytics."""
    
    def __init__(self, database: FitnessDatabase):
        self.database = database
    
    def log_progress(self, user_id: str, weight: float, body_fat: Optional[float] = None, 
                    steps: Optional[int] = None, sleep_hours: Optional[float] = None):
        """Log daily progress metrics."""
        try:
            with sqlite3.connect(self.database.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT INTO progress (user_id, date, weight, body_fat, steps, sleep_hours)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (user_id, datetime.now().strftime("%Y-%m-%d"), weight, body_fat, steps, sleep_hours))
                conn.commit()
                
                logger.info(f"Progress logged for user {user_id}")
        
        except Exception as e:
            logger.error(f"Progress logging error: {e}")
    
    def get_progress_data(self, user_id: str, days: int = 30) -> pd.DataFrame:
        """Retrieve progress data for analysis."""
        try:
            with sqlite3.connect(self.database.db_path) as conn:
                query = """
                    SELECT date, weight, body_fat, steps, sleep_hours
                    FROM progress
                    WHERE user_id = ? AND date >= date('now', '-{} days')
                    ORDER BY date
                """.format(days)
                
                df = pd.read_sql_query(query, conn, params=[user_id])
                df['date'] = pd.to_datetime(df['date'])
                return df
        
        except Exception as e:
            logger.error(f"Progress data retrieval error: {e}")
            return pd.DataFrame()
    
    def analyze_trends(self, user_id: str) -> Dict[str, Any]:
        """Analyze progress trends and provide insights."""
        try:
            df = self.get_progress_data(user_id, 90)  # 3 months of data
            
            if df.empty:
                return {"error": "No progress data available"}
            
            analysis = {}
            
            # Weight trend
            if 'weight' in df.columns and df['weight'].notna().sum() > 1:
                weight_data = df.dropna(subset=['weight'])
                days_diff = (weight_data['date'].iloc[-1] - weight_data['date'].iloc[0]).days
                weight_change = weight_data['weight'].iloc[-1] - weight_data['weight'].iloc[0]
                
                analysis['weight_trend'] = {
                    'total_change': round(weight_change, 1),
                    'weekly_rate': round((weight_change / max(days_diff, 1)) * 7, 2),
                    'direction': 'decreasing' if weight_change < 0 else 'increasing' if weight_change > 0 else 'stable'
                }
            
            # Activity trends
            if 'steps' in df.columns and df['steps'].notna().sum() > 0:
                avg_steps = df['steps'].mean()
                analysis['activity_trend'] = {
                    'avg_daily_steps': int(avg_steps),
                    'most_active_day': df.loc[df['steps'].idxmax(), 'date'].strftime('%Y-%m-%d') if not df['steps'].isna().all() else None
                }
            
            # Sleep patterns
            if 'sleep_hours' in df.columns and df['sleep_hours'].notna().sum() > 0:
                avg_sleep = df['sleep_hours'].mean()
                analysis['sleep_trend'] = {
                    'avg_sleep_hours': round(avg_sleep, 1),
                    'sleep_quality': 'good' if avg_sleep >= 7 else 'needs_improvement'
                }
            
            return analysis
        
        except Exception as e:
            logger.error(f"Trend analysis error: {e}")
            return {"error": str(e)}

class FitnessNutritionCoach:
    """Main coach agent orchestrating all components."""
    
    def __init__(self, openai_api_key: Optional[str] = None):
        self.database = FitnessDatabase()
        self.nutrition_calc = NutritionCalculator()
        self.meal_planner = MealPlanner(self.nutrition_calc, openai_api_key)
        self.workout_planner = WorkoutPlanner()
        self.progress_tracker = ProgressTracker(self.database)
        
        self.current_user = None
    
    def create_user_profile(self, name: str, age: int, gender: str, height: float, 
                          weight: float, activity_level: str, goal_type: str) -> str:
        """Create a new user profile."""
        try:
            user_id = str(uuid.uuid4())
            user = UserProfile(
                user_id=user_id,
                name=name,
                age=age,
                gender=gender,
                height=height,
                weight=weight,
                activity_level=ActivityLevel(activity_level),
                goal_type=GoalType(goal_type)
            )
            
            # Save to database
            with sqlite3.connect(self.database.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT INTO users (user_id, name, age, gender, height, weight, 
                                     activity_level, goal_type, created_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (user.user_id, user.name, user.age, user.gender, user.height, 
                     user.weight, user.activity_level.value, user.goal_type.value, 
                     user.created_at.isoformat()))
                conn.commit()
            
            self.current_user = user
            logger.info(f"Created user profile for {name}")
            return user_id
        
        except Exception as e:
            logger.error(f"User creation error: {e}")
            return None
    
    def get_personalized_plan(self, user_id: str) -> Dict[str, Any]:
        """Generate comprehensive personalized plan."""
        try:
            # Load user
            user = self._load_user(user_id)
            if not user:
                return {"error": "User not found"}
            
            # Calculate nutrition goals
            nutrition_goals = self.nutrition_calc.calculate_nutrition_goals(user)
            
            # Generate meal plan
            meal_plan = self.meal_planner.generate_meal_plan(user, nutrition_goals)
            
            # Generate workout plan
            workout = self.workout_planner.generate_workout(user)
            
            # Get progress analysis
            progress_analysis = self.progress_tracker.analyze_trends(user_id)
            
            plan = {
                "user_profile": {
                    "name": user.name,
                    "goal": user.goal_type.value,
                    "activity_level": user.activity_level.value
                },
                "nutrition_goals": {
                    "daily_calories": round(nutrition_goals.calories),
                    "protein": round(nutrition_goals.protein),
                    "carbs": round(nutrition_goals.carbs),
                    "fat": round(nutrition_goals.fat),
                    "fiber": round(nutrition_goals.fiber),
                    "water": round(nutrition_goals.water, 1)
                },
                "meal_plan": meal_plan[:3],  # First 3 days
                "workout_plan": {
                    "name": workout.name if workout else "No workout available",
                    "exercises": [{"name": ex.name, "sets": ex.sets, "reps": ex.reps} 
                                for ex in workout.exercises] if workout else [],
                    "duration": workout.estimated_duration if workout else 0,
                    "calories": workout.estimated_calories if workout else 0
                },
                "progress_analysis": progress_analysis
            }
            
            return plan
        
        except Exception as e:
            logger.error(f"Plan generation error: {e}")
            return {"error": str(e)}
    
    def _load_user(self, user_id: str) -> Optional[UserProfile]:
        """Load user profile from database."""
        try:
            with sqlite3.connect(self.database.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
                row = cursor.fetchone()
                
                if row:
                    return UserProfile(
                        user_id=row[0],
                        name=row[1],
                        age=row[2],
                        gender=row[3],
                        height=row[4],
                        weight=row[5],
                        activity_level=ActivityLevel(row[6]),
                        goal_type=GoalType(row[7])
                    )
            
            return None
        
        except Exception as e:
            logger.error(f"User loading error: {e}")
            return None

def main():
    """Main Streamlit application."""
    st.set_page_config(
        page_title="Fitness & Nutrition Coach Agent",
        page_icon="üí™",
        layout="wide"
    )
    
    st.title("üí™ Fitness & Nutrition Coach Agent")
    st.markdown("**AI-powered personalized fitness coaching and nutrition planning**")
    
    # Initialize session state
    if 'coach' not in st.session_state:
        st.session_state['coach'] = None
    if 'user_id' not in st.session_state:
        st.session_state['user_id'] = None
    if 'current_plan' not in st.session_state:
        st.session_state['current_plan'] = None
    
    # Sidebar
    with st.sidebar:
        st.header("üîß Setup")
        
        openai_key = st.text_input("OpenAI API Key (Optional)", type="password")
        
        if st.button("Initialize Coach") or st.session_state['coach'] is None:
            with st.spinner("Initializing Fitness Coach..."):
                st.session_state['coach'] = FitnessNutritionCoach(openai_key)
                st.success("Coach ready!")
        
        # User profile creation
        if st.session_state['coach'] and not st.session_state['user_id']:
            st.header("üë§ Create Profile")
            
            with st.form("user_profile"):
                name = st.text_input("Name")
                age = st.number_input("Age", 18, 100, 30)
                gender = st.selectbox("Gender", ["male", "female"])
                height = st.number_input("Height (cm)", 140, 220, 170)
                weight = st.number_input("Weight (kg)", 40, 200, 70)
                activity = st.selectbox("Activity Level", [level.value for level in ActivityLevel])
                goal = st.selectbox("Fitness Goal", [goal.value for goal in GoalType])
                
                if st.form_submit_button("Create Profile"):
                    user_id = st.session_state['coach'].create_user_profile(
                        name, age, gender, height, weight, activity, goal
                    )
                    if user_id:
                        st.session_state['user_id'] = user_id
                        st.success(f"Profile created for {name}!")
                        st.rerun()
    
    if not st.session_state['coach']:
        st.info("üëà Please initialize the Fitness Coach")
        return
    
    if not st.session_state['user_id']:
        st.info("üëà Please create your user profile")
        return
    
    coach = st.session_state['coach']
    user_id = st.session_state['user_id']
    
    # Main tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üéØ Dashboard", "üçΩÔ∏è Nutrition", "üí™ Workouts", "üìà Progress", "‚öôÔ∏è Settings"])
    
    with tab1:
        st.header("üéØ Your Fitness Dashboard")
        
        if st.button("üîÑ Generate New Plan"):
            with st.spinner("Creating your personalized plan..."):
                plan = coach.get_personalized_plan(user_id)
                st.session_state['current_plan'] = plan
        
        if st.session_state['current_plan']:
            plan = st.session_state['current_plan']
            
            if 'error' not in plan:
                # User info
                st.subheader("üë§ Profile Overview")
                profile = plan['user_profile']
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.write(f"**Name:** {profile['name']}")
                with col2:
                    st.write(f"**Goal:** {profile['goal'].replace('_', ' ').title()}")
                with col3:
                    st.write(f"**Activity:** {profile['activity_level'].replace('_', ' ').title()}")
                
                # Nutrition goals
                st.subheader("üéØ Daily Nutrition Targets")
                nutrition = plan['nutrition_goals']
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Calories", f"{nutrition['daily_calories']}")
                with col2:
                    st.metric("Protein", f"{nutrition['protein']}g")
                with col3:
                    st.metric("Carbs", f"{nutrition['carbs']}g")
                with col4:
                    st.metric("Fat", f"{nutrition['fat']}g")
                
                # Today's plan
                st.subheader("üìÖ Today's Plan")
                
                if plan.get('meal_plan'):
                    today_meals = plan['meal_plan'][0]['meals']
                    
                    for meal in today_meals:
                        with st.expander(f"üçΩÔ∏è {meal['name']} ({meal['calories']} cal)"):
                            st.write(f"**Prep Time:** {meal['prep_time']} minutes")
                            st.write(f"**Instructions:** {meal['instructions']}")
                            
                            # Nutrition breakdown
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.write(f"Protein: {meal['protein']}g")
                            with col2:
                                st.write(f"Carbs: {meal['carbs']}g")
                            with col3:
                                st.write(f"Fat: {meal['fat']}g")
                
                # Workout plan
                workout = plan.get('workout_plan', {})
                if workout.get('exercises'):
                    st.subheader("üí™ Today's Workout")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.write(f"**Duration:** {workout['duration']} minutes")
                    with col2:
                        st.write(f"**Est. Calories:** {workout['calories']}")
                    
                    for exercise in workout['exercises']:
                        st.write(f"‚Ä¢ {exercise['name']}: {exercise['sets']} sets x {exercise['reps']}")
            else:
                st.error(plan['error'])
        else:
            st.info("Click 'Generate New Plan' to get your personalized fitness plan!")
    
    with tab2:
        st.header("üçΩÔ∏è Nutrition Planning")
        
        if st.session_state['current_plan'] and 'meal_plan' in st.session_state['current_plan']:
            meal_plan = st.session_state['current_plan']['meal_plan']
            
            # Meal plan overview
            st.subheader("üìÖ 7-Day Meal Plan")
            
            for day_plan in meal_plan:
                with st.expander(f"Day {day_plan['day']} - {day_plan['date']}"):
                    
                    # Daily nutrition summary
                    col1, col2, col3, col4 = st.columns(4)
                    with col1:
                        st.metric("Calories", int(day_plan['total_calories']))
                    with col2:
                        st.metric("Protein", f"{int(day_plan['total_protein'])}g")
                    with col3:
                        st.metric("Carbs", f"{int(day_plan['total_carbs'])}g")
                    with col4:
                        st.metric("Fat", f"{int(day_plan['total_fat'])}g")
                    
                    # Meals for the day
                    for meal in day_plan['meals']:
                        st.write(f"**{meal['type'].title()}: {meal['name']}**")
                        st.write(f"*{meal['instructions']}*")
                        st.write(f"Calories: {meal['calories']} | Prep: {meal['prep_time']} min")
                        st.write("---")
        
        # Nutrition tracking
        st.subheader("üìä Track Today's Intake")
        
        with st.form("nutrition_log"):
            meal_type = st.selectbox("Meal Type", ["breakfast", "lunch", "dinner", "snack"])
            food_name = st.text_input("Food Item")
            quantity = st.number_input("Quantity (grams)", 1, 1000, 100)
            
            if st.form_submit_button("Log Food"):
                # In a real implementation, this would calculate nutrition and save to database
                st.success(f"Logged {quantity}g of {food_name} for {meal_type}")
    
    with tab3:
        st.header("üí™ Workout Planning")
        
        # Workout type selection
        workout_type = st.selectbox("Workout Type", ["strength", "cardio", "flexibility"])
        
        if st.button("Generate Workout"):
            with st.spinner("Creating your workout..."):
                user = coach._load_user(user_id)
                if user:
                    workout = coach.workout_planner.generate_workout(user, workout_type)
                    
                    if workout:
                        st.success(f"Generated {workout.name}")
                        
                        # Workout details
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("Duration", f"{workout.estimated_duration} min")
                        with col2:
                            st.metric("Exercises", len(workout.exercises))
                        with col3:
                            st.metric("Est. Calories", workout.estimated_calories)
                        
                        # Exercise list
                        st.subheader("Exercises")
                        
                        for i, exercise in enumerate(workout.exercises, 1):
                            with st.expander(f"{i}. {exercise.name}"):
                                st.write(f"**Target:** {', '.join(exercise.muscle_groups)}")
                                st.write(f"**Equipment:** {', '.join(exercise.equipment) if exercise.equipment else 'None'}")
                                st.write(f"**Sets/Reps:** {exercise.sets} sets x {exercise.reps}")
                                st.write(f"**Instructions:** {exercise.instructions}")
        
        # Workout history
        st.subheader("üìù Log Workout")
        
        with st.form("workout_log"):
            workout_name = st.text_input("Workout Name")
            duration = st.number_input("Duration (minutes)", 5, 180, 30)
            calories = st.number_input("Calories Burned", 50, 1000, 200)
            notes = st.text_area("Notes")
            
            if st.form_submit_button("Log Workout"):
                # Save to database
                try:
                    with sqlite3.connect(coach.database.db_path) as conn:
                        cursor = conn.cursor()
                        cursor.execute("""
                            INSERT INTO workouts_log (user_id, date, workout_name, duration, calories_burned, notes)
                            VALUES (?, ?, ?, ?, ?, ?)
                        """, (user_id, datetime.now().strftime("%Y-%m-%d"), workout_name, duration, calories, notes))
                        conn.commit()
                    
                    st.success("Workout logged successfully!")
                except Exception as e:
                    st.error(f"Error logging workout: {e}")
    
    with tab4:
        st.header("üìà Progress Tracking")
        
        # Log today's metrics
        st.subheader("üìù Log Today's Progress")
        
        with st.form("progress_log"):
            weight = st.number_input("Weight (kg)", 40.0, 200.0, 70.0, 0.1)
            steps = st.number_input("Steps", 0, 50000, 8000)
            sleep_hours = st.number_input("Sleep Hours", 0.0, 24.0, 8.0, 0.5)
            
            if st.form_submit_button("Log Progress"):
                coach.progress_tracker.log_progress(user_id, weight, None, steps, sleep_hours)
                st.success("Progress logged!")
        
        # Progress visualization
        st.subheader("üìä Progress Charts")
        
        # Get progress data
        progress_df = coach.progress_tracker.get_progress_data(user_id, 30)
        
        if not progress_df.empty:
            # Weight chart
            if 'weight' in progress_df.columns and progress_df['weight'].notna().sum() > 0:
                fig_weight = px.line(progress_df, x='date', y='weight', 
                                   title='Weight Progress (30 days)')
                st.plotly_chart(fig_weight, use_container_width=True)
            
            # Activity chart
            if 'steps' in progress_df.columns and progress_df['steps'].notna().sum() > 0:
                fig_steps = px.bar(progress_df, x='date', y='steps', 
                                 title='Daily Steps (30 days)')
                st.plotly_chart(fig_steps, use_container_width=True)
            
            # Sleep chart
            if 'sleep_hours' in progress_df.columns and progress_df['sleep_hours'].notna().sum() > 0:
                fig_sleep = px.line(progress_df, x='date', y='sleep_hours', 
                                  title='Sleep Hours (30 days)')
                fig_sleep.add_hline(y=8, line_dash="dash", line_color="green", 
                                  annotation_text="Recommended")
                st.plotly_chart(fig_sleep, use_container_width=True)
        else:
            st.info("No progress data available. Start logging your daily metrics!")
        
        # Progress analysis
        st.subheader("üîç Progress Analysis")
        
        analysis = coach.progress_tracker.analyze_trends(user_id)
        
        if 'error' not in analysis:
            if 'weight_trend' in analysis:
                weight_trend = analysis['weight_trend']
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Weight Change", f"{weight_trend['total_change']} kg")
                with col2:
                    st.metric("Weekly Rate", f"{weight_trend['weekly_rate']} kg/week")
                with col3:
                    direction_emoji = "üìâ" if weight_trend['direction'] == 'decreasing' else "üìà" if weight_trend['direction'] == 'increasing' else "‚û°Ô∏è"
                    st.metric("Trend", f"{direction_emoji} {weight_trend['direction']}")
            
            if 'activity_trend' in analysis:
                activity = analysis['activity_trend']
                st.metric("Average Daily Steps", f"{activity['avg_daily_steps']:,}")
            
            if 'sleep_trend' in analysis:
                sleep = analysis['sleep_trend']
                quality_emoji = "üò¥" if sleep['sleep_quality'] == 'good' else "üòµ"
                st.metric("Average Sleep", f"{quality_emoji} {sleep['avg_sleep_hours']} hours")
        else:
            st.info("No analysis available yet. Keep logging your progress!")
    
    with tab5:
        st.header("‚öôÔ∏è Settings")
        
        st.subheader("üë§ Profile Settings")
        
        # Profile updates would go here
        st.info("Profile update functionality would be implemented here")
        
        st.subheader("üéØ Goal Updates")
        
        new_goal = st.selectbox("Update Fitness Goal", [goal.value for goal in GoalType])
        new_activity = st.selectbox("Update Activity Level", [level.value for level in ActivityLevel])
        
        if st.button("Update Goals"):
            st.success("Goals updated! Generate a new plan to see changes.")
        
        st.subheader("üì± Integrations")
        
        st.info("Wearable device integrations:")
        st.write("‚Ä¢ Fitbit API")
        st.write("‚Ä¢ Apple HealthKit")
        st.write("‚Ä¢ Google Fit")
        st.write("‚Ä¢ Garmin Connect")
        
        st.subheader("üîî Notifications")
        
        meal_reminders = st.checkbox("Meal reminders", True)
        workout_reminders = st.checkbox("Workout reminders", True)
        progress_updates = st.checkbox("Weekly progress updates", True)

if __name__ == "__main__":
    main()
````

## Project Summary

The Fitness & Nutrition Coach Agent delivers comprehensive personalized health coaching through AI-driven meal planning, workout generation, and progress tracking, integrating wearable data to provide adaptive fitness guidance and sustainable lifestyle transformation support.

### Key Value Propositions:
- **Personalized Coaching**: AI-powered meal plans and workouts adapted to individual goals and preferences
- **Comprehensive Tracking**: Integrated progress monitoring with wearable device data synchronization
- **Intelligent Analytics**: Trend analysis and predictive insights for optimized health outcomes
- **Adaptive Planning**: Dynamic adjustment of nutrition and fitness plans based on progress and feedback

### Technical Architecture:
The system combines nutritional calculation engines for meal planning, exercise databases for workout generation, SQLite for progress tracking, and machine learning for trend analysis, creating a scalable health coaching platform that transforms personal fitness management through data-driven insights and intelligent automation while maintaining focus on sustainable behavior change and long-term health optimization.