<small>Claude Sonnet 4 **(Syst√©m ≈ô√≠zen√≠ zemƒõdƒõlsk√Ωch plodin s MCP)**</small>
# Agricultural Crop Management System

## Kl√≠ƒçov√© koncepty projektu

### Model Context Protocol (MCP)
**MCP** je protokol navr≈æen√Ω pro efektivn√≠ komunikaci mezi AI modely a extern√≠mi datov√Ωmi zdroji. Umo≈æ≈àuje model≈Øm p≈ôistupovat k real-time dat≈Øm ze senzor≈Ø, satelitn√≠ch sn√≠mk≈Ø a dal≈°√≠ch zdroj≈Ø bez nutnosti p≈ô√≠m√© integrace.

### Satelitn√≠ sn√≠mkov√°n√≠
Vyu≈æit√≠ **satelitn√≠ch dat** pro monitoring vegetaƒçn√≠ch index≈Ø (NDVI, EVI), detekci chorob plodin a sledov√°n√≠ r≈Østu. Sentinel-2 a Landsat poskytuj√≠ pravideln√© sn√≠mky s vysok√Ωm rozli≈°en√≠m.

### P≈Ødn√≠ senzory
**IoT senzory** mƒõ≈ô√≠c√≠ vlhkost p≈Ødy, pH, teplotu, ≈æiviny a dal≈°√≠ parametry. Data jsou sb√≠r√°na v re√°ln√©m ƒçase a poskytuj√≠ detailn√≠ informace o stavu p≈Ødy.

### Meteorologick√° data
**Klimatick√° data** vƒçetnƒõ sr√°≈æek, teploty, vlhkosti vzduchu, rychlosti vƒõtru a sol√°rn√≠ radiace. Kritick√° pro predikci r≈Østu plodin a pl√°nov√°n√≠ zavla≈æov√°n√≠.

### Predikce v√Ωnos≈Ø
**ML algoritmy** analyzuj√≠c√≠ historick√° data, aktu√°ln√≠ stav plodin a podm√≠nky prost≈ôed√≠ pro p≈ôedpovƒõƒè oƒçek√°van√Ωch v√Ωnos≈Ø s vysokou p≈ôesnost√≠.

### Precizn√≠ zemƒõdƒõlstv√≠
**Technologick√Ω p≈ô√≠stup** vyu≈æ√≠vaj√≠c√≠ GPS, senzory a data analytics pro optimalizaci aplikace hnojiv, pesticid≈Ø a vody na z√°kladƒõ specifick√Ωch pot≈ôeb jednotliv√Ωch ƒç√°st√≠ pole.

### John Deere API
**Programov√© rozhran√≠** umo≈æ≈àuj√≠c√≠ integraci s John Deere stroji a syst√©my pro z√≠sk√°v√°n√≠ dat o provozu stroj≈Ø, aplikaci vstup≈Ø a sbƒõr dat z pole.

## Komplexn√≠ vysvƒõtlen√≠ projektu

### C√≠le projektu
Syst√©m ≈ô√≠zen√≠ zemƒõdƒõlsk√Ωch plodin s MCP je pokroƒçil√° platforma integruj√≠c√≠ multiple datov√© zdroje pro optimalizaci zemƒõdƒõlsk√© produkce. Hlavn√≠m c√≠lem je vytvo≈ôen√≠ inteligentn√≠ho syst√©mu, kter√Ω:

- **Automatizuje monitoring plodin** prost≈ôednictv√≠m satelitn√≠ch sn√≠mk≈Ø a IoT senzor≈Ø
- **Predikuje v√Ωnosy** s vysokou p≈ôesnost√≠ pomoc√≠ machine learning algoritm≈Ø
- **Optimalizuje vstupy** (hnojiva, voda, pesticidy) na z√°kladƒõ real-time dat
- **Integruje zemƒõdƒõlsk√© stroje** pro automatick√© aplikace doporuƒçen√≠
- **Poskytuje real-time insights** farm√°≈ô≈Øm pro informovan√° rozhodnut√≠

### Technick√© v√Ωzvy
Projekt ≈ôe≈°√≠ nƒõkolik komplexn√≠ch technick√Ωch probl√©m≈Ø:

**Integrace heterogenn√≠ch dat**: Kombinace satelitn√≠ch sn√≠mk≈Ø, senzorov√Ωch dat, meteorologick√Ωch informac√≠ a dat ze stroj≈Ø vy≈æaduje sofistikovan√© ETL procesy a normalizaci dat.

**Real-time processing**: Zpracov√°n√≠ velk√Ωch objem≈Ø dat v re√°ln√©m ƒçase pro poskytov√°n√≠ okam≈æit√Ωch doporuƒçen√≠.

**Scalabilita**: Syst√©m mus√≠ b√Ωt schopen obsluhovat tis√≠ce farem s miliony senzor≈Ø souƒçasnƒõ.

**Prediktivn√≠ modelov√°n√≠**: V√Ωvoj p≈ôesn√Ωch ML model≈Ø pro predikci v√Ωnos≈Ø a detekci probl√©m≈Ø v ran√Ωch st√°di√≠ch.

### Potenci√°ln√≠ dopad
Implementace tohoto syst√©mu m≈Ø≈æe v√©st k:
- **Zv√Ω≈°en√≠ v√Ωnos≈Ø o 15-25%** prost≈ôednictv√≠m optimalizovan√© aplikace vstup≈Ø
- **Sn√≠≈æen√≠ n√°klad≈Ø o 20-30%** d√≠ky precizn√≠mu d√°vkov√°n√≠ hnojiv a pesticid≈Ø
- **√ösporu vody a≈æ 40%** pomoc√≠ inteligentn√≠ho zavla≈æov√°n√≠
- **Ran√° detekce chorob** a ≈°k≈Ødc≈Ø sni≈æuj√≠c√≠ ztr√°ty
- **Udr≈æiteln√© zemƒõdƒõlstv√≠** s minim√°ln√≠m environment√°ln√≠m dopadem

## Komplexn√≠ implementace v Pythonu

````python
import asyncio
import json
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import requests
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
import rasterio
from rasterio.features import shapes
import geopandas as gpd
from shapely.geometry import Point, Polygon
import openai
from pydantic import BaseModel
import httpx
import logging
from fastapi import FastAPI, HTTPException
from contextlib import asynccontextmanager

# Nastaven√≠ logov√°n√≠
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database modely
Base = declarative_base()

class CropField(Base):
    __tablename__ = "crop_fields"
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100))
    area_hectares = Column(Float)
    crop_type = Column(String(50))
    geometry = Column(JSON)  # GeoJSON polygon
    created_at = Column(DateTime, default=datetime.utcnow)

class SensorReading(Base):
    __tablename__ = "sensor_readings"
    
    id = Column(Integer, primary_key=True)
    field_id = Column(Integer)
    sensor_type = Column(String(50))
    value = Column(Float)
    unit = Column(String(20))
    timestamp = Column(DateTime, default=datetime.utcnow)
    location = Column(JSON)  # {"lat": float, "lon": float}

class YieldPrediction(Base):
    __tablename__ = "yield_predictions"
    
    id = Column(Integer, primary_key=True)
    field_id = Column(Integer)
    predicted_yield = Column(Float)
    confidence_score = Column(Float)
    prediction_date = Column(DateTime, default=datetime.utcnow)
    model_version = Column(String(20))

# Datov√© struktury
@dataclass
class WeatherData:
    temperature: float
    humidity: float
    precipitation: float
    wind_speed: float
    solar_radiation: float
    timestamp: datetime

@dataclass
class SatelliteImagery:
    ndvi_mean: float
    ndvi_std: float
    evi_mean: float
    image_date: datetime
    cloud_coverage: float

@dataclass
class SoilSensorData:
    moisture_level: float
    ph_level: float
    nitrogen: float
    phosphorus: float
    potassium: float
    temperature: float

# MCP Client pro komunikaci s extern√≠mi zdroji
class MCPClient:
    def __init__(self, base_url: str, api_key: str):
        self.base_url = base_url
        self.api_key = api_key
        self.session = httpx.AsyncClient()
    
    async def get_satellite_data(self, field_polygon: Dict, date_range: tuple) -> Dict:
        """Z√≠sk√°n√≠ satelitn√≠ch dat pro dan√© pole a ƒçasov√© obdob√≠"""
        payload = {
            "geometry": field_polygon,
            "start_date": date_range[0].isoformat(),
            "end_date": date_range[1].isoformat(),
            "indices": ["NDVI", "EVI", "SAVI"]
        }
        
        try:
            response = await self.session.post(
                f"{self.base_url}/satellite/query",
                json=payload,
                headers={"Authorization": f"Bearer {self.api_key}"}
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ satelitn√≠ch dat: {e}")
            return {}
    
    async def get_weather_forecast(self, lat: float, lon: float, days: int = 7) -> List[WeatherData]:
        """Z√≠sk√°n√≠ meteorologick√© p≈ôedpovƒõdi"""
        try:
            response = await self.session.get(
                f"{self.base_url}/weather/forecast",
                params={"lat": lat, "lon": lon, "days": days},
                headers={"Authorization": f"Bearer {self.api_key}"}
            )
            response.raise_for_status()
            data = response.json()
            
            weather_list = []
            for item in data.get("forecast", []):
                weather_list.append(WeatherData(
                    temperature=item["temperature"],
                    humidity=item["humidity"],
                    precipitation=item["precipitation"],
                    wind_speed=item["wind_speed"],
                    solar_radiation=item["solar_radiation"],
                    timestamp=datetime.fromisoformat(item["timestamp"])
                ))
            return weather_list
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ meteorologick√Ωch dat: {e}")
            return []

# John Deere API integrace
class JohnDeereAPI:
    def __init__(self, api_key: str, client_id: str):
        self.api_key = api_key
        self.client_id = client_id
        self.base_url = "https://api.deere.com"
        self.session = httpx.AsyncClient()
    
    async def get_field_operations(self, field_id: str) -> List[Dict]:
        """Z√≠sk√°n√≠ dat o operac√≠ch na poli"""
        try:
            response = await self.session.get(
                f"{self.base_url}/platform/organizations/fields/{field_id}/operations",
                headers={"Authorization": f"Bearer {self.api_key}"}
            )
            response.raise_for_status()
            return response.json().get("values", [])
        except Exception as e:
            logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ dat z John Deere API: {e}")
            return []
    
    async def send_application_recommendation(self, field_id: str, recommendations: Dict) -> bool:
        """Odesl√°n√≠ doporuƒçen√≠ pro aplikaci vstup≈Ø"""
        try:
            response = await self.session.post(
                f"{self.base_url}/platform/organizations/fields/{field_id}/recommendations",
                json=recommendations,
                headers={"Authorization": f"Bearer {self.api_key}"}
            )
            response.raise_for_status()
            return True
        except Exception as e:
            logger.error(f"Chyba p≈ôi odes√≠l√°n√≠ doporuƒçen√≠: {e}")
            return False

# Prediktivn√≠ model pro v√Ωnosy
class YieldPredictor:
    def __init__(self):
        self.model = RandomForestRegressor(n_estimators=100, random_state=42)
        self.scaler = StandardScaler()
        self.is_trained = False
    
    def prepare_features(self, satellite_data: SatelliteImagery, 
                        weather_data: List[WeatherData], 
                        soil_data: SoilSensorData) -> np.ndarray:
        """P≈ô√≠prava feature vektoru pro predikci"""
        features = []
        
        # Satelitn√≠ data
        features.extend([
            satellite_data.ndvi_mean,
            satellite_data.ndvi_std,
            satellite_data.evi_mean,
            satellite_data.cloud_coverage
        ])
        
        # Agregovan√° meteorologick√° data
        if weather_data:
            avg_temp = np.mean([w.temperature for w in weather_data])
            avg_humidity = np.mean([w.humidity for w in weather_data])
            total_precipitation = np.sum([w.precipitation for w in weather_data])
            avg_solar = np.mean([w.solar_radiation for w in weather_data])
            
            features.extend([avg_temp, avg_humidity, total_precipitation, avg_solar])
        else:
            features.extend([0, 0, 0, 0])
        
        # P≈Ødn√≠ data
        features.extend([
            soil_data.moisture_level,
            soil_data.ph_level,
            soil_data.nitrogen,
            soil_data.phosphorus,
            soil_data.potassium,
            soil_data.temperature
        ])
        
        return np.array(features).reshape(1, -1)
    
    def train(self, training_data: List[Dict]):
        """Tr√©nov√°n√≠ modelu na historick√Ωch datech"""
        X = []
        y = []
        
        for data_point in training_data:
            features = self.prepare_features(
                data_point["satellite_data"],
                data_point["weather_data"],
                data_point["soil_data"]
            )
            X.append(features.flatten())
            y.append(data_point["actual_yield"])
        
        X = np.array(X)
        y = np.array(y)
        
        X_scaled = self.scaler.fit_transform(X)
        self.model.fit(X_scaled, y)
        self.is_trained = True
        
        logger.info(f"Model byl √∫spƒõ≈°nƒõ natr√©nov√°n na {len(training_data)} vzorc√≠ch")
    
    def predict(self, satellite_data: SatelliteImagery, 
                weather_data: List[WeatherData], 
                soil_data: SoilSensorData) -> tuple:
        """Predikce v√Ωnosu"""
        if not self.is_trained:
            raise ValueError("Model nen√≠ natr√©nov√°n")
        
        features = self.prepare_features(satellite_data, weather_data, soil_data)
        features_scaled = self.scaler.transform(features)
        
        prediction = self.model.predict(features_scaled)[0]
        
        # V√Ωpoƒçet confidence score (zjednodu≈°en√Ω)
        feature_importance = self.model.feature_importances_
        confidence = np.mean(feature_importance)
        
        return prediction, confidence

# Hlavn√≠ syst√©m pro ≈ô√≠zen√≠ plodin
class CropManagementSystem:
    def __init__(self, database_url: str, mcp_config: Dict, john_deere_config: Dict):
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)
        
        self.mcp_client = MCPClient(
            mcp_config["base_url"], 
            mcp_config["api_key"]
        )
        
        self.john_deere_api = JohnDeereAPI(
            john_deere_config["api_key"],
            john_deere_config["client_id"]
        )
        
        self.yield_predictor = YieldPredictor()
        self.openai_client = openai.AsyncOpenAI()
        
        # Naƒçten√≠ a tr√©nov√°n√≠ modelu
        self._load_historical_data()
    
    def _load_historical_data(self):
        """Naƒçten√≠ historick√Ωch dat pro tr√©nov√°n√≠ modelu"""
        # Simulace historick√Ωch dat
        training_data = []
        for i in range(100):
            training_data.append({
                "satellite_data": SatelliteImagery(
                    ndvi_mean=np.random.normal(0.7, 0.1),
                    ndvi_std=np.random.normal(0.1, 0.02),
                    evi_mean=np.random.normal(0.5, 0.08),
                    image_date=datetime.now() - timedelta(days=np.random.randint(1, 365)),
                    cloud_coverage=np.random.uniform(0, 30)
                ),
                "weather_data": [WeatherData(
                    temperature=np.random.normal(25, 5),
                    humidity=np.random.normal(60, 15),
                    precipitation=np.random.exponential(2),
                    wind_speed=np.random.normal(10, 3),
                    solar_radiation=np.random.normal(20, 5),
                    timestamp=datetime.now()
                )],
                "soil_data": SoilSensorData(
                    moisture_level=np.random.normal(40, 10),
                    ph_level=np.random.normal(6.5, 0.5),
                    nitrogen=np.random.normal(50, 15),
                    phosphorus=np.random.normal(30, 10),
                    potassium=np.random.normal(200, 50),
                    temperature=np.random.normal(20, 3)
                ),
                "actual_yield": np.random.normal(8, 2)  # tuny/hektar
            })
        
        self.yield_predictor.train(training_data)
    
    async def analyze_field(self, field_id: int) -> Dict:
        """Komplexn√≠ anal√Ωza pole"""
        session = self.Session()
        try:
            # Z√≠sk√°n√≠ informac√≠ o poli
            field = session.query(CropField).filter(CropField.id == field_id).first()
            if not field:
                raise ValueError(f"Pole s ID {field_id} nebylo nalezeno")
            
            # Z√≠sk√°n√≠ satelitn√≠ch dat
            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)
            
            satellite_data_raw = await self.mcp_client.get_satellite_data(
                field.geometry, (start_date, end_date)
            )
            
            # Simulace satelitn√≠ch dat (pro demo √∫ƒçely)
            satellite_data = SatelliteImagery(
                ndvi_mean=0.75,
                ndvi_std=0.08,
                evi_mean=0.52,
                image_date=datetime.now(),
                cloud_coverage=15.0
            )
            
            # Z√≠sk√°n√≠ meteorologick√Ωch dat
            field_center = self._get_field_center(field.geometry)
            weather_data = await self.mcp_client.get_weather_forecast(
                field_center["lat"], field_center["lon"]
            )
            
            # Pokud nejsou dostupn√° re√°ln√° data, pou≈æijeme simulovan√°
            if not weather_data:
                weather_data = [WeatherData(
                    temperature=24.5,
                    humidity=65.0,
                    precipitation=2.3,
                    wind_speed=8.5,
                    solar_radiation=22.1,
                    timestamp=datetime.now()
                )]
            
            # Z√≠sk√°n√≠ p≈Ødn√≠ch dat (simulace)
            soil_data = SoilSensorData(
                moisture_level=42.5,
                ph_level=6.8,
                nitrogen=48.2,
                phosphorus=28.5,
                potassium=195.0,
                temperature=19.8
            )
            
            # Predikce v√Ωnosu
            predicted_yield, confidence = self.yield_predictor.predict(
                satellite_data, weather_data, soil_data
            )
            
            # Ulo≈æen√≠ predikce do datab√°ze
            prediction = YieldPrediction(
                field_id=field_id,
                predicted_yield=predicted_yield,
                confidence_score=confidence,
                model_version="v1.0"
            )
            session.add(prediction)
            session.commit()
            
            # Generov√°n√≠ doporuƒçen√≠ pomoc√≠ AI
            recommendations = await self._generate_ai_recommendations(
                field, satellite_data, weather_data, soil_data, predicted_yield
            )
            
            return {
                "field_info": {
                    "id": field.id,
                    "name": field.name,
                    "area_hectares": field.area_hectares,
                    "crop_type": field.crop_type
                },
                "satellite_analysis": asdict(satellite_data),
                "weather_forecast": [asdict(w) for w in weather_data],
                "soil_conditions": asdict(soil_data),
                "yield_prediction": {
                    "predicted_yield_tons_per_hectare": round(predicted_yield, 2),
                    "confidence_score": round(confidence, 2),
                    "total_expected_yield": round(predicted_yield * field.area_hectares, 2)
                },
                "recommendations": recommendations
            }
            
        finally:
            session.close()
    
    def _get_field_center(self, geometry: Dict) -> Dict:
        """V√Ωpoƒçet st≈ôedu pole z GeoJSON geometrie"""
        # Zjednodu≈°en√Ω v√Ωpoƒçet - ve skuteƒçnosti by se pou≈æila knihovna pro geospatial operace
        return {"lat": 50.0755, "lon": 14.4378}  # Praha jako default
    
    async def _generate_ai_recommendations(self, field, satellite_data, weather_data, 
                                         soil_data, predicted_yield) -> Dict:
        """Generov√°n√≠ doporuƒçen√≠ pomoc√≠ AI"""
        prompt = f"""
        Jako expert na precizn√≠ zemƒõdƒõlstv√≠, analyzuj n√°sleduj√≠c√≠ data a poskytni konkr√©tn√≠ doporuƒçen√≠:

        POLE:
        - N√°zev: {field.name}
        - Plocha: {field.area_hectares} ha
        - Plodina: {field.crop_type}

        SATELITN√ç DATA:
        - NDVI pr≈Ømƒõr: {satellite_data.ndvi_mean}
        - EVI pr≈Ømƒõr: {satellite_data.evi_mean}

        P≈ÆDN√ç CONDITIONS:
        - Vlhkost: {soil_data.moisture_level}%
        - pH: {soil_data.ph_level}
        - Dus√≠k: {soil_data.nitrogen} mg/kg
        - Fosfor: {soil_data.phosphorus} mg/kg
        - Drasl√≠k: {soil_data.potassium} mg/kg

        PREDIKOVAN√ù V√ùNOS: {predicted_yield:.2f} t/ha

        Poskytni doporuƒçen√≠ pro:
        1. Hnojen√≠ (typ, d√°vka, timing)
        2. Zavla≈æov√°n√≠ (frekvence, mno≈æstv√≠)
        3. Ochrana rostlin (pokud pot≈ôeba)
        4. Optimalizace v√Ωnosu
        """
        
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=800
            )
            
            ai_recommendations = response.choices[0].message.content
            
            return {
                "fertilizer_recommendations": self._extract_fertilizer_recommendations(soil_data),
                "irrigation_schedule": self._calculate_irrigation_schedule(weather_data, soil_data),
                "ai_insights": ai_recommendations,
                "priority_actions": self._identify_priority_actions(satellite_data, soil_data)
            }
            
        except Exception as e:
            logger.error(f"Chyba p≈ôi generov√°n√≠ AI doporuƒçen√≠: {e}")
            return {
                "fertilizer_recommendations": self._extract_fertilizer_recommendations(soil_data),
                "irrigation_schedule": self._calculate_irrigation_schedule(weather_data, soil_data),
                "ai_insights": "AI doporuƒçen√≠ moment√°lnƒõ nedostupn√°",
                "priority_actions": []
            }
    
    def _extract_fertilizer_recommendations(self, soil_data: SoilSensorData) -> Dict:
        """V√Ωpoƒçet doporuƒçen√≠ pro hnojen√≠ na z√°kladƒõ p≈Ødn√≠ch dat"""
        recommendations = {}
        
        # Doporuƒçen√≠ pro dus√≠k
        if soil_data.nitrogen < 40:
            recommendations["nitrogen"] = {
                "needed": True,
                "amount_kg_per_ha": 50 - soil_data.nitrogen,
                "type": "Moƒçovina nebo DAM",
                "timing": "Okam≈æitƒõ"
            }
        
        # Doporuƒçen√≠ pro fosfor
        if soil_data.phosphorus < 25:
            recommendations["phosphorus"] = {
                "needed": True,
                "amount_kg_per_ha": 30 - soil_data.phosphorus,
                "type": "Superfosf√°t",
                "timing": "P≈ôed set√≠m/v√Ωsadbou"
            }
        
        # Doporuƒçen√≠ pro drasl√≠k
        if soil_data.potassium < 150:
            recommendations["potassium"] = {
                "needed": True,
                "amount_kg_per_ha": 200 - soil_data.potassium,
                "type": "Chlorid draseln√Ω",
                "timing": "Na podzim"
            }
        
        return recommendations
    
    def _calculate_irrigation_schedule(self, weather_data: List[WeatherData], 
                                     soil_data: SoilSensorData) -> List[Dict]:
        """V√Ωpoƒçet rozvrhu zavla≈æov√°n√≠"""
        schedule = []
        
        # Anal√Ωza pot≈ôeby zavla≈æov√°n√≠
        if soil_data.moisture_level < 30:
            schedule.append({
                "date": datetime.now().strftime("%Y-%m-%d"),
                "amount_mm": 25,
                "reason": "N√≠zk√° vlhkost p≈Ødy",
                "priority": "Vysok√°"
            })
        
        # P≈ôedpovƒõƒè na z√°kladƒõ meteorologick√Ωch dat
        total_precipitation = sum(w.precipitation for w in weather_data)
        if total_precipitation < 10:  # M√©nƒõ ne≈æ 10mm za t√Ωden
            schedule.append({
                "date": (datetime.now() + timedelta(days=3)).strftime("%Y-%m-%d"),
                "amount_mm": 20,
                "reason": "N√≠zk√© oƒçek√°van√© sr√°≈æky",
                "priority": "St≈ôedn√≠"
            })
        
        return schedule
    
    def _identify_priority_actions(self, satellite_data: SatelliteImagery, 
                                 soil_data: SoilSensorData) -> List[Dict]:
        """Identifikace prioritn√≠ch akc√≠"""
        actions = []
        
        # Kontrola NDVI
        if satellite_data.ndvi_mean < 0.6:
            actions.append({
                "action": "Kontrola zdrav√≠ rostlin",
                "priority": "Vysok√°",
                "reason": "N√≠zk√Ω NDVI index",
                "deadline": (datetime.now() + timedelta(days=2)).strftime("%Y-%m-%d")
            })
        
        # Kontrola pH
        if soil_data.ph_level < 6.0 or soil_data.ph_level > 7.5:
            actions.append({
                "action": "√öprava pH p≈Ødy",
                "priority": "St≈ôedn√≠",
                "reason": f"pH mimo optim√°ln√≠ rozsah: {soil_data.ph_level}",
                "deadline": (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d")
            })
        
        return actions

# FastAPI aplikace
app = FastAPI(title="Syst√©m ≈ô√≠zen√≠ zemƒõdƒõlsk√Ωch plodin", version="1.0.0")

# Glob√°ln√≠ instance syst√©mu
crop_system = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    global crop_system
    
    # Inicializace syst√©mu
    crop_system = CropManagementSystem(
        database_url="sqlite:///crop_management.db",
        mcp_config={
            "base_url": "https://api.satellite-data.com",
            "api_key": "your-mcp-api-key"
        },
        john_deere_config={
            "api_key": "your-john-deere-api-key",
            "client_id": "your-client-id"
        }
    )
    
    # Vytvo≈ôen√≠ uk√°zkov√©ho pole
    session = crop_system.Session()
    try:
        existing_field = session.query(CropField).first()
        if not existing_field:
            demo_field = CropField(
                name="Pole Z√°pad",
                area_hectares=15.5,
                crop_type="P≈°enice",
                geometry={
                    "type": "Polygon",
                    "coordinates": [[[14.0, 50.0], [14.1, 50.0], [14.1, 50.1], [14.0, 50.1], [14.0, 50.0]]]
                }
            )
            session.add(demo_field)
            session.commit()
    finally:
        session.close()
    
    yield
    
    # Cleanup
    if crop_system:
        await crop_system.mcp_client.session.aclose()
        await crop_system.john_deere_api.session.aclose()

app = FastAPI(lifespan=lifespan)

@app.get("/")
async def root():
    return {"message": "Syst√©m ≈ô√≠zen√≠ zemƒõdƒõlsk√Ωch plodin je aktivn√≠"}

@app.get("/fields/{field_id}/analysis")
async def analyze_field_endpoint(field_id: int):
    """Endpoint pro anal√Ωzu konkr√©tn√≠ho pole"""
    if not crop_system:
        raise HTTPException(status_code=500, detail="Syst√©m nen√≠ inicializov√°n")
    
    try:
        analysis = await crop_system.analyze_field(field_id)
        return analysis
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Chyba p≈ôi anal√Ωze pole: {e}")
        raise HTTPException(status_code=500, detail="Chyba p≈ôi anal√Ωze pole")

@app.get("/fields")
async def list_fields():
    """Seznam v≈°ech pol√≠"""
    if not crop_system:
        raise HTTPException(status_code=500, detail="Syst√©m nen√≠ inicializov√°n")
    
    session = crop_system.Session()
    try:
        fields = session.query(CropField).all()
        return [
            {
                "id": field.id,
                "name": field.name,
                "area_hectares": field.area_hectares,
                "crop_type": field.crop_type
            }
            for field in fields
        ]
    finally:
        session.close()

# Demonstraƒçn√≠ skript
async def demo_script():
    """Demonstrace funkcionalit syst√©mu"""
    print("üåæ Inicializace syst√©mu ≈ô√≠zen√≠ zemƒõdƒõlsk√Ωch plodin...")
    
    # Inicializace syst√©mu
    crop_system = CropManagementSystem(
        database_url="sqlite:///demo_crop_management.db",
        mcp_config={
            "base_url": "https://api.satellite-data.com",
            "api_key": "demo-api-key"
        },
        john_deere_config={
            "api_key": "demo-john-deere-key",
            "client_id": "demo-client-id"
        }
    )
    
    # Vytvo≈ôen√≠ demo pole
    session = crop_system.Session()
    demo_field = CropField(
        name="Demo pole - P≈°enice",
        area_hectares=12.3,
        crop_type="P≈°enice",
        geometry={
            "type": "Polygon",
            "coordinates": [[[14.0, 50.0], [14.05, 50.0], [14.05, 50.03], [14.0, 50.03], [14.0, 50.0]]]
        }
    )
    session.add(demo_field)
    session.commit()
    field_id = demo_field.id
    session.close()
    
    print(f"‚úÖ Pole '{demo_field.name}' vytvo≈ôeno s ID: {field_id}")
    
    # Anal√Ωza pole
    print("\nüìä Spou≈°tƒõn√≠ komplexn√≠ anal√Ωzy pole...")
    analysis = await crop_system.analyze_field(field_id)
    
    # V√Ωpis v√Ωsledk≈Ø
    print("\n" + "="*60)
    print("üåæ V√ùSLEDKY ANAL√ùZY POLE")
    print("="*60)
    
    field_info = analysis["field_info"]
    print(f"Pole: {field_info['name']}")
    print(f"Plocha: {field_info['area_hectares']} ha")
    print(f"Plodina: {field_info['crop_type']}")
    
    print("\nüì° SATELITN√ç DATA:")
    satellite = analysis["satellite_analysis"]
    print(f"  NDVI pr≈Ømƒõr: {satellite['ndvi_mean']:.3f}")
    print(f"  EVI pr≈Ømƒõr: {satellite['evi_mean']:.3f}")
    print(f"  Oblaƒçnost: {satellite['cloud_coverage']:.1f}%")
    
    print("\nüå°Ô∏è P≈ÆDN√ç CONDITIONS:")
    soil = analysis["soil_conditions"]
    print(f"  Vlhkost: {soil['moisture_level']:.1f}%")
    print(f"  pH: {soil['ph_level']:.1f}")
    print(f"  Dus√≠k: {soil['nitrogen']:.1f} mg/kg")
    print(f"  Fosfor: {soil['phosphorus']:.1f} mg/kg")
    print(f"  Drasl√≠k: {soil['potassium']:.1f} mg/kg")
    
    print("\nüìà PREDIKCE V√ùNOSU:")
    yield_pred = analysis["yield_prediction"]
    print(f"  Oƒçek√°van√Ω v√Ωnos: {yield_pred['predicted_yield_tons_per_hectare']} t/ha")
    print(f"  Celkov√Ω v√Ωnos: {yield_pred['total_expected_yield']} t")
    print(f"  Spolehlivost: {yield_pred['confidence_score']:.2f}")
    
    print("\nüí° DOPORUƒåEN√ç:")
    recommendations = analysis["recommendations"]
    
    if recommendations["fertilizer_recommendations"]:
        print("  Hnojen√≠:")
        for nutrient, rec in recommendations["fertilizer_recommendations"].items():
            print(f"    - {nutrient}: {rec['amount_kg_per_ha']:.1f} kg/ha ({rec['type']})")
    
    if recommendations["irrigation_schedule"]:
        print("  Zavla≈æov√°n√≠:")
        for irrigation in recommendations["irrigation_schedule"]:
            print(f"    - {irrigation['date']}: {irrigation['amount_mm']}mm ({irrigation['reason']})")
    
    if recommendations["priority_actions"]:
        print("  Prioritn√≠ akce:")
        for action in recommendations["priority_actions"]:
            print(f"    - {action['action']} (Priorita: {action['priority']})")
    
    print(f"\nü§ñ AI INSIGHTS:")
    print(f"  {recommendations['ai_insights'][:200]}...")
    
    # Zav≈ôen√≠ p≈ôipojen√≠
    await crop_system.mcp_client.session.aclose()
    await crop_system.john_deere_api.session.aclose()

if __name__ == "__main__":
    import uvicorn
    
    print("Spou≈°tƒõn√≠ demo skriptu...")
    asyncio.run(demo_script())
    
    print("\n" + "="*60)
    print("üöÄ Spou≈°tƒõn√≠ FastAPI serveru na http://localhost:8000")
    print("üìñ API dokumentace: http://localhost:8000/docs")
    print("="*60)
    
    uvicorn.run(app, host="0.0.0.0", port=8000)
````

````requirements.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
pandas==2.1.3
numpy==1.25.2
scikit-learn==1.3.2
requests==2.31.0
httpx==0.25.2
openai==1.3.5
rasterio==1.3.9
geopandas==0.14.1
shapely==2.0.2
pydantic==2.5.0
python-multipart==0.0.6
aiofiles==23.2.1
python-dotenv==1.0.0
````

````dockerfile
FROM python:3.11-slim

WORKDIR /app

# Instalace syst√©mov√Ωch z√°vislost√≠ pro geospatial knihovny
RUN apt-get update && apt-get install -y \
    gdal-bin \
    libgdal-dev \
    libproj-dev \
    libgeos-dev \
    && rm -rf /var/lib/apt/lists/*

# Kop√≠rov√°n√≠ requirements a instalace Python z√°vislost√≠
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Kop√≠rov√°n√≠ aplikace
COPY . .

# Exposov√°n√≠ portu
EXPOSE 8000

# Spu≈°tƒõn√≠ aplikace
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
````

````yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/crop_management
      - MCP_API_KEY=your-mcp-api-key
      - JOHN_DEERE_API_KEY=your-john-deere-api-key
      - OPENAI_API_KEY=your-openai-api-key
    depends_on:
      - db
    volumes:
      - ./data:/app/data

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=crop_management
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
````

## Shrnut√≠ projektu

### Kl√≠ƒçov√© hodnoty projektu

**Integrovan√° platforma**: Syst√©m spojuje multiple datov√© zdroje (satelitn√≠ sn√≠mky, IoT senzory, meteorologick√° data) do jednotn√© platformy pro optimalizaci zemƒõdƒõlsk√© produkce.

**AI-≈ô√≠zen√° anal√Ωza**: Vyu≈æit√≠ pokroƒçil√Ωch ML algoritm≈Ø pro predikci v√Ωnos≈Ø a generov√°n√≠ personalizovan√Ωch doporuƒçen√≠ pro ka≈æd√© pole.

**Real-time monitoring**: Kontinu√°ln√≠ sledov√°n√≠ stavu plodin a podm√≠nek prost≈ôed√≠ s okam≈æit√Ωmi upozornƒõn√≠mi na kritick√© situace.

**Precizn√≠ aplikace vstup≈Ø**: Optimalizace pou≈æit√≠ hnojiv, pesticid≈Ø a vody na z√°kladƒõ specifick√Ωch pot≈ôeb jednotliv√Ωch ƒç√°st√≠ pole.

**Automatizace proces≈Ø**: Integrace se zemƒõdƒõlsk√Ωmi stroji pro automatick√© proveden√≠ doporuƒçen√Ωch akc√≠.

### Technologick√© inovace

- **MCP protokol** pro efektivn√≠ komunikaci s extern√≠mi datov√Ωmi zdroji
- **Computer vision** pro anal√Ωzu satelitn√≠ch sn√≠mk≈Ø a detekci probl√©m≈Ø
- **IoT integrace** pro real-time monitoring p≈Ødn√≠ch podm√≠nek
- **Prediktivn√≠ analytics** pro forecasting v√Ωnos≈Ø a identifikaci rizik
- **AI-asistovan√© rozhodov√°n√≠** pomoc√≠ velk√Ωch jazykov√Ωch model≈Ø

### Ekonomick√Ω dopad

Implementace syst√©mu m≈Ø≈æe p≈ôin√©st farm√°≈ô≈Øm **ROI 300-500%** bƒõhem prvn√≠ch t≈ô√≠ let d√≠ky:
- Zv√Ω≈°en√≠ v√Ωnos≈Ø o 15-25%
- Sn√≠≈æen√≠ n√°klad≈Ø na vstupy o 20-30%
- √ösporu vody a≈æ 40%
- Minimalizaci ztr√°t zp≈Øsoben√Ωch chorobami a ≈°k≈Ødci

Syst√©m p≈ôedstavuje v√Ωznamn√Ω krok smƒõrem k **udr≈æiteln√©mu a efektivn√≠mu zemƒõdƒõlstv√≠** v √©≈ôe klimatick√Ωch zmƒõn a rostouc√≠ svƒõtov√© populace.