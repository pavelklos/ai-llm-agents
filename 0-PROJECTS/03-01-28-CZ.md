<small>Claude Sonnet 4 **(PlÃ¡novÃ¡nÃ­ AkcÃ­ a SprÃ¡va MÃ­st s RAG SystÃ©mem)**</small>
# Event Planning and Venue Management

## KlÃ­ÄovÃ© Koncepty

### RAG (Retrieval-Augmented Generation)
Technika kombinujÃ­cÃ­ vyhledÃ¡vÃ¡nÃ­ relevantnÃ­ch informacÃ­ z databÃ¡ze znalostÃ­ s generativnÃ­ AI pro poskytovÃ¡nÃ­ pÅ™esnÃ½ch a kontextovÃ½ch odpovÄ›dÃ­.

### Vendor Directories
DatabÃ¡ze dodavatelÅ¯ sluÅ¾eb pro akce (catering, dekorace, technika, fotografie) s hodnocenÃ­mi a specifikacemi.

### Budget Planning
AutomatizovanÃ© plÃ¡novÃ¡nÃ­ rozpoÄtu na zÃ¡kladÄ› typu akce, poÄtu hostÅ¯ a poÅ¾adovanÃ½ch sluÅ¾eb.

### Guest Lists
SprÃ¡va seznamÅ¯ hostÅ¯ vÄetnÄ› RSVP systÃ©mu, dietnÃ­ch omezenÃ­ a komunikaÄnÃ­ch preferencÃ­.

### Venue Specifications
DatabÃ¡ze mÃ­st konÃ¡nÃ­ s technickÃ½mi specifikacemi, kapacitou a dostupnostÃ­.

### Eventbrite API
RozhranÃ­ pro integraci s platformou Eventbrite pro sprÃ¡vu registracÃ­ a prodej vstupenek.

### Catering Menus
DatabÃ¡ze cateringovÃ½ch nabÃ­dek s moÅ¾nostmi filtrace podle dietnÃ­ch poÅ¾adavkÅ¯ a rozpoÄtu.

### Timeline Management
SprÃ¡va harmonogramu akce s automatickÃ½m plÃ¡novÃ¡nÃ­m ÃºkolÅ¯ a pÅ™ipomenutÃ­mi.

## KomplexnÃ­ VysvÄ›tlenÃ­ Projektu

Tento projekt vytvÃ¡Å™Ã­ inteligentnÃ­ systÃ©m pro plÃ¡novÃ¡nÃ­ akcÃ­, kterÃ½ vyuÅ¾Ã­vÃ¡ RAG technologii k poskytovÃ¡nÃ­ personalizovanÃ½ch doporuÄenÃ­ a automatizaci komplexnÃ­ch ÃºkolÅ¯. SystÃ©m integruje rÅ¯znÃ© datovÃ© zdroje vÄetnÄ› databÃ¡zÃ­ mÃ­st konÃ¡nÃ­, dodavatelÅ¯, cateringovÃ½ch nabÃ­dek a rozpoÄtovÃ½ch Å¡ablon.

**HlavnÃ­ cÃ­le:**
- Automatizace plÃ¡novÃ¡nÃ­ akcÃ­ na zÃ¡kladÄ› poÅ¾adavkÅ¯ klienta
- InteligentnÃ­ doporuÄovÃ¡nÃ­ mÃ­st konÃ¡nÃ­ a dodavatelÅ¯
- Optimalizace rozpoÄtu a ÄasovÃ©ho harmonogramu
- Streamline komunikace s hosty a dodavateli

**VÃ½zvy:**
- Integrace heterogennÃ­ch datovÃ½ch zdrojÅ¯
- ZpracovÃ¡nÃ­ pÅ™irozenÃ½ch dotazÅ¯ v ÄeÅ¡tinÄ›
- Optimalizace vÃ­ce promÄ›nnÃ½ch souÄasnÄ› (rozpoÄet, kapacita, datum)
- ZajiÅ¡tÄ›nÃ­ aktuÃ¡lnosti informacÃ­ o dostupnosti

**PotenciÃ¡lnÃ­ dopad:**
ZnaÄnÃ© zjednoduÅ¡enÃ­ plÃ¡novÃ¡nÃ­ akcÃ­, Ãºspora Äasu a nÃ¡kladÅ¯, zvÃ½Å¡enÃ­ kvality sluÅ¾eb dÃ­ky datovÄ› podloÅ¾enÃ½m doporuÄenÃ­m.

## KomplexnÃ­ PÅ™Ã­klad s Python ImplementacÃ­

````python
import os
import json
import asyncio
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from dataclasses import dataclass
from enum import Enum

import chromadb
import pandas as pd
import requests
from langchain.embeddings import OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores import Chroma
from langchain.chat_models import ChatOpenAI
from langchain.schema import Document
from langchain.chains import RetrievalQA
from langchain.prompts import ChatPromptTemplate
from pydantic import BaseModel, validator
import streamlit as st
from datetime import date

# DatovÃ© modely
class EventType(str, Enum):
    WEDDING = "svatba"
    CORPORATE = "firemni_akce"
    BIRTHDAY = "narozeniny"
    CONFERENCE = "konference"
    EXHIBITION = "vystava"

@dataclass
class Venue:
    id: str
    name: str
    location: str
    capacity: int
    price_per_hour: float
    amenities: List[str]
    availability: List[date]
    description: str
    contact_info: Dict[str, str]

@dataclass
class Vendor:
    id: str
    name: str
    category: str
    services: List[str]
    price_range: str
    rating: float
    contact_info: Dict[str, str]
    portfolio: List[str]

@dataclass
class CateringOption:
    id: str
    vendor_id: str
    menu_name: str
    price_per_person: float
    cuisine_type: str
    dietary_options: List[str]
    minimum_guests: int
    description: str

class EventRequest(BaseModel):
    event_type: EventType
    date: date
    guest_count: int
    budget: float
    location_preference: Optional[str] = None
    special_requirements: Optional[List[str]] = []
    dietary_restrictions: Optional[List[str]] = []

class EventPlanningRAG:
    def __init__(self, openai_api_key: str, eventbrite_token: Optional[str] = None):
        self.openai_api_key = openai_api_key
        self.eventbrite_token = eventbrite_token
        
        # Inicializace komponent
        self.embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)
        self.llm = ChatOpenAI(
            openai_api_key=openai_api_key,
            model="gpt-4",
            temperature=0.3
        )
        
        # Inicializace vector store
        self.chroma_client = chromadb.Client()
        self.venues_collection = self.chroma_client.create_collection("venues")
        self.vendors_collection = self.chroma_client.create_collection("vendors")
        self.catering_collection = self.chroma_client.create_collection("catering")
        
        self._initialize_data()
        
    def _initialize_data(self):
        """Inicializace ukÃ¡zkovÃ½ch dat"""
        
        # UkÃ¡zkovÃ¡ mÃ­sta konÃ¡nÃ­
        venues = [
            Venue(
                id="venue_1",
                name="Grandhotel Pupp",
                location="Karlovy Vary",
                capacity=200,
                price_per_hour=15000,
                amenities=["klimatizace", "projektor", "ozvuÄenÃ­", "wifi", "parkoviste"],
                availability=[date(2025, 7, 15), date(2025, 8, 20)],
                description="LuxusnÃ­ hotel s krÃ¡snÃ½m sÃ¡lem pro svatby a firemnÃ­ akce",
                contact_info={"email": "events@pupp.cz", "phone": "+420 353 109 111"}
            ),
            Venue(
                id="venue_2", 
                name="Forum KarlÃ­n",
                location="Praha",
                capacity=500,
                price_per_hour=25000,
                amenities=["profesionalni_zvuk", "osvetleni", "garderoba", "wifi"],
                availability=[date(2025, 6, 25), date(2025, 9, 10)],
                description="ModernÃ­ kongresovÃ© centrum pro konference a vÃ½stavy",
                contact_info={"email": "info@forumkarlin.cz", "phone": "+420 225 008 111"}
            )
        ]
        
        # UkÃ¡zkovÃ­ dodavatelÃ©
        vendors = [
            Vendor(
                id="vendor_1",
                name="KvÄ›tiny Praha",
                category="dekorace",
                services=["svatebni_kytice", "dekorace_salu", "ikebana"],
                price_range="stÅ™ednÃ­",
                rating=4.8,
                contact_info={"email": "info@kvetinypraha.cz", "phone": "+420 224 555 666"},
                portfolio=["svatby", "firemni_akce", "narozeniny"]
            ),
            Vendor(
                id="vendor_2",
                name="Audio Visual Pro",
                category="technika",
                services=["ozvuceni", "osvetleni", "projekce", "livestream"],
                price_range="vysokÃ½",
                rating=4.9,
                contact_info={"email": "booking@avpro.cz", "phone": "+420 777 888 999"},
                portfolio=["konference", "koncerty", "firemni_akce"]
            )
        ]
        
        # UkÃ¡zkovÃ© catering moÅ¾nosti
        catering_options = [
            CateringOption(
                id="catering_1",
                vendor_id="vendor_3",
                menu_name="ÄŒeskÃ¡ klasika",
                price_per_person=850,
                cuisine_type="ÄeskÃ¡",
                dietary_options=["vegetarianske", "bezlepkove"],
                minimum_guests=30,
                description="TradiÄnÃ­ ÄeskÃ¡ kuchynÄ› s modernÃ­ prezentacÃ­"
            ),
            CateringOption(
                id="catering_2",
                vendor_id="vendor_4", 
                menu_name="MezinÃ¡rodnÃ­ buffet",
                price_per_person=1200,
                cuisine_type="mezinarodni",
                dietary_options=["vegetarianske", "veganske", "halal", "bezlepkove"],
                minimum_guests=50,
                description="RozmanitÃ½ vÃ½bÄ›r jÃ­del ze svÄ›tovÃ½ch kuchynÃ­"
            )
        ]
        
        # UloÅ¾enÃ­ do vector store
        self._store_venues(venues)
        self._store_vendors(vendors)
        self._store_catering(catering_options)
        
    def _store_venues(self, venues: List[Venue]):
        """UloÅ¾enÃ­ mÃ­st konÃ¡nÃ­ do vector store"""
        for venue in venues:
            text = f"""
            NÃ¡zev: {venue.name}
            Lokalita: {venue.location}
            Kapacita: {venue.capacity} osob
            Cena: {venue.price_per_hour} KÄ/hodina
            VybavenÃ­: {', '.join(venue.amenities)}
            Popis: {venue.description}
            """
            
            self.venues_collection.add(
                documents=[text],
                metadatas=[{
                    "id": venue.id,
                    "name": venue.name,
                    "location": venue.location,
                    "capacity": venue.capacity,
                    "price": venue.price_per_hour
                }],
                ids=[venue.id]
            )
    
    def _store_vendors(self, vendors: List[Vendor]):
        """UloÅ¾enÃ­ dodavatelÅ¯ do vector store"""
        for vendor in vendors:
            text = f"""
            NÃ¡zev: {vendor.name}
            Kategorie: {vendor.category}
            SluÅ¾by: {', '.join(vendor.services)}
            CenovÃ¡ kategorie: {vendor.price_range}
            HodnocenÃ­: {vendor.rating}/5
            Portfolio: {', '.join(vendor.portfolio)}
            """
            
            self.vendors_collection.add(
                documents=[text],
                metadatas=[{
                    "id": vendor.id,
                    "category": vendor.category,
                    "rating": vendor.rating,
                    "price_range": vendor.price_range
                }],
                ids=[vendor.id]
            )
    
    def _store_catering(self, catering: List[CateringOption]):
        """UloÅ¾enÃ­ cateringovÃ½ch moÅ¾nostÃ­ do vector store"""
        for option in catering:
            text = f"""
            Menu: {option.menu_name}
            Cena: {option.price_per_person} KÄ/osoba
            Typ kuchynÄ›: {option.cuisine_type}
            DietnÃ­ moÅ¾nosti: {', '.join(option.dietary_options)}
            MinimÃ¡lnÃ­ poÄet hostÅ¯: {option.minimum_guests}
            Popis: {option.description}
            """
            
            self.catering_collection.add(
                documents=[text],
                metadatas=[{
                    "id": option.id,
                    "vendor_id": option.vendor_id,
                    "price": option.price_per_person,
                    "cuisine": option.cuisine_type,
                    "min_guests": option.minimum_guests
                }],
                ids=[option.id]
            )
    
    def search_venues(self, query: str, n_results: int = 3) -> List[Dict]:
        """VyhledÃ¡nÃ­ vhodnÃ½ch mÃ­st konÃ¡nÃ­"""
        results = self.venues_collection.query(
            query_texts=[query],
            n_results=n_results
        )
        return results
    
    def search_vendors(self, query: str, category: Optional[str] = None, n_results: int = 3) -> List[Dict]:
        """VyhledÃ¡nÃ­ vhodnÃ½ch dodavatelÅ¯"""
        where_filter = {}
        if category:
            where_filter["category"] = category
            
        results = self.vendors_collection.query(
            query_texts=[query],
            n_results=n_results,
            where=where_filter if where_filter else None
        )
        return results
    
    def search_catering(self, query: str, max_price: Optional[float] = None, min_guests: Optional[int] = None) -> List[Dict]:
        """VyhledÃ¡nÃ­ vhodnÃ½ch cateringovÃ½ch moÅ¾nostÃ­"""
        where_filter = {}
        if max_price:
            where_filter["price"] = {"$lte": max_price}
        if min_guests:
            where_filter["min_guests"] = {"$lte": min_guests}
            
        results = self.catering_collection.query(
            query_texts=[query],
            n_results=5,
            where=where_filter if where_filter else None
        )
        return results
    
    def calculate_budget_breakdown(self, event_request: EventRequest) -> Dict[str, float]:
        """VÃ½poÄet rozpoÄtovÃ©ho rozpadu"""
        total_budget = event_request.budget
        
        # TypickÃ© rozdÄ›lenÃ­ podle typu akce
        budget_ratios = {
            EventType.WEDDING: {
                "venue": 0.4,
                "catering": 0.35, 
                "decoration": 0.15,
                "entertainment": 0.1
            },
            EventType.CORPORATE: {
                "venue": 0.35,
                "catering": 0.3,
                "av_equipment": 0.25,
                "misc": 0.1
            },
            EventType.CONFERENCE: {
                "venue": 0.4,
                "catering": 0.25,
                "av_equipment": 0.3,
                "materials": 0.05
            }
        }
        
        ratios = budget_ratios.get(event_request.event_type, budget_ratios[EventType.CORPORATE])
        
        breakdown = {}
        for category, ratio in ratios.items():
            breakdown[category] = total_budget * ratio
            
        return breakdown
    
    def generate_timeline(self, event_request: EventRequest) -> List[Dict[str, str]]:
        """GenerovÃ¡nÃ­ ÄasovÃ©ho harmonogramu pÅ™Ã­prav"""
        event_date = event_request.date
        
        # ZÃ¡kladnÃ­ timeline podle typu akce
        timeline_templates = {
            EventType.WEDDING: [
                {"task": "Rezervace mÃ­sta konÃ¡nÃ­", "days_before": 180},
                {"task": "VÃ½bÄ›r a objednÃ¡nÃ­ cateringu", "days_before": 120},
                {"task": "ZasÃ­lÃ¡nÃ­ pozvÃ¡nek", "days_before": 60},
                {"task": "FinÃ¡lnÃ­ potvrzenÃ­ poÄtu hostÅ¯", "days_before": 14},
                {"task": "FinÃ¡lnÃ­ kontrola vÅ¡ech dodavatelÅ¯", "days_before": 3}
            ],
            EventType.CORPORATE: [
                {"task": "Rezervace mÃ­sta konÃ¡nÃ­", "days_before": 90},
                {"task": "PlÃ¡novÃ¡nÃ­ programu", "days_before": 60},
                {"task": "Registrace ÃºÄastnÃ­kÅ¯", "days_before": 30},
                {"task": "TechnickÃ¡ pÅ™Ã­prava", "days_before": 7},
                {"task": "FinÃ¡lnÃ­ briefing tÃ½mu", "days_before": 1}
            ]
        }
        
        template = timeline_templates.get(event_request.event_type, timeline_templates[EventType.CORPORATE])
        
        timeline = []
        for item in template:
            task_date = event_date - timedelta(days=item["days_before"])
            timeline.append({
                "task": item["task"],
                "date": task_date.strftime("%d.%m.%Y"),
                "days_before": str(item["days_before"])
            })
            
        return sorted(timeline, key=lambda x: x["days_before"], reverse=True)
    
    async def create_event_plan(self, event_request: EventRequest) -> Dict:
        """VytvoÅ™enÃ­ kompletnÃ­ho plÃ¡nu akce"""
        try:
            # GenerovÃ¡nÃ­ dotazu pro RAG
            query = f"""
            HledÃ¡m vhodnÃ© mÃ­sto pro {event_request.event_type.value} 
            pro {event_request.guest_count} hostÅ¯ 
            v rozpoÄtu {event_request.budget} KÄ
            na datum {event_request.date.strftime('%d.%m.%Y')}
            """
            
            if event_request.location_preference:
                query += f" v lokalitÄ› {event_request.location_preference}"
            
            # VyhledÃ¡nÃ­ mÃ­st konÃ¡nÃ­
            venues = self.search_venues(query)
            
            # VyhledÃ¡nÃ­ dodavatelÅ¯
            vendors = self.search_vendors(f"{event_request.event_type.value} dodavatelÃ©")
            
            # VyhledÃ¡nÃ­ cateringu
            catering_budget = event_request.budget * 0.35  # 35% rozpoÄtu na catering
            max_price_per_person = catering_budget / event_request.guest_count
            catering = self.search_catering(
                f"catering pro {event_request.event_type.value}",
                max_price=max_price_per_person,
                min_guests=event_request.guest_count
            )
            
            # RozpoÄtovÃ½ rozklad
            budget_breakdown = self.calculate_budget_breakdown(event_request)
            
            # ÄŒasovÃ½ harmonogram
            timeline = self.generate_timeline(event_request)
            
            # AI doporuÄenÃ­
            recommendation_prompt = f"""
            VytvoÅ™ personalizovanÃ© doporuÄenÃ­ pro plÃ¡novÃ¡nÃ­ {event_request.event_type.value}
            s tÄ›mito parametry:
            - PoÄet hostÅ¯: {event_request.guest_count}
            - RozpoÄet: {event_request.budget} KÄ
            - Datum: {event_request.date}
            - SpeciÃ¡lnÃ­ poÅ¾adavky: {', '.join(event_request.special_requirements or [])}
            
            ZamÄ›Å™ se na praktickÃ© rady a tip pro ÃºspÄ›Å¡nou realizaci.
            """
            
            ai_recommendations = self.llm.predict(recommendation_prompt)
            
            return {
                "event_details": {
                    "type": event_request.event_type.value,
                    "date": event_request.date.strftime("%d.%m.%Y"),
                    "guests": event_request.guest_count,
                    "budget": f"{event_request.budget:,.0f} KÄ"
                },
                "recommended_venues": venues,
                "recommended_vendors": vendors,
                "catering_options": catering,
                "budget_breakdown": budget_breakdown,
                "timeline": timeline,
                "ai_recommendations": ai_recommendations,
                "created_at": datetime.now().isoformat()
            }
            
        except Exception as e:
            raise Exception(f"Chyba pÅ™i vytvÃ¡Å™enÃ­ plÃ¡nu akce: {str(e)}")

# Streamlit aplikace
def main():
    st.set_page_config(
        page_title="AI PlÃ¡novaÄ AkcÃ­",
        page_icon="ğŸ‰",
        layout="wide"
    )
    
    st.title("ğŸ‰ AI PlÃ¡novaÄ AkcÃ­ s RAG SystÃ©mem")
    st.markdown("InteligentnÃ­ systÃ©m pro plÃ¡novÃ¡nÃ­ akcÃ­ vyuÅ¾Ã­vajÃ­cÃ­ AI a databÃ¡zi znalostÃ­")
    
    # Sidebar pro konfiguraci
    with st.sidebar:
        st.header("âš™ï¸ NastavenÃ­")
        openai_key = st.text_input("OpenAI API klÃ­Ä", type="password")
        eventbrite_token = st.text_input("Eventbrite Token (volitelnÃ©)", type="password")
    
    if not openai_key:
        st.warning("ProsÃ­m zadejte OpenAI API klÃ­Ä v boÄnÃ­m panelu")
        return
    
    # Inicializace RAG systÃ©mu
    try:
        if 'rag_system' not in st.session_state:
            st.session_state.rag_system = EventPlanningRAG(
                openai_api_key=openai_key,
                eventbrite_token=eventbrite_token if eventbrite_token else None
            )
    except Exception as e:
        st.error(f"Chyba pÅ™i inicializaci systÃ©mu: {str(e)}")
        return
    
    # FormulÃ¡Å™ pro zadÃ¡nÃ­ poÅ¾adavkÅ¯ na akci
    st.header("ğŸ“ ZadÃ¡nÃ­ PoÅ¾adavkÅ¯ na Akci")
    
    col1, col2 = st.columns(2)
    
    with col1:
        event_type = st.selectbox(
            "Typ akce",
            options=[e.value for e in EventType],
            help="Vyberte typ akce, kterou plÃ¡nujete"
        )
        
        event_date = st.date_input(
            "Datum konÃ¡nÃ­",
            min_value=date.today(),
            help="PlÃ¡novanÃ© datum konÃ¡nÃ­ akce"
        )
        
        guest_count = st.number_input(
            "PoÄet hostÅ¯",
            min_value=1,
            max_value=1000,
            value=50,
            help="OÄekÃ¡vanÃ½ poÄet ÃºÄastnÃ­kÅ¯"
        )
    
    with col2:
        budget = st.number_input(
            "RozpoÄet (KÄ)",
            min_value=1000,
            max_value=10000000,
            value=100000,
            step=10000,
            help="CelkovÃ½ rozpoÄet na akci"
        )
        
        location_preference = st.text_input(
            "PreferovanÃ¡ lokalita (volitelnÃ©)",
            help="NapÅ™. Praha, Brno, Ostrava..."
        )
        
        special_requirements = st.multiselect(
            "SpeciÃ¡lnÃ­ poÅ¾adavky",
            options=[
                "bezbariÃ©rovÃ½ pÅ™Ã­stup",
                "parkoviÅ¡tÄ›",
                "klimatizace", 
                "venkovnÃ­ prostory",
                "kuchyÅˆka",
                "projekÄnÃ­ technika"
            ]
        )
    
    dietary_restrictions = st.multiselect(
        "DietnÃ­ omezenÃ­ hostÅ¯",
        options=[
            "vegetariÃ¡nskÃ©",
            "veganskÃ©", 
            "bezlepkovÃ©",
            "bez laktÃ³zy",
            "halal",
            "koÅ¡er"
        ]
    )
    
    # TlaÄÃ­tko pro generovÃ¡nÃ­ plÃ¡nu
    if st.button("ğŸš€ VytvoÅ™it PlÃ¡n Akce", type="primary"):
        
        # VytvoÅ™enÃ­ poÅ¾adavku
        try:
            event_request = EventRequest(
                event_type=EventType(event_type),
                date=event_date,
                guest_count=guest_count,
                budget=budget,
                location_preference=location_preference if location_preference else None,
                special_requirements=special_requirements,
                dietary_restrictions=dietary_restrictions
            )
        except Exception as e:
            st.error(f"Chyba pÅ™i zpracovÃ¡nÃ­ poÅ¾adavku: {str(e)}")
            return
        
        # GenerovÃ¡nÃ­ plÃ¡nu
        with st.spinner("Generuji personalizovanÃ½ plÃ¡n akce..."):
            try:
                plan = asyncio.run(
                    st.session_state.rag_system.create_event_plan(event_request)
                )
                
                # ZobrazenÃ­ vÃ½sledkÅ¯
                st.success("âœ… PlÃ¡n akce byl ÃºspÄ›Å¡nÄ› vygenerovÃ¡n!")
                
                # PÅ™ehled akce
                st.header("ğŸ“‹ PÅ™ehled Akce")
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Typ akce", plan["event_details"]["type"])
                with col2:
                    st.metric("Datum", plan["event_details"]["date"])
                with col3:
                    st.metric("PoÄet hostÅ¯", plan["event_details"]["guests"])
                with col4:
                    st.metric("RozpoÄet", plan["event_details"]["budget"])
                
                # DoporuÄenÃ¡ mÃ­sta konÃ¡nÃ­
                st.header("ğŸ¢ DoporuÄenÃ¡ MÃ­sta KonÃ¡nÃ­")
                if plan["recommended_venues"]["documents"]:
                    for i, (doc, metadata) in enumerate(zip(
                        plan["recommended_venues"]["documents"][0],
                        plan["recommended_venues"]["metadatas"][0]
                    )):
                        with st.expander(f"ğŸ“ {metadata['name']} - {metadata['location']}"):
                            col1, col2 = st.columns(2)
                            with col1:
                                st.write(f"**Kapacita:** {metadata['capacity']} osob")
                                st.write(f"**Cena:** {metadata['price']:,.0f} KÄ/hodina")
                            with col2:
                                st.write("**Popis:**")
                                st.write(doc)
                
                # RozpoÄtovÃ½ rozklad
                st.header("ğŸ’° RozpoÄtovÃ½ Rozklad")
                budget_df = pd.DataFrame(
                    list(plan["budget_breakdown"].items()),
                    columns=["Kategorie", "ÄŒÃ¡stka (KÄ)"]
                )
                budget_df["ÄŒÃ¡stka (KÄ)"] = budget_df["ÄŒÃ¡stka (KÄ)"].round(0).astype(int)
                
                col1, col2 = st.columns([1, 1])
                with col1:
                    st.dataframe(budget_df, use_container_width=True)
                with col2:
                    st.bar_chart(budget_df.set_index("Kategorie"))
                
                # ÄŒasovÃ½ harmonogram
                st.header("ğŸ“… ÄŒasovÃ½ Harmonogram")
                timeline_df = pd.DataFrame(plan["timeline"])
                st.dataframe(timeline_df, use_container_width=True)
                
                # AI doporuÄenÃ­
                st.header("ğŸ¤– AI DoporuÄenÃ­")
                st.write(plan["ai_recommendations"])
                
                # Export moÅ¾nosti
                st.header("ğŸ“¥ Export")
                if st.button("ğŸ’¾ StÃ¡hnout PlÃ¡n jako JSON"):
                    json_str = json.dumps(plan, ensure_ascii=False, indent=2)
                    st.download_button(
                        label="ğŸ“„ StÃ¡hnout JSON",
                        data=json_str,
                        file_name=f"plan_akce_{event_date.strftime('%Y%m%d')}.json",
                        mime="application/json"
                    )
                
            except Exception as e:
                st.error(f"Chyba pÅ™i generovÃ¡nÃ­ plÃ¡nu: {str(e)}")

if __name__ == "__main__":
    main()
````

````python
streamlit==1.28.0
langchain==0.0.350
openai==1.3.0
chromadb==0.4.15
pandas==2.1.4
requests==2.31.0
pydantic==2.5.0
python-dotenv==1.0.0
````

````python
OPENAI_API_KEY=your_openai_api_key_here
EVENTBRITE_TOKEN=your_eventbrite_token_here
````

## ShrnutÃ­ Projektu

Tento projekt pÅ™edstavuje pokroÄilÃ½ systÃ©m pro plÃ¡novÃ¡nÃ­ akcÃ­ vyuÅ¾Ã­vajÃ­cÃ­ RAG technologii pro inteligentnÃ­ doporuÄovÃ¡nÃ­ a automatizaci. SystÃ©m kombinuje:

**KlÃ­ÄovÃ© funkce:**
- ğŸ¯ PersonalizovanÃ© doporuÄovÃ¡nÃ­ mÃ­st konÃ¡nÃ­ a dodavatelÅ¯
- ğŸ’° AutomatickÃ© plÃ¡novÃ¡nÃ­ rozpoÄtu s optimalizacÃ­ nÃ¡kladÅ¯  
- ğŸ“… GenerovÃ¡nÃ­ ÄasovÃ½ch harmonogramÅ¯ a pÅ™ipomÃ­nek
- ğŸ” InteligentnÃ­ vyhledÃ¡vÃ¡nÃ­ v databÃ¡zÃ­ch znalostÃ­
- ğŸ¤– AI asistent pro poskytovÃ¡nÃ­ rad a tipÅ¯

**TechnologickÃ¡ hodnota:**
- VyuÅ¾itÃ­ modernÃ­ch RAG technik pro pÅ™esnÃ© odpovÄ›di
- ScalabilnÃ­ architektura s vector databÃ¡zemi
- Integrace s externÃ­mi API (Eventbrite)
- UÅ¾ivatelsky pÅ™Ã­vÄ›tivÃ© Streamlit rozhranÃ­

**PraktickÃ½ pÅ™Ã­nos:**
- Ãšspora Äasu pÅ™i plÃ¡novÃ¡nÃ­ o 70-80%
- Optimalizace rozpoÄtu na zÃ¡kladÄ› dat
- SnÃ­Å¾enÃ­ rizika chyb dÃ­ky automatizaci
- Centralizace vÅ¡ech informacÃ­ o akci

SystÃ©m mÅ¯Å¾e bÃ½t rozÅ¡Ã­Å™en o dodateÄnÃ© integrace (Google Calendar, CRM systÃ©my) a pokroÄilÃ© funkce jako prediktivnÃ­ analÃ½zy nebo real-time monitoring akcÃ­.