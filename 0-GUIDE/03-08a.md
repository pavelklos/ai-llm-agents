<small>Claude 3.7 Sonnet Thinking</small>
# 08. Customer Assistant Design and Configuration

## Key Terms

- **User Persona**: A fictional representation of the ideal user based on demographic and behavioral data
- **Conversation Design**: The process of planning AI assistant dialogues including user inputs and system responses
- **Intent Recognition**: The ability to identify the purpose or goal behind a user's message
- **Entity Extraction**: Identifying and classifying key information from user inputs
- **Conversational UX**: User experience design principles applied to conversational interfaces
- **Tone of Voice**: The personality and style characteristics exhibited in an assistant's responses
- **Guardrails**: Boundaries and constraints that determine what the assistant can and cannot discuss
- **Response Templates**: Pre-defined patterns for structuring responses to common queries
- **Conversation Flow**: The logical pathway through different conversational states
- **Knowledge Base**: The structured information repository an assistant can access

## Designing Goal-Oriented Customer Assistants

The design and configuration of customer assistants begins with a clear definition of business objectives and user needs. Effective assistants require careful planning of their purpose, capabilities, and communication style.

### 1. Defining Goals and Style

The first step in creating an effective customer assistant is defining clear objectives and establishing the assistant's tone of voice. Let's implement a structured approach using a configuration framework:

```python
import os
import json
import yaml
from typing import Dict, List, Any, Optional, Union
from enum import Enum
from pydantic import BaseModel, Field
import logging
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("AssistantConfig")

# Load environment variables
load_dotenv()

class AssistantRole(str, Enum):
    """Possible roles for customer assistants."""
    CUSTOMER_SUPPORT = "customer_support"
    SALES = "sales"
    TECHNICAL_SUPPORT = "technical_support"
    PRODUCT_EXPERT = "product_expert"
    ONBOARDING = "onboarding"
    GENERAL_INFORMATION = "general_information"
    BOOKING_ASSISTANT = "booking_assistant"

class CommunicationStyle(str, Enum):
    """Communication style options for the assistant."""
    FORMAL = "formal"
    FRIENDLY = "friendly"
    TECHNICAL = "technical"
    CASUAL = "casual"
    PROFESSIONAL = "professional"
    EMPATHETIC = "empathetic"
    CONCISE = "concise"

class ResponseFormat(str, Enum):
    """Format options for assistant responses."""
    CONVERSATIONAL = "conversational"
    STRUCTURED = "structured"
    BULLET_POINTS = "bullet_points"
    STEP_BY_STEP = "step_by_step"
    FAQ_STYLE = "faq_style"

class KnowledgeArea(BaseModel):
    """Definition of a knowledge area for the assistant."""
    name: str
    description: str
    expertise_level: int = Field(1, ge=1, le=5)  # 1-5 scale
    fallback_message: Optional[str] = None

class UserPersona(BaseModel):
    """Definition of target user persona."""
    name: str
    role: str
    needs: List[str]
    pain_points: List[str]
    technical_proficiency: int = Field(1, ge=1, le=5)  # 1-5 scale
    typical_questions: List[str]

class AssistantPersonality(BaseModel):
    """Personality traits of the assistant."""
    name: str
    communication_style: CommunicationStyle
    tone: List[str]
    values: List[str]
    response_format: ResponseFormat = ResponseFormat.CONVERSATIONAL
    example_responses: Dict[str, str]

class Guardrail(BaseModel):
    """Guardrail for assistant responses."""
    type: str  # e.g., "prohibited_topics", "sensitive_information"
    description: str
    detection_keywords: List[str]
    response: str

class AssistantConfig(BaseModel):
    """Complete configuration for a customer assistant."""
    name: str
    description: str
    version: str
    primary_role: AssistantRole
    secondary_roles: List[AssistantRole] = []
    knowledge_areas: List[KnowledgeArea]
    user_personas: List[UserPersona]
    personality: AssistantPersonality
    guardrails: List[Guardrail]
    system_prompt: str
    greeting_message: str
    fallback_message: str
    
    class Config:
        validate_assignment = True

class AssistantConfigManager:
    """Manager for handling assistant configurations."""
    
    def __init__(self, config_dir: str = "configs"):
        """
        Initialize the configuration manager.
        
        Args:
            config_dir: Directory for storing configurations
        """
        self.config_dir = config_dir
        os.makedirs(config_dir, exist_ok=True)
    
    def create_config(self, config: AssistantConfig) -> None:
        """
        Create a new assistant configuration.
        
        Args:
            config: The assistant configuration
        """
        # Validate config
        config_dict = config.dict()
        
        # Save as YAML
        file_path = os.path.join(self.config_dir, f"{config.name.lower().replace(' ', '_')}.yaml")
        with open(file_path, 'w') as f:
            yaml.dump(config_dict, f, default_flow_style=False)
        
        logger.info(f"Created assistant configuration: {file_path}")
    
    def load_config(self, name: str) -> AssistantConfig:
        """
        Load an assistant configuration.
        
        Args:
            name: Name of the configuration to load
            
        Returns:
            The assistant configuration
        """
        file_path = os.path.join(self.config_dir, f"{name.lower().replace(' ', '_')}.yaml")
        
        try:
            with open(file_path, 'r') as f:
                config_dict = yaml.safe_load(f)
            
            return AssistantConfig(**config_dict)
        except Exception as e:
            logger.error(f"Error loading configuration {name}: {str(e)}")
            raise ValueError(f"Could not load configuration: {str(e)}")
    
    def list_configs(self) -> List[str]:
        """
        List available configurations.
        
        Returns:
            List of configuration names
        """
        try:
            return [f.split('.')[0] for f in os.listdir(self.config_dir) if f.endswith('.yaml')]
        except Exception as e:
            logger.error(f"Error listing configurations: {str(e)}")
            return []
    
    def generate_system_prompt(self, config: AssistantConfig) -> str:
        """
        Generate a system prompt from the configuration.
        
        Args:
            config: The assistant configuration
            
        Returns:
            System prompt for the assistant
        """
        # Build comprehensive system prompt
        system_prompt = f"""
        You are {config.name}, a {config.primary_role.value} assistant designed to help users with {', '.join([ka.name for ka in config.knowledge_areas])}.
        
        ## Your Personality
        - Communication style: {config.personality.communication_style.value}
        - Tone: {', '.join(config.personality.tone)}
        - Values: {', '.join(config.personality.values)}
        
        ## Your Knowledge Areas
        {chr(10).join(['- ' + ka.name + ': ' + ka.description for ka in config.knowledge_areas])}
        
        ## Response Guidelines
        - Preferred format: {config.personality.response_format.value}
        - Be helpful, accurate, and relevant to the user's needs
        - If you don't know something, admit it clearly and offer alternatives
        
        ## Guardrails
        {chr(10).join(['- ' + g.description for g in config.guardrails])}
        
        ## Default Messages
        - Greeting: {config.greeting_message}
        - Fallback: {config.fallback_message}
        
        Remember: Your goal is to assist users effectively while maintaining your defined personality and respecting all guardrails.
        """
        
        return system_prompt.strip()
```

### 2. Establishing Functions and User Scenarios

After defining the basic configuration, we need to establish the specific functions and user scenarios the assistant will handle. This involves creating structured conversation flows and identifying key capabilities:

```python
import os
import json
import yaml
from typing import Dict, List, Any, Optional, Union, Set
from enum import Enum
from pydantic import BaseModel, Field
import logging
from uuid import uuid4
from assistant_design.config_manager import AssistantConfig

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ConversationFlows")

class IntentType(str, Enum):
    """Types of user intents."""
    INFORMATION = "information"
    TASK = "task"
    NAVIGATION = "navigation"
    CLARIFICATION = "clarification"
    CONFIRMATION = "confirmation"
    OBJECTION = "objection"
    GREETING = "greeting"
    FAREWELL = "farewell"
    GRATITUDE = "gratitude"
    COMPLAINT = "complaint"
    FEEDBACK = "feedback"

class EntityType(str, Enum):
    """Types of entities that can be extracted from user input."""
    PRODUCT = "product"
    SERVICE = "service"
    FEATURE = "feature"
    LOCATION = "location"
    DATETIME = "datetime"
    PERSON = "person"
    ORGANIZATION = "organization"
    AMOUNT = "amount"
    PERCENTAGE = "percentage"
    EMAIL = "email"
    PHONE = "phone"
    URL = "url"
    CUSTOM = "custom"

class Intent(BaseModel):
    """User intent definition."""
    id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    type: IntentType
    description: str
    sample_phrases: List[str]
    required_entities: List[str] = []
    optional_entities: List[str] = []
    response_templates: List[str]
    
    class Config:
        validate_assignment = True

class Entity(BaseModel):
    """Entity definition for extraction from user input."""
    id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    type: EntityType
    description: str
    examples: List[str]
    patterns: Optional[List[str]] = None  # Regex patterns for extraction
    synonyms: Optional[List[str]] = None

class ConversationState(BaseModel):
    """State in the conversation flow."""
    id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    description: str
    expected_intents: List[str]
    response_templates: Dict[str, List[str]]  # Intent ID -> possible responses
    default_response: str
    next_states: Dict[str, str] = {}  # Intent ID -> next state ID
    
    class Config:
        validate_assignment = True

class ConversationFlow(BaseModel):
    """Complete conversation flow definition."""
    id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    description: str
    intents: List[Intent]
    entities: List[Entity]
    states: List[ConversationState]
    initial_state_id: str
    
    class Config:
        validate_assignment = True

class UserScenario(BaseModel):
    """User scenario definition."""
    id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    description: str
    user_persona: str
    goal: str
    conversation_flow_id: str
    expected_outcomes: List[str]
    success_criteria: List[str]
    
    class Config:
        validate_assignment = True

class ConversationFlowManager:
    """Manager for conversation flows and user scenarios."""
    
    def __init__(self, flows_dir: str = "conversation_flows"):
        """
        Initialize the conversation flow manager.
        
        Args:
            flows_dir: Directory for storing flows
        """
        self.flows_dir = flows_dir
        os.makedirs(flows_dir, exist_ok=True)
    
    def create_flow(self, flow: ConversationFlow) -> None:
        """
        Create a new conversation flow.
        
        Args:
            flow: The conversation flow
        """
        # Validate flow
        flow_dict = flow.dict()
        
        # Ensure all referenced intents exist
        intent_ids = set(i.id for i in flow.intents)
        for state in flow.states:
            for intent_id in state.expected_intents:
                if intent_id not in intent_ids:
                    raise ValueError(f"State {state.name} references non-existent intent ID {intent_id}")
            
            for intent_id in state.next_states.keys():
                if intent_id not in intent_ids:
                    raise ValueError(f"State {state.name} next_state references non-existent intent ID {intent_id}")
        
        # Ensure initial state exists
        if flow.initial_state_id not in set(s.id for s in flow.states):
            raise ValueError(f"Initial state ID {flow.initial_state_id} does not exist")
        
        # Save as YAML
        file_path = os.path.join(self.flows_dir, f"{flow.name.lower().replace(' ', '_')}.yaml")
        with open(file_path, 'w') as f:
            yaml.dump(flow_dict, f, default_flow_style=False)
        
        logger.info(f"Created conversation flow: {file_path}")
    
    def load_flow(self, name: str) -> ConversationFlow:
        """
        Load a conversation flow.
        
        Args:
            name: Name of the flow to load
            
        Returns:
            The conversation flow
        """
        file_path = os.path.join(self.flows_dir, f"{name.lower().replace(' ', '_')}.yaml")
        
        try:
            with open(file_path, 'r') as f:
                flow_dict = yaml.safe_load(f)
            
            return ConversationFlow(**flow_dict)
        except Exception as e:
            logger.error(f"Error loading flow {name}: {str(e)}")
            raise ValueError(f"Could not load flow: {str(e)}")
    
    def create_scenario(self, scenario: UserScenario, scenarios_dir: str = "scenarios") -> None:
        """
        Create a new user scenario.
        
        Args:
            scenario: The user scenario
            scenarios_dir: Directory for storing scenarios
        """
        os.makedirs(scenarios_dir, exist_ok=True)
        
        # Validate scenario
        scenario_dict = scenario.dict()
        
        # Save as YAML
        file_path = os.path.join(scenarios_dir, f"{scenario.name.lower().replace(' ', '_')}.yaml")
        with open(file_path, 'w') as f:
            yaml.dump(scenario_dict, f, default_flow_style=False)
        
        logger.info(f"Created user scenario: {file_path}")
    
    def visualize_flow(self, flow: ConversationFlow) -> Dict[str, Any]:
        """
        Create a visualization-ready representation of the flow.
        
        Args:
            flow: The conversation flow
            
        Returns:
            Dictionary with visualization data
        """
        # Create nodes for states
        nodes = []
        for state in flow.states:
            nodes.append({
                "id": state.id,
                "label": state.name,
                "description": state.description,
                "type": "state"
            })
        
        # Create nodes for intents
        for intent in flow.intents:
            nodes.append({
                "id": intent.id,
                "label": intent.name,
                "description": intent.description,
                "type": "intent"
            })
        
        # Create edges between states and intents
        edges = []
        for state in flow.states:
            for intent_id, next_state_id in state.next_states.items():
                # Edge from state to intent
                edges.append({
                    "source": state.id,
                    "target": intent_id,
                    "label": "expects"
                })
                
                # Edge from intent to next state
                edges.append({
                    "source": intent_id,
                    "target": next_state_id,
                    "label": "transitions to"
                })
        
        return {
            "name": flow.name,
            "description": flow.description,
            "nodes": nodes,
            "edges": edges,
            "initial_state_id": flow.initial_state_id
        }
```

### 3. Adapting Communication to Target Audiences

Different user populations have unique needs and communication preferences. We'll implement a system to adapt the assistant's responses to various target audiences:

```python
import os
import json
from typing import Dict, List, Any, Optional, Union, Callable
from enum import Enum
from pydantic import BaseModel, Field
import logging
from assistant_design.config_manager import AssistantConfig, UserPersona
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("AudienceAdaptation")

class TechnicalLevel(int, Enum):
    """Technical proficiency levels for audience adaptation."""
    BEGINNER = 1
    BASIC = 2
    INTERMEDIATE = 3
    ADVANCED = 4
    EXPERT = 5

class CommunicationPreference(str, Enum):
    """Communication preferences for audience adaptation."""
    VISUAL = "visual"
    TEXTUAL = "textual"
    CONCISE = "concise"
    DETAILED = "detailed"
    STEP_BY_STEP = "step_by_step"
    EXAMPLES = "examples"
    ANALOGIES = "analogies"

class LanguageModification(BaseModel):
    """Definition of language modifications for different audiences."""
    technical_jargon: Dict[str, Dict[TechnicalLevel, str]]
    phrase_alternatives: Dict[CommunicationPreference, Dict[str, str]]
    explanation_templates: Dict[TechnicalLevel, Dict[str, str]]
    
    class Config:
        validate_assignment = True

class AudienceAdapter:
    """System for adapting assistant responses to different audiences."""
    
    def __init__(self, language_file: str = "language_modifications.json"):
        """
        Initialize the audience adapter.
        
        Args:
            language_file: File with language modifications
        """
        try:
            with open(language_file, 'r') as f:
                language_data = json.load(f)
            
            # Convert integer keys to enum values for technical_jargon
            tech_jargon = {}
            for term, levels in language_data["technical_jargon"].items():
                tech_jargon[term] = {TechnicalLevel(int(level)): alt for level, alt in levels.items()}
            
            # Convert string keys to enum values for phrase_alternatives
            phrase_alts = {}
            for pref_str, phrases in language_data["phrase_alternatives"].items():
                pref = CommunicationPreference(pref_str)
                phrase_alts[pref] = phrases
            
            # Convert integer keys to enum values for explanation_templates
            expl_templates = {}
            for level_str, templates in language_data["explanation_templates"].items():
                level = TechnicalLevel(int(level_str))
                expl_templates[level] = templates
            
            self.language_mods = LanguageModification(
                technical_jargon=tech_jargon,
                phrase_alternatives=phrase_alts,
                explanation_templates=expl_templates
            )
        except FileNotFoundError:
            # Create default language modifications
            self.language_mods = self._create_default_language_mods()
            
            # Save defaults
            self._save_language_mods(language_file)
    
    def _create_default_language_mods(self) -> LanguageModification:
        """
        Create default language modifications.
        
        Returns:
            Default language modifications
        """
        # Default technical jargon alternatives for different technical levels
        tech_jargon = {
            "API": {
                TechnicalLevel.BEGINNER: "connection point that allows different software to talk to each other",
                TechnicalLevel.BASIC: "interface that allows different applications to connect",
                TechnicalLevel.INTERMEDIATE: "Application Programming Interface",
                TechnicalLevel.ADVANCED: "API",
                TechnicalLevel.EXPERT: "API"
            },
            "algorithm": {
                TechnicalLevel.BEGINNER: "step-by-step process to solve a problem",
                TechnicalLevel.BASIC: "set of instructions to perform a task",
                TechnicalLevel.INTERMEDIATE: "computational procedure",
                TechnicalLevel.ADVANCED: "algorithm",
                TechnicalLevel.EXPERT: "algorithm"
            },
            # Add more terms...
        }
        
        # Default phrase alternatives for different communication preferences
        phrase_alts = {
            CommunicationPreference.CONCISE: {
                "I would like to inform you that": "",
                "Please be advised that": "",
                "It is important to note that": "Note:",
                "In order to": "To"
            },
            CommunicationPreference.DETAILED: {
                "Click": "Left-click your mouse on",
                "Install": "Download and install",
                "Fix": "Troubleshoot and resolve"
            },
            # Add more preferences...
        }
        
        # Default explanation templates for different technical levels
        expl_templates = {
            TechnicalLevel.BEGINNER: {
                "definition": "This means {simple_explanation}. In simple terms, {analogy}.",
                "process": "Here's how this works: {numbered_steps}",
                "recommendation": "I suggest you {action} because {simple_reason}."
            },
            TechnicalLevel.EXPERT: {
                "definition": "{technical_term}: {technical_explanation}",
                "process": "Process: {technical_steps}",
                "recommendation": "Recommendation: {action} due to {technical_reason}"
            },
            # Add more levels...
        }
        
        return LanguageModification(
            technical_jargon=tech_jargon,
            phrase_alternatives=phrase_alts,
            explanation_templates=expl_templates
        )
    
    def _save_language_mods(self, file_path: str) -> None:
        """
        Save language modifications to file.
        
        Args:
            file_path: File path to save to
        """
        # Convert enum keys to serializable format
        tech_jargon = {}
        for term, levels in self.language_mods.technical_jargon.items():
            tech_jargon[term] = {str(level.value): alt for level, alt in levels.items()}
        
        phrase_alts = {}
        for pref, phrases in self.language_mods.phrase_alternatives.items():
            phrase_alts[pref.value] = phrases
        
        expl_templates = {}
        for level, templates in self.language_mods.explanation_templates.items():
            expl_templates[str(level.value)] = templates
        
        language_data = {
            "technical_jargon": tech_jargon,
            "phrase_alternatives": phrase_alts,
            "explanation_templates": expl_templates
        }
        
        with open(file_path, 'w') as f:
            json.dump(language_data, f, indent=2)
    
    def adapt_response(self, 
                     response: str, 
                     technical_level: TechnicalLevel,
                     communication_prefs: List[CommunicationPreference]) -> str:
        """
        Adapt a response to the specified audience.
        
        Args:
            response: Original response
            technical_level: Technical level of the audience
            communication_prefs: Communication preferences
            
        Returns:
            Adapted response
        """
        adapted = response
        
        # Adapt technical jargon
        for term, levels in self.language_mods.technical_jargon.items():
            if technical_level in levels and term in adapted:
                # Only replace standalone terms (with word boundaries)
                pattern = r'\b' + re.escape(term) + r'\b'
                adapted = re.sub(pattern, levels[technical_level], adapted)
        
        # Apply communication preference adaptations
        for pref in communication_prefs:
            if pref in self.language_mods.phrase_alternatives:
                for phrase, alt in self.language_mods.phrase_alternatives[pref].items():
                    adapted = adapted.replace(phrase, alt)
        
        return adapted

    def generate_explanation(self, 
                           template_type: str, 
                           technical_level: TechnicalLevel,
                           **kwargs) -> str:
        """
        Generate an explanation using templates.
        
        Args:
            template_type: Type of explanation (definition, process, etc.)
            technical_level: Technical level of the audience
            **kwargs: Variables to fill in the template
            
        Returns:
            Generated explanation
        """
        if (technical_level in self.language_mods.explanation_templates and 
            template_type in self.language_mods.explanation_templates[technical_level]):
            
            template = self.language_mods.explanation_templates[technical_level][template_type]
            try:
                return template.format(**kwargs)
            except KeyError as e:
                logger.error(f"Missing template variable: {str(e)}")
                return template
        else:
            return " ".join(f"{k}: {v}" for k, v in kwargs.items())
```

## Building a Complete Assistant Implementation

Now we'll bring these components together into a comprehensive implementation:

```python
import os
import json
import yaml
from typing import Dict, List, Any, Optional, Union
from enum import Enum
from pydantic import BaseModel, Field
import logging
from dotenv import load_dotenv
from openai import OpenAI
from assistant_design.config_manager import (
    AssistantConfig, AssistantConfigManager, 
    CommunicationStyle, ResponseFormat
)
from assistant_design.conversation_flows import (
    ConversationFlow, ConversationFlowManager,
    Intent, Entity, ConversationState
)
from assistant_design.audience_adaptation import (
    AudienceAdapter, TechnicalLevel, CommunicationPreference
)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("CustomerAssistant")

# Load environment variables
load_dotenv()

class ConversationMemory(BaseModel):
    """Memory for tracking conversation state and history."""
    messages: List[Dict[str, Any]] = []
    current_state_id: Optional[str] = None
    extracted_entities: Dict[str, Any] = {}
    identified_intents: List[Dict[str, Any]] = []
    satisfaction_signals: List[Dict[str, Any]] = []
    
    class Config:
        validate_assignment = True

class CustomerAssistant:
    """Complete implementation of a customer assistant."""
    
    def __init__(self, 
               config_name: str,
               flow_name: Optional[str] = None,
               model: str = "gpt-4o"):
        """
        Initialize the customer assistant.
        
        Args:
            config_name: Name of the assistant configuration
            flow_name: Name of the conversation flow (optional)
            model: OpenAI model to use
        """
        # Initialize OpenAI client
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        self.model = model
        
        # Load configuration
        config_manager = AssistantConfigManager()
        self.config = config_manager.load_config(config_name)
        
        # Generate system prompt
        self.system_prompt = config_manager.generate_system_prompt(self.config)
        
        # Load conversation flow if provided
        self.flow = None
        self.current_state = None
        if flow_name:
            flow_manager = ConversationFlowManager()
            self.flow = flow_manager.load_flow(flow_name)
            
            # Set initial state
            for state in self.flow.states:
                if state.id == self.flow.initial_state_id:
                    self.current_state = state
                    break
        
        # Initialize audience adapter
        self.audience_adapter = AudienceAdapter()
        
        # Initialize conversation memory
        self.memory = ConversationMemory()
        if self.current_state:
            self.memory.current_state_id = self.current_state.id
        
        # Set default audience settings
        self.audience_technical_level = TechnicalLevel.INTERMEDIATE
        self.audience_communication_prefs = [CommunicationPreference.CONCISE]
    
    def identify_intent(self, message: str) -> Optional[Intent]:
        """
        Identify the user's intent from a message.
        
        Args:
            message: User message
            
        Returns:
            Identified intent or None
        """
        if not self.flow:
            return None
        
        # Use OpenAI to classify intent
        intent_prompt = f"""
        You are an intent classifier for a customer assistant.
        
        The user's message is: "{message}"
        
        Based on this message, which of the following intents is the user expressing?
        
        {chr(10).join([f"- {intent.name}: {intent.description}" for intent in self.flow.intents])}
        
        Respond with ONLY the name of the most likely intent.
        """
        
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[{"role": "system", "content": intent_prompt}],
                temperature=0.1,
                max_tokens=20
            )
            
            intent_name = response.choices[0].message.content.strip()
            
            # Find matching intent
            for intent in self.flow.intents:
                if intent.name.lower() == intent_name.lower():
                    return intent
            
            return None
        except Exception as e:
            logger.error(f"Error identifying intent: {str(e)}")
            return None
    
    def extract_entities(self, message: str) -> Dict[str, Any]:
        """
        Extract entities from a user message.
        
        Args:
            message: User message
            
        Returns:
            Dictionary of extracted entities
        """
        if not self.flow:
            return {}
        
        # Use OpenAI to extract entities
        entity_prompt = f"""
        You are an entity extraction system for a customer assistant.
        
        The user's message is: "{message}"
        
        Extract the following types of entities if they are present:
        
        {chr(10).join([f"- {entity.name}: {entity.description}" for entity in self.flow.entities])}
        
        Respond with a JSON object where keys are entity names and values are the extracted values.
        If an entity is not present, do not include it in the response.
        """
        
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[{"role": "system", "content": entity_prompt}],
                response_format={"type": "json_object"},
                temperature=0.1
            )
            
            entities_json = response.choices[0].message.content
            return json.loads(entities_json)
        except Exception as e:
            logger.error(f"Error extracting entities: {str(e)}")
            return {}
    
    def get_next_state(self, intent: Intent) -> Optional[ConversationState]:
        """
        Get the next conversation state based on the identified intent.
        
        Args:
            intent: Identified intent
            
        Returns:
            Next conversation state or None
        """
        if not self.flow or not self.current_state:
            return None
        
        # Check if current state has a transition for this intent
        if intent.id in self.current_state.next_states:
            next_state_id = self.current_state.next_states[intent.id]
            
            # Find and return the next state
            for state in self.flow.states:
                if state.id == next_state_id:
                    return state
        
        return None
    
    def generate_response(self, message: str) -> str:
        """
        Generate a response to a user message.
        
        Args:
            message: User message
            
        Returns:
            Assistant response
        """
        # Update conversation memory
        self.memory.messages.append({"role": "user", "content": message})
        
        # Prepare response
        if self.flow:
            # Using structured conversation flow
            
            # Identify intent
            intent = self.identify_intent(message)
            
            # Extract entities
            entities = self.extract_entities(message)
            self.memory.extracted_entities.update(entities)
            
            if intent and intent.id in self.current_state.expected_intents:
                # Record identified intent
                self.memory.identified_intents.append({
                    "intent": intent.name,
                    "message": message,
                    "confidence": 1.0  # Placeholder for actual confidence score
                })
                
                # Generate response using templates
                if intent.id in self.current_state.response_templates:
                    templates = self.current_state.response_templates[intent.id]
                    if templates:
                        # Simple template selection - could be more sophisticated
                        response = templates[0]
                        
                        # Format response with extracted entities
                        try:
                            response = response.format(**entities)
                        except KeyError:
                            # If not all required placeholders are in entities, use raw template
                            pass
                        
                        # Get next state
                        next_state = self.get_next_state(intent)
                        if next_state:
                            self.current_state = next_state
                            self.memory.current_state_id = next_state.id
                        
                        # Adapt response to audience
                        response = self.audience_adapter.adapt_response(
                            response,
                            self.audience_technical_level,
                            self.audience_communication_prefs
                        )
                        
                        # Update memory and return response
                        self.memory.messages.append({"role": "assistant", "content": response})
                        return response
                
                # Default to LLM response if no template matches
                response = self._generate_llm_response(message)
                self.memory.messages.append({"role": "assistant", "content": response})
                return response
            else:
                # Intent not expected in current state or no intent identified
                if self.current_state and self.current_state.default_response:
                    response = self.current_state.default_response
                    self.memory.messages.append({"role": "assistant", "content": response})
                    return response
                else:
                    # Fall back to LLM
                    response = self._generate_llm_response(message)
                    self.memory.messages.append({"role": "assistant", "content": response})
                    return response
        else:
            # No flow defined, use LLM directly
            response = self._generate_llm_response(message)
            self.memory.messages.append({"role": "assistant", "content": response})
            return response
    
    def _generate_llm_response(self, message: str) -> str:
        """
        Generate a response using LLM.
        
        Args:
            message: User message
            
        Returns:
            LLM-generated response
        """
        try:
            # Prepare context for the LLM
            messages = [{"role": "system", "content": self.system_prompt}]
            
            # Add conversation history
            messages.extend(self.memory.messages[:-1])  # Exclude the most recent message
            
            # Add current message
            messages.append({"role": "user", "content": message})
            
            # Generate response
            response = self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7
            )
            
            llm_response = response.choices[0].message.content
            
            # Adapt to audience
            adapted_response = self.audience_adapter.adapt_response(
                llm_response,
                self.audience_technical_level,
                self.audience_communication_prefs
            )
            
            return adapted_response
        except Exception as e:
            logger.error(f"Error generating LLM response: {str(e)}")
            return self.config.fallback_message
    
    def set_audience_technical_level(self, level: TechnicalLevel) -> None:
        """
        Set the technical level for audience adaptation.
        
        Args:
            level: Technical level
        """
        self.audience_technical_level = level
    
    def set_audience_communication_prefs(self, prefs: List[CommunicationPreference]) -> None:
        """
        Set communication preferences for audience adaptation.
        
        Args:
            prefs: Communication preferences
        """
        self.audience_communication_prefs = prefs
    
    def reset_conversation(self) -> None:
        """Reset the conversation."""
        self.memory = ConversationMemory()
        
        # Reset to initial state if flow is defined
        if self.flow:
            for state in self.flow.states:
                if state.id == self.flow.initial_state_id:
                    self.current_state = state
                    self.memory.current_state_id = state.id
                    break
```

## Practical Exercise: Design and Configure a Customer Assistant

Let's create a practical example of designing and configuring a customer assistant for an e-commerce company:

```python
import os
import json
import yaml
from typing import Dict, List, Any
from assistant_design.config_manager import (
    AssistantConfig, AssistantConfigManager,
    AssistantRole, CommunicationStyle, ResponseFormat,
    KnowledgeArea, UserPersona, AssistantPersonality, Guardrail
)
from assistant_design.conversation_flows import (
    ConversationFlow, ConversationFlowManager,
    Intent, Entity, ConversationState, IntentType, EntityType,
    UserScenario
)
from assistant_design.customer_assistant import CustomerAssistant
from assistant_design.audience_adaptation import (
    TechnicalLevel, CommunicationPreference
)
import logging
from uuid import uuid4

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("EcommerceExample")

def setup_ecommerce_assistant():
    """Set up a complete e-commerce customer assistant."""
    
    # 1. Create assistant configuration
    knowledge_areas = [
        KnowledgeArea(
            name="Product Information",
            description="Details about products, features, specifications, and availability",
            expertise_level=5,
            fallback_message="I don't have specific details about that product, but I can help you find more information."
        ),
        KnowledgeArea(
            name="Order Processing",
            description="Information about placing orders, tracking, shipping, and delivery",
            expertise_level=4,
            fallback_message="I'm not able to find details about that order. Please provide your order number or contact customer support."
        ),
        KnowledgeArea(
            name="Returns and Refunds",
            description="Policies and procedures for returning items and processing refunds",
            expertise_level=4,
            fallback_message="For specific details about your return or refund, please contact our customer service team."
        ),
        KnowledgeArea(
            name="Account Management",
            description="Help with account creation, login issues, and profile updates",
            expertise_level=3,
            fallback_message="I can't access your specific account details for security reasons. Please try the account settings page or contact support."
        )
    ]
    
    user_personas = [
        UserPersona(
            name="New Customer",
            role="Potential buyer",
            needs=["Product information", "Assistance with first purchase", "Account creation help"],
            pain_points=["Uncertainty about products", "Unfamiliarity with shopping process", "Trust concerns"],
            technical_proficiency=2,
            typical_questions=[
                "How do I create an account?",
                "What's the difference between these products?",
                "Is it safe to shop here?",
                "Do you ship to my country?"
            ]
        ),
        UserPersona(
            name="Regular Shopper",
            role="Repeat customer",
            needs=["Order status updates", "Product recommendations", "Quick checkout"],
            pain_points=["Shipping delays", "Out-of-stock items", "Finding specific products"],
            technical_proficiency=3,
            typical_questions=[
                "Where is my order?",
                "Is this item in stock?",
                "Can I change my shipping address?",
                "Do you have anything similar to this product?"
            ]
        ),
        UserPersona(
            name="Product Return",
            role="Customer with issue",
            needs=["Return guidance", "Refund information", "Problem resolution"],
            pain_points=["Unclear return process", "Slow refunds", "Damaged items"],
            technical_proficiency=3,
            typical_questions=[
                "How do I return this item?",
                "When will I get my refund?",
                "The product arrived damaged, what should I do?",
                "Can I exchange this for a different size?"
            ]
        )
    ]
    
    personality = AssistantPersonality(
        name="ShopHelper",
        communication_style=CommunicationStyle.FRIENDLY,
        tone=["Helpful", "Enthusiastic", "Respectful", "Patient"],
        values=["Customer satisfaction", "Clarity", "Efficiency", "Accuracy"],
        response_format=ResponseFormat.CONVERSATIONAL,
        example_responses={
            "greeting": "Welcome to our online store! I'm ShopHelper, your shopping assistant. How can I help you today?",
            "product_query": "Our [Product] comes in [Colors] and features [Features]. It's priced at [Price] and currently [Availability]. Would you like more details about specific features?",
            "order_status": "I'd be happy to help with your order status. Could you please provide your order number? If you don't have it handy, I can also look it up using your email address.",
            "return_request": "I understand you'd like to return your purchase. Our return process is simple: 1) Initiate the return through your account, 2) Print the return label, 3) Send the item back. Would you like me to guide you through these steps?",
            "fallback": "I'm not quite sure I understood your question. Could you please provide more details so I can better assist you?"
        }
    )
    
    guardrails = [
        Guardrail(
            type="prohibited_topics",
            description="Do not discuss competitors' products or compare with competitors directly",
            detection_keywords=["competitor", "vs", "better than", "compared to", "other stores"],
            response="I'm focused on helping you with our products and services. I'd be happy to tell you about our unique features and benefits."
        ),
        Guardrail(
            type="sensitive_information",
            description="Do not ask for or store sensitive customer information",
            detection_keywords=["password", "credit card", "social security", "ID number", "address"],
            response="For your security, please don't share sensitive information like passwords or payment details here. You can enter that information securely during the checkout process."
        ),
        Guardrail(
            type="scope_limitation",
            description="Stay within the scope of shopping assistance",
            detection_keywords=["legal advice", "medical", "therapy", "politics", "investment advice"],
            response="I'm your shopping assistant and can help with product information, orders, and account questions. For advice on this topic, I'd recommend consulting with a qualified professional."
        )
    ]
    
    ecommerce_config = AssistantConfig(
        name="ShopHelper",
        description="E-commerce shopping assistant for product information, order management, and customer support",
        version="1.0.0",
        primary_role=AssistantRole.CUSTOMER_SUPPORT,
        secondary_roles=[AssistantRole.SALES, AssistantRole.PRODUCT_EXPERT],
        knowledge_areas=knowledge_areas,
        user_personas=user_personas,
        personality=personality,
        guardrails=guardrails,
        system_prompt="You are ShopHelper, an e-commerce shopping assistant designed to help customers with product information, ordering, and support.",
        greeting_message="Welcome to our online store! I'm ShopHelper, your shopping assistant. How can I help you today?",
        fallback_message="I'm sorry, I couldn't understand your request. Could you please rephrase or provide more details so I can assist you better?"
    )
    
    # Save the configuration
    config_manager = AssistantConfigManager()
    config_manager.create_config(ecommerce_config)
    logger.info("Created e-commerce assistant configuration")
    
    # 2. Create conversation flow
    # Define intents
    product_info_intent = Intent(
        id=str(uuid4()),
        name="ProductInquiry",
        type=IntentType.INFORMATION,
        description="Customer asking about product details, features, or availability",
        sample_phrases=[
            "Tell me about this product",
            "Do you have [product] in [color]",
            "What features does [product] have",
            "Is [product] in stock"
        ],
        required_entities=["product"],
        optional_entities=["feature", "color", "size"],
        response_templates=[
            "I'd be happy to tell you about {product}. It comes with {feature} and is available in {color}. Would you like more specific details?"
        ]
    )
    
    order_status_intent = Intent(
        id=str(uuid4()),
        name="OrderStatus",
        type=IntentType.INFORMATION,
        description="Customer inquiring about the status of their order",
        sample_phrases=[
            "Where is my order",
            "When will my order arrive",
            "Check status of order [order_number]",
            "Track my package"
        ],
        required_entities=["order_number"],
        optional_entities=["email"],
        response_templates=[
            "Let me check on order {order_number} for you. Your order is currently {status} and should arrive by {date}. Is there anything else you'd like to know about your order?"
        ]
    )
    
    return_intent = Intent(
        id=str(uuid4()),
        name="ReturnRequest",
        type=IntentType.TASK,
        description="Customer wanting to return an item",
        sample_phrases=[
            "I want to return this",
            "How do I return [product]",
            "Return policy",
            "Start a return"
        ],
        required_entities=["product"],
        optional_entities=["order_number", "reason"],
        response_templates=[
            "I understand you'd like to return {product}. Our return process is simple: 1) Log into your account, 2) Go to order history, 3) Select the item and reason for return, 4) Print the return label. Would you like help with any of these steps?"
        ]
    )
    
    greeting_intent = Intent(
        id=str(uuid4()),
        name="Greeting",
        type=IntentType.GREETING,
        description="Customer greeting or starting conversation",
        sample_phrases=[
            "Hello",
            "Hi there",
            "Hey",
            "Good morning/afternoon/evening"
        ],
        required_entities=[],
        optional_entities=[],
        response_templates=[
            "Hello there! Welcome to our online store. I'm ShopHelper, your shopping assistant. How can I help you today?"
        ]
    )
    
    farewell_intent = Intent(
        id=str(uuid4()),
        name="Farewell",
        type=IntentType.FAREWELL,
        description="Customer ending the conversation",
        sample_phrases=[
            "Goodbye",
            "Bye",
            "Thanks, that's all",
            "I'm done"
        ],
        required_entities=[],
        optional_entities=[],
        response_templates=[
            "Thank you for shopping with us today! If you have any more questions later, feel free to come back and chat. Have a great day!"
        ]
    )
    
    # Define entities
    product_entity = Entity(
        id=str(uuid4()),
        name="product",
        type=EntityType.PRODUCT,
        description="Specific product or product category",
        examples=["laptop", "T-shirt", "coffee maker", "running shoes"],
        synonyms=["item", "thing", "goods"]
    )
    
    order_number_entity = Entity(
        id=str(uuid4()),
        name="order_number",
        type=EntityType.CUSTOM,
        description="Order identification number",
        examples=["ORD-12345", "12345", "ORDER-ABC-123"],
        patterns=[r"(ORD|ORDER)?[-]?\d{5,}", r"ORDER-[A-Z]+-\d+"]
    )
    
    color_entity = Entity(
        id=str(uuid4()),
        name="color",
        type=EntityType.CUSTOM,
        description="Color option for a product",
        examples=["red", "blue", "green", "black", "white"],
        synonyms=[]
    )
    
    feature_entity = Entity(
        id=str(uuid4()),
        name="feature",
        type=EntityType.FEATURE,
        description="Product feature or specification",
        examples=["waterproof", "wireless", "64GB storage", "cotton", "fast charging"],
        synonyms=["specification", "spec", "capability"]
    )
    
    email_entity = Entity(
        id=str(uuid4()),
        name="email",
        type=EntityType.EMAIL,
        description="Customer email address",
        examples=["user@example.com"],
        patterns=[r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"]
    )
    
    # Define conversation states
    greeting_state = ConversationState(
        id=str(uuid4()),
        name="Greeting",
        description="Initial greeting state",
        expected_intents=[greeting_intent.id, product_info_intent.id, order_status_intent.id, return_intent.id],
        response_templates={
            greeting_intent.id: [
                "Hello there! Welcome to our online store. I'm ShopHelper, your shopping assistant. How can I help you today?"
            ]
        },
        default_response="Hello! How can I assist you with your shopping today?",
        next_states={
            greeting_intent.id: str(uuid4()),  # Will be filled in later
            product_info_intent.id: str(uuid4()),  # Will be filled in later
            order_status_intent.id: str(uuid4()),  # Will be filled in later
            return_intent.id: str(uuid4())  # Will be filled in later
        }
    )
    
    product_info_state = ConversationState(
        id=str(uuid4()),
        name="ProductInformation",
        description="Providing product information",
        expected_intents=[product_info_intent.id, order_status_intent.id, return_intent.id, farewell_intent.id],
        response_templates={
            product_info_intent.id: [
                "Here's what I know about {product}: It features {feature} and comes in {color}. The price is $XX.XX. Is there anything specific about this product you'd like to know?"
            ]
        },
        default_response="I'd be happy to tell you more about our products. Which one are you interested in?",
        next_states={
            product_info_intent.id: str(uuid4()),  # Product detail state (would be added in a complete implementation)
            order_status_intent.id: str(uuid4()),  # Order status state
            return_intent.id: str(uuid4()),  # Return state
            farewell_intent.id: greeting_state.id  # Back to greeting for new conversation
        }
    )
    
    # Update the next states with actual IDs
    greeting_state.next_states = {
        greeting_intent.id: greeting_state.id,
        product_info_intent.id: product_info_state.id,
        order_status_intent.id: str(uuid4()),  # Would be order status state ID
        return_intent.id: str(uuid4())  # Would be return state ID
    }
    
    # Create flow
    ecommerce_flow = ConversationFlow(
        id=str(uuid4()),
        name="ShoppingAssistantFlow",
        description="Conversation flow for e-commerce shopping assistant",
        intents=[greeting_intent, product_info_intent, order_status_intent, return_intent, farewell_intent],
        entities=[product_entity, order_number_entity, color_entity, feature_entity, email_entity],
        states=[greeting_state, product_info_state],  # Would add more states in complete implementation
        initial_state_id=greeting_state.id
    )
    
    # Save the flow
    flow_manager = ConversationFlowManager()
    flow_manager.create_flow(ecommerce_flow)
    logger.info("Created e-commerce conversation flow")
    
    # 3. Create user scenarios
    new_customer_scenario = UserScenario(
        id=str(uuid4()),
        name="NewCustomerProductInquiry",
        description="New customer asking about product features and availability",
        user_persona="New Customer",
        goal="Get detailed information about a product to make a purchase decision",
        conversation_flow_id=ecommerce_flow.id,
        expected_outcomes=[
            "Customer receives detailed product information",
            "Customer's questions about features are answered",
            "Customer is informed about availability",
            "Customer is offered assistance with purchase"
        ],
        success_criteria=[
            "All product questions answered accurately",
            "No technical jargon for new customers",
            "Clear next steps provided for purchasing",
            "Customer feels confident about product details"
        ]
    )
    
    # Save the scenario
    flow_manager.create_scenario(new_customer_scenario)
    logger.info("Created user scenario")
    
    # 4. Initialize the assistant
    assistant = CustomerAssistant(
        config_name="ShopHelper",
        flow_name="ShoppingAssistantFlow",
        model="gpt-4o"
    )
    
    # Configure for new customer (lower technical level)
    assistant.set_audience_technical_level(TechnicalLevel.BASIC)
    assistant.set_audience_communication_prefs([
        CommunicationPreference.FRIENDLY,
        CommunicationPreference.EXAMPLES
    ])
    
    # Example interaction
    logger.info("\nTesting assistant with example interaction:")
    
    test_messages = [
        "Hi there",
        "I'm looking for a laptop for graphic design work",
        "What features should I look for?",
        "Do you have any models with at least 16GB RAM and a good graphics card?",
        "Great, and what about warranty options?",
        "Thanks for your help!"
    ]
    
    # Process test messages
    for message in test_messages:
        logger.info(f"\nUser: {message}")
        response = assistant.generate_response(message)
        logger.info(f"Assistant: {response}")
    
    return assistant

if __name__ == "__main__":
    setup_ecommerce_assistant()
```

## Conclusion

Designing and configuring effective customer assistants requires a systematic approach that combines technical implementation with user-centered design principles. By breaking down the process into defining goals, establishing functions, and adapting to target audiences, we can create assistants that truly meet business objectives and user needs.

Key takeaways from this section include:

1. **Structured Configuration Framework**: Using a well-organized configuration system enables consistent assistant design and makes customization more maintainable.

2. **Conversation Flows**: Defining explicit intents, entities, and states creates predictable and reliable conversation experiences, while still maintaining natural interactions.

3. **Audience Adaptation**: Dynamically adjusting communication style based on user characteristics significantly improves engagement and effectiveness.

4. **Guardrails and Safety**: Incorporating clear boundaries and fallback mechanisms ensures assistants operate within appropriate parameters.

5. **Modular Architecture**: Separating configuration, conversation management, and audience adaptation into distinct components supports easier maintenance and extension.

When designing customer assistants, it's essential to continually refine both the technical implementation and the conversational experience based on real-world usage patterns and feedback. This iterative approach helps assistants evolve to better meet user needs over time.

The frameworks presented here provide a solid foundation for creating sophisticated, user-centered AI assistants that can be tailored to specific business contexts while maintaining consistent quality and reliability. By thoughtfully defining goals, functions, and communication approaches during the design phase, organizations can develop assistants that truly represent their brand values and effectively serve their customers.