<small>Claude 3.7 Sonnet Thinking</small>
# 10. Building Emotional Intelligence and Digital Twins

## Key Terms

- **Digital Twin**: A virtual representation of a real-world entity, in this case modeling the emotional and psychological state of a user
- **Sentiment Analysis**: Computational process of identifying and categorizing opinions to determine the emotional tone
- **Emotion Detection**: Process of identifying human emotions from text, voice, or facial expressions
- **Emotional Valence**: The intrinsic attractiveness (positive) or aversiveness (negative) of an emotion
- **Arousal Level**: Intensity dimension of emotion, from calm to excited
- **Emotion Tracking**: Monitoring changes in emotional state over time
- **Affective Computing**: Computing that relates to, arises from, or influences emotions
- **State Machine**: Mathematical model of computation used to design systems with discrete states
- **Adaptive Response**: System behavior that changes based on the perceived state of the user
- **Emotional Intelligence**: Ability to perceive, understand, and manage emotions

## Emotion Detection in Conversations

Detecting emotions in conversational text requires sophisticated natural language processing techniques that go beyond simple sentiment analysis. Let's implement a complex emotion detection system using transformer models:

```python
import os
import numpy as np
import torch
from typing import Dict, List, Tuple, Optional, Union
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from dotenv import load_dotenv
import logging
from dataclasses import dataclass
import json
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("EmotionDetector")

# Load environment variables
load_dotenv()

@dataclass
class EmotionProfile:
    """Data class representing an emotion profile with multiple dimensions."""
    primary_emotion: str
    secondary_emotion: Optional[str] = None
    valence: float = 0.0  # -1.0 to 1.0 (negative to positive)
    arousal: float = 0.0  # 0.0 to 1.0 (calm to excited)
    dominance: float = 0.0  # 0.0 to 1.0 (submissive to dominant)
    confidence: float = 0.0  # 0.0 to 1.0
    emotion_scores: Dict[str, float] = None
    
    def __post_init__(self):
        """Initialize emotion_scores if None."""
        if self.emotion_scores is None:
            self.emotion_scores = {}
    
    def to_dict(self) -> Dict:
        """Convert emotion profile to dictionary."""
        return {
            "primary_emotion": self.primary_emotion,
            "secondary_emotion": self.secondary_emotion,
            "valence": self.valence,
            "arousal": self.arousal,
            "dominance": self.dominance,
            "confidence": self.confidence,
            "emotion_scores": self.emotion_scores
        }

class EmotionDetector:
    """Advanced emotion detection system using transformer models."""
    
    # Basic emotion categories
    EMOTION_CATEGORIES = [
        "joy", "sadness", "anger", "fear",
        "surprise", "disgust", "trust", "anticipation",
        "neutral", "confusion", "curiosity", "frustration"
    ]
    
    # VAD (Valence-Arousal-Dominance) mapping for basic emotions
    EMOTION_VAD_MAPPING = {
        "joy": (0.8, 0.7, 0.6),         # High valence, moderately high arousal, moderate dominance
        "sadness": (-0.7, 0.3, 0.2),    # Negative valence, low arousal, low dominance
        "anger": (-0.8, 0.9, 0.8),      # Negative valence, high arousal, high dominance
        "fear": (-0.9, 0.8, 0.2),       # Very negative valence, high arousal, low dominance
        "surprise": (0.1, 0.8, 0.4),    # Slightly positive valence, high arousal, moderate dominance
        "disgust": (-0.8, 0.6, 0.5),    # Negative valence, moderate arousal, moderate dominance
        "trust": (0.7, 0.3, 0.5),       # Positive valence, low arousal, moderate dominance
        "anticipation": (0.4, 0.6, 0.5), # Moderate positive valence, moderate arousal, moderate dominance
        "neutral": (0.0, 0.0, 0.5),     # Neutral valence, low arousal, moderate dominance
        "confusion": (-0.3, 0.5, 0.3),  # Slightly negative valence, moderate arousal, low dominance
        "curiosity": (0.5, 0.6, 0.4),   # Positive valence, moderate arousal, moderate dominance
        "frustration": (-0.6, 0.7, 0.4)  # Negative valence, high arousal, moderate dominance
    }
    
    def __init__(self, model_name: str = "joeddav/distilbert-base-uncased-go-emotions-student"):
        """
        Initialize the emotion detector with a pre-trained model.
        
        Args:
            model_name: Name of the pre-trained model to use
        """
        try:
            self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
            self.tokenizer = AutoTokenizer.from_pretrained(model_name)
            self.model = AutoModelForSequenceClassification.from_pretrained(model_name)
            self.model.to(self.device)
            self.model.eval()
            
            # Get emotion labels from the model
            self.id2label = self.model.config.id2label
            self.label2id = {v: k for k, v in self.id2label.items()}
            
            logger.info(f"Emotion detector initialized with model: {model_name}")
            logger.info(f"Using device: {self.device}")
        except Exception as e:
            logger.error(f"Error initializing emotion detector: {str(e)}")
            raise
    
    def detect_emotion(self, text: str) -> EmotionProfile:
        """
        Detect emotions in the given text.
        
        Args:
            text: Input text to analyze
            
        Returns:
            Emotion profile containing detected emotions and dimensions
        """
        try:
            # Tokenize and prepare input
            inputs = self.tokenizer(text, return_tensors="pt", truncation=True, padding=True)
            inputs = {k: v.to(self.device) for k, v in inputs.items()}
            
            # Get model predictions
            with torch.no_grad():
                outputs = self.model(**inputs)
                logits = outputs.logits
                scores = torch.sigmoid(logits).squeeze().cpu().numpy()
            
            # Get emotion scores
            emotion_scores = {self.id2label[i]: float(score) for i, score in enumerate(scores)}
            
            # Sort emotions by score
            sorted_emotions = sorted(emotion_scores.items(), key=lambda x: x[1], reverse=True)
            
            # Get primary and secondary emotions
            primary_emotion = sorted_emotions[0][0] if sorted_emotions else "neutral"
            primary_score = sorted_emotions[0][1] if sorted_emotions else 0.0
            
            secondary_emotion = sorted_emotions[1][0] if len(sorted_emotions) > 1 else None
            
            # Map emotions to VAD dimensions
            valence, arousal, dominance = self._map_to_vad_dimensions(emotion_scores)
            
            # Create emotion profile
            profile = EmotionProfile(
                primary_emotion=primary_emotion,
                secondary_emotion=secondary_emotion,
                valence=valence,
                arousal=arousal,
                dominance=dominance,
                confidence=primary_score,
                emotion_scores=emotion_scores
            )
            
            return profile
        
        except Exception as e:
            logger.error(f"Error detecting emotion: {str(e)}")
            # Return a neutral profile in case of error
            return EmotionProfile(primary_emotion="neutral", confidence=0.0)
    
    def _map_to_vad_dimensions(self, emotion_scores: Dict[str, float]) -> Tuple[float, float, float]:
        """
        Map emotion scores to Valence-Arousal-Dominance dimensions.
        
        Args:
            emotion_scores: Dictionary of emotion scores
            
        Returns:
            Tuple of (valence, arousal, dominance) values
        """
        # Calculate weighted average of VAD values based on emotion scores
        total_score = sum(emotion_scores.values()) or 1.0  # Avoid division by zero
        
        valence = 0.0
        arousal = 0.0
        dominance = 0.0
        
        for emotion, score in emotion_scores.items():
            # Get VAD values for known emotions or default to neutral
            v, a, d = self.EMOTION_VAD_MAPPING.get(emotion, (0.0, 0.0, 0.5))
            
            # Weighted contribution to dimensions
            weight = score / total_score
            valence += v * weight
            arousal += a * weight
            dominance += d * weight
        
        return valence, arousal, dominance
    
    def detect_emotion_shift(self, 
                           previous_profile: EmotionProfile, 
                           current_profile: EmotionProfile) -> Dict[str, float]:
        """
        Detect shifts in emotional state between two profiles.
        
        Args:
            previous_profile: Previous emotion profile
            current_profile: Current emotion profile
            
        Returns:
            Dictionary of emotional dimension shifts
        """
        return {
            "valence_shift": current_profile.valence - previous_profile.valence,
            "arousal_shift": current_profile.arousal - previous_profile.arousal,
            "dominance_shift": current_profile.dominance - previous_profile.dominance,
            "emotion_change": current_profile.primary_emotion != previous_profile.primary_emotion
        }
    
    def analyze_conversation_trend(self, 
                                 profiles: List[EmotionProfile], 
                                 window_size: int = 5) -> Dict[str, float]:
        """
        Analyze emotion trends in a conversation history.
        
        Args:
            profiles: List of emotion profiles from the conversation
            window_size: Size of the window for trend analysis
            
        Returns:
            Dictionary of trend metrics
        """
        if len(profiles) < 2:
            return {"trend": "insufficient_data"}
        
        # Focus on the most recent profiles
        recent_profiles = profiles[-window_size:] if len(profiles) >= window_size else profiles
        
        # Calculate average dimensions
        avg_valence = sum(p.valence for p in recent_profiles) / len(recent_profiles)
        avg_arousal = sum(p.arousal for p in recent_profiles) / len(recent_profiles)
        
        # Calculate trends (positive values indicate upward trend)
        valence_trend = recent_profiles[-1].valence - recent_profiles[0].valence
        arousal_trend = recent_profiles[-1].arousal - recent_profiles[0].arousal
        
        # Analyze emotional stability (standard deviation of valence)
        valence_stability = np.std([p.valence for p in recent_profiles])
        
        # Determine dominant emotion
        emotion_counter = {}
        for profile in recent_profiles:
            emotion_counter[profile.primary_emotion] = emotion_counter.get(profile.primary_emotion, 0) + 1
        
        dominant_emotion = max(emotion_counter.items(), key=lambda x: x[1])[0]
        
        return {
            "dominant_emotion": dominant_emotion,
            "avg_valence": avg_valence,
            "avg_arousal": avg_arousal,
            "valence_trend": valence_trend,
            "arousal_trend": arousal_trend,
            "emotional_stability": 1.0 - min(valence_stability, 1.0)  # 0.0 to 1.0, higher means more stable
        }
```

## Creating Internal User State (Digital Twin)

A digital twin of a user's emotional state requires maintaining a persistent model that evolves over time. Let's build a system for tracking and updating the user's emotional state:

```python
import os
import json
import numpy as np
from typing import Dict, List, Any, Optional, Union, Tuple
import logging
from datetime import datetime, timedelta
import uuid
from emotion_detection.detector import EmotionDetector, EmotionProfile
from collections import deque
import pickle

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("EmotionalDigitalTwin")

class UserState:
    """Represent the complete psychological state of a user."""
    
    def __init__(
        self,
        user_id: str,
        current_emotion: EmotionProfile = None,
        baseline_emotion: EmotionProfile = None,
        emotion_history: List[Tuple[datetime, EmotionProfile]] = None,
        personality_traits: Dict[str, float] = None,
        interaction_preferences: Dict[str, Any] = None,
        context: Dict[str, Any] = None
    ):
        """
        Initialize user state.
        
        Args:
            user_id: Unique identifier for the user
            current_emotion: Current emotional profile
            baseline_emotion: Baseline (neutral) emotional profile for the user
            emotion_history: Historical emotion data with timestamps
            personality_traits: Dictionary of personality trait scores
            interaction_preferences: User preferences for interaction
            context: Additional contextual information
        """
        self.user_id = user_id
        self.current_emotion = current_emotion or EmotionProfile(primary_emotion="neutral")
        self.baseline_emotion = baseline_emotion or self.current_emotion
        self.emotion_history = emotion_history or []
        self.personality_traits = personality_traits or {
            "openness": 0.5,
            "conscientiousness": 0.5,
            "extraversion": 0.5,
            "agreeableness": 0.5,
            "neuroticism": 0.5
        }
        self.interaction_preferences = interaction_preferences or {
            "communication_style": "neutral",
            "detail_level": "medium",
            "response_tone": "balanced"
        }
        self.context = context or {}
        self.creation_time = datetime.now()
        self.last_updated = self.creation_time
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert user state to dictionary."""
        return {
            "user_id": self.user_id,
            "current_emotion": self.current_emotion.to_dict() if self.current_emotion else None,
            "baseline_emotion": self.baseline_emotion.to_dict() if self.baseline_emotion else None,
            "emotion_history": [(ts.isoformat(), ep.to_dict()) for ts, ep in self.emotion_history],
            "personality_traits": self.personality_traits,
            "interaction_preferences": self.interaction_preferences,
            "context": self.context,
            "creation_time": self.creation_time.isoformat(),
            "last_updated": self.last_updated.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'UserState':
        """Create user state from dictionary."""
        current_emotion = EmotionProfile(**data["current_emotion"]) if data.get("current_emotion") else None
        baseline_emotion = EmotionProfile(**data["baseline_emotion"]) if data.get("baseline_emotion") else None
        
        # Convert emotion history from dict representation
        emotion_history = []
        for ts_str, ep_dict in data.get("emotion_history", []):
            ts = datetime.fromisoformat(ts_str)
            ep = EmotionProfile(**ep_dict)
            emotion_history.append((ts, ep))
        
        return cls(
            user_id=data["user_id"],
            current_emotion=current_emotion,
            baseline_emotion=baseline_emotion,
            emotion_history=emotion_history,
            personality_traits=data.get("personality_traits"),
            interaction_preferences=data.get("interaction_preferences"),
            context=data.get("context", {})
        )

class EmotionalDigitalTwin:
    """Digital twin that models and predicts user's emotional state."""
    
    def __init__(
        self,
        emotion_detector: EmotionDetector,
        storage_path: str = "user_states",
        history_window: int = 20
    ):
        """
        Initialize the emotional digital twin.
        
        Args:
            emotion_detector: Detector for analyzing emotions
            storage_path: Path to store user states
            history_window: Maximum number of historical emotional states to keep
        """
        self.emotion_detector = emotion_detector
        self.storage_path = storage_path
        self.history_window = history_window
        self.active_users = {}  # Cache of currently active user states
        
        os.makedirs(storage_path, exist_ok=True)
        logger.info(f"Emotional digital twin initialized with storage at {storage_path}")
    
    def get_user_state(self, user_id: str, load_if_needed: bool = True) -> UserState:
        """
        Get the current state for a user.
        
        Args:
            user_id: User identifier
            load_if_needed: Whether to load from storage if not in memory
            
        Returns:
            User state object
        """
        # Check in-memory cache first
        if user_id in self.active_users:
            return self.active_users[user_id]
        
        # Load from storage if requested and available
        if load_if_needed:
            user_file = os.path.join(self.storage_path, f"{user_id}.json")
            if os.path.exists(user_file):
                try:
                    with open(user_file, 'r') as f:
                        user_data = json.load(f)
                    
                    user_state = UserState.from_dict(user_data)
                    self.active_users[user_id] = user_state
                    return user_state
                except Exception as e:
                    logger.error(f"Error loading user state for {user_id}: {str(e)}")
        
        # Create new user state if not found
        new_state = UserState(user_id=user_id)
        self.active_users[user_id] = new_state
        return new_state
    
    def save_user_state(self, user_state: UserState) -> bool:
        """
        Save user state to storage.
        
        Args:
            user_state: User state to save
            
        Returns:
            Whether the save was successful
        """
        try:
            user_file = os.path.join(self.storage_path, f"{user_state.user_id}.json")
            with open(user_file, 'w') as f:
                json.dump(user_state.to_dict(), f, indent=2)
            
            logger.info(f"Saved user state for {user_state.user_id}")
            return True
        except Exception as e:
            logger.error(f"Error saving user state for {user_state.user_id}: {str(e)}")
            return False
    
    def update_user_emotion(self, user_id: str, message: str) -> UserState:
        """
        Update the user's emotional state based on a new message.
        
        Args:
            user_id: User identifier
            message: New message from the user
            
        Returns:
            Updated user state
        """
        # Get current user state
        user_state = self.get_user_state(user_id)
        
        # Detect emotion in the message
        emotion_profile = self.emotion_detector.detect_emotion(message)
        
        # Save previous emotion for tracking changes
        previous_emotion = user_state.current_emotion
        
        # Update user state
        user_state.current_emotion = emotion_profile
        user_state.last_updated = datetime.now()
        
        # Track emotion history, limiting to history window size
        user_state.emotion_history.append((user_state.last_updated, emotion_profile))
        if len(user_state.emotion_history) > self.history_window:
            user_state.emotion_history = user_state.emotion_history[-self.history_window:]
        
        # Update baseline emotion if this is the first interaction or if sufficient history exists
        if not user_state.baseline_emotion or len(user_state.emotion_history) >= 5:
            self._update_baseline_emotion(user_state)
        
        # Update personality traits based on emotional patterns
        if len(user_state.emotion_history) >= 10:
            self._update_personality_traits(user_state)
        
        # Update interaction preferences based on recent emotions
        self._update_interaction_preferences(user_state)
        
        # Save the updated state
        self.save_user_state(user_state)
        
        return user_state
    
    def _update_baseline_emotion(self, user_state: UserState) -> None:
        """
        Update the baseline emotional profile for a user.
        
        Args:
            user_state: User state to update
        """
        # Calculate average emotion dimensions across history
        if not user_state.emotion_history:
            return
        
        avg_valence = sum(ep.valence for _, ep in user_state.emotion_history) / len(user_state.emotion_history)
        avg_arousal = sum(ep.arousal for _, ep in user_state.emotion_history) / len(user_state.emotion_history)
        avg_dominance = sum(ep.dominance for _, ep in user_state.emotion_history) / len(user_state.emotion_history)
        
        # Count occurrences of primary emotions
        emotion_counts = {}
        for _, ep in user_state.emotion_history:
            emotion_counts[ep.primary_emotion] = emotion_counts.get(ep.primary_emotion, 0) + 1
        
        # Find most frequent emotion
        most_frequent = max(emotion_counts.items(), key=lambda x: x[1])[0] if emotion_counts else "neutral"
        
        # Create new baseline emotion profile
        user_state.baseline_emotion = EmotionProfile(
            primary_emotion=most_frequent,
            valence=avg_valence,
            arousal=avg_arousal,
            dominance=avg_dominance,
            confidence=0.7  # Confidence in baseline is assumed to be moderately high
        )
    
    def _update_personality_traits(self, user_state: UserState) -> None:
        """
        Update personality trait estimates based on emotional patterns.
        
        Args:
            user_state: User state to update
        """
        # This is a simplified approach to personality trait inference
        # A real implementation would use more sophisticated models
        
        # Calculate emotion statistics
        emotions = [ep for _, ep in user_state.emotion_history]
        
        # Variance in valence might correlate with neuroticism
        valence_variance = np.var([ep.valence for ep in emotions])
        
        # Average arousal might correlate with extraversion
        avg_arousal = np.mean([ep.arousal for ep in emotions])
        
        # Average dominance might correlate with agreeableness (inversely)
        avg_dominance = np.mean([ep.dominance for ep in emotions])
        
        # Count positive vs negative emotions
        positive_emotions = sum(1 for ep in emotions if ep.valence > 0.2)
        negative_emotions = sum(1 for ep in emotions if ep.valence < -0.2)
        positivity_ratio = positive_emotions / (positive_emotions + negative_emotions) if (positive_emotions + negative_emotions) > 0 else 0.5
        
        # Update personality traits (with smoothing to avoid dramatic changes)
        smoothing_factor = 0.3  # Lower means slower changes
        
        user_state.personality_traits["neuroticism"] = (
            (1 - smoothing_factor) * user_state.personality_traits["neuroticism"] +
            smoothing_factor * min(1.0, valence_variance * 2)
        )
        
        user_state.personality_traits["extraversion"] = (
            (1 - smoothing_factor) * user_state.personality_traits["extraversion"] +
            smoothing_factor * min(1.0, avg_arousal + 0.2)
        )
        
        user_state.personality_traits["agreeableness"] = (
            (1 - smoothing_factor) * user_state.personality_traits["agreeableness"] +
            smoothing_factor * min(1.0, 1.0 - avg_dominance * 0.5)
        )
        
        user_state.personality_traits["openness"] = (
            (1 - smoothing_factor) * user_state.personality_traits["openness"] +
            smoothing_factor * min(1.0, 0.5 + avg_arousal * 0.3)
        )
        
        user_state.personality_traits["conscientiousness"] = (
            (1 - smoothing_factor) * user_state.personality_traits["conscientiousness"] +
            smoothing_factor * min(1.0, 0.5 + positivity_ratio * 0.3)
        )
    
    def _update_interaction_preferences(self, user_state: UserState) -> None:
        """
        Update interaction preferences based on current emotional state.
        
        Args:
            user_state: User state to update
        """
        current_emotion = user_state.current_emotion
        
        # Adjust communication style based on emotional valence
        if current_emotion.valence < -0.5:
            user_state.interaction_preferences["communication_style"] = "empathetic"
            user_state.interaction_preferences["response_tone"] = "supportive"
        elif current_emotion.valence > 0.5:
            user_state.interaction_preferences["communication_style"] = "enthusiastic"
            user_state.interaction_preferences["response_tone"] = "positive"
        else:
            user_state.interaction_preferences["communication_style"] = "neutral"
            user_state.interaction_preferences["response_tone"] = "balanced"
        
        # Adjust detail level based on arousal
        if current_emotion.arousal < 0.3:
            # Low arousal (calm) might prefer more details
            user_state.interaction_preferences["detail_level"] = "high"
        elif current_emotion.arousal > 0.7:
            # High arousal (excited/agitated) might prefer concise responses
            user_state.interaction_preferences["detail_level"] = "low"
        else:
            user_state.interaction_preferences["detail_level"] = "medium"
    
    def get_emotional_trajectory(self, user_id: str, window: int = 10) -> Dict[str, Any]:
        """
        Analyze the emotional trajectory of a user over time.
        
        Args:
            user_id: User identifier
            window: Maximum number of historical states to analyze
            
        Returns:
            Dictionary with trajectory analysis
        """
        user_state = self.get_user_state(user_id)
        
        if not user_state.emotion_history:
            return {"trajectory": "insufficient_data"}
        
        # Get recent history
        recent_history = user_state.emotion_history[-window:]
        
        # Extract timestamps and profiles
        timestamps = [ts for ts, _ in recent_history]
        profiles = [ep for _, ep in recent_history]
        
        # Calculate trend lines for valence and arousal
        valence_values = [ep.valence for ep in profiles]
        arousal_values = [ep.arousal for ep in profiles]
        
        # Simple linear regression to detect trends
        # Using numpy's polyfit for a degree 1 polynomial (straight line)
        x = np.arange(len(timestamps))
        
        if len(x) > 1:
            valence_trend = np.polyfit(x, valence_values, 1)[0]  # Slope of the trend line
            arousal_trend = np.polyfit(x, arousal_values, 1)[0]
        else:
            valence_trend = 0
            arousal_trend = 0
        
        # Calculate volatility (standard deviation)
        valence_volatility = np.std(valence_values) if len(valence_values) > 1 else 0
        arousal_volatility = np.std(arousal_values) if len(arousal_values) > 1 else 0
        
        # Determine emotional trend description
        trend_description = self._describe_emotional_trend(valence_trend, arousal_trend)
        
        # Compare current emotion to baseline
        current = user_state.current_emotion
        baseline = user_state.baseline_emotion
        
        deviation_from_baseline = {
            "valence_deviation": current.valence - baseline.valence,
            "arousal_deviation": current.arousal - baseline.arousal,
            "dominance_deviation": current.dominance - baseline.dominance
        }
        
        return {
            "trend_description": trend_description,
            "valence_trend": float(valence_trend),
            "arousal_trend": float(arousal_trend),
            "valence_volatility": float(valence_volatility),
            "arousal_volatility": float(arousal_volatility),
            "deviation_from_baseline": deviation_from_baseline,
            "data_points": len(recent_history)
        }
    
    def _describe_emotional_trend(self, valence_trend: float, arousal_trend: float) -> str:
        """
        Generate a description of emotional trends.
        
        Args:
            valence_trend: Trend in emotional valence
            arousal_trend: Trend in emotional arousal
            
        Returns:
            Description of the emotional trend
        """
        descriptions = []
        
        # Valence trend description
        if valence_trend > 0.1:
            descriptions.append("becoming more positive")
        elif valence_trend < -0.1:
            descriptions.append("becoming more negative")
        else:
            descriptions.append("maintaining emotional tone")
        
        # Arousal trend description
        if arousal_trend > 0.1:
            descriptions.append("increasing energy/intensity")
        elif arousal_trend < -0.1:
            descriptions.append("becoming calmer")
        else:
            descriptions.append("stable energy level")
        
        return ", ".join(descriptions)
```

## Reaction Strategies Based on Emotional Dynamics

Now that we have a digital twin tracking user emotions, we need strategies for the assistant to respond appropriately to different emotional states:

```python
import os
import json
from typing import Dict, List, Any, Optional, Union
import logging
from datetime import datetime
import random
from emotion_detection.digital_twin import UserState, EmotionalDigitalTwin
from emotion_detection.detector import EmotionProfile
from openai import OpenAI
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("EmotionalResponseStrategy")

class ResponseStrategy:
    """Generate appropriate responses based on user's emotional state."""
    
    # Emotional response strategies
    RESPONSE_STRATEGIES = {
        "joy": {
            "approach": "mirror and build",
            "tone": "enthusiastic",
            "techniques": ["acknowledge positive emotion", "build on enthusiasm", "future-oriented"]
        },
        "sadness": {
            "approach": "validate and support",
            "tone": "empathetic",
            "techniques": ["acknowledge feelings", "express empathy", "gentle encouragement"]
        },
        "anger": {
            "approach": "de-escalate and address",
            "tone": "calm",
            "techniques": ["acknowledge frustration", "show understanding", "offer solutions"]
        },
        "fear": {
            "approach": "reassure and support",
            "tone": "supportive",
            "techniques": ["validate concerns", "provide clarity", "offer guidance"]
        },
        "surprise": {
            "approach": "explain and elaborate",
            "tone": "clear",
            "techniques": ["provide context", "explain thoroughly", "check understanding"]
        },
        "disgust": {
            "approach": "acknowledge and redirect",
            "tone": "respectful",
            "techniques": ["acknowledge reaction", "provide alternatives", "shift focus constructively"]
        },
        "trust": {
            "approach": "honor and deepen",
            "tone": "reliable",
            "techniques": ["express appreciation", "provide depth", "be transparent"]
        },
        "anticipation": {
            "approach": "channel and direct",
            "tone": "engaging",
            "techniques": ["acknowledge excitement", "provide clear next steps", "set expectations"]
        },
        "neutral": {
            "approach": "balanced information",
            "tone": "neutral",
            "techniques": ["provide balanced view", "match energy level", "adapt to context"]
        },
        "confusion": {
            "approach": "clarify and guide",
            "tone": "patient",
            "techniques": ["simplify explanation", "check understanding", "provide examples"]
        },
        "curiosity": {
            "approach": "explore and expand",
            "tone": "informative",
            "techniques": ["provide detailed information", "suggest related topics", "ask follow-up questions"]
        },
        "frustration": {
            "approach": "acknowledge and simplify",
            "tone": "patient",
            "techniques": ["acknowledge difficulty", "simplify steps", "offer alternatives"]
        }
    }
    
    def __init__(self, 
               digital_twin: EmotionalDigitalTwin,
               strategies_path: str = "response_strategies.json",
               model: str = "gpt-4o"):
        """
        Initialize the response strategy handler.
        
        Args:
            digital_twin: Digital twin for accessing user states
            strategies_path: Path to custom strategies file
            model: LLM model to use for response generation
        """
        self.digital_twin = digital_twin
        self.model = model
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        
        # Load custom strategies if available
        if os.path.exists(strategies_path):
            try:
                with open(strategies_path, 'r') as f:
                    custom_strategies = json.load(f)
                self.RESPONSE_STRATEGIES.update(custom_strategies)
                logger.info(f"Loaded custom response strategies from {strategies_path}")
            except Exception as e:
                logger.error(f"Error loading custom strategies: {str(e)}")
    
    def generate_response(self, 
                        user_id: str, 
                        message: str, 
                        context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate an emotionally aware response to the user message.
        
        Args:
            user_id: User identifier
            message: User message
            context: Additional context for the response
            
        Returns:
            Response data including text and metadata
        """
        # Update the user's emotional state based on the new message
        user_state = self.digital_twin.update_user_emotion(user_id, message)
        
        # Get the current emotional profile
        emotion = user_state.current_emotion
        
        # Get baseline for comparison
        baseline = user_state.baseline_emotion
        
        # Get emotional trajectory
        trajectory = self.digital_twin.get_emotional_trajectory(user_id)
        
        # Determine appropriate response strategy
        strategy = self._select_response_strategy(user_state, trajectory)
        
        # Generate response text using LLM
        response_text = self._generate_llm_response(message, user_state, strategy, context)
        
        # Package the response with metadata
        response_data = {
            "response_text": response_text,
            "detected_emotion": emotion.primary_emotion,
            "response_strategy": strategy,
            "user_state_summary": {
                "current_emotion": emotion.to_dict(),
                "baseline_emotion": baseline.to_dict(),
                "trajectory": trajectory,
                "personality_traits": user_state.personality_traits,
                "interaction_preferences": user_state.interaction_preferences
            }
        }
        
        return response_data
    
    def _select_response_strategy(self, 
                                user_state: UserState, 
                                trajectory: Dict[str, Any]) -> Dict[str, Any]:
        """
        Select the most appropriate response strategy for the current emotional state.
        
        Args:
            user_state: Current user state
            trajectory: Emotional trajectory analysis
            
        Returns:
            Selected response strategy
        """
        current_emotion = user_state.current_emotion
        primary_emotion = current_emotion.primary_emotion
        
        # Get base strategy for the primary emotion
        base_strategy = self.RESPONSE_STRATEGIES.get(
            primary_emotion, self.RESPONSE_STRATEGIES["neutral"]
        )
        
        # Make a copy to avoid modifying the base strategy
        strategy = base_strategy.copy()
        
        # Check for significant deviation from baseline
        baseline = user_state.baseline_emotion
        valence_deviation = abs(current_emotion.valence - baseline.valence)
        arousal_deviation = abs(current_emotion.arousal - baseline.arousal)
        
        significant_deviation = valence_deviation > 0.4 or arousal_deviation > 0.5
        
        # Modify strategy based on trajectory
        if "valence_trend" in trajectory:
            valence_trend = trajectory["valence_trend"]
            arousal_trend = trajectory["arousal_trend"]
            
            # If emotions are intensifying negatively
            if valence_trend < -0.1 and current_emotion.valence < 0:
                strategy["priority"] = "stabilize"
                strategy["techniques"].append("validate feelings before solutions")
            
            # If emotions are becoming more positive
            elif valence_trend > 0.1 and current_emotion.valence > 0:
                strategy["priority"] = "reinforce"
                strategy["techniques"].append("acknowledge positive shift")
            
            # If arousal is increasing significantly
            if arousal_trend > 0.2:
                strategy["techniques"].append("match energy but guide toward clarity")
        
        # Consider personality traits
        if user_state.personality_traits["neuroticism"] > 0.7:
            strategy["techniques"].append("provide reassurance")
        
        if user_state.personality_traits["openness"] > 0.7:
            strategy["techniques"].append("offer broader perspectives")
        
        # Consider interaction preferences
        strategy["communication_style"] = user_state.interaction_preferences["communication_style"]
        strategy["detail_level"] = user_state.interaction_preferences["detail_level"]
        
        return strategy
    
    def _generate_llm_response(self, 
                             message: str, 
                             user_state: UserState, 
                             strategy: Dict[str, Any],
                             context: Optional[Dict[str, Any]] = None) -> str:
        """
        Generate a response using a large language model with emotional guidance.
        
        Args:
            message: User message
            user_state: Current user state
            strategy: Selected response strategy
            context: Additional context
            
        Returns:
            Generated response text
        """
        # Create a system prompt that guides the LLM on how to respond
        system_prompt = self._create_emotion_aware_prompt(user_state, strategy)
        
        # Create messages array
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": message}
        ]
        
        # Add context from conversation if available
        if context and "conversation_history" in context:
            # Insert conversation history before the current message
            history = context["conversation_history"]
            if history:
                # Limit history to last 5 exchanges to manage context length
                for i, exchange in enumerate(history[-5:]):
                    if "user" in exchange and "assistant" in exchange:
                        messages.insert(i+1, {"role": "user", "content": exchange["user"]})
                        messages.insert(i+2, {"role": "assistant", "content": exchange["assistant"]})
        
        try:
            # Generate response using OpenAI
            response = self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=500
            )
            
            return response.choices[0].message.content
        
        except Exception as e:
            logger.error(f"Error generating response: {str(e)}")
            # Fallback response
            return "I'm having trouble processing that right now. Could you please rephrase your message?"
    
    def _create_emotion_aware_prompt(self, 
                                   user_state: UserState, 
                                   strategy: Dict[str, Any]) -> str:
        """
        Create a system prompt that guides the response generation based on emotional state.
        
        Args:
            user_state: Current user state
            strategy: Response strategy to apply
            
        Returns:
            System prompt for the LLM
        """
        # Extract key information
        emotion = user_state.current_emotion
        approach = strategy.get("approach", "balanced information")
        tone = strategy.get("tone", "neutral")
        techniques = strategy.get("techniques", [])
        communication_style = strategy.get("communication_style", "neutral")
        detail_level = strategy.get("detail_level", "medium")
        
        # Build the system prompt
        prompt = f"""
        You are an emotionally intelligent assistant responding to a user who is currently expressing {emotion.primary_emotion}.
        
        EMOTIONAL CONTEXT:
        - Primary emotion: {emotion.primary_emotion} (confidence: {emotion.confidence:.2f})
        - Emotional valence: {emotion.valence:.2f} (-1.0 negative to 1.0 positive)
        - Emotional arousal: {emotion.arousal:.2f} (0.0 calm to 1.0 excited)
        
        RESPONSE APPROACH:
        - Use the "{approach}" approach
        - Maintain a "{tone}" tone throughout your response
        - Employ the following techniques: {', '.join(techniques)}
        - Communication style: {communication_style}
        - Detail level: {detail_level}
        
        USER PERSONALITY TRAITS:
        - Openness: {user_state.personality_traits["openness"]:.2f}
        - Conscientiousness: {user_state.personality_traits["conscientiousness"]:.2f}
        - Extraversion: {user_state.personality_traits["extraversion"]:.2f}
        - Agreeableness: {user_state.personality_traits["agreeableness"]:.2f}
        - Neuroticism: {user_state.personality_traits["neuroticism"]:.2f}
        
        GUIDELINES:
        1. Respond in a way that acknowledges their emotional state without explicitly labeling it
        2. Adapt your response length to their current state (shorter for high arousal, more detailed for low arousal)
        3. Match your energy level to theirs but guide toward a constructive direction
        4. Be authentic and genuinely helpful, not formulaic
        
        Respond to the user's message in a way that feels natural and empathetic.
        """
        
        return prompt
```

## Practical Example: Building an Emotion-Aware Assistant

Let's put it all together to build a complete emotion-aware assistant that uses the digital twin concept:

```python
import os
import json
import logging
from typing import Dict, List, Any
from dotenv import load_dotenv
from datetime import datetime
import pandas as pd
import matplotlib.pyplot as plt
from emotion_detection.detector import EmotionDetector, EmotionProfile
from emotion_detection.digital_twin import EmotionalDigitalTwin, UserState
from emotion_detection.response_strategy import ResponseStrategy

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("EmotionAwareAssistant")

class EmotionAwareAssistant:
    """Assistant that adapts responses based on the user's emotional state."""
    
    def __init__(self, 
               name: str = "EmotionAssistant",
               emotion_model: str = "joeddav/distilbert-base-uncased-go-emotions-student",
               llm_model: str = "gpt-4o"):
        """
        Initialize the emotion-aware assistant.
        
        Args:
            name: Name of the assistant
            emotion_model: Model for emotion detection
            llm_model: Model for response generation
        """
        self.name = name
        
        # Initialize components
        logger.info("Initializing emotion detector...")
        self.emotion_detector = EmotionDetector(model_name=emotion_model)
        
        logger.info("Initializing digital twin manager...")
        self.digital_twin = EmotionalDigitalTwin(
            emotion_detector=self.emotion_detector,
            storage_path="user_states"
        )
        
        logger.info("Initializing response strategy manager...")
        self.strategy_manager = ResponseStrategy(
            digital_twin=self.digital_twin,
            model=llm_model
        )
        
        # Conversation history
        self.conversations = {}
        
        logger.info(f"Emotion-aware assistant '{name}' initialized successfully")
    
    def process_message(self, 
                       user_id: str, 
                       message: str) -> Dict[str, Any]:
        """
        Process a user message and generate an emotionally aware response.
        
        Args:
            user_id: User identifier
            message: User message
            
        Returns:
            Response data including text and metadata
        """
        # Initialize conversation history if needed
        if user_id not in self.conversations:
            self.conversations[user_id] = []
        
        # Process message context
        context = {
            "conversation_history": self.conversations[user_id],
            "timestamp": datetime.now().isoformat()
        }
        
        # Generate response
        response_data = self.strategy_manager.generate_response(
            user_id=user_id,
            message=message,
            context=context
        )
        
        # Update conversation history
        self.conversations[user_id].append({
            "user": message,
            "assistant": response_data["response_text"],
            "timestamp": context["timestamp"],
            "emotion": response_data["detected_emotion"]
        })
        
        return response_data
    
    def get_user_emotional_profile(self, user_id: str) -> Dict[str, Any]:
        """
        Get a summary of the user's emotional profile.
        
        Args:
            user_id: User identifier
            
        Returns:
            Emotional profile summary
        """
        user_state = self.digital_twin.get_user_state(user_id)
        trajectory = self.digital_twin.get_emotional_trajectory(user_id)
        
        return {
            "current_emotion": user_state.current_emotion.to_dict(),
            "baseline_emotion": user_state.baseline_emotion.to_dict(),
            "personality_traits": user_state.personality_traits,
            "interaction_preferences": user_state.interaction_preferences,
            "emotional_trajectory": trajectory,
            "conversation_count": len(self.conversations.get(user_id, [])),
            "last_updated": user_state.last_updated.isoformat()
        }
    
    def get_emotion_history(self, user_id: str) -> List[Dict[str, Any]]:
        """
        Get the historical emotion data for a user.
        
        Args:
            user_id: User identifier
            
        Returns:
            List of historical emotion data points
        """
        user_state = self.digital_twin.get_user_state(user_id)
        
        return [
            {
                "timestamp": ts.isoformat(),
                "emotion": ep.primary_emotion,
                "valence": ep.valence,
                "arousal": ep.arousal,
                "dominance": ep.dominance
            }
            for ts, ep in user_state.emotion_history
        ]
    
    def analyze_conversation(self, user_id: str) -> Dict[str, Any]:
        """
        Analyze the conversation with a user to identify patterns.
        
        Args:
            user_id: User identifier
            
        Returns:
            Conversation analysis data
        """
        if user_id not in self.conversations or not self.conversations[user_id]:
            return {"error": "No conversation history found"}
        
        history = self.conversations[user_id]
        
        # Extract emotions and timestamps
        emotions = [msg.get("emotion", "unknown") for msg in history]
        timestamps = [msg.get("timestamp") for msg in history]
        
        # Count emotions
        emotion_counts = {}
        for emotion in emotions:
            emotion_counts[emotion] = emotion_counts.get(emotion, 0) + 1
        
        # Calculate emotional progression (would be expanded in a real system)
        
        return {
            "message_count": len(history),
            "emotion_distribution": emotion_counts,
            "first_message_time": timestamps[0] if timestamps else None,
            "last_message_time": timestamps[-1] if timestamps else None,
            "user_id": user_id
        }

# Interactive mode for testing
def run_interactive_mode():
    """Run the assistant in interactive mode for testing."""
    print("\n=== Emotion-Aware Assistant Interactive Mode ===\n")
    assistant = EmotionAwareAssistant()
    
    user_id = input("Enter a test user ID: ")
    
    print("\nType your messages to interact with the assistant.")
    print("Type 'emotions' to see your emotion history.")
    print("Type 'profile' to see your emotional profile.")
    print("Type 'exit' to quit.\n")
    
    while True:
        user_input = input("\nYou: ")
        
        if user_input.lower() == 'exit':
            break
        
        elif user_input.lower() == 'emotions':
            history = assistant.get_emotion_history(user_id)
            print("\n=== Your Emotion History ===")
            for item in history:
                print(f"{item['timestamp']}: {item['emotion']} (valence: {item['valence']:.2f}, arousal: {item['arousal']:.2f})")
            continue
        
        elif user_input.lower() == 'profile':
            profile = assistant.get_user_emotional_profile(user_id)
            print("\n=== Your Emotional Profile ===")
            print(f"Current emotion: {profile['current_emotion']['primary_emotion']}")
            print(f"Baseline emotion: {profile['baseline_emotion']['primary_emotion']}")
            print("\nPersonality traits:")
            for trait, value in profile['personality_traits'].items():
                print(f"- {trait}: {value:.2f}")
            print("\nInteraction preferences:")
            for pref, value in profile['interaction_preferences'].items():
                print(f"- {pref}: {value}")
            continue
        
        # Process regular message
        response_data = assistant.process_message(user_id, user_input)
        
        print(f"\nAssistant: {response_data['response_text']}")
        print(f"\n(Detected emotion: {response_data['detected_emotion']})")

if __name__ == "__main__":
    run_interactive_mode()
```

## Conclusion

Building digital twins for emotional expression represents an advanced frontier in AI assistant development. By modeling users' emotional states and adapting responses accordingly, we can create significantly more engaging and effective conversational experiences.

Key takeaways from this section:

1. **Emotional Detection and Tracking**: Modern transformer models can detect nuanced emotions from text, going beyond simple sentiment analysis to identify specific emotional states and dimensions.

2. **Digital Twin Implementation**: Creating a persistent digital twin of user emotional states allows assistants to maintain context and understand trends over time rather than treating each interaction in isolation.

3. **Multi-dimensional Emotional Modeling**: Effective emotional models must track valence, arousal, and dominance aspects of emotion, as well as baseline states and personality traits to properly contextualize responses.

4. **Adaptive Response Strategies**: By aligning response strategies with emotional states, assistants can provide more empathetic and effective support—from mirroring positive emotions to de-escalating negative ones.

5. **Privacy and Ethics**: Working with emotional data requires careful consideration of privacy and ethical concerns, including transparent data handling and appropriate user consent.

The techniques presented here provide a foundation for building emotionally intelligent assistants that can adapt to users' psychological states. The real power of this approach comes from its ability to create more natural, human-like interactions that acknowledge the emotional dimensions of communication.

This approach can be extended by incorporating multimodal inputs (voice tone, facial expressions), more sophisticated psychological models, and reinforcement learning from successful interactions to continuously improve emotional intelligence over time.