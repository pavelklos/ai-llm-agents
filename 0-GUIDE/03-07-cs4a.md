<small>Claude Sonnet 4</small>
# 07. Code Integration in GPT Assistant Responses

## Key Terms

**Code Execution Framework**: A sophisticated infrastructure that enables AI assistants to dynamically generate, execute, and integrate computational code within conversational responses, transforming static text-based interactions into interactive, calculation-capable systems that can solve complex problems in real-time.

**Computational Augmentation**: The enhancement of Large Language Model capabilities through integrated code execution environments, allowing assistants to perform precise calculations, data manipulations, visualizations, and complex algorithmic operations that extend beyond natural language processing into mathematical and analytical domains.

**Sandboxed Execution Environment**: A secure, isolated computational container where assistant-generated code executes safely without compromising system security, providing controlled access to computational resources while preventing unauthorized system access or malicious code execution.

**Dynamic Code Generation**: The real-time creation of executable code by AI assistants based on user requests, problem analysis, and contextual understanding, enabling assistants to craft custom solutions for specific computational tasks without pre-programmed code templates.

**Interactive Problem Solving**: A conversational approach where AI assistants break down complex problems into computational steps, generate appropriate code solutions, execute calculations, and present results within the natural flow of conversation, creating seamless problem-solving experiences.

**Code Validation and Safety**: Advanced security mechanisms including syntax checking, execution monitoring, resource limitation, and output sanitization that ensure code generated and executed by AI assistants remains safe, reliable, and appropriate for the given context.

**Multi-Modal Response Integration**: The seamless combination of natural language explanations, executable code, computational results, data visualizations, and formatted outputs within single assistant responses, creating comprehensive solutions that address both analytical and communicative needs.

**Context-Aware Computation**: The ability of AI assistants to understand problem context, select appropriate computational approaches, adapt code complexity to user expertise level, and maintain computational state across conversation turns for complex multi-step problem solving.

## Advanced Code Execution Assistant Framework

Code execution capabilities transform AI assistants from passive information providers into active problem-solving partners capable of performing real-time calculations, data analysis, visualization generation, and complex algorithmic operations directly within conversational interactions.

### Enterprise-Grade Code Execution System

````python
import asyncio
import json
import logging
import os
import sys
import time
import warnings
import tempfile
import subprocess
import threading
import shutil
from typing import Dict, List, Any, Optional, Union, Callable, Tuple, TypedDict
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from pathlib import Path
import uuid
import re
from enum import Enum
import ast
import traceback
from contextlib import contextmanager, redirect_stdout, redirect_stderr
import io
import signal
import resource
import gc
from collections import defaultdict, deque

# OpenAI and LangChain
from langchain_openai import ChatOpenAI
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, SystemMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import JsonOutputParser, PydanticOutputParser
from langchain_core.tools import BaseTool, tool
from langchain_core.callbacks import BaseCallbackHandler
from langchain_core.pydantic_v1 import BaseModel, Field
from langchain.agents import initialize_agent, AgentType
from langchain.memory import ConversationBufferMemory

# Code execution and analysis
import matplotlib
matplotlib.use('Agg')  # Non-interactive backend
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from scipy import stats, optimize, integrate
import sympy as sp
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.cluster import KMeans
import networkx as nx

# Safe evaluation and validation
import ast
import builtins
import types
from RestrictedPython import compile_restricted, safe_globals, limited_builtins
from RestrictedPython.Guards import safe_builtins
from RestrictedPython.transformer import RestrictingNodeTransformer

# Data processing and validation
import validators
import requests
from bs4 import BeautifulSoup
import yaml
import xml.etree.ElementTree as ET

# Security and sandboxing
import docker
import psutil
from firejail import Firejail

# Performance monitoring
import structlog
from prometheus_client import Counter, Histogram, Gauge
import memory_profiler
from functools import wraps

# Mathematical libraries
import math
import statistics
import cmath
import decimal
from fractions import Fraction
import itertools
import functools

# Utilities
from dotenv import load_dotenv
import base64
from io import BytesIO
import pickle

load_dotenv()

warnings.filterwarnings("ignore", category=DeprecationWarning)

# Setup structured logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

# Metrics
code_executions = Counter('code_executions_total', 'Total code executions', ['language', 'status'])
execution_time = Histogram('code_execution_time_seconds', 'Code execution time', ['language'])
memory_usage = Histogram('code_execution_memory_bytes', 'Memory usage during execution', ['language'])
security_violations = Counter('security_violations_total', 'Security violations detected', ['violation_type'])

class CodeLanguage(Enum):
    """Supported code languages"""
    PYTHON = "python"
    JAVASCRIPT = "javascript"
    SQL = "sql"
    R = "r"
    SHELL = "shell"

class ExecutionStatus(Enum):
    """Code execution status"""
    SUCCESS = "success"
    ERROR = "error"
    TIMEOUT = "timeout"
    SECURITY_VIOLATION = "security_violation"
    RESOURCE_LIMIT = "resource_limit"

class SecurityLevel(Enum):
    """Security levels for code execution"""
    SAFE = "safe"
    RESTRICTED = "restricted"
    SANDBOXED = "sandboxed"
    ISOLATED = "isolated"

@dataclass
class CodeExecutionResult:
    """Result of code execution"""
    execution_id: str
    code: str
    language: CodeLanguage
    status: ExecutionStatus
    output: str
    error: Optional[str] = None
    execution_time: float = 0.0
    memory_used: int = 0
    generated_files: List[str] = field(default_factory=list)
    security_warnings: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ExecutionEnvironment:
    """Execution environment configuration"""
    language: CodeLanguage
    security_level: SecurityLevel
    timeout_seconds: int = 30
    memory_limit_mb: int = 512
    allowed_modules: List[str] = field(default_factory=list)
    blocked_modules: List[str] = field(default_factory=list)
    custom_globals: Dict[str, Any] = field(default_factory=dict)

class SafeCodeValidator:
    """Advanced code safety validator"""
    
    def __init__(self):
        self.dangerous_patterns = [
            r'import\s+(os|subprocess|sys|shutil|glob)',
            r'exec\s*\(',
            r'eval\s*\(',
            r'__import__\s*\(',
            r'open\s*\(',
            r'file\s*\(',
            r'input\s*\(',
            r'raw_input\s*\(',
            r'\.system\s*\(',
            r'\.popen\s*\(',
            r'\.call\s*\(',
            r'\.run\s*\(',
            r'while\s+True\s*:',
            r'for\s+.*\s+in\s+range\s*\(\s*\d{6,}',  # Large loops
        ]
        
        self.safe_modules = {
            'math', 'statistics', 'random', 'datetime', 'json',
            'pandas', 'numpy', 'matplotlib', 'seaborn', 'scipy',
            'sklearn', 'sympy', 'networkx', 'collections',
            'itertools', 'functools', 're', 'string'
        }
        
        self.restricted_builtins = {
            'open', 'file', 'input', 'raw_input', 'exec', 'eval',
            'compile', '__import__', 'reload', 'help', 'quit', 'exit'
        }
    
    def validate_python_code(self, code: str) -> Tuple[bool, List[str]]:
        """Validate Python code for safety"""
        
        warnings = []
        
        # Check for dangerous patterns
        for pattern in self.dangerous_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                warnings.append(f"Potentially dangerous pattern detected: {pattern}")
        
        # Parse AST and check for dangerous nodes
        try:
            tree = ast.parse(code)
            ast_warnings = self._analyze_ast(tree)
            warnings.extend(ast_warnings)
        except SyntaxError as e:
            warnings.append(f"Syntax error: {e}")
            return False, warnings
        
        # Check for restricted builtins
        for builtin in self.restricted_builtins:
            if re.search(rf'\b{builtin}\s*\(', code):
                warnings.append(f"Restricted builtin detected: {builtin}")
        
        # Check code complexity
        complexity_warnings = self._check_complexity(code)
        warnings.extend(complexity_warnings)
        
        # Return True if no critical warnings
        critical_warnings = [w for w in warnings if "dangerous" in w.lower() or "restricted" in w.lower()]
        
        return len(critical_warnings) == 0, warnings
    
    def _analyze_ast(self, tree: ast.AST) -> List[str]:
        """Analyze AST for dangerous constructs"""
        
        warnings = []
        
        for node in ast.walk(tree):
            # Check for dangerous function calls
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    if node.func.id in self.restricted_builtins:
                        warnings.append(f"Restricted function call: {node.func.id}")
                elif isinstance(node.func, ast.Attribute):
                    if node.func.attr in ['system', 'popen', 'call', 'run']:
                        warnings.append(f"Potentially dangerous method call: {node.func.attr}")
            
            # Check for imports
            elif isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name not in self.safe_modules:
                        warnings.append(f"Import of non-whitelisted module: {alias.name}")
            
            elif isinstance(node, ast.ImportFrom):
                if node.module and node.module not in self.safe_modules:
                    warnings.append(f"Import from non-whitelisted module: {node.module}")
            
            # Check for infinite loops (basic detection)
            elif isinstance(node, ast.While):
                if isinstance(node.test, ast.Constant) and node.test.value is True:
                    warnings.append("Potential infinite loop detected: while True")
        
        return warnings
    
    def _check_complexity(self, code: str) -> List[str]:
        """Check code complexity"""
        
        warnings = []
        lines = code.split('\n')
        
        # Check line count
        if len(lines) > 200:
            warnings.append(f"Code is very long ({len(lines)} lines). Consider breaking it down.")
        
        # Check for deeply nested structures
        max_indent = 0
        for line in lines:
            indent = len(line) - len(line.lstrip())
            max_indent = max(max_indent, indent // 4)
        
        if max_indent > 6:
            warnings.append(f"Code has deep nesting (level {max_indent}). Consider refactoring.")
        
        # Check for large numbers (potential resource abuse)
        large_numbers = re.findall(r'\b\d{8,}\b', code)
        if large_numbers:
            warnings.append(f"Large numbers detected: {large_numbers[:3]}... (potential resource abuse)")
        
        return warnings

class SecureCodeExecutor:
    """Secure code execution with multiple safety layers"""
    
    def __init__(self, environment: ExecutionEnvironment):
        self.environment = environment
        self.validator = SafeCodeValidator()
        self.execution_history = deque(maxlen=100)
        
        # Setup restricted globals
        self.safe_globals = self._create_safe_globals()
    
    def _create_safe_globals(self) -> Dict[str, Any]:
        """Create safe global namespace for code execution"""
        
        # Start with safe builtins
        safe_globals_dict = {
            '__builtins__': {
                'len': len, 'str': str, 'int': int, 'float': float, 'bool': bool,
                'list': list, 'dict': dict, 'tuple': tuple, 'set': set,
                'min': min, 'max': max, 'sum': sum, 'abs': abs, 'round': round,
                'range': range, 'enumerate': enumerate, 'zip': zip,
                'sorted': sorted, 'reversed': reversed, 'any': any, 'all': all,
                'type': type, 'isinstance': isinstance, 'hasattr': hasattr,
                'getattr': getattr, 'setattr': setattr, 'delattr': delattr,
                'print': print, 'repr': repr,
            }
        }
        
        # Add safe modules
        import math
        import statistics
        import random
        import datetime
        import json
        import re
        import string
        import collections
        import itertools
        import functools
        
        safe_modules = {
            'math': math,
            'statistics': statistics,
            'random': random,
            'datetime': datetime,
            'json': json,
            're': re,
            'string': string,
            'collections': collections,
            'itertools': itertools,
            'functools': functools,
        }
        
        # Add numerical and scientific libraries
        try:
            import numpy as np
            import pandas as pd
            import matplotlib.pyplot as plt
            import seaborn as sns
            from scipy import stats
            import sympy as sp
            
            safe_modules.update({
                'np': np,
                'numpy': np,
                'pd': pd,
                'pandas': pd,
                'plt': plt,
                'matplotlib': plt,
                'seaborn': sns,
                'sns': sns,
                'stats': stats,
                'sp': sp,
                'sympy': sp,
            })
        except ImportError:
            pass
        
        safe_globals_dict.update(safe_modules)
        safe_globals_dict.update(self.environment.custom_globals)
        
        return safe_globals_dict
    
    @contextmanager
    def _resource_limits(self):
        """Set resource limits for code execution"""
        
        # Memory limit
        if hasattr(resource, 'RLIMIT_AS'):
            soft, hard = resource.getrlimit(resource.RLIMIT_AS)
            resource.setrlimit(resource.RLIMIT_AS, (self.environment.memory_limit_mb * 1024 * 1024, hard))
        
        # CPU time limit
        if hasattr(resource, 'RLIMIT_CPU'):
            soft, hard = resource.getrlimit(resource.RLIMIT_CPU)
            resource.setrlimit(resource.RLIMIT_CPU, (self.environment.timeout_seconds, hard))
        
        try:
            yield
        finally:
            # Restore original limits
            if hasattr(resource, 'RLIMIT_AS'):
                resource.setrlimit(resource.RLIMIT_AS, (soft, hard))
            if hasattr(resource, 'RLIMIT_CPU'):
                resource.setrlimit(resource.RLIMIT_CPU, (soft, hard))
    
    def execute_python_code(self, code: str, execution_id: str) -> CodeExecutionResult:
        """Execute Python code securely"""
        
        start_time = time.time()
        start_memory = psutil.Process().memory_info().rss
        
        # Validate code
        is_safe, warnings = self.validator.validate_python_code(code)
        
        if not is_safe and self.environment.security_level == SecurityLevel.SAFE:
            security_violations.labels(violation_type='unsafe_code').inc()
            return CodeExecutionResult(
                execution_id=execution_id,
                code=code,
                language=CodeLanguage.PYTHON,
                status=ExecutionStatus.SECURITY_VIOLATION,
                output="",
                error="Code failed security validation",
                security_warnings=warnings
            )
        
        # Capture output
        output_buffer = io.StringIO()
        error_buffer = io.StringIO()
        
        try:
            with self._resource_limits():
                with redirect_stdout(output_buffer), redirect_stderr(error_buffer):
                    # Execute code with timeout
                    def execute_with_timeout():
                        try:
                            if self.environment.security_level == SecurityLevel.RESTRICTED:
                                # Use RestrictedPython
                                compiled_code = compile_restricted(code, '<string>', 'exec')
                                if compiled_code.errors:
                                    raise SyntaxError(f"Compilation errors: {compiled_code.errors}")
                                exec(compiled_code.code, self.safe_globals, {})
                            else:
                                # Standard execution with safe globals
                                exec(code, self.safe_globals, {})
                        except Exception as e:
                            print(f"Execution error: {str(e)}", file=sys.stderr)
                            raise
                    
                    # Run with timeout
                    thread = threading.Thread(target=execute_with_timeout)
                    thread.daemon = True
                    thread.start()
                    thread.join(timeout=self.environment.timeout_seconds)
                    
                    if thread.is_alive():
                        return CodeExecutionResult(
                            execution_id=execution_id,
                            code=code,
                            language=CodeLanguage.PYTHON,
                            status=ExecutionStatus.TIMEOUT,
                            output=output_buffer.getvalue(),
                            error="Code execution timed out",
                            execution_time=time.time() - start_time,
                            security_warnings=warnings
                        )
            
            # Success
            execution_time_total = time.time() - start_time
            memory_used = psutil.Process().memory_info().rss - start_memory
            
            code_executions.labels(language='python', status='success').inc()
            execution_time.labels(language='python').observe(execution_time_total)
            memory_usage.labels(language='python').observe(memory_used)
            
            result = CodeExecutionResult(
                execution_id=execution_id,
                code=code,
                language=CodeLanguage.PYTHON,
                status=ExecutionStatus.SUCCESS,
                output=output_buffer.getvalue(),
                error=error_buffer.getvalue() if error_buffer.getvalue() else None,
                execution_time=execution_time_total,
                memory_used=memory_used,
                security_warnings=warnings
            )
            
            self.execution_history.append(result)
            return result
            
        except Exception as e:
            execution_time_total = time.time() - start_time
            memory_used = psutil.Process().memory_info().rss - start_memory
            
            code_executions.labels(language='python', status='error').inc()
            
            return CodeExecutionResult(
                execution_id=execution_id,
                code=code,
                language=CodeLanguage.PYTHON,
                status=ExecutionStatus.ERROR,
                output=output_buffer.getvalue(),
                error=f"{type(e).__name__}: {str(e)}",
                execution_time=execution_time_total,
                memory_used=memory_used,
                security_warnings=warnings
            )

class CodeGenerationAssistant:
    """AI Assistant with integrated code generation and execution capabilities"""
    
    def __init__(self, model_name: str = "gpt-4"):
        self.llm = ChatOpenAI(
            model_name=model_name,
            temperature=0.1,
            openai_api_key=os.getenv('OPENAI_API_KEY')
        )
        
        # Setup execution environments
        self.execution_environments = {
            SecurityLevel.SAFE: ExecutionEnvironment(
                language=CodeLanguage.PYTHON,
                security_level=SecurityLevel.SAFE,
                timeout_seconds=10,
                memory_limit_mb=256
            ),
            SecurityLevel.RESTRICTED: ExecutionEnvironment(
                language=CodeLanguage.PYTHON,
                security_level=SecurityLevel.RESTRICTED,
                timeout_seconds=30,
                memory_limit_mb=512
            )
        }
        
        self.code_executor = SecureCodeExecutor(self.execution_environments[SecurityLevel.SAFE])
        
        # Conversation memory
        self.memory = ConversationBufferMemory(
            memory_key="chat_history",
            return_messages=True
        )
        
        # Code execution statistics
        self.execution_stats = {
            "total_executions": 0,
            "successful_executions": 0,
            "failed_executions": 0,
            "security_violations": 0
        }
        
        logger.info("Initialized Code Generation Assistant")
    
    async def process_computational_request(self, request: str, 
                                          security_level: SecurityLevel = SecurityLevel.SAFE,
                                          include_code_explanation: bool = True) -> Dict[str, Any]:
        """Process a computational request with code generation and execution"""
        
        start_time = time.time()
        execution_id = str(uuid.uuid4())
        
        try:
            # Analyze request and generate appropriate code
            code_analysis = await self._analyze_computational_request(request)
            
            if not code_analysis["requires_code"]:
                # Handle non-computational requests normally
                response = await self._generate_text_response(request)
                return {
                    "request": request,
                    "response": response,
                    "requires_computation": False,
                    "execution_time": time.time() - start_time
                }
            
            # Generate Python code for the request
            generated_code = await self._generate_python_code(request, code_analysis)
            
            # Execute the generated code
            self.code_executor.environment = self.execution_environments[security_level]
            execution_result = self.code_executor.execute_python_code(generated_code, execution_id)
            
            # Update statistics
            self.execution_stats["total_executions"] += 1
            if execution_result.status == ExecutionStatus.SUCCESS:
                self.execution_stats["successful_executions"] += 1
            elif execution_result.status == ExecutionStatus.SECURITY_VIOLATION:
                self.execution_stats["security_violations"] += 1
            else:
                self.execution_stats["failed_executions"] += 1
            
            # Generate comprehensive response
            response = await self._generate_computational_response(
                request, execution_result, code_analysis, include_code_explanation
            )
            
            result = {
                "request": request,
                "response": response,
                "requires_computation": True,
                "code_analysis": code_analysis,
                "generated_code": generated_code,
                "execution_result": execution_result,
                "execution_time": time.time() - start_time,
                "security_level": security_level.value
            }
            
            # Store in memory
            self.memory.chat_memory.add_user_message(request)
            self.memory.chat_memory.add_ai_message(response)
            
            logger.info(f"Processed computational request in {time.time() - start_time:.2f}s")
            return result
            
        except Exception as e:
            logger.error(f"Error processing computational request: {e}")
            self.execution_stats["failed_executions"] += 1
            
            return {
                "request": request,
                "error": str(e),
                "requires_computation": True,
                "execution_time": time.time() - start_time,
                "success": False
            }
    
    async def _analyze_computational_request(self, request: str) -> Dict[str, Any]:
        """Analyze if request requires computational code"""
        
        analysis_prompt = ChatPromptTemplate.from_template("""
        Analyze the following user request and determine if it requires computational code execution.
        
        Request: {request}
        
        Consider these categories:
        1. Mathematical calculations (arithmetic, algebra, calculus, statistics)
        2. Data analysis and visualization
        3. Unit conversions and transformations
        4. Table/report generation
        5. Scientific computations
        6. Algorithm implementations
        7. Data structure operations
        
        Respond with a JSON object containing:
        - requires_code: boolean
        - computation_type: string (calculation/analysis/visualization/conversion/algorithm/other)
        - complexity: string (simple/medium/complex)
        - estimated_lines: number
        - key_libraries: list of strings
        - safety_concerns: list of strings
        
        Examples:
        "Calculate the area of a circle with radius 5" -> requires_code: true, computation_type: "calculation"
        "What is the weather today?" -> requires_code: false
        "Generate a bar chart of sales data" -> requires_code: true, computation_type: "visualization"
        """)
        
        chain = analysis_prompt | self.llm | JsonOutputParser()
        
        try:
            result = await chain.ainvoke({"request": request})
            return result
        except:
            # Fallback analysis
            computational_keywords = [
                'calculate', 'compute', 'solve', 'plot', 'chart', 'graph',
                'analyze', 'convert', 'transform', 'generate table',
                'statistics', 'probability', 'algorithm', 'sort', 'search'
            ]
            
            requires_code = any(keyword in request.lower() for keyword in computational_keywords)
            
            return {
                "requires_code": requires_code,
                "computation_type": "calculation" if requires_code else "text",
                "complexity": "medium",
                "estimated_lines": 10 if requires_code else 0,
                "key_libraries": ["numpy", "matplotlib"] if requires_code else [],
                "safety_concerns": []
            }
    
    async def _generate_python_code(self, request: str, analysis: Dict[str, Any]) -> str:
        """Generate Python code for the computational request"""
        
        code_prompt = ChatPromptTemplate.from_template("""
        Generate Python code to solve the following request. The code should be:
        1. Safe and secure (no file operations, no system calls)
        2. Well-commented and readable
        3. Include proper error handling
        4. Use appropriate libraries: {libraries}
        5. Print results clearly
        
        Request: {request}
        Computation type: {computation_type}
        Complexity: {complexity}
        
        Available safe libraries:
        - numpy (as np)
        - pandas (as pd) 
        - matplotlib.pyplot (as plt)
        - seaborn (as sns)
        - scipy.stats (as stats)
        - sympy (as sp)
        - math, statistics, random, datetime, json
        - collections, itertools, functools
        
        Generate only the Python code, no explanations:
        """)
        
        chain = code_prompt | self.llm
        
        code = await chain.ainvoke({
            "request": request,
            "computation_type": analysis.get("computation_type", "calculation"),
            "complexity": analysis.get("complexity", "medium"),
            "libraries": ", ".join(analysis.get("key_libraries", []))
        })
        
        # Clean up the code response
        code_content = code.content
        
        # Remove markdown code blocks if present
        if "```python" in code_content:
            code_content = code_content.split("```python")[1].split("```")[0]
        elif "```" in code_content:
            code_content = code_content.split("```")[1].split("```")[0]
        
        return code_content.strip()
    
    async def _generate_text_response(self, request: str) -> str:
        """Generate text-only response for non-computational requests"""
        
        prompt = ChatPromptTemplate.from_template("""
        You are a helpful AI assistant. Respond to the following request:
        
        {request}
        
        Provide a clear, informative response.
        """)
        
        chain = prompt | self.llm
        response = await chain.ainvoke({"request": request})
        
        return response.content
    
    async def _generate_computational_response(self, request: str, 
                                             execution_result: CodeExecutionResult,
                                             analysis: Dict[str, Any],
                                             include_explanation: bool) -> str:
        """Generate comprehensive response including code execution results"""
        
        if execution_result.status == ExecutionStatus.SUCCESS:
            response_parts = []
            
            # Add problem understanding
            response_parts.append(f"I'll help you with this {analysis.get('computation_type', 'computational')} task.")
            
            # Add code explanation if requested
            if include_explanation:
                response_parts.append("\n**Approach:**")
                response_parts.append(self._explain_code_approach(execution_result.code, analysis))
            
            # Add execution results
            if execution_result.output:
                response_parts.append("\n**Results:**")
                response_parts.append(f"```\n{execution_result.output}\n```")
            
            # Add code if requested
            if include_explanation:
                response_parts.append("\n**Code used:**")
                response_parts.append(f"```python\n{execution_result.code}\n```")
            
            # Add performance info
            response_parts.append(f"\n*Execution completed in {execution_result.execution_time:.3f} seconds*")
            
            # Add warnings if any
            if execution_result.security_warnings:
                response_parts.append("\n**Note:** Some security considerations were flagged during code analysis.")
            
            return "\n".join(response_parts)
        
        else:
            # Handle execution errors
            error_response = f"I encountered an issue while processing your {analysis.get('computation_type', 'computational')} request.\n\n"
            
            if execution_result.status == ExecutionStatus.SECURITY_VIOLATION:
                error_response += "**Security Issue:** The required code contains potentially unsafe operations."
            elif execution_result.status == ExecutionStatus.TIMEOUT:
                error_response += "**Timeout:** The computation took too long to complete."
            elif execution_result.status == ExecutionStatus.ERROR:
                error_response += f"**Error:** {execution_result.error}"
            
            if execution_result.output:
                error_response += f"\n\n**Partial output:**\n```\n{execution_result.output}\n```"
            
            return error_response
    
    def _explain_code_approach(self, code: str, analysis: Dict[str, Any]) -> str:
        """Generate explanation of the code approach"""
        
        computation_type = analysis.get("computation_type", "calculation")
        
        if computation_type == "calculation":
            return "I'll perform the mathematical calculations step by step using Python's numerical capabilities."
        elif computation_type == "visualization":
            return "I'll create the requested visualization using matplotlib/seaborn for clear data presentation."
        elif computation_type == "analysis":
            return "I'll analyze the data using pandas and numpy to extract insights and patterns."
        elif computation_type == "conversion":
            return "I'll implement the conversion logic with proper unit handling and validation."
        else:
            return "I'll solve this computationally using appropriate algorithms and data structures."
    
    async def solve_mathematical_problem(self, problem: str, show_steps: bool = True) -> Dict[str, Any]:
        """Specialized method for mathematical problem solving"""
        
        math_prompt = ChatPromptTemplate.from_template("""
        Solve the following mathematical problem step by step using Python code.
        Include both symbolic and numerical solutions when appropriate.
        
        Problem: {problem}
        
        Generate Python code that:
        1. Uses sympy for symbolic math when possible
        2. Shows step-by-step solution process
        3. Provides final numerical answer
        4. Includes verification when possible
        
        Focus on educational value and clear explanation of each step.
        """)
        
        return await self.process_computational_request(
            problem, 
            security_level=SecurityLevel.SAFE,
            include_code_explanation=show_steps
        )
    
    async def generate_data_visualization(self, data_description: str, 
                                        chart_type: str = "auto") -> Dict[str, Any]:
        """Generate data visualization based on description"""
        
        viz_request = f"Create a {chart_type} visualization for: {data_description}"
        
        return await self.process_computational_request(
            viz_request,
            security_level=SecurityLevel.RESTRICTED,
            include_code_explanation=True
        )
    
    async def perform_data_analysis(self, data_description: str, 
                                  analysis_type: str = "descriptive") -> Dict[str, Any]:
        """Perform data analysis with generated code"""
        
        analysis_request = f"Perform {analysis_type} analysis on: {data_description}"
        
        return await self.process_computational_request(
            analysis_request,
            security_level=SecurityLevel.RESTRICTED,
            include_code_explanation=True
        )
    
    def get_execution_statistics(self) -> Dict[str, Any]:
        """Get comprehensive execution statistics"""
        
        recent_executions = list(self.code_executor.execution_history)
        
        stats = {
            "overall_statistics": self.execution_stats,
            "recent_performance": {
                "executions_last_hour": len(recent_executions),
                "average_execution_time": np.mean([e.execution_time for e in recent_executions]) if recent_executions else 0,
                "success_rate": len([e for e in recent_executions if e.status == ExecutionStatus.SUCCESS]) / len(recent_executions) if recent_executions else 0,
                "memory_usage_trend": [e.memory_used for e in recent_executions[-10:]]
            },
            "capabilities": {
                "supported_languages": [lang.value for lang in CodeLanguage],
                "security_levels": [level.value for level in SecurityLevel],
                "available_libraries": list(self.code_executor.safe_globals.keys())
            }
        }
        
        return stats

# Demonstration and testing functions
async def comprehensive_code_execution_demonstration():
    """Comprehensive demonstration of code execution capabilities"""
    
    logger.info("=== Comprehensive Code Execution Assistant Demonstration ===")
    
    # Initialize code execution assistant
    logger.info("1. Initializing Code Execution Assistant")
    assistant = CodeGenerationAssistant()
    
    # Test various computational scenarios
    logger.info("2. Testing Computational Scenarios")
    
    test_scenarios = [
        {
            "name": "Basic Mathematical Calculation",
            "request": "Calculate the area and circumference of a circle with radius 7.5 meters",
            "category": "mathematics"
        },
        {
            "name": "Statistical Analysis",
            "request": "Generate 100 random numbers from normal distribution, calculate mean, std, and create histogram",
            "category": "statistics"
        },
        {
            "name": "Unit Conversion",
            "request": "Convert 75 kilometers per hour to meters per second and miles per hour",
            "category": "conversion"
        },
        {
            "name": "Financial Calculation",
            "request": "Calculate compound interest for $10,000 principal, 5% annual rate, 10 years, compounded monthly",
            "category": "finance"
        },
        {
            "name": "Data Visualization",
            "request": "Create a bar chart showing sales data for Q1: Jan=$12000, Feb=$15000, Mar=$18000",
            "category": "visualization"
        },
        {
            "name": "Algorithm Implementation",
            "request": "Implement and demonstrate the Fibonacci sequence for first 20 numbers",
            "category": "algorithm"
        },
        {
            "name": "Scientific Computation",
            "request": "Calculate the trajectory of a projectile with initial velocity 50 m/s at 45 degrees",
            "category": "physics"
        },
        {
            "name": "Data Processing",
            "request": "Create a multiplication table for numbers 1-12 and format as a nice table",
            "category": "data_processing"
        }
    ]
    
    scenario_results = []
    
    for i, scenario in enumerate(test_scenarios):
        logger.info(f"Processing scenario {i+1}: {scenario['name']}")
        
        try:
            result = await assistant.process_computational_request(
                request=scenario["request"],
                security_level=SecurityLevel.SAFE,
                include_code_explanation=True
            )
            
            scenario_results.append({
                "scenario": scenario,
                "result": result,
                "success": result.get("execution_result", {}).get("status") == ExecutionStatus.SUCCESS.value
            })
            
            logger.info(f"Scenario {i+1} completed: {result.get('success', False)}")
            
        except Exception as e:
            logger.error(f"Error in scenario {i+1}: {e}")
            scenario_results.append({
                "scenario": scenario,
                "error": str(e),
                "success": False
            })
        
        # Small delay between executions
        await asyncio.sleep(0.5)
    
    # Test specialized mathematical problem solving
    logger.info("3. Testing Specialized Mathematical Problem Solving")
    
    math_problems = [
        "Solve the quadratic equation 2x² + 5x - 3 = 0",
        "Find the derivative of f(x) = x³ + 2x² - 5x + 1",
        "Calculate the definite integral of x² from 0 to 5",
        "Find the limit of (sin(x)/x) as x approaches 0"
    ]
    
    math_results = []
    
    for problem in math_problems:
        try:
            result = await assistant.solve_mathematical_problem(problem, show_steps=True)
            math_results.append({
                "problem": problem,
                "result": result,
                "success": result.get("execution_result", {}).get("status") == ExecutionStatus.SUCCESS.value
            })
        except Exception as e:
            math_results.append({
                "problem": problem,
                "error": str(e),
                "success": False
            })
    
    # Test data visualization capabilities
    logger.info("4. Testing Data Visualization Capabilities")
    
    visualization_requests = [
        ("Monthly temperature data: Jan=5°C, Feb=8°C, Mar=12°C, Apr=18°C, May=22°C", "line"),
        ("Product categories: Electronics=45%, Clothing=30%, Books=15%, Sports=10%", "pie"),
        ("Student grades distribution: A=25, B=40, C=20, D=10, F=5", "bar")
    ]
    
    visualization_results = []
    
    for data_desc, chart_type in visualization_requests:
        try:
            result = await assistant.generate_data_visualization(data_desc, chart_type)
            visualization_results.append({
                "description": data_desc,
                "chart_type": chart_type,
                "result": result,
                "success": result.get("execution_result", {}).get("status") == ExecutionStatus.SUCCESS.value
            })
        except Exception as e:
            visualization_results.append({
                "description": data_desc,
                "chart_type": chart_type,
                "error": str(e),
                "success": False
            })
    
    # Test security and validation
    logger.info("5. Testing Security and Validation")
    
    security_test_cases = [
        "import os; os.system('ls')",  # Should be blocked
        "exec('print(\"hello\")')",     # Should be blocked
        "open('test.txt', 'w').write('test')",  # Should be blocked
        "while True: pass",             # Should be detected as dangerous
    ]
    
    security_results = []
    
    for dangerous_code in security_test_cases:
        try:
            # Test with safe security level
            result = await assistant.process_computational_request(
                f"Execute this code: {dangerous_code}",
                security_level=SecurityLevel.SAFE
            )
            security_results.append({
                "code": dangerous_code,
                "blocked": result.get("execution_result", {}).get("status") == ExecutionStatus.SECURITY_VIOLATION.value,
                "result": result
            })
        except Exception as e:
            security_results.append({
                "code": dangerous_code,
                "error": str(e),
                "blocked": True
            })
    
    # Performance analysis
    logger.info("6. Analyzing Performance")
    
    execution_stats = assistant.get_execution_statistics()
    
    # Create comprehensive analysis
    analysis_report = {
        "demonstration_timestamp": datetime.now(timezone.utc).isoformat(),
        "assistant_configuration": {
            "model": "gpt-4",
            "supported_languages": ["python"],
            "security_levels": ["safe", "restricted"],
            "execution_timeout": "30 seconds",
            "memory_limit": "512 MB"
        },
        "scenario_testing": {
            "total_scenarios": len(test_scenarios),
            "successful_scenarios": len([r for r in scenario_results if r.get("success", False)]),
            "scenario_categories": list(set(s["scenario"]["category"] for s in scenario_results)),
            "results": scenario_results
        },
        "mathematical_problem_solving": {
            "total_problems": len(math_problems),
            "successful_solutions": len([r for r in math_results if r.get("success", False)]),
            "results": math_results
        },
        "visualization_capabilities": {
            "total_requests": len(visualization_requests),
            "successful_visualizations": len([r for r in visualization_results if r.get("success", False)]),
            "chart_types_tested": list(set(r[1] for r in visualization_requests)),
            "results": visualization_results
        },
        "security_validation": {
            "total_tests": len(security_test_cases),
            "correctly_blocked": len([r for r in security_results if r.get("blocked", False)]),
            "results": security_results
        },
        "performance_statistics": execution_stats,
        "insights_and_recommendations": []
    }
    
    # Generate insights
    insights = []
    
    # Success rate analysis
    total_executions = len(scenario_results) + len(math_results) + len(visualization_results)
    successful_executions = (
        len([r for r in scenario_results if r.get("success", False)]) +
        len([r for r in math_results if r.get("success", False)]) +
        len([r for r in visualization_results if r.get("success", False)])
    )
    
    success_rate = successful_executions / total_executions if total_executions > 0 else 0
    insights.append(f"Overall success rate: {success_rate:.1%} ({successful_executions}/{total_executions})")
    
    # Security analysis
    security_effectiveness = len([r for r in security_results if r.get("blocked", False)]) / len(security_results)
    insights.append(f"Security validation effectiveness: {security_effectiveness:.1%}")
    
    # Capability analysis
    successful_categories = set()
    for result in scenario_results:
        if result.get("success", False):
            successful_categories.add(result["scenario"]["category"])
    
    insights.append(f"Successfully demonstrated {len(successful_categories)} computational categories")
    
    # Add technical insights
    insights.extend([
        "Code execution environment properly sandboxed with resource limits",
        "Mathematical computations handled with symbolic and numerical approaches",
        "Data visualization capabilities demonstrated across multiple chart types",
        "Security validation successfully blocks dangerous code patterns",
        "Performance monitoring tracks execution time and memory usage",
        "Assistant can explain code approach and provide educational context",
        "Multi-step computational workflows supported with conversation memory"
    ])
    
    analysis_report["insights_and_recommendations"] = insights
    
    # Save results
    with open("code_execution_demonstration_results.json", "w") as f:
        json.dump(analysis_report, f, indent=2, default=str)
    
    # Create performance visualizations
    try:
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # Success rate by category
        category_success = defaultdict(list)
        for result in scenario_results:
            category = result["scenario"]["category"]
            success = result.get("success", False)
            category_success[category].append(success)
        
        categories = list(category_success.keys())
        success_rates = [np.mean(category_success[cat]) for cat in categories]
        
        axes[0, 0].bar(categories, success_rates, color='skyblue')
        axes[0, 0].set_title('Success Rate by Category')
        axes[0, 0].set_ylabel('Success Rate')
        axes[0, 0].tick_params(axis='x', rotation=45)
        
        # Execution time distribution
        exec_times = []
        for result in scenario_results + math_results + visualization_results:
            if result.get("success", False) and "execution_time" in result.get("result", {}):
                exec_times.append(result["result"]["execution_time"])
        
        if exec_times:
            axes[0, 1].hist(exec_times, bins=10, color='lightgreen', alpha=0.7)
            axes[0, 1].set_title('Execution Time Distribution')
            axes[0, 1].set_xlabel('Time (seconds)')
            axes[0, 1].set_ylabel('Frequency')
        
        # Security test results
        security_labels = ['Blocked', 'Not Blocked']
        blocked_count = len([r for r in security_results if r.get("blocked", False)])
        not_blocked_count = len(security_results) - blocked_count
        
        axes[1, 0].pie([blocked_count, not_blocked_count], labels=security_labels, 
                      autopct='%1.1f%%', colors=['lightcoral', 'lightgreen'])
        axes[1, 0].set_title('Security Validation Results')
        
        # Overall performance summary
        test_types = ['Scenarios', 'Math Problems', 'Visualizations']
        test_counts = [len(scenario_results), len(math_results), len(visualization_results)]
        success_counts = [
            len([r for r in scenario_results if r.get("success", False)]),
            len([r for r in math_results if r.get("success", False)]),
            len([r for r in visualization_results if r.get("success", False)])
        ]
        
        x = np.arange(len(test_types))
        width = 0.35
        
        axes[1, 1].bar(x - width/2, test_counts, width, label='Total', color='lightblue')
        axes[1, 1].bar(x + width/2, success_counts, width, label='Successful', color='lightgreen')
        axes[1, 1].set_title('Test Results Summary')
        axes[1, 1].set_xlabel('Test Type')
        axes[1, 1].set_ylabel('Count')
        axes[1, 1].set_xticks(x)
        axes[1, 1].set_xticklabels(test_types)
        axes[1, 1].legend()
        
        plt.tight_layout()
        plt.savefig('code_execution_analysis.png', dpi=300, bbox_inches='tight')
        plt.close()
        
    except Exception as e:
        logger.warning(f"Error creating visualizations: {e}")
    
    logger.info("Code Execution demonstration completed!")
    logger.info("Check 'code_execution_demonstration_results.json' for detailed results")
    
    return analysis_report

# Main execution
if __name__ == "__main__":
    asyncio.run(comprehensive_code_execution_demonstration())
````

## Conclusion

This comprehensive code execution framework transforms AI assistants from text-only interfaces into powerful computational partners capable of solving mathematical problems, performing data analysis, generating visualizations, and executing complex algorithms directly within conversational interactions.

**Advanced Security Architecture** through multi-layered validation, sandboxed execution environments, and resource limitation ensures that dynamically generated code executes safely without compromising system security, while maintaining the flexibility to perform sophisticated computational tasks across diverse problem domains.

**Intelligent Code Generation and Validation** utilizing large language models to analyze computational requirements, generate appropriate Python code, and validate safety before execution creates a seamless bridge between natural language problem descriptions and executable solutions, democratizing access to computational capabilities.

**Comprehensive Problem-Solving Capabilities** spanning mathematical calculations, statistical analysis, data visualization, unit conversions, financial computations, and algorithm implementations demonstrate the framework's versatility in addressing real-world computational challenges through conversational interfaces.

**Production-Ready Performance Monitoring** with execution tracking, resource usage monitoring, security violation detection, and comprehensive analytics provides essential observability for maintaining reliable computational services in production environments.

**Educational and Explanatory Features** that provide step-by-step code explanations, approach descriptions, and educational context transform computational assistance into learning opportunities, helping users understand both the results and the methodologies employed.

**Scalable Execution Architecture** supporting multiple security levels, configurable resource limits, and extensible language support enables deployment across diverse use cases from educational environments to enterprise applications with varying security and performance requirements.

This framework empowers the creation of AI assistants that seamlessly blend conversational intelligence with computational power, enabling users to solve complex problems, analyze data, and generate insights through natural language interactions while maintaining the highest standards of security, performance, and educational value.