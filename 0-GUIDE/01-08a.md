<small>Claude 3.7 Sonnet Thinking</small>
# 08. AI Agent in Practice: OpenAI Operator Style

## Key Terms

- **Operator Pattern**: A design approach where AI agents operate systems and applications through well-defined interfaces.
- **System Control**: The ability of an agent to interact with and manipulate software and hardware systems.
- **Context Window**: The amount of text an LLM can process in a single interaction.
- **Tool Functions**: Specialized functions that extend an agent's capabilities, allowing it to interact with external systems.
- **Action Space**: The set of all possible actions an agent can take in a given environment.
- **Feedback Loop**: The cycle of agent actions and environment responses that guides the agent's learning and operation.
- **Human-in-the-loop (HITL)**: A paradigm where human oversight and intervention are integrated into an autonomous system's operation.
- **Task Decomposition**: Breaking complex tasks into smaller, manageable subtasks.
- **State Management**: Tracking and persisting the agent's understanding of the environment across interactions.

## Building a System-Controlling Agent

The OpenAI Operator pattern represents an approach to building AI agents that can effectively control and operate systems. These agents can interpret user requests, determine the appropriate sequence of actions, execute those actions against target systems, and interpret the resultsâ€”all while maintaining context awareness.

### Setting up the Environment

First, let's set up our environment with the necessary dependencies:

```python
import os
import subprocess
import sys
from dotenv import load_dotenv

def install_dependencies():
    """Install required packages for the operator agent"""
    dependencies = [
        "openai>=1.5.0",
        "python-dotenv>=1.0.0",
        "pydantic>=2.4.0",
        "fastapi>=0.104.1",
        "uvicorn>=0.23.2",
        "rich>=13.6.0",
        "click>=8.1.7",
        "tenacity>=8.2.3",
        "jsonschema>=4.19.1",
        "websockets>=11.0.3",
        "httpx>=0.25.1",
        "tiktoken>=0.5.1",
        "psutil>=5.9.6"
    ]
    
    for package in dependencies:
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])
    
    print("All dependencies installed successfully!")

if __name__ == "__main__":
    install_dependencies()
    
    # Set up environment variables
    load_dotenv()
    
    # Check for required API keys
    required_vars = ["OPENAI_API_KEY"]
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        print(f"Error: Missing required environment variables: {', '.join(missing_vars)}")
        print("Please add them to your .env file")
    else:
        print("Environment setup complete!")
```

### Core Agent Architecture

Now, let's create the core architecture for our operator agent:

```python
import os
import json
import uuid
import time
import logging
from typing import Dict, List, Any, Optional, Union, Callable, Tuple
from enum import Enum
from pydantic import BaseModel, Field
import openai
from tenacity import retry, stop_after_attempt, wait_exponential
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger("operator-agent")

# Configure OpenAI client
client = openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

class ActionStatus(str, Enum):
    """Status of an action execution"""
    SUCCESS = "success"
    FAILURE = "failure"
    PENDING = "pending"
    UNAUTHORIZED = "unauthorized"

class Action(BaseModel):
    """Representation of a system action to be performed"""
    name: str
    description: str
    parameters: Dict[str, Any] = Field(default_factory=dict)
    
class ActionResult(BaseModel):
    """Result of executing an action"""
    action_id: str
    status: ActionStatus
    result: Optional[Any] = None
    error_message: Optional[str] = None
    execution_time: float = 0.0
    timestamp: float = Field(default_factory=time.time)

class SystemTool(BaseModel):
    """Definition of a system tool that the agent can use"""
    name: str
    description: str
    parameters_schema: Dict[str, Any]
    function: Optional[Callable] = None
    
    def execute(self, **kwargs) -> Any:
        """Execute the tool function with provided parameters"""
        if not self.function:
            raise ValueError(f"Tool {self.name} has no associated function")
        
        try:
            return self.function(**kwargs)
        except Exception as e:
            logger.error(f"Error executing tool {self.name}: {str(e)}")
            raise

class OperatorAgent:
    """AI agent that can operate and control systems through defined tools"""
    
    def __init__(
        self,
        model: str = "gpt-4-turbo",
        tools: Optional[List[SystemTool]] = None,
        system_message: Optional[str] = None,
        max_iterations: int = 10,
        verbose: bool = False
    ):
        """Initialize the operator agent"""
        self.model = model
        self.tools = tools or []
        self.tool_map = {tool.name: tool for tool in self.tools}
        self.max_iterations = max_iterations
        self.verbose = verbose
        
        # Default system message if none provided
        default_system_message = """
        You are an AI Operator Agent responsible for controlling systems and applications through available tools.
        Your goal is to complete user tasks by breaking them down into appropriate actions.
        For each step:
        1. Analyze the current state and history
        2. Determine the next action to take
        3. Execute the action using available tools
        4. Interpret the results and decide on next steps
        
        Be precise in your use of tools, and always provide clear reasoning for your actions.
        If you encounter errors, try to recover or suggest alternative approaches.
        """
        
        self.system_message = system_message or default_system_message
        self.conversation_history = []
        self.action_history = []
        self.session_id = str(uuid.uuid4())
    
    def add_tool(self, tool: SystemTool) -> None:
        """Add a new tool to the agent's capabilities"""
        self.tools.append(tool)
        self.tool_map[tool.name] = tool
    
    def _format_tools_for_openai(self) -> List[Dict[str, Any]]:
        """Format tools in OpenAI's function calling format"""
        formatted_tools = []
        
        for tool in self.tools:
            formatted_tools.append({
                "type": "function",
                "function": {
                    "name": tool.name,
                    "description": tool.description,
                    "parameters": {
                        "type": "object",
                        "properties": tool.parameters_schema,
                        "required": [
                            param for param, details in tool.parameters_schema.items() 
                            if details.get("required", False)
                        ]
                    }
                }
            })
        
        return formatted_tools
    
    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=1, max=10))
    def _call_llm(self, messages: List[Dict[str, str]]) -> Dict[str, Any]:
        """Call the OpenAI API with retry logic"""
        try:
            response = client.chat.completions.create(
                model=self.model,
                messages=messages,
                tools=self._format_tools_for_openai() if self.tools else None,
                tool_choice="auto"
            )
            return response
        except Exception as e:
            logger.error(f"Error calling OpenAI API: {str(e)}")
            raise
    
    def _execute_tool(self, tool_name: str, parameters: Dict[str, Any]) -> ActionResult:
        """Execute a tool and return the result"""
        if tool_name not in self.tool_map:
            return ActionResult(
                action_id=str(uuid.uuid4()),
                status=ActionStatus.FAILURE,
                error_message=f"Tool {tool_name} not found"
            )
        
        tool = self.tool_map[tool_name]
        action_id = str(uuid.uuid4())
        
        try:
            start_time = time.time()
            result = tool.execute(**parameters)
            execution_time = time.time() - start_time
            
            return ActionResult(
                action_id=action_id,
                status=ActionStatus.SUCCESS,
                result=result,
                execution_time=execution_time
            )
        except Exception as e:
            return ActionResult(
                action_id=action_id,
                status=ActionStatus.FAILURE,
                error_message=str(e)
            )
    
    def process_task(self, task: str) -> Dict[str, Any]:
        """Process a user task using the operator paradigm"""
        self.conversation_history.append({"role": "system", "content": self.system_message})
        self.conversation_history.append({"role": "user", "content": task})
        
        iterations = 0
        final_result = {"success": False, "message": "Maximum iterations reached", "actions": []}
        
        # Main agent loop
        while iterations < self.max_iterations:
            iterations += 1
            
            if self.verbose:
                logger.info(f"Iteration {iterations} of {self.max_iterations}")
            
            # Get agent response
            response = self._call_llm(self.conversation_history)
            response_message = response.choices[0].message
            
            # Add to conversation history
            self.conversation_history.append({
                "role": "assistant", 
                "content": response_message.content or ""
            })
            
            # Check if the response contains a tool call
            if response_message.tool_calls:
                for tool_call in response_message.tool_calls:
                    # Extract tool name and parameters
                    tool_name = tool_call.function.name
                    try:
                        parameters = json.loads(tool_call.function.arguments)
                    except json.JSONDecodeError:
                        parameters = {}
                    
                    if self.verbose:
                        logger.info(f"Executing tool: {tool_name}")
                        logger.info(f"Parameters: {json.dumps(parameters, indent=2)}")
                    
                    # Execute the tool
                    action_result = self._execute_tool(tool_name, parameters)
                    self.action_history.append(action_result)
                    
                    # Add the result to the conversation
                    result_content = (
                        json.dumps(action_result.result) 
                        if action_result.status == ActionStatus.SUCCESS 
                        else f"Error: {action_result.error_message}"
                    )
                    
                    self.conversation_history.append({
                        "role": "tool",
                        "tool_call_id": tool_call.id,
                        "content": result_content
                    })
                    
                    if self.verbose:
                        logger.info(f"Tool result: {result_content[:100]}...")
                    
                    # Add to the final result list
                    final_result["actions"].append({
                        "tool": tool_name,
                        "parameters": parameters,
                        "status": action_result.status,
                        "result": action_result.result if action_result.status == ActionStatus.SUCCESS else None,
                        "error": action_result.error_message if action_result.status == ActionStatus.FAILURE else None
                    })
            else:
                # No tool call means the agent is providing a final answer
                final_result["success"] = True
                final_result["message"] = response_message.content
                break
        
        return final_result
```

### System Tools Implementation

Now let's implement specific system tools that our operator agent can use:

```python
import os
import sys
import platform
import subprocess
import shutil
import psutil
import json
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
import logging
import httpx
import socket
from pathlib import Path

from .core import SystemTool

logger = logging.getLogger("system-tools")

# File System Tools
def list_directory(path: str = ".") -> Dict[str, Any]:
    """List contents of a directory"""
    try:
        path_obj = Path(path).resolve()
        if not path_obj.exists():
            return {"success": False, "error": f"Path {path} does not exist"}
        
        items = []
        for item in path_obj.iterdir():
            item_type = "directory" if item.is_dir() else "file"
            size = item.stat().st_size if item.is_file() else 0
            modified = datetime.fromtimestamp(item.stat().st_mtime).isoformat()
            items.append({
                "name": item.name,
                "type": item_type,
                "size": size,
                "modified": modified
            })
        
        return {
            "success": True,
            "path": str(path_obj),
            "items": sorted(items, key=lambda x: (x["type"] == "file", x["name"]))
        }
    except Exception as e:
        return {"success": False, "error": str(e)}

def read_file(filepath: str, max_size_kb: int = 100) -> Dict[str, Any]:
    """Read contents of a file with size limit"""
    try:
        path_obj = Path(filepath).resolve()
        
        # Security check to prevent directory traversal
        if not path_obj.exists():
            return {"success": False, "error": f"File {filepath} does not exist"}
        
        # Check file size
        size_kb = path_obj.stat().st_size / 1024
        if size_kb > max_size_kb:
            return {"success": False, "error": f"File exceeds maximum size of {max_size_kb} KB"}
        
        # Read file content
        content = path_obj.read_text(errors="replace")
        
        return {
            "success": True,
            "filepath": str(path_obj),
            "size_kb": size_kb,
            "content": content
        }
    except Exception as e:
        return {"success": False, "error": str(e)}

def write_file(filepath: str, content: str, mode: str = "w") -> Dict[str, Any]:
    """Write content to a file"""
    try:
        # Security checks and validations would be implemented here in a real system
        if mode not in ["w", "a"]:
            return {"success": False, "error": f"Invalid mode: {mode}. Use 'w' for write or 'a' for append."}
        
        path_obj = Path(filepath).resolve()
        
        # Create parent directories if they don't exist
        path_obj.parent.mkdir(parents=True, exist_ok=True)
        
        # Write content to file
        with open(path_obj, mode) as f:
            f.write(content)
        
        return {
            "success": True,
            "filepath": str(path_obj),
            "size": len(content),
            "mode": mode
        }
    except Exception as e:
        return {"success": False, "error": str(e)}

# System Information Tools
def get_system_info() -> Dict[str, Any]:
    """Get detailed system information"""
    try:
        info = {
            "platform": platform.platform(),
            "system": platform.system(),
            "node": platform.node(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "python_version": platform.python_version(),
            "hostname": socket.gethostname(),
            "ip_address": socket.gethostbyname(socket.gethostname())
        }
        
        # Add CPU information
        info["cpu"] = {
            "physical_cores": psutil.cpu_count(logical=False),
            "total_cores": psutil.cpu_count(logical=True),
            "max_frequency": psutil.cpu_freq().max if psutil.cpu_freq() else None,
            "current_frequency": psutil.cpu_freq().current if psutil.cpu_freq() else None,
            "usage_percent": psutil.cpu_percent(interval=0.1)
        }
        
        # Add memory information
        memory = psutil.virtual_memory()
        info["memory"] = {
            "total": memory.total,
            "available": memory.available,
            "used": memory.used,
            "percent": memory.percent
        }
        
        # Add disk information
        disk = psutil.disk_usage('/')
        info["disk"] = {
            "total": disk.total,
            "used": disk.used,
            "free": disk.free,
            "percent": disk.percent
        }
        
        return {"success": True, "info": info}
    except Exception as e:
        return {"success": False, "error": str(e)}

def get_running_processes(limit: int = 20) -> Dict[str, Any]:
    """Get list of running processes"""
    try:
        processes = []
        for proc in psutil.process_iter(['pid', 'name', 'username', 'memory_percent', 'cpu_percent', 'create_time']):
            try:
                # Convert create time to ISO format
                create_time = datetime.fromtimestamp(proc.info['create_time']).isoformat() if 'create_time' in proc.info else None
                
                processes.append({
                    "pid": proc.info['pid'],
                    "name": proc.info['name'],
                    "username": proc.info['username'],
                    "memory_percent": proc.info['memory_percent'],
                    "cpu_percent": proc.info['cpu_percent'],
                    "create_time": create_time
                })
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        
        # Sort by memory usage and limit results
        processes = sorted(processes, key=lambda x: x['memory_percent'], reverse=True)[:limit]
        
        return {"success": True, "processes": processes}
    except Exception as e:
        return {"success": False, "error": str(e)}

# Network Tools
async def http_request(url: str, method: str = "GET", headers: Optional[Dict[str, str]] = None, 
                     body: Optional[str] = None, timeout: int = 10) -> Dict[str, Any]:
    """Make HTTP request to specified URL"""
    try:
        headers = headers or {}
        
        async with httpx.AsyncClient(timeout=timeout) as client:
            if method == "GET":
                response = await client.get(url, headers=headers)
            elif method == "POST":
                response = await client.post(url, headers=headers, content=body)
            elif method == "PUT":
                response = await client.put(url, headers=headers, content=body)
            elif method == "DELETE":
                response = await client.delete(url, headers=headers)
            else:
                return {"success": False, "error": f"Unsupported method: {method}"}
            
            # Try to parse response as JSON
            try:
                response_json = response.json()
                content_type = "json"
            except json.JSONDecodeError:
                response_json = None
                content_type = "text"
            
            return {
                "success": True,
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "content_type": content_type,
                "content": response_json if response_json else response.text,
                "elapsed_ms": response.elapsed.total_seconds() * 1000
            }
    except Exception as e:
        return {"success": False, "error": str(e)}

def check_port(host: str, port: int, timeout: int = 5) -> Dict[str, Any]:
    """Check if a port is open on the specified host"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, port))
        is_open = result == 0
        sock.close()
        
        return {
            "success": True,
            "host": host,
            "port": port,
            "is_open": is_open,
            "status": "open" if is_open else "closed"
        }
    except Exception as e:
        return {"success": False, "error": str(e)}

# Create SystemTool instances
file_system_tools = [
    SystemTool(
        name="list_directory",
        description="List contents of a directory",
        parameters_schema={
            "path": {
                "type": "string",
                "description": "Path to the directory",
                "required": False
            }
        },
        function=list_directory
    ),
    SystemTool(
        name="read_file",
        description="Read contents of a file",
        parameters_schema={
            "filepath": {
                "type": "string",
                "description": "Path to the file",
                "required": True
            },
            "max_size_kb": {
                "type": "integer",
                "description": "Maximum file size in KB",
                "required": False
            }
        },
        function=read_file
    ),
    SystemTool(
        name="write_file",
        description="Write content to a file",
        parameters_schema={
            "filepath": {
                "type": "string",
                "description": "Path to the file",
                "required": True
            },
            "content": {
                "type": "string",
                "description": "Content to write",
                "required": True
            },
            "mode": {
                "type": "string",
                "description": "Write mode: 'w' for write, 'a' for append",
                "enum": ["w", "a"],
                "required": False
            }
        },
        function=write_file
    )
]

system_info_tools = [
    SystemTool(
        name="get_system_info",
        description="Get detailed system information",
        parameters_schema={},
        function=get_system_info
    ),
    SystemTool(
        name="get_running_processes",
        description="Get list of running processes",
        parameters_schema={
            "limit": {
                "type": "integer",
                "description": "Maximum number of processes to return",
                "required": False
            }
        },
        function=get_running_processes
    )
]

# Combine all tools
all_tools = file_system_tools + system_info_tools
```

### Main Application Entry Point

Let's create an entry point for our application:

```python
import os
import click
import asyncio
import json
from typing import List, Optional
from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel
from rich.syntax import Syntax

from .core import OperatorAgent
from .system_tools import all_tools, http_request, check_port

console = Console()

def display_result(result: dict):
    """Display the result in a rich formatted manner"""
    if result.get("success", False):
        console.print(Panel(
            Markdown(f"# Success \n\n{result.get('message', 'Task completed successfully')}"),
            title="Task Result",
            border_style="green"
        ))
    else:
        console.print(Panel(
            Markdown(f"# Failure \n\n{result.get('message', 'Task failed')}"),
            title="Task Result",
            border_style="red"
        ))
    
    # Display actions taken
    if "actions" in result and result["actions"]:
        console.print("\n[bold]Actions Performed:[/bold]")
        for i, action in enumerate(result["actions"]):
            status_color = "green" if action.get("status") == "success" else "red"
            console.print(f"[{i+1}] [bold]{action['tool']}[/bold]")
            console.print(f"   Parameters: {json.dumps(action['parameters'], indent=2)}")
            console.print(f"   Status: [{status_color}]{action.get('status', 'unknown')}[/{status_color}]")
            
            if action.get("result"):
                result_text = json.dumps(action["result"], indent=2)
                console.print("   Result:")
                console.print(Syntax(result_text, "json", theme="monokai", line_numbers=True))
            
            if action.get("error"):
                console.print(f"   Error: [red]{action['error']}[/red]")
            
            console.print("")

@click.group()
def cli():
    """OpenAI Operator-Style Agent CLI"""
    pass

@cli.command()
@click.argument("task", required=True)
@click.option("--model", default="gpt-4-turbo", help="OpenAI model to use")
@click.option("--iterations", default=10, help="Maximum number of iterations")
@click.option("--verbose", is_flag=True, help="Enable verbose output")
def run(task: str, model: str, iterations: int, verbose: bool):
    """Run a task using the Operator agent"""
    # Create the agent with all tools
    agent = OperatorAgent(
        model=model,
        tools=all_tools,
        max_iterations=iterations,
        verbose=verbose
    )
    
    # Add network tools (converted to sync for simplicity)
    async def async_http_wrapper(*args, **kwargs):
        return await http_request(*args, **kwargs)
    
    # Custom sync wrapper for the async function
    def sync_http_request(*args, **kwargs):
        return asyncio.run(async_http_wrapper(*args, **kwargs))
    
    agent.add_tool(
        SystemTool(
            name="http_request",
            description="Make HTTP request to specified URL",
            parameters_schema={
                "url": {
                    "type": "string",
                    "description": "URL to request",
                    "required": True
                },
                "method": {
                    "type": "string",
                    "description": "HTTP method",
                    "enum": ["GET", "POST", "PUT", "DELETE"],
                    "required": False
                },
                "headers": {
                    "type": "object",
                    "description": "HTTP headers",
                    "required": False
                },
                "body": {
                    "type": "string",
                    "description": "Request body",
                    "required": False
                },
                "timeout": {
                    "type": "integer",
                    "description": "Request timeout in seconds",
                    "required": False
                }
            },
            function=sync_http_request
        )
    )
    
    agent.add_tool(
        SystemTool(
            name="check_port",
            description="Check if a port is open on the specified host",
            parameters_schema={
                "host": {
                    "type": "string",
                    "description": "Host to check",
                    "required": True
                },
                "port": {
                    "type": "integer",
                    "description": "Port to check",
                    "required": True
                },
                "timeout": {
                    "type": "integer",
                    "description": "Timeout in seconds",
                    "required": False
                }
            },
            function=check_port
        )
    )
    
    # Display task information
    console.print(Panel(f"[bold]{task}[/bold]", title="Task", border_style="blue"))
    console.print(f"Using model: [bold]{model}[/bold]")
    console.print(f"Maximum iterations: [bold]{iterations}[/bold]")
    
    with console.status("[bold green]Processing task..."):
        result = agent.process_task(task)
    
    display_result(result)

if __name__ == "__main__":
    cli()
```

## Advanced System Control with Safety Measures

Let's extend our agent with safety measures and advanced system control capabilities:

```python
import os
import json
import time
import logging
from typing import Dict, Any, List, Optional, Callable, Set
import re
from functools import wraps

logger = logging.getLogger("safety")

class OperatorSafety:
    """Safety mechanisms for the Operator agent"""
    
    def __init__(self):
        """Initialize safety measures"""
        self.blocked_paths = set([
            "/etc", "/var/log", "/var/run", "/var/lock", 
            "/proc", "/sys", "/boot", "/root", "/home"
        ])
        
        # Add Windows system paths if on Windows
        if os.name == "nt":
            self.blocked_paths.update([
                "C:\\Windows", "C:\\Program Files", "C:\\Program Files (x86)",
                "C:\\Users\\Administrator", "C:\\ProgramData"
            ])
        
        self.allowed_file_extensions = set([
            ".txt", ".md", ".json", ".csv", ".yaml", ".yml", 
            ".log", ".py", ".js", ".html", ".css"
        ])
        
        self.blocked_commands = set([
            "rm", "rmdir", "del", "format", "mkfs", "dd",
            "shutdown", "reboot", "halt", "poweroff",
            "passwd", "chmod", "chown", "chgrp"
        ])
        
        self.rate_limits = {
            "file_writes": {"count": 0, "max": 10, "period": 60, "last_reset": time.time()},
            "http_requests": {"count": 0, "max": 20, "period": 60, "last_reset": time.time()},
            "system_commands": {"count": 0, "max": 5, "period": 60, "last_reset": time.time()}
        }
    
    def check_path_safety(self, path: str) -> bool:
        """Check if a file path is safe to access"""
        path = os.path.abspath(path)
        
        # Check against blocked paths
        for blocked in self.blocked_paths:
            if path.startswith(blocked):
                logger.warning(f"Attempted access to blocked path: {path}")
                return False
        
        return True
    
    def check_file_extension(self, filepath: str) -> bool:
        """Check if a file extension is allowed"""
        _, ext = os.path.splitext(filepath)
        
        if ext.lower() not in self.allowed_file_extensions:
            logger.warning(f"Attempted access to file with blocked extension: {ext}")
            return False
        
        return True
    
    def check_command_safety(self, command: str) -> bool:
        """Check if a shell command is safe to execute"""
        # Split command by spaces and check the first part
        cmd_parts = command.split()
        if not cmd_parts:
            return False
        
        base_cmd = cmd_parts[0].lower()
        
        # Check against blocked commands
        if base_cmd in self.blocked_commands:
            logger.warning(f"Attempted execution of blocked command: {base_cmd}")
            return False
        
        # Check for attempts to chain commands
        if any(char in command for char in ["&&", "||", ";", "|"]):
            logger.warning(f"Attempted command chaining detected: {command}")
            return False
        
        return True
    
    def check_rate_limit(self, action_type: str) -> bool:
        """Check if an action has exceeded its rate limit"""
        if action_type not in self.rate_limits:
            return True
        
        limit = self.rate_limits[action_type]
        current_time = time.time()
        
        # Reset counter if period has passed
        if current_time - limit["last_reset"] > limit["period"]:
            limit["count"] = 0
            limit["last_reset"] = current_time
        
        # Check if limit exceeded
        if limit["count"] >= limit["max"]:
            logger.warning(f"Rate limit exceeded for {action_type}")
            return False
        
        # Increment counter
        limit["count"] += 1
        return True
    
    def safe_file_operation(self, func: Callable) -> Callable:
        """Decorator for safe file operations"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Extract filepath from args or kwargs
            filepath = kwargs.get("filepath") or kwargs.get("path")
            if not filepath and len(args) > 0:
                filepath = args[0]
            
            if not filepath or not isinstance(filepath, str):
                return {"success": False, "error": "Invalid filepath"}
            
            # Check path safety
            if not self.check_path_safety(filepath):
                return {"success": False, "error": "Access to this path is not allowed"}
            
            # For write operations, check extension and rate limit
            if func.__name__ in ["write_file"]:
                if not self.check_file_extension(filepath):
                    return {"success": False, "error": "File extension not allowed"}
                
                if not self.check_rate_limit("file_writes"):
                    return {"success": False, "error": "Rate limit exceeded for file writes"}
            
            # Execute the function
            return func(*args, **kwargs)
        return wrapper
    
    def safe_command_execution(self, func: Callable) -> Callable:
        """Decorator for safe command execution"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Extract command from args or kwargs
            command = kwargs.get("command") or kwargs.get("cmd")
            if not command and len(args) > 0:
                command = args[0]
            
            if not command or not isinstance(command, str):
                return {"success": False, "error": "Invalid command"}
            
            # Check command safety
            if not self.check_command_safety(command):
                return {"success": False, "error": "This command is not allowed"}
            
            # Check rate limit
            if not self.check_rate_limit("system_commands"):
                return {"success": False, "error": "Rate limit exceeded for system commands"}
            
            # Execute the function
            return func(*args, **kwargs)
        return wrapper
    
    def safe_http_request(self, func: Callable) -> Callable:
        """Decorator for safe HTTP requests"""
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Check rate limit
            if not self.check_rate_limit("http_requests"):
                return {"success": False, "error": "Rate limit exceeded for HTTP requests"}
            
            # Extract URL from args or kwargs
            url = kwargs.get("url")
            if not url and len(args) > 0:
                url = args[0]
            
            # Check if URL is private IP or localhost
            if url and isinstance(url, str):
                if re.search(r"(localhost|127\.0\.0\.1|::1|0\.0\.0\.0)", url):
                    return {"success": False, "error": "Access to localhost is not allowed"}
                
                # Check for private IP ranges
                private_ip_patterns = [
                    r"^https?://10\.", r"^https?://172\.(1[6-9]|2[0-9]|3[0-1])\.",
                    r"^https?://192\.168\.", r"^https?://169\.254\."
                ]
                
                if any(re.search(pattern, url) for pattern in private_ip_patterns):
                    return {"success": False, "error": "Access to private IP addresses is not allowed"}
            
            # Execute the function
            return await func(*args, **kwargs)
        return wrapper
```

## Practical Application: Creating a System Monitor Agent

Let's implement a practical application using our operator pattern - a system monitoring agent:

```python
import os
import time
import json
import asyncio
import click
from rich.console import Console
from rich.panel import Panel
from rich.live import Live
from rich.table import Table
from rich.markdown import Markdown
from rich import box
import logging

from .core import OperatorAgent
from .system_tools import get_system_info, get_running_processes
from .safety import OperatorSafety

console = Console()
safety = OperatorSafety()

class SystemMonitorAgent:
    """Agent that monitors system health and responds to issues"""
    
    def __init__(self, model: str = "gpt-4", check_interval: int = 60):
        """Initialize the monitor agent"""
        self.model = model
        self.check_interval = check_interval
        self.agent = self._create_agent()
        self.monitoring = False
        self.history = []
        self.alerts = []
    
    def _create_agent(self):
        """Create and configure the operator agent"""
        system_message = """
        You are a System Monitoring Agent responsible for:
        1. Analyzing system metrics and identifying potential issues
        2. Alerting about critical conditions (high CPU usage, low disk space, etc.)
        3. Suggesting remedial actions for detected problems
        4. Maintaining system health logs
        
        Be vigilant, proactive, and provide clear explanations of any issues you find.
        Always consider the severity of problems and prioritize them accordingly.
        """
        
        agent = OperatorAgent(
            model=self.model,
            system_message=system_message,
            verbose=True
        )
        
        # Add monitoring tools
        agent.add_tool(
            SystemTool(
                name="get_system_info",
                description="Get detailed system information",
                parameters_schema={},
                function=get_system_info
            )
        )
        
        agent.add_tool(
            SystemTool(
                name="get_running_processes",
                description="Get list of running processes",
                parameters_schema={
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of processes to return",
                        "required": False
                    }
                },
                function=get_running_processes
            )
        )
        
        @safety.safe_file_operation
        def log_system_event(event_type: str, description: str, severity: str = "info"):
            """Log a system event to a file"""
            try:
                log_entry = {
                    "timestamp": time.time(),
                    "event_type": event_type,
                    "description": description,
                    "severity": severity
                }
                
                log_dir = "system_logs"
                os.makedirs(log_dir, exist_ok=True)
                
                log_file = os.path.join(log_dir, f"system_events_{time.strftime('%Y-%m-%d')}.log")
                
                with open(log_file, "a") as f:
                    f.write(json.dumps(log_entry) + "\n")
                
                return {
                    "success": True, 
                    "file": log_file, 
                    "entry": log_entry
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        agent.add_tool(
            SystemTool(
                name="log_system_event",
                description="Log a system event to the monitoring logs",
                parameters_schema={
                    "event_type": {
                        "type": "string",
                        "description": "Type of event (e.g., 'alert', 'info', 'warning')",
                        "required": True
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the event",
                        "required": True
                    },
                    "severity": {
                        "type": "string",
                        "description": "Severity of the event",
                        "enum": ["info", "warning", "critical"],
                        "required": False
                    }
                },
                function=log_system_event
            )
        )
        
        return agent
    
    async def monitor_once(self) -> Dict[str, Any]:
        """Run a single monitoring check"""
        prompt = """
        Perform a system health check based on current metrics.
        Identify any issues or anomalies, and suggest remedial actions if needed.
        If everything looks normal, simply confirm that the system is healthy.
        Be sure to log your findings appropriately.
        """
        
        result = self.agent.process_task(prompt)
        
        # Store the check result in history
        self.history.append({
            "timestamp": time.time(),
            "result": result
        })
        
        # Check for alerts in the actions
        for action in result.get("actions", []):
            if action.get("tool") == "log_system_event" and action.get("parameters", {}).get("severity") in ["warning", "critical"]:
                self.alerts.append({
                    "timestamp": time.time(),
                    "event_type": action.get("parameters", {}).get("event_type"),
                    "description": action.get("parameters", {}).get("description"),
                    "severity": action.get("parameters", {}).get("severity")
                })
        
        return result
    
    async def start_monitoring(self):
        """Start continuous monitoring"""
        self.monitoring = True
        console.print(Panel("[green]System monitoring started[/green]", title="Monitor Agent"))
        
        try:
            while self.monitoring:
                with console.status("[bold green]Performing system health check..."):
                    result = await self.monitor_once()
                
                # Display results
                self._display_monitoring_status()
                
                # Wait for next check
                await asyncio.sleep(self.check_interval)
                
        except KeyboardInterrupt:
            self.monitoring = False
            console.print("[yellow]Monitoring stopped by user[/yellow]")
    
    def _display_monitoring_status(self):
        """Display current monitoring status"""
        # Create a table for system info
        system_info = get_system_info()
        if system_info.get("success"):
            info = system_info.get("info", {})
            
            system_table = Table(title="System Status", box=box.ROUNDED)
            system_table.add_column("Metric", style="cyan")
            system_table.add_column("Value", style="green")
            
            system_table.add_row("Platform", info.get("platform", "Unknown"))
            system_table.add_row("CPU Usage", f"{info.get('cpu', {}).get('usage_percent', 0)}%")
            system_table.add_row("Memory Usage", f"{info.get('memory', {}).get('percent', 0)}%")
            system_table.add_row("Disk Usage", f"{info.get('disk', {}).get('percent', 0)}%")
            
            console.print(system_table)
        
        # Display recent alerts
        if self.alerts:
            alerts_table = Table(title="Recent Alerts", box=box.ROUNDED)
            alerts_table.add_column("Time", style="cyan")
            alerts_table.add_column("Type", style="yellow")
            alerts_table.add_column("Severity", style="red")
            alerts_table.add_column("Description")
            
            # Show last 5 alerts
            for alert in self.alerts[-5:]:
                time_str = time.strftime("%H:%M:%S", time.localtime(alert.get("timestamp")))
                severity = alert.get("severity", "info")
                severity_style = "red" if severity == "critical" else "yellow"
                
                alerts_table.add_row(
                    time_str,
                    alert.get("event_type", "Unknown"),
                    f"[{severity_style}]{severity}[/{severity_style}]",
                    alert.get("description", "")
                )
            
            console.print(alerts_table)
        
        # Display agent's analysis
        if self.history:
            latest = self.history[-1]
            result = latest.get("result", {})
            
            if result.get("message"):
                console.print(Panel(
                    Markdown(result.get("message")),
                    title="Agent Analysis",
                    border_style="blue"
                ))

@click.command()
@click.option("--model", default="gpt-4", help="OpenAI model to use")
@click.option("--interval", default=60, help="Check interval in seconds")
def run_monitor(model: str, interval: int):
    """Run the system monitoring agent"""
    monitor = SystemMonitorAgent(model=model, check_interval=interval)
    
    try:
        asyncio.run(monitor.start_monitoring())
    except KeyboardInterrupt:
        console.print("[yellow]Monitoring stopped[/yellow]")

if __name__ == "__main__":
    run_monitor()
```

## Conclusion

The OpenAI Operator pattern represents a powerful approach to building system-controlling AI agents. By creating a structured interface between LLMs and system tools, we can develop agents that effectively operate complex systems while maintaining appropriate safety guardrails.

Key aspects of this approach include:

1. **Tool-Based Architecture**: Breaking down system operations into discrete, well-defined tools with clear input/output contracts.

2. **Stateful Interactions**: Maintaining conversation and action history to provide context for decision-making.

3. **Safety Mechanisms**: Implementing rate limiting, path restrictions, command filtering, and other safety measures to prevent harmful actions.

4. **Autonomous Decision-Making**: Empowering the agent to determine the appropriate sequence of actions based on the task and system state.

5. **Feedback Integration**: Incorporating results from previous actions into the agent's decision-making process.

Building effective operator agents requires balancing autonomy with safety, capability with constraints. The implementation demonstrated here provides a foundation that can be extended to control various systems - from local computing environments to cloud infrastructure, software applications, or even physical devices through appropriate APIs.

As these technologies evolve, we can expect operator-style agents to become increasingly sophisticated, handling complex workflows across multiple systems while maintaining appropriate guardrails. The key to successful implementation lies in thoughtful tool design, comprehensive testing, and continuous monitoring - ensuring that these powerful agents remain helpful, harmless, and honest in their operation.