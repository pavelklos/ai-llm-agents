<small>Claude 3.7 Sonnet Thinking</small>
# 07. Code Integration in GPT Assistant Responses

## Key Terms

- **Code Interpreter**: A capability that allows LLMs to write and execute code to solve problems, manipulate data, or perform calculations
- **Sandboxing**: The isolation of executing code in a controlled environment to prevent security vulnerabilities
- **Jupyter Notebook**: An interactive computing environment that enables the mixing of code execution, rich text, and visualizations
- **OpenAI API Function Calling**: A feature that allows models to generate structured JSON to invoke specific functions
- **Input Validation**: The process of verifying that inputs to code are correct and safe before execution
- **AST (Abstract Syntax Tree)**: A tree representation of code structure used for analysis and transformation
- **Serialization/Deserialization**: Converting complex data structures to and from string formats for transmission
- **Output Rendering**: Converting computational results into human-readable formats (text, tables, etc.)
- **Ephemeral Execution**: Short-lived code execution that produces results but doesn't persist beyond the conversation
- **Computational Thinking**: Problem-solving approach that involves decomposition, pattern recognition, abstraction, and algorithms

## Incorporating Code into Assistant Responses

Modern AI assistants can extend their capabilities beyond text generation by incorporating executable code into their responses. This allows them to perform dynamic calculations, data manipulations, and visualizations directly within the conversation flow. There are several approaches to implementing this functionality:

### 1. Server-Side Code Execution

The most robust approach involves executing code on the server side within a secure sandbox environment. This implementation requires building a custom backend that can:

1. Extract code blocks from assistant responses
2. Execute them in an isolated environment
3. Capture outputs and error messages
4. Return the results to be incorporated into the conversation

Let's implement a comprehensive server-side code execution system:

```python
import os
import sys
import ast
import json
import base64
import traceback
import subprocess
import tempfile
from typing import Dict, List, Any, Optional, Union, Tuple
from enum import Enum
import uuid
import io
import contextlib
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("CodeExecutor")

class CodeLanguage(str, Enum):
    """Supported programming languages."""
    PYTHON = "python"
    JAVASCRIPT = "javascript"
    R = "r"
    SQL = "sql"
    SHELL = "shell"

class ExecutionResult:
    """Container for code execution results."""
    
    def __init__(
        self,
        success: bool,
        output: str,
        error: Optional[str] = None,
        execution_time: float = 0.0,
        artifacts: Optional[List[Dict[str, Any]]] = None
    ):
        """
        Initialize execution result.
        
        Args:
            success: Whether execution was successful
            output: Stdout from execution
            error: Stderr from execution (if any)
            execution_time: Time taken to execute (seconds)
            artifacts: Generated files or objects (e.g., images)
        """
        self.success = success
        self.output = output
        self.error = error
        self.execution_time = execution_time
        self.artifacts = artifacts or []
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "success": self.success,
            "output": self.output,
            "error": self.error,
            "execution_time": self.execution_time,
            "artifacts": self.artifacts
        }
    
    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict())
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ExecutionResult':
        """Create from dictionary."""
        return cls(
            success=data["success"],
            output=data["output"],
            error=data.get("error"),
            execution_time=data.get("execution_time", 0.0),
            artifacts=data.get("artifacts", [])
        )

class CodeValidator:
    """Validates and sanitizes code before execution."""
    
    # List of potentially dangerous modules
    DANGEROUS_MODULES = {
        "os", "subprocess", "shutil", "sys", "socket", "requests",
        "urllib", "ftplib", "telnetlib", "smtplib"
    }
    
    # List of dangerous function names
    DANGEROUS_FUNCTIONS = {
        "eval", "exec", "compile", "__import__", "open", "file",
        "input", "raw_input", "system", "popen", "execfile"
    }
    
    @classmethod
    def validate_python_code(cls, code: str) -> Tuple[bool, Optional[str]]:
        """
        Validate Python code for potential security issues.
        
        Args:
            code: Python code to validate
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        # Check if code is parseable
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return False, f"Syntax error: {str(e)}"
        
        # Check for dangerous imports
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for name in node.names:
                    if name.name.split('.')[0] in cls.DANGEROUS_MODULES:
                        return False, f"Import of module '{name.name}' is not allowed"
            
            elif isinstance(node, ast.ImportFrom):
                if node.module and node.module.split('.')[0] in cls.DANGEROUS_MODULES:
                    return False, f"Import from module '{node.module}' is not allowed"
            
            # Check for dangerous function calls
            elif isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name) and node.func.id in cls.DANGEROUS_FUNCTIONS:
                    return False, f"Use of function '{node.func.id}' is not allowed"
        
        return True, None
    
    @classmethod
    def sanitize_code(cls, code: str, language: CodeLanguage) -> Tuple[str, List[str]]:
        """
        Sanitize code for safe execution.
        
        Args:
            code: Code to sanitize
            language: Programming language
            
        Returns:
            Tuple of (sanitized_code, warnings)
        """
        warnings = []
        
        if language == CodeLanguage.PYTHON:
            # Add proper indentation if needed
            lines = code.split("\n")
            if any(line.startswith("def ") or line.startswith("class ") for line in lines):
                # Ensure the code has a newline at the end
                if not code.endswith("\n"):
                    code += "\n"
            
            # Limit execution time using a context manager
            code = (
                "import signal\n"
                "class TimeoutException(Exception): pass\n"
                "def timeout_handler(signum, frame):\n"
                "    raise TimeoutException('Code execution timed out')\n"
                "signal.signal(signal.SIGALRM, timeout_handler)\n"
                "signal.alarm(10)  # Timeout after 10 seconds\n"
                "try:\n" +
                "\n".join(f"    {line}" for line in code.split("\n")) +
                "\nexcept TimeoutException as e:\n"
                "    print(str(e))\n"
                "finally:\n"
                "    signal.alarm(0)\n"
            )
            
            warnings.append("Added execution timeout of 10 seconds.")
        
        return code, warnings

class CodeExecutor:
    """Executes code in a sandboxed environment."""
    
    def __init__(self, workspace_dir: Optional[str] = None):
        """
        Initialize code executor.
        
        Args:
            workspace_dir: Directory for storing temporary files
        """
        self.workspace_dir = workspace_dir or os.path.join(tempfile.gettempdir(), "code_executor")
        os.makedirs(self.workspace_dir, exist_ok=True)
        logger.info(f"Initialized CodeExecutor with workspace at {self.workspace_dir}")
    
    def execute_python(self, code: str, timeout: int = 10) -> ExecutionResult:
        """
        Execute Python code in a sandboxed environment.
        
        Args:
            code: Python code to execute
            timeout: Maximum execution time in seconds
            
        Returns:
            Execution result
        """
        start_time = datetime.now()
        
        # Validate the code
        is_valid, error_message = CodeValidator.validate_python_code(code)
        if not is_valid:
            return ExecutionResult(
                success=False,
                output="",
                error=f"Validation error: {error_message}",
                execution_time=0.0
            )
        
        # Sanitize the code
        sanitized_code, warnings = CodeValidator.sanitize_code(code, CodeLanguage.PYTHON)
        
        # Create a unique ID for this execution
        execution_id = str(uuid.uuid4())
        
        # Create a temporary file
        file_path = os.path.join(self.workspace_dir, f"{execution_id}.py")
        with open(file_path, "w") as f:
            f.write(sanitized_code)
        
        # Redirect stdout and stderr
        stdout_file = os.path.join(self.workspace_dir, f"{execution_id}_stdout.txt")
        stderr_file = os.path.join(self.workspace_dir, f"{execution_id}_stderr.txt")
        
        # Command to execute
        cmd = [sys.executable, file_path]
        
        try:
            # Execute the code
            process = subprocess.Popen(
                cmd,
                stdout=open(stdout_file, "w"),
                stderr=open(stderr_file, "w"),
                cwd=self.workspace_dir
            )
            
            # Wait for the process to complete with timeout
            try:
                process.wait(timeout=timeout)
            except subprocess.TimeoutExpired:
                process.kill()
                return ExecutionResult(
                    success=False,
                    output="",
                    error=f"Execution timed out after {timeout} seconds",
                    execution_time=timeout
                )
            
            # Read stdout and stderr
            with open(stdout_file, "r") as f:
                stdout = f.read()
            
            with open(stderr_file, "r") as f:
                stderr = f.read()
            
            # Delete temporary files
            for file in [file_path, stdout_file, stderr_file]:
                try:
                    os.remove(file)
                except:
                    pass
            
            # Calculate execution time
            execution_time = (datetime.now() - start_time).total_seconds()
            
            if process.returncode == 0:
                return ExecutionResult(
                    success=True,
                    output=stdout,
                    error=stderr if stderr else None,
                    execution_time=execution_time
                )
            else:
                return ExecutionResult(
                    success=False,
                    output=stdout,
                    error=stderr if stderr else "Unknown error",
                    execution_time=execution_time
                )
                
        except Exception as e:
            logger.error(f"Error executing code: {str(e)}")
            return ExecutionResult(
                success=False,
                output="",
                error=f"Execution error: {str(e)}",
                execution_time=(datetime.now() - start_time).total_seconds()
            )
    
    def execute_code_in_memory(self, code: str) -> ExecutionResult:
        """
        Execute Python code in memory using StringIO for capturing output.
        
        Args:
            code: Python code to execute
            
        Returns:
            Execution result
        """
        start_time = datetime.now()
        
        # Validate the code
        is_valid, error_message = CodeValidator.validate_python_code(code)
        if not is_valid:
            return ExecutionResult(
                success=False,
                output="",
                error=f"Validation error: {error_message}",
                execution_time=0.0
            )
        
        # Create string buffers for stdout and stderr
        stdout_buffer = io.StringIO()
        stderr_buffer = io.StringIO()
        
        # Redirect stdout and stderr
        with contextlib.redirect_stdout(stdout_buffer), contextlib.redirect_stderr(stderr_buffer):
            try:
                # Execute the code
                exec(code, {"__builtins__": __builtins__}, {})
                success = True
                error = None
            except Exception as e:
                success = False
                error = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
        
        # Get output and error
        output = stdout_buffer.getvalue()
        stderr = stderr_buffer.getvalue()
        
        # Calculate execution time
        execution_time = (datetime.now() - start_time).total_seconds()
        
        return ExecutionResult(
            success=success,
            output=output,
            error=error or stderr if stderr else None,
            execution_time=execution_time
        )

    def execute(self, code: str, language: CodeLanguage, use_subprocess: bool = True) -> ExecutionResult:
        """
        Execute code in the specified language.
        
        Args:
            code: Code to execute
            language: Programming language
            use_subprocess: Whether to use subprocess for execution
            
        Returns:
            Execution result
        """
        if language == CodeLanguage.PYTHON:
            if use_subprocess:
                return self.execute_python(code)
            else:
                return self.execute_code_in_memory(code)
        else:
            return ExecutionResult(
                success=False,
                output="",
                error=f"Language {language} is not supported yet",
                execution_time=0.0
            )
```

### 2. Integrating with Assistant APIs

Now that we have a code execution engine, let's integrate it with a GPT assistant to enable code execution within conversation:

```python
import os
import re
import json
from typing import Dict, List, Any, Optional, Union, Callable
from dotenv import load_dotenv
from openai import OpenAI
from code_execution.executor import CodeExecutor, CodeLanguage, ExecutionResult
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("CodeAssistant")

# Load environment variables
load_dotenv()

class CodeAssistant:
    """Assistant with code execution capabilities."""
    
    def __init__(self, model: str = "gpt-4o"):
        """
        Initialize the code-capable assistant.
        
        Args:
            model: OpenAI model to use
        """
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        self.model = model
        self.executor = CodeExecutor()
        self.conversation_history = []
        self.code_pattern = re.compile(r"```(\w+)\n(.*?)\n```", re.DOTALL)
        self.system_prompt = """
        You are a helpful coding assistant that can write and execute Python code to solve problems.
        When code execution is needed, write valid Python code inside triple backticks with the language specified. Example:
        ```python
        print("Hello, world!")
        ```
        
        Your code should be well-commented, error-handled, and efficient.
        For data analysis and visualization tasks, use libraries like pandas, numpy, and matplotlib.
        After providing code, explain the approach and what the code does.
        
        Avoid using libraries that might not be available in the execution environment.
        Stick to these libraries: math, random, datetime, json, collections, itertools, statistics,
        numpy, pandas, matplotlib, seaborn, sklearn.
        
        If the user asks you to perform operations that require sensitive access (filesystem, network, etc.),
        explain why you cannot do that and suggest alternative approaches.
        """
    
    def _prepare_messages(self, new_message: str) -> List[Dict[str, Any]]:
        """Prepare messages for the API call."""
        if not self.conversation_history:
            # Start with system message if it's a new conversation
            messages = [
                {"role": "system", "content": self.system_prompt}
            ]
        else:
            messages = self.conversation_history.copy()
        
        # Add the new user message
        messages.append({"role": "user", "content": new_message})
        
        return messages
    
    def _extract_and_execute_code(self, message: str) -> str:
        """
        Extract and execute code blocks from a message.
        
        Args:
            message: Assistant message containing code blocks
            
        Returns:
            Message with execution results added
        """
        # Find all code blocks
        matches = self.code_pattern.finditer(message)
        result = message
        offset = 0  # Track position changes as we modify the string
        
        for match in matches:
            lang_match, code_match = match.groups()
            language = lang_match.lower()
            code = code_match
            
            # Only execute Python code
            if language == "python" or language == "py":
                try:
                    # Execute the code
                    execution_result = self.executor.execute(
                        code,
                        CodeLanguage.PYTHON,
                        use_subprocess=True
                    )
                    
                    # Format the result
                    if execution_result.success:
                        output = execution_result.output.strip()
                        # Insert the execution results after the code block
                        insertion = f"\n\n**Execution Result:**\n```\n{output}\n```"
                    else:
                        error = execution_result.error or "Unknown error"
                        # Insert the error after the code block
                        insertion = f"\n\n**Execution Error:**\n```\n{error}\n```"
                    
                    # Calculate the start and end positions of the whole code block
                    start = match.start() + offset
                    end = match.end() + offset
                    
                    # Insert the result after the code block
                    result = result[:end] + insertion + result[end:]
                    
                    # Update the offset
                    offset += len(insertion)
                    
                except Exception as e:
                    logger.error(f"Error executing code: {str(e)}")
                    # Insert error message
                    insertion = f"\n\n**System Error:**\n```\n{str(e)}\n```"
                    
                    # Calculate positions
                    start = match.start() + offset
                    end = match.end() + offset
                    
                    # Insert the error after the code block
                    result = result[:end] + insertion + result[end:]
                    
                    # Update the offset
                    offset += len(insertion)
        
        return result
    
    def ask(self, message: str, execute_code: bool = True) -> str:
        """
        Send a message to the assistant and get the response.
        
        Args:
            message: User message
            execute_code: Whether to execute code in the response
            
        Returns:
            Assistant response with optional code execution results
        """
        try:
            # Prepare messages
            messages = self._prepare_messages(message)
            
            # Send to OpenAI
            response = self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=2048
            )
            
            # Get the response content
            assistant_message = response.choices[0].message.content
            
            # Execute code if requested
            if execute_code:
                assistant_message = self._extract_and_execute_code(assistant_message)
            
            # Update conversation history
            self.conversation_history = messages + [{"role": "assistant", "content": assistant_message}]
            
            return assistant_message
        
        except Exception as e:
            logger.error(f"Error in ask method: {str(e)}")
            return f"I encountered an error: {str(e)}"
    
    def reset_conversation(self) -> None:
        """Reset the conversation history."""
        self.conversation_history = []
```

## Benefits of Computational Capabilities Within Chat

Integrating code execution into AI assistants offers several key advantages:

1. **Dynamic Problem Solving**: Instead of providing static answers, assistants can generate and execute code to solve problems dynamically, adapting to different inputs and requirements.

2. **Data Processing and Analysis**: Assistants can manipulate, analyze, and visualize data directly within the conversation, enabling interactive data exploration.

3. **Interactive Learning**: Users can learn programming concepts by seeing code examples executed in real-time, with immediate feedback and results.

4. **Complex Calculations**: Assistants can perform mathematical operations beyond simple arithmetic, including statistical analysis, financial calculations, or scientific computations.

5. **Custom Automation**: Users can collaborate with the assistant to build small automation scripts or utility functions for specific tasks.

Let's create a more specialized implementation focused on data analysis:

```python
# filepath: code_execution/data_analyst_assistant.py
import os
import re
import json
import base64
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from io import StringIO, BytesIO
from typing import Dict, List, Any, Optional, Union
from dotenv import load_dotenv
from openai import OpenAI
from code_execution.executor import CodeExecutor, CodeLanguage, ExecutionResult
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("DataAnalystAssistant")

# Load environment variables
load_dotenv()

class DataAnalystAssistant:
    """Assistant specialized in data analysis with code execution capabilities."""
    
    def __init__(self, model: str = "gpt-4o"):
        """
        Initialize the data analysis assistant.
        
        Args:
            model: OpenAI model to use
        """
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        self.model = model
        self.executor = CodeExecutor()
        self.conversation_history = []
        self.datasets = {}  # Store dataset references
        
        self.system_prompt = """
        You are a data analyst assistant with Python coding capabilities. You can:
        
        1. Analyze data using pandas, numpy, and other libraries
        2. Create visualizations with matplotlib and seaborn
        3. Perform statistical analysis
        4. Clean and transform datasets
        5. Generate insights and recommendations
        
        When writing code:
        - Include clear comments explaining your approach
        - Use efficient pandas operations
        - Handle errors and edge cases
        - Format visualizations for readability
        - Explain your results after the code execution
        
        For visualizations, use matplotlib with this style to ensure readability:
        ```python
        plt.figure(figsize=(10, 6))
        plt.style.use('ggplot')
        # Your visualization code
        plt.tight_layout()
        ```
        
        When the code generates a visualization, the image will be displayed directly in the conversation.
        """
    
    def _prepare_messages(self, new_message: str) -> List[Dict[str, Any]]:
        """Prepare messages for the API call."""
        if not self.conversation_history:
            # Start with system message if it's a new conversation
            messages = [
                {"role": "system", "content": self.system_prompt}
            ]
        else:
            messages = self.conversation_history.copy()
        
        # Add the new user message
        messages.append({"role": "user", "content": new_message})
        
        return messages
    
    def _extract_and_execute_code(self, message: str) -> str:
        """
        Extract and execute code blocks from a message.
        
        Args:
            message: Assistant message containing code blocks
            
        Returns:
            Message with execution results added
        """
        # Find all code blocks
        code_pattern = re.compile(r"```python\n(.*?)\n```", re.DOTALL)
        matches = code_pattern.finditer(message)
        result = message
        offset = 0  # Track position changes as we modify the string
        
        for match in matches:
            code = match.group(1)
            
            try:
                # Check if code generates plots
                has_plt_show = "plt.show()" in code
                has_plt_import = "import matplotlib.pyplot as plt" in code or "from matplotlib import pyplot as plt" in code
                might_generate_plot = has_plt_import and ("plt." in code or "savefig" in code)
                
                # If plotting is used but plt.show() is missing, add it
                if might_generate_plot and not has_plt_show:
                    code += "\n\n# Save figure to bytes\nfrom io import BytesIO\nbuf = BytesIO()\nplt.savefig(buf, format='png')\nbuf.seek(0)\nprint('DATA_ANALYST_FIGURE:' + base64.b64encode(buf.read()).decode('utf-8'))\nplt.close()"
                
                # Execute the code
                execution_result = self.executor.execute(code, CodeLanguage.PYTHON)
                
                # Format the result
                if execution_result.success:
                    output = execution_result.output.strip()
                    
                    # Check if output contains a base64-encoded figure
                    figure_match = re.search(r"DATA_ANALYST_FIGURE:(.+)", output)
                    if figure_match:
                        # Extract the base64 data
                        b64_data = figure_match.group(1)
                        
                        # Replace the flag with markdown image
                        output = re.sub(
                            r"DATA_ANALYST_FIGURE:.+", 
                            "",
                            output
                        )
                        
                        # Create image insertion
                        image_markdown = f"\n\n**Visualization:**\n\n![Chart](data:image/png;base64,{b64_data})\n"
                    else:
                        image_markdown = ""
                    
                    # Insert the execution results after the code block
                    if output:
                        insertion = f"\n\n**Execution Result:**\n```\n{output}\n```{image_markdown}"
                    else:
                        insertion = image_markdown if image_markdown else "\n\n**Execution Result:** Code executed successfully with no output."
                else:
                    error = execution_result.error or "Unknown error"
                    # Insert the error after the code block
                    insertion = f"\n\n**Execution Error:**\n```\n{error}\n```"
                
                # Calculate the start and end positions of the whole code block
                start = match.start() + offset
                end = match.end() + offset
                
                # Insert the result after the code block
                result = result[:end] + insertion + result[end:]
                
                # Update the offset
                offset += len(insertion)
                
            except Exception as e:
                logger.error(f"Error executing code: {str(e)}")
                # Insert error message
                insertion = f"\n\n**System Error:**\n```\n{str(e)}\n```"
                
                # Calculate positions
                start = match.start() + offset
                end = match.end() + offset
                
                # Insert the error after the code block
                result = result[:end] + insertion + result[end:]
                
                # Update the offset
                offset += len(insertion)
        
        return result
    
    def load_dataframe(self, name: str, data_frame: pd.DataFrame) -> None:
        """
        Load a pandas DataFrame into the assistant's memory.
        
        Args:
            name: Reference name for the DataFrame
            data_frame: The pandas DataFrame to load
        """
        # Store the DataFrame description
        self.datasets[name] = {
            "type": "dataframe",
            "shape": data_frame.shape,
            "columns": list(data_frame.columns),
            "dtypes": {col: str(dtype) for col, dtype in data_frame.dtypes.items()},
            "head": data_frame.head(5).to_dict(orient="records"),
            "description": data_frame.describe().to_dict()
        }
        
        # Store the actual DataFrame in a separate namespace
        globals()[f"df_{name}"] = data_frame
        
        # Add context to the conversation
        context_message = f"""
        I've loaded a new dataset called '{name}' with shape {data_frame.shape}.
        
        Column preview:
        {', '.join(list(data_frame.columns)[:10])}{"..." if len(data_frame.columns) > 10 else ""}
        
        You can access this DataFrame in your code using `df_{name}`.
        """
        
        # Add as system message
        self.conversation_history.append({
            "role": "system",
            "content": context_message
        })
    
    def ask(self, message: str, execute_code: bool = True) -> str:
        """
        Send a message to the assistant and get the response with executed code.
        
        Args:
            message: User message
            execute_code: Whether to execute code in the response
            
        Returns:
            Assistant response with code execution results
        """
        try:
            # Prepare messages
            messages = self._prepare_messages(message)
            
            # Send to OpenAI
            response = self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=2048
            )
            
            # Get the response content
            assistant_message = response.choices[0].message.content
            
            # Execute code if requested
            if execute_code:
                assistant_message = self._extract_and_execute_code(assistant_message)
            
            # Update conversation history
            self.conversation_history = messages + [{"role": "assistant", "content": assistant_message}]
            
            return assistant_message
        
        except Exception as e:
            logger.error(f"Error in ask method: {str(e)}")
            return f"I encountered an error: {str(e)}"
```

## Practical Use Cases

Let's explore practical scenarios where integrating code into assistant responses adds significant value:

### 1. Data Analysis and Visualization

When users need to analyze data or create visualizations, code execution enables the assistant to process data and generate visual insights directly in the conversation:

```python
# filepath: code_execution/use_cases.py
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from code_execution.data_analyst_assistant import DataAnalystAssistant

def data_analysis_demo():
    """Demo of data analysis capabilities."""
    # Create a sample dataset
    np.random.seed(42)
    dates = pd.date_range(start='2022-01-01', periods=100, freq='D')
    data = {
        'date': dates,
        'sales': np.random.normal(1000, 200, size=100).cumsum(),
        'customers': np.random.normal(50, 10, size=100).cumsum(),
        'category': np.random.choice(['A', 'B', 'C'], size=100),
        'region': np.random.choice(['North', 'South', 'East', 'West'], size=100),
        'promotion': np.random.choice([True, False], size=100)
    }
    sales_df = pd.DataFrame(data)
    
    # Initialize the assistant
    assistant = DataAnalystAssistant()
    
    # Load the dataset
    assistant.load_dataframe("sales", sales_df)
    
    # Ask questions
    questions = [
        "Show me the trend in sales over time with a visualization",
        "Calculate the correlation between sales and customers, and explain what it means",
        "Which region has the highest average sales? Create a bar chart to visualize this",
        "Show me the distribution of sales by category with a box plot",
        "Create a report comparing performance with and without promotions"
    ]
    
    # Process each question
    for question in questions:
        print(f"\n\n===== QUESTION: {question} =====\n")
        response = assistant.ask(question)
        print(response)

if __name__ == "__main__":
    data_analysis_demo()
```

### 2. Financial Calculations and Modeling

For financial applications, code execution allows the assistant to perform complex calculations and generate custom financial models:

```python
# filepath: code_execution/financial_examples.py
from code_execution.assistant import CodeAssistant

def financial_calculations_demo():
    """Demo of financial calculation capabilities."""
    # Initialize the assistant
    assistant = CodeAssistant()
    
    # Financial questions
    questions = [
        """
        Calculate the monthly payment for a 30-year mortgage with:
        - Principal: $350,000
        - Annual interest rate: 4.5%
        - Show the amortization schedule for the first 12 months
        """,
        
        """
        Compare investment growth for three scenarios:
        1. $10,000 initial investment, 7% annual return, 20 years
        2. $5,000 initial + $200 monthly contribution, 7% annual return, 20 years
        3. $0 initial + $500 monthly contribution, 7% annual return, 20 years
        Create a chart showing the growth over time.
        """,
        
        """
        Calculate the internal rate of return (IRR) for a project with these cash flows:
        - Initial investment: $50,000
        - Year 1: $12,000
        - Year 2: $15,000
        - Year 3: $18,000
        - Year 4: $21,000
        - Year 5: $25,000
        """
    ]
    
    # Process each question
    for question in questions:
        print(f"\n\n===== FINANCIAL QUERY =====\n")
        response = assistant.ask(question)
        print(response)

if __name__ == "__main__":
    financial_calculations_demo()
```

### 3. Data Format Conversions and Transformations

Assistants with code execution can help users convert between different data formats or transform data structures:

```python
# filepath: code_execution/conversion_examples.py
from code_execution.assistant import CodeAssistant

def data_conversion_demo():
    """Demo of data conversion capabilities."""
    # Initialize the assistant
    assistant = CodeAssistant()
    
    # Conversion tasks
    tasks = [
        """
        Convert this JSON to CSV format:
        ```json
        [
            {"id": 1, "name": "John Doe", "email": "john@example.com", "roles": ["admin", "user"]},
            {"id": 2, "name": "Jane Smith", "email": "jane@example.com", "roles": ["user"]},
            {"id": 3, "name": "Bob Johnson", "email": "bob@example.com", "roles": ["manager", "user"]}
        ]
        ```
        """,
        
        """
        I have this XML data, convert it to JSON:
        ```xml
        <employees>
            <employee id="1">
                <name>John Doe</name>
                <department>Engineering</department>
                <salary currency="USD">75000</salary>
            </employee>
            <employee id="2">
                <name>Jane Smith</name>
                <department>Marketing</department>
                <salary currency="USD">65000</salary>
            </employee>
        </employees>
        ```
        """,
        
        """
        Convert this markdown table to HTML:
        
        | Name | Age | Occupation |
        |------|-----|------------|
        | John | 32  | Developer  |
        | Lisa | 28  | Designer   |
        | Mike | 45  | Manager    |
        """
    ]
    
    # Process each task
    for task in tasks:
        print(f"\n\n===== CONVERSION TASK =====\n")
        response = assistant.ask(task)
        print(response)

if __name__ == "__main__":
    data_conversion_demo()
```

### 4. Custom Table Generation and Reporting

Code execution enables the generation of custom reports and formatted tables based on specific requirements:

```python
# filepath: code_execution/reporting_examples.py
from code_execution.assistant import CodeAssistant

def reporting_demo():
    """Demo of reporting and table generation capabilities."""
    # Initialize the assistant
    assistant = CodeAssistant()
    
    # Reporting tasks
    tasks = [
        """
        Generate a detailed sales report table for Q1-Q4 2023 with the following requirements:
        - Include columns for Quarter, Revenue, Expenses, Profit, and Profit Margin
        - Make up some realistic numbers for a software company
        - Format the table with proper alignment and thousands separators
        - Calculate the profit margin as a percentage of revenue
        - Add a summary row with totals
        """,
        
        """
        Create a project timeline using ASCII art or a text table, with these milestones:
        - Project Kickoff: January 15, 2024
        - Requirements Gathering: January 20-31, 2024
        - Design Phase: February 1-15, 2024
        - Development: February 16 - March 31, 2024
        - Testing: April 1-15, 2024
        - Deployment: April 20, 2024
        """,
        
        """
        Generate a performance score card for 5 employees with:
        - Random names
        - Scores (1-5) for: Technical Skills, Communication, Teamwork, and Leadership
        - Calculate an overall score (weighted: Technical 40%, Communication 20%, Teamwork 20%, Leadership 20%)
        - Add a visual indicator (like stars or a letter grade) based on the overall score
        - Sort the table by overall score
        """
    ]
    
    # Process each task
    for task in tasks:
        print(f"\n\n===== REPORTING TASK =====\n")
        response = assistant.ask(task)
        print(response)

if __name__ == "__main__":
    reporting_demo()
```

## Practical Exercise: Embedding Python Code in Assistant Responses

Let's create a complete example application that demonstrates how to embed Python code in assistant responses:

```python
# filepath: code_execution/app.py
import os
import re
import streamlit as st
from code_execution.data_analyst_assistant import DataAnalystAssistant
import pandas as pd
import numpy as np
from io import StringIO
import base64
import matplotlib.pyplot as plt
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Set page config
st.set_page_config(
    page_title="Code-Enabled Assistant",
    page_icon="ðŸ§®",
    layout="wide"
)

# Initialize session state
if "assistant" not in st.session_state:
    st.session_state.assistant = DataAnalystAssistant()

if "messages" not in st.session_state:
    st.session_state.messages = []

if "datasets" not in st.session_state:
    st.session_state.datasets = {}

# Header
st.title("ðŸ’» Code-Enabled Assistant")
st.subheader("Ask questions that require calculations, data analysis, or visualizations")

# Sidebar for data upload and examples
with st.sidebar:
    st.header("Data Upload")
    
    uploaded_file = st.file_uploader("Upload a CSV or Excel file", type=["csv", "xlsx"])
    
    if uploaded_file is not None:
        try:
            # Determine file type from extension
            file_name = uploaded_file.name
            if file_name.endswith('.csv'):
                df = pd.read_csv(uploaded_file)
            elif file_name.endswith('.xlsx'):
                df = pd.read_excel(uploaded_file)
            
            # Preview the data
            st.write("Data Preview:")
            st.dataframe(df.head(5))
            
            # Load the data into the assistant
            if st.button("Use This Dataset"):
                dataset_name = file_name.split('.')[0].replace(" ", "_")
                st.session_state.assistant.load_dataframe(dataset_name, df)
                st.session_state.datasets[dataset_name] = df
                st.success(f"Dataset '{dataset_name}' loaded successfully!")
                
                # Add a system message to the chat
                system_msg = f"Loaded dataset '{dataset_name}' with {df.shape[0]} rows and {df.shape[1]} columns."
                st.session_state.messages.append({"role": "system", "content": system_msg})
        
        except Exception as e:
            st.error(f"Error loading file: {str(e)}")
    
    st.divider()
    
    st.header("Example Datasets")
    
    if st.button("Load Sample Sales Data"):
        # Create a sample sales dataset
        np.random.seed(42)
        dates = pd.date_range(start='2023-01-01', periods=100, freq='D')
        data = {
            'date': dates,
            'sales': np.random.normal(1000, 200, size=100).cumsum(),
            'customers': np.random.normal(50, 10, size=100).cumsum(),
            'category': np.random.choice(['Electronics', 'Clothing', 'Food'], size=100),
            'region': np.random.choice(['North', 'South', 'East', 'West'], size=100),
            'promotion': np.random.choice([True, False], size=100)
        }
        sales_df = pd.DataFrame(data)
        
        # Load into assistant
        st.session_state.assistant.load_dataframe("sales", sales_df)
        st.session_state.datasets["sales"] = sales_df
        st.success("Sample sales dataset loaded successfully!")
        
        # Add a system message to the chat
        system_msg = "Loaded sample sales dataset with 100 days of data."
        st.session_state.messages.append({"role": "system", "content": system_msg})
    
    st.divider()
    
    st.header("Example Questions")
    
    example_questions = [
        "Calculate the compound interest on $10,000 invested for 5 years at 7% annual interest rate.",
        "Generate a random password with 12 characters including uppercase, lowercase, numbers, and symbols.",
        "Convert 25 Celsius to Fahrenheit and show the formula.",
        "Create a simple neural network to classify points in a 2D space.",
        "Show the sales trend over time with a line chart and calculate the growth rate."
    ]
    
    for question in example_questions:
        if st.button(question, key=question):
            # Add to chat input
            st.session_state.messages.append({"role": "user", "content": question})
            with st.spinner("Thinking..."):
                response = st.session_state.assistant.ask(question)
            st.session_state.messages.append({"role": "assistant", "content": response})
            st.rerun()
    
    st.divider()
    
    # Reset conversation
    if st.button("Reset Conversation"):
        st.session_state.messages = []
        st.session_state.assistant = DataAnalystAssistant()
        st.rerun()

# Display chat messages
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        # Replace base64 images with st.image
        content = message["content"]
        
        # Check for base64 images in markdown format
        img_pattern = r"!\[.*?\]\(data:image\/png;base64,(.*?)\)"
        img_matches = re.finditer(img_pattern, content)
        
        # Split content at image locations and process each part
        last_end = 0
        parts = []
        
        for match in img_matches:
            # Add text before image
            if match.start() > last_end:
                parts.append(("text", content[last_end:match.start()]))
            
            # Add image
            b64_data = match.group(1)
            parts.append(("image", b64_data))
            
            last_end = match.end()
        
        # Add remaining text
        if last_end < len(content):
            parts.append(("text", content[last_end:]))
        
        # If no images found, just add the whole content
        if not parts:
            parts.append(("text", content))
        
        # Display each part
        for part_type, part_content in parts:
            if part_type == "text":
                st.markdown(part_content)
            elif part_type == "image":
                try:
                    image_data = base64.b64decode(part_content)
                    st.image(image_data, use_column_width=True)
                except Exception as e:
                    st.error(f"Error displaying image: {str(e)}")

# Chat input
if prompt := st.chat_input("Ask a question that requires code to answer..."):
    # Add user message to chat
    st.session_state.messages.append({"role": "user", "content": prompt})
    
    # Display user message
    with st.chat_message("user"):
        st.write(prompt)
    
    # Get response from assistant
    with st.spinner("Thinking and executing code..."):
        response = st.session_state.assistant.ask(prompt)
    
    # Add assistant response to chat
    st.session_state.messages.append({"role": "assistant", "content": response})
    st.rerun()  # Rerun to properly render the images
```

To run this application:

1. Set up environment variables in a `.env` file:
```
OPENAI_API_KEY=your_openai_api_key
```

2. Install required dependencies:
```
pip install streamlit openai python-dotenv pandas matplotlib numpy
```

3. Run the Streamlit app:
```
streamlit run code_execution/app.py
```

## Conclusion

Integrating code execution capabilities into GPT assistants significantly expands their utility beyond simple text generation. By enabling assistants to write, execute, and explain code directly within conversations, we create a more interactive and powerful problem-solving environment.

Key benefits of this approach include:

1. **Extended Capabilities**: Code execution enables assistants to perform complex calculations, data transformations, and visualizations that would be impractical to express in text alone.

2. **Real-Time Problem Solving**: Users can receive immediate, customized solutions to computational problems without switching contexts or tools.

3. **Educational Value**: The combination of explanations with executable code examples creates an effective learning environment for programming concepts.

4. **Flexibility**: This approach can be customized for specific domains like data analysis, financial modeling, or scientific computing.

5. **Workflow Integration**: By embedding computational capabilities directly in the conversation interface, users maintain their thought process without context switching.

However, implementing code execution also requires careful attention to security considerations, resource limitations, and user experience design. Proper validation, sandboxing, and error handling are essential to create a robust and safe system.

As AI assistants continue to evolve, the integration of code execution will become increasingly sophisticated, potentially incorporating more advanced features like interactive widgets, collaborative editing, and persistent computational environments. This represents a significant step toward truly intelligent assistants that can not only discuss problems but actively help solve them through computation.