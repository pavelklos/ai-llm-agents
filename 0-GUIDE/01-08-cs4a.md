<small>Claude Sonnet 4</small>
# 08. AI Agent in Practice: OpenAI Operator Style

## Key Terms

**OpenAI Operator**: A system control paradigm where AI agents have the capability to interact with and control operating system functions, applications, and system resources through programmatic interfaces, similar to how human operators manage computer systems.

**System Control Agent**: An AI agent specifically designed to perform system administration tasks, manage applications, control hardware resources, and execute complex multi-step operations on computer systems.

**Privileged Operations**: System-level operations that require elevated permissions, such as process management, file system manipulation, network configuration, and hardware control.

**Command Execution Interface**: A secure abstraction layer that allows AI agents to execute system commands while maintaining safety boundaries and preventing unauthorized or destructive operations.

**Process Orchestration**: The coordination and management of multiple system processes, applications, and services by an AI agent to achieve complex operational objectives.

**System State Monitoring**: Continuous observation and analysis of system resources, performance metrics, application states, and security indicators to enable intelligent decision-making.

**Sandboxed Execution**: A security mechanism that isolates agent operations within controlled environments to prevent system damage while allowing legitimate system interactions.

## Creating System-Controlling Agents

Building AI agents capable of system control requires sophisticated architecture that balances powerful capabilities with robust security measures. These agents must understand system states, execute complex operations, and maintain safety boundaries while providing human-like operational intelligence.

### Advanced System Control Agent Implementation

````python
import asyncio
import os
import json
import subprocess
import psutil
import platform
import logging
import hashlib
from typing import Dict, List, Any, Optional, Union, Callable
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import sqlite3
import yaml
from dotenv import load_dotenv

import openai
from pydantic import BaseModel, Field
import docker
import kubernetes
from kubernetes import client, config

load_dotenv()

class OperationLevel(Enum):
    READ_ONLY = "read_only"
    SAFE_WRITE = "safe_write"
    PRIVILEGED = "privileged"
    SYSTEM_CRITICAL = "system_critical"

class SystemResource(Enum):
    CPU = "cpu"
    MEMORY = "memory"
    DISK = "disk"
    NETWORK = "network"
    PROCESSES = "processes"
    SERVICES = "services"
    APPLICATIONS = "applications"

@dataclass
class SystemOperation:
    operation_id: str
    command: str
    operation_level: OperationLevel
    target_resources: List[SystemResource]
    description: str
    expected_outcome: str
    rollback_command: Optional[str] = None
    timeout_seconds: int = 30
    requires_confirmation: bool = True
    safety_checks: List[str] = field(default_factory=list)

@dataclass
class SystemState:
    timestamp: datetime
    cpu_usage: float
    memory_usage: float
    disk_usage: Dict[str, float]
    network_connections: int
    running_processes: int
    system_load: float
    available_resources: Dict[str, Any]
    security_alerts: List[str] = field(default_factory=list)

class SecurityManager:
    """Advanced security manager for system operations"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.allowed_commands = self._load_allowed_commands()
        self.blocked_patterns = self._load_blocked_patterns()
        self.operation_log = []
        
    def _load_allowed_commands(self) -> List[str]:
        """Load allowed command patterns from configuration"""
        return [
            r"^ls\s+",
            r"^ps\s+",
            r"^top$",
            r"^htop$",
            r"^df\s+",
            r"^free\s+",
            r"^netstat\s+",
            r"^systemctl\s+status\s+",
            r"^docker\s+ps",
            r"^kubectl\s+get\s+",
            r"^ping\s+[\w\.\-]+$",
            r"^curl\s+\-\w+\s+[\w\.\-\/:]+$",
            r"^python\s+[\w\.\-\/]+\.py$",
            r"^cat\s+[\w\.\-\/]+$",
            r"^head\s+[\w\.\-\/]+$",
            r"^tail\s+[\w\.\-\/]+$"
        ]
    
    def _load_blocked_patterns(self) -> List[str]:
        """Load blocked command patterns for security"""
        return [
            r".*rm\s+\-rf.*",
            r".*sudo\s+.*",
            r".*chmod\s+777.*",
            r".*>/dev/null.*",
            r".*\|\s*sh.*",
            r".*eval.*",
            r".*exec.*",
            r".*system\(.*",
            r".*dd\s+if=.*",
            r".*mkfs.*",
            r".*fdisk.*",
            r".*mount.*",
            r".*umount.*",
            r".*iptables.*",
            r".*ufw.*",
            r".*firewall.*"
        ]
    
    def validate_operation(self, operation: SystemOperation) -> Dict[str, Any]:
        """Comprehensive operation validation"""
        validation_result = {
            "approved": False,
            "security_level": "unknown",
            "risks": [],
            "recommendations": [],
            "required_approvals": []
        }
        
        # Check command against allowed patterns
        command_approved = self._check_command_patterns(operation.command)
        
        # Check for blocked patterns
        command_blocked = self._check_blocked_patterns(operation.command)
        
        # Analyze operation level requirements
        level_requirements = self._analyze_operation_level(operation.operation_level)
        
        # Resource impact assessment
        resource_impact = self._assess_resource_impact(operation)
        
        if command_blocked:
            validation_result["risks"].append("Command matches blocked security patterns")
            validation_result["approved"] = False
            return validation_result
        
        if not command_approved and operation.operation_level != OperationLevel.READ_ONLY:
            validation_result["risks"].append("Command not in approved patterns list")
            validation_result["required_approvals"].append("manual_review")
        
        # Determine approval based on operation level
        if operation.operation_level == OperationLevel.READ_ONLY:
            validation_result["approved"] = command_approved
            validation_result["security_level"] = "low"
            
        elif operation.operation_level == OperationLevel.SAFE_WRITE:
            validation_result["approved"] = command_approved and not command_blocked
            validation_result["security_level"] = "medium"
            validation_result["required_approvals"].append("supervisor_review")
            
        elif operation.operation_level in [OperationLevel.PRIVILEGED, OperationLevel.SYSTEM_CRITICAL]:
            validation_result["approved"] = False  # Always require manual approval
            validation_result["security_level"] = "high"
            validation_result["required_approvals"].extend(["administrator_approval", "backup_verification"])
        
        return validation_result
    
    def _check_command_patterns(self, command: str) -> bool:
        """Check if command matches allowed patterns"""
        import re
        return any(re.match(pattern, command) for pattern in self.allowed_commands)
    
    def _check_blocked_patterns(self, command: str) -> bool:
        """Check if command matches blocked patterns"""
        import re
        return any(re.match(pattern, command) for pattern in self.blocked_patterns)
    
    def _analyze_operation_level(self, level: OperationLevel) -> Dict[str, Any]:
        """Analyze requirements for operation level"""
        requirements = {
            OperationLevel.READ_ONLY: {
                "approval_required": False,
                "backup_required": False,
                "monitoring_level": "basic"
            },
            OperationLevel.SAFE_WRITE: {
                "approval_required": True,
                "backup_required": True,
                "monitoring_level": "detailed"
            },
            OperationLevel.PRIVILEGED: {
                "approval_required": True,
                "backup_required": True,
                "monitoring_level": "comprehensive"
            },
            OperationLevel.SYSTEM_CRITICAL: {
                "approval_required": True,
                "backup_required": True,
                "monitoring_level": "real_time"
            }
        }
        return requirements.get(level, requirements[OperationLevel.READ_ONLY])
    
    def _assess_resource_impact(self, operation: SystemOperation) -> Dict[str, Any]:
        """Assess potential resource impact of operation"""
        impact_assessment = {
            "cpu_impact": "low",
            "memory_impact": "low",
            "disk_impact": "low",
            "network_impact": "low",
            "estimated_duration": operation.timeout_seconds
        }
        
        # Analyze based on target resources
        if SystemResource.CPU in operation.target_resources:
            impact_assessment["cpu_impact"] = "medium"
        
        if SystemResource.MEMORY in operation.target_resources:
            impact_assessment["memory_impact"] = "medium"
        
        if SystemResource.DISK in operation.target_resources:
            impact_assessment["disk_impact"] = "high"
        
        return impact_assessment

class SystemMonitor:
    """Comprehensive system monitoring and state management"""
    
    def __init__(self):
        self.monitoring_active = False
        self.state_history: List[SystemState] = []
        self.alert_thresholds = {
            "cpu_usage": 80.0,
            "memory_usage": 85.0,
            "disk_usage": 90.0,
            "load_average": 4.0
        }
        
    async def get_current_state(self) -> SystemState:
        """Get comprehensive current system state"""
        
        # CPU and memory usage
        cpu_usage = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        memory_usage = memory.percent
        
        # Disk usage for all mounted filesystems
        disk_usage = {}
        for partition in psutil.disk_partitions():
            try:
                partition_usage = psutil.disk_usage(partition.mountpoint)
                disk_usage[partition.mountpoint] = partition_usage.percent
            except PermissionError:
                continue
        
        # Network connections
        network_connections = len(psutil.net_connections())
        
        # Running processes
        running_processes = len(psutil.pids())
        
        # System load (Unix-like systems)
        try:
            load_average = os.getloadavg()[0] if hasattr(os, 'getloadavg') else 0.0
        except:
            load_average = 0.0
        
        # Available resources
        available_resources = {
            "cpu_cores": psutil.cpu_count(),
            "total_memory_gb": round(memory.total / (1024**3), 2),
            "available_memory_gb": round(memory.available / (1024**3), 2),
            "platform": platform.platform(),
            "architecture": platform.architecture()[0]
        }
        
        # Security alerts
        security_alerts = self._check_security_alerts(cpu_usage, memory_usage, disk_usage, load_average)
        
        current_state = SystemState(
            timestamp=datetime.now(),
            cpu_usage=cpu_usage,
            memory_usage=memory_usage,
            disk_usage=disk_usage,
            network_connections=network_connections,
            running_processes=running_processes,
            system_load=load_average,
            available_resources=available_resources,
            security_alerts=security_alerts
        )
        
        self.state_history.append(current_state)
        
        # Keep only last 1000 states
        if len(self.state_history) > 1000:
            self.state_history = self.state_history[-1000:]
        
        return current_state
    
    def _check_security_alerts(self, cpu_usage: float, memory_usage: float, 
                             disk_usage: Dict[str, float], load_average: float) -> List[str]:
        """Check for security and performance alerts"""
        alerts = []
        
        if cpu_usage > self.alert_thresholds["cpu_usage"]:
            alerts.append(f"High CPU usage: {cpu_usage:.1f}%")
        
        if memory_usage > self.alert_thresholds["memory_usage"]:
            alerts.append(f"High memory usage: {memory_usage:.1f}%")
        
        for mount_point, usage in disk_usage.items():
            if usage > self.alert_thresholds["disk_usage"]:
                alerts.append(f"High disk usage on {mount_point}: {usage:.1f}%")
        
        if load_average > self.alert_thresholds["load_average"]:
            alerts.append(f"High system load: {load_average:.2f}")
        
        return alerts
    
    async def start_monitoring(self, interval_seconds: int = 60):
        """Start continuous system monitoring"""
        self.monitoring_active = True
        
        while self.monitoring_active:
            try:
                await self.get_current_state()
                await asyncio.sleep(interval_seconds)
            except Exception as e:
                logging.error(f"Monitoring error: {e}")
                await asyncio.sleep(interval_seconds)
    
    def stop_monitoring(self):
        """Stop system monitoring"""
        self.monitoring_active = False
    
    def get_performance_trends(self, hours: int = 24) -> Dict[str, Any]:
        """Analyze performance trends over specified time period"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        recent_states = [s for s in self.state_history if s.timestamp >= cutoff_time]
        
        if not recent_states:
            return {"error": "No data available for the specified time period"}
        
        cpu_values = [s.cpu_usage for s in recent_states]
        memory_values = [s.memory_usage for s in recent_states]
        
        return {
            "time_period_hours": hours,
            "data_points": len(recent_states),
            "cpu_trend": {
                "average": sum(cpu_values) / len(cpu_values),
                "min": min(cpu_values),
                "max": max(cpu_values),
                "trend": "increasing" if cpu_values[-1] > cpu_values[0] else "decreasing"
            },
            "memory_trend": {
                "average": sum(memory_values) / len(memory_values),
                "min": min(memory_values),
                "max": max(memory_values),
                "trend": "increasing" if memory_values[-1] > memory_values[0] else "decreasing"
            },
            "alert_frequency": len([s for s in recent_states if s.security_alerts]) / len(recent_states)
        }

class OpenAIOperatorAgent:
    """Advanced AI agent capable of system control operations"""
    
    def __init__(self, agent_id: str, config: Dict[str, Any]):
        self.agent_id = agent_id
        self.config = config
        
        # Initialize OpenAI client
        self.openai_client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
        
        # Initialize components
        self.security_manager = SecurityManager(config.get('security', {}))
        self.system_monitor = SystemMonitor()
        self.execution_history: List[Dict[str, Any]] = []
        
        # Operation capabilities
        self.operation_registry = self._initialize_operations()
        
        # Database for logging
        self.db_path = f"operator_agent_{agent_id}.db"
        self._init_database()
        
        # Start monitoring
        asyncio.create_task(self.system_monitor.start_monitoring())
    
    def _init_database(self):
        """Initialize SQLite database for operation logging"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS operation_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                operation_id TEXT NOT NULL,
                command TEXT NOT NULL,
                operation_level TEXT NOT NULL,
                execution_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                success BOOLEAN NOT NULL,
                output TEXT,
                error_message TEXT,
                system_state_before TEXT,
                system_state_after TEXT,
                security_validation TEXT,
                human_approved BOOLEAN DEFAULT FALSE
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS system_snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                snapshot_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                cpu_usage REAL,
                memory_usage REAL,
                disk_usage TEXT,
                running_processes INTEGER,
                security_alerts TEXT,
                performance_score REAL
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def _initialize_operations(self) -> Dict[str, SystemOperation]:
        """Initialize predefined system operations"""
        operations = {}
        
        # System information operations
        operations["get_system_info"] = SystemOperation(
            operation_id="get_system_info",
            command="uname -a && cat /proc/version 2>/dev/null || sw_vers 2>/dev/null || ver 2>/dev/null",
            operation_level=OperationLevel.READ_ONLY,
            target_resources=[SystemResource.CPU],
            description="Get detailed system information",
            expected_outcome="System version and architecture details"
        )
        
        operations["list_processes"] = SystemOperation(
            operation_id="list_processes",
            command="ps aux",
            operation_level=OperationLevel.READ_ONLY,
            target_resources=[SystemResource.PROCESSES],
            description="List all running processes",
            expected_outcome="Comprehensive process list with resource usage"
        )
        
        operations["check_disk_space"] = SystemOperation(
            operation_id="check_disk_space",
            command="df -h",
            operation_level=OperationLevel.READ_ONLY,
            target_resources=[SystemResource.DISK],
            description="Check disk space usage",
            expected_outcome="Disk usage information for all mounted filesystems"
        )
        
        operations["monitor_network"] = SystemOperation(
            operation_id="monitor_network",
            command="netstat -tuln",
            operation_level=OperationLevel.READ_ONLY,
            target_resources=[SystemResource.NETWORK],
            description="Monitor network connections",
            expected_outcome="List of active network connections and listening ports"
        )
        
        # Docker operations
        operations["list_containers"] = SystemOperation(
            operation_id="list_containers",
            command="docker ps -a",
            operation_level=OperationLevel.READ_ONLY,
            target_resources=[SystemResource.APPLICATIONS],
            description="List all Docker containers",
            expected_outcome="Status of all Docker containers"
        )
        
        operations["start_container"] = SystemOperation(
            operation_id="start_container",
            command="docker start {container_name}",
            operation_level=OperationLevel.SAFE_WRITE,
            target_resources=[SystemResource.APPLICATIONS],
            description="Start a Docker container",
            expected_outcome="Container successfully started",
            rollback_command="docker stop {container_name}",
            requires_confirmation=True
        )
        
        # Service management
        operations["check_service_status"] = SystemOperation(
            operation_id="check_service_status",
            command="systemctl status {service_name}",
            operation_level=OperationLevel.READ_ONLY,
            target_resources=[SystemResource.SERVICES],
            description="Check status of a system service",
            expected_outcome="Service status and recent log entries"
        )
        
        return operations
    
    async def execute_operation(self, operation_id: str, parameters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute system operation with comprehensive safety checks"""
        
        if operation_id not in self.operation_registry:
            return {
                "success": False,
                "error": f"Operation {operation_id} not found",
                "available_operations": list(self.operation_registry.keys())
            }
        
        operation = self.operation_registry[operation_id]
        parameters = parameters or {}
        
        # Format command with parameters
        formatted_command = operation.command.format(**parameters)
        operation.command = formatted_command
        
        # Get system state before operation
        system_state_before = await self.system_monitor.get_current_state()
        
        # Security validation
        security_result = self.security_manager.validate_operation(operation)
        
        if not security_result["approved"]:
            return {
                "success": False,
                "error": "Operation not approved by security manager",
                "security_result": security_result,
                "operation_id": operation_id
            }
        
        # Execute operation
        execution_result = await self._execute_command_safely(operation)
        
        # Get system state after operation
        system_state_after = await self.system_monitor.get_current_state()
        
        # Log operation
        await self._log_operation(
            operation,
            execution_result,
            system_state_before,
            system_state_after,
            security_result
        )
        
        return {
            "success": execution_result["success"],
            "operation_id": operation_id,
            "output": execution_result.get("output", ""),
            "error": execution_result.get("error", ""),
            "execution_time": execution_result.get("execution_time", 0),
            "security_validation": security_result,
            "system_impact": self._analyze_system_impact(system_state_before, system_state_after)
        }
    
    async def _execute_command_safely(self, operation: SystemOperation) -> Dict[str, Any]:
        """Execute command with timeout and error handling"""
        
        start_time = datetime.now()
        
        try:
            # Execute command with timeout
            process = await asyncio.create_subprocess_shell(
                operation.command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                limit=1024*1024  # 1MB limit
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=operation.timeout_seconds
                )
                
                execution_time = (datetime.now() - start_time).total_seconds()
                
                if process.returncode == 0:
                    return {
                        "success": True,
                        "output": stdout.decode('utf-8', errors='ignore'),
                        "execution_time": execution_time,
                        "return_code": process.returncode
                    }
                else:
                    return {
                        "success": False,
                        "error": stderr.decode('utf-8', errors='ignore'),
                        "execution_time": execution_time,
                        "return_code": process.returncode
                    }
                    
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()
                return {
                    "success": False,
                    "error": f"Command timed out after {operation.timeout_seconds} seconds",
                    "execution_time": operation.timeout_seconds
                }
                
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            return {
                "success": False,
                "error": f"Execution error: {str(e)}",
                "execution_time": execution_time
            }
    
    def _analyze_system_impact(self, before: SystemState, after: SystemState) -> Dict[str, Any]:
        """Analyze system impact of operation"""
        
        return {
            "cpu_change": after.cpu_usage - before.cpu_usage,
            "memory_change": after.memory_usage - before.memory_usage,
            "process_count_change": after.running_processes - before.running_processes,
            "new_alerts": [alert for alert in after.security_alerts if alert not in before.security_alerts],
            "resolved_alerts": [alert for alert in before.security_alerts if alert not in after.security_alerts],
            "performance_impact": "low" if abs(after.cpu_usage - before.cpu_usage) < 5 else "high"
        }
    
    async def _log_operation(self, operation: SystemOperation, execution_result: Dict[str, Any],
                           before_state: SystemState, after_state: SystemState,
                           security_result: Dict[str, Any]):
        """Log operation to database"""
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO operation_log 
            (operation_id, command, operation_level, success, output, error_message,
             system_state_before, system_state_after, security_validation)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            operation.operation_id,
            operation.command,
            operation.operation_level.value,
            execution_result["success"],
            execution_result.get("output", ""),
            execution_result.get("error", ""),
            json.dumps({
                "cpu_usage": before_state.cpu_usage,
                "memory_usage": before_state.memory_usage,
                "running_processes": before_state.running_processes
            }),
            json.dumps({
                "cpu_usage": after_state.cpu_usage,
                "memory_usage": after_state.memory_usage,
                "running_processes": after_state.running_processes
            }),
            json.dumps(security_result)
        ))
        
        conn.commit()
        conn.close()
    
    async def intelligent_system_analysis(self, query: str) -> Dict[str, Any]:
        """Use AI to analyze system and suggest operations"""
        
        # Get current system state
        current_state = await self.system_monitor.get_current_state()
        
        # Get recent performance trends
        performance_trends = self.system_monitor.get_performance_trends(hours=6)
        
        # Prepare context for AI analysis
        system_context = {
            "current_state": {
                "cpu_usage": current_state.cpu_usage,
                "memory_usage": current_state.memory_usage,
                "disk_usage": current_state.disk_usage,
                "running_processes": current_state.running_processes,
                "security_alerts": current_state.security_alerts
            },
            "performance_trends": performance_trends,
            "available_operations": list(self.operation_registry.keys())
        }
        
        analysis_prompt = f"""
        You are an expert system administrator AI analyzing a computer system.
        
        User Query: {query}
        
        Current System State:
        {json.dumps(system_context, indent=2)}
        
        Please provide:
        1. Analysis of the current system state
        2. Identification of any issues or concerns
        3. Recommended operations to address the query
        4. Step-by-step action plan
        5. Risk assessment for recommended actions
        
        Available operations: {', '.join(self.operation_registry.keys())}
        
        Format your response as JSON with clear sections for analysis, recommendations, and action_plan.
        """
        
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an expert system administrator AI. Provide detailed technical analysis and actionable recommendations."
                    },
                    {
                        "role": "user",
                        "content": analysis_prompt
                    }
                ],
                temperature=0.3,
                max_tokens=2000
            )
            
            ai_analysis = response.choices[0].message.content
            
            # Try to parse as JSON, fallback to plain text
            try:
                analysis_json = json.loads(ai_analysis)
            except json.JSONDecodeError:
                analysis_json = {"raw_analysis": ai_analysis}
            
            return {
                "query": query,
                "system_analysis": analysis_json,
                "system_context": system_context,
                "timestamp": datetime.now().isoformat(),
                "agent_id": self.agent_id
            }
            
        except Exception as e:
            return {
                "query": query,
                "error": f"AI analysis failed: {str(e)}",
                "system_context": system_context,
                "timestamp": datetime.now().isoformat()
            }
    
    async def execute_ai_recommended_plan(self, analysis_result: Dict[str, Any]) -> Dict[str, Any]:
        """Execute operations recommended by AI analysis"""
        
        if "system_analysis" not in analysis_result:
            return {"error": "No valid analysis result provided"}
        
        analysis = analysis_result["system_analysis"]
        
        # Extract recommended operations
        recommended_operations = []
        
        if "action_plan" in analysis:
            for step in analysis.get("action_plan", []):
                if isinstance(step, dict) and "operation" in step:
                    recommended_operations.append(step)
                elif isinstance(step, str):
                    # Try to extract operation names from text
                    for op_name in self.operation_registry.keys():
                        if op_name in step:
                            recommended_operations.append({"operation": op_name})
        
        execution_results = []
        
        for operation_spec in recommended_operations:
            operation_name = operation_spec.get("operation")
            parameters = operation_spec.get("parameters", {})
            
            if operation_name in self.operation_registry:
                result = await self.execute_operation(operation_name, parameters)
                execution_results.append({
                    "operation": operation_name,
                    "result": result,
                    "timestamp": datetime.now().isoformat()
                })
            else:
                execution_results.append({
                    "operation": operation_name,
                    "result": {"success": False, "error": "Operation not found"},
                    "timestamp": datetime.now().isoformat()
                })
        
        return {
            "plan_execution": execution_results,
            "total_operations": len(recommended_operations),
            "successful_operations": len([r for r in execution_results if r["result"]["success"]]),
            "original_analysis": analysis_result,
            "execution_timestamp": datetime.now().isoformat()
        }
    
    def get_operation_history(self, limit: int = 50) -> List[Dict[str, Any]]:
        """Get recent operation history"""
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT operation_id, command, operation_level, execution_time, 
                   success, output, error_message, security_validation
            FROM operation_log 
            ORDER BY execution_time DESC 
            LIMIT ?
        ''', (limit,))
        
        rows = cursor.fetchall()
        conn.close()
        
        history = []
        for row in rows:
            history.append({
                "operation_id": row[0],
                "command": row[1],
                "operation_level": row[2],
                "execution_time": row[3],
                "success": bool(row[4]),
                "output": row[5],
                "error_message": row[6],
                "security_validation": json.loads(row[7]) if row[7] else {}
            })
        
        return history
    
    async def system_health_check(self) -> Dict[str, Any]:
        """Comprehensive system health assessment"""
        
        current_state = await self.system_monitor.get_current_state()
        performance_trends = self.system_monitor.get_performance_trends(hours=24)
        
        # Run multiple diagnostic operations
        diagnostics = {}
        
        # Basic system info
        system_info_result = await self.execute_operation("get_system_info")
        diagnostics["system_info"] = system_info_result
        
        # Process check
        process_result = await self.execute_operation("list_processes")
        diagnostics["processes"] = process_result
        
        # Disk space check
        disk_result = await self.execute_operation("check_disk_space")
        diagnostics["disk_space"] = disk_result
        
        # Network check
        network_result = await self.execute_operation("monitor_network")
        diagnostics["network"] = network_result
        
        # Calculate health score
        health_score = self._calculate_health_score(current_state, diagnostics)
        
        return {
            "health_score": health_score,
            "current_state": {
                "cpu_usage": current_state.cpu_usage,
                "memory_usage": current_state.memory_usage,
                "disk_usage": current_state.disk_usage,
                "security_alerts": current_state.security_alerts
            },
            "performance_trends": performance_trends,
            "diagnostics": diagnostics,
            "recommendations": self._generate_health_recommendations(current_state, health_score),
            "timestamp": datetime.now().isoformat()
        }
    
    def _calculate_health_score(self, state: SystemState, diagnostics: Dict[str, Any]) -> float:
        """Calculate overall system health score (0-100)"""
        
        score = 100.0
        
        # CPU usage penalty
        if state.cpu_usage > 80:
            score -= (state.cpu_usage - 80) * 2
        
        # Memory usage penalty
        if state.memory_usage > 85:
            score -= (state.memory_usage - 85) * 2
        
        # Disk usage penalty
        for mount_point, usage in state.disk_usage.items():
            if usage > 90:
                score -= (usage - 90) * 3
        
        # Security alerts penalty
        score -= len(state.security_alerts) * 5
        
        # Failed diagnostics penalty
        failed_diagnostics = len([d for d in diagnostics.values() if not d.get("success", False)])
        score -= failed_diagnostics * 10
        
        return max(0.0, min(100.0, score))
    
    def _generate_health_recommendations(self, state: SystemState, health_score: float) -> List[str]:
        """Generate health improvement recommendations"""
        
        recommendations = []
        
        if health_score < 70:
            recommendations.append("System health is below optimal. Immediate attention required.")
        
        if state.cpu_usage > 80:
            recommendations.append("High CPU usage detected. Consider identifying resource-intensive processes.")
        
        if state.memory_usage > 85:
            recommendations.append("High memory usage detected. Consider freeing up memory or adding more RAM.")
        
        for mount_point, usage in state.disk_usage.items():
            if usage > 90:
                recommendations.append(f"Critical disk space on {mount_point}. Clean up files or expand storage.")
        
        if state.security_alerts:
            recommendations.append("Security alerts detected. Review and address security concerns.")
        
        if not recommendations:
            recommendations.append("System is operating within normal parameters.")
        
        return recommendations

# Usage example and testing framework
async def main():
    """Example usage of OpenAI Operator Agent"""
    
    # Configuration
    config = {
        "security": {
            "max_operation_level": "safe_write",
            "require_human_approval": True
        },
        "monitoring": {
            "interval_seconds": 30,
            "alert_thresholds": {
                "cpu_usage": 80.0,
                "memory_usage": 85.0
            }
        }
    }
    
    # Create agent
    agent = OpenAIOperatorAgent("system_operator_001", config)
    
    print("OpenAI Operator Agent initialized")
    
    # Wait for initial monitoring data
    await asyncio.sleep(2)
    
    # Example 1: Get system information
    print("\n=== Getting System Information ===")
    result = await agent.execute_operation("get_system_info")
    print(json.dumps(result, indent=2))
    
    # Example 2: AI-powered system analysis
    print("\n=== AI System Analysis ===")
    analysis = await agent.intelligent_system_analysis(
        "Check system performance and identify any potential issues"
    )
    print(json.dumps(analysis, indent=2))
    
    # Example 3: System health check
    print("\n=== System Health Check ===")
    health_check = await agent.system_health_check()
    print(f"System Health Score: {health_check['health_score']:.1f}/100")
    print("Recommendations:")
    for rec in health_check['recommendations']:
        print(f"- {rec}")
    
    # Example 4: Operation history
    print("\n=== Operation History ===")
    history = agent.get_operation_history(limit=5)
    for op in history:
        print(f"- {op['operation_id']}: {'Success' if op['success'] else 'Failed'}")

if __name__ == "__main__":
    asyncio.run(main())
````

### Advanced Container and Kubernetes Integration

````python
import asyncio
import os
import json
from typing import Dict, List, Any, Optional
from datetime import datetime
import docker
import kubernetes
from kubernetes import client, config
from dotenv import load_dotenv

load_dotenv()

class ContainerOrchestrationAgent:
    """Advanced agent for container and Kubernetes operations"""
    
    def __init__(self, agent_id: str):
        self.agent_id = agent_id
        
        # Initialize Docker client
        try:
            self.docker_client = docker.from_env()
        except Exception as e:
            print(f"Docker not available: {e}")
            self.docker_client = None
        
        # Initialize Kubernetes client
        try:
            config.load_incluster_config()  # For in-cluster execution
        except:
            try:
                config.load_kube_config()  # For local execution
            except Exception as e:
                print(f"Kubernetes not available: {e}")
        
        try:
            self.k8s_v1 = client.CoreV1Api()
            self.k8s_apps = client.AppsV1Api()
        except:
            self.k8s_v1 = None
            self.k8s_apps = None
    
    async def manage_docker_containers(self, action: str, **kwargs) -> Dict[str, Any]:
        """Manage Docker containers"""
        
        if not self.docker_client:
            return {"error": "Docker client not available"}
        
        try:
            if action == "list":
                containers = self.docker_client.containers.list(all=True)
                return {
                    "containers": [
                        {
                            "id": c.id[:12],
                            "name": c.name,
                            "status": c.status,
                            "image": c.image.tags[0] if c.image.tags else "unknown"
                        }
                        for c in containers
                    ]
                }
            
            elif action == "start":
                container_name = kwargs.get("container_name")
                container = self.docker_client.containers.get(container_name)
                container.start()
                return {"success": True, "message": f"Container {container_name} started"}
            
            elif action == "stop":
                container_name = kwargs.get("container_name")
                container = self.docker_client.containers.get(container_name)
                container.stop()
                return {"success": True, "message": f"Container {container_name} stopped"}
            
            elif action == "create":
                image = kwargs.get("image")
                name = kwargs.get("name")
                ports = kwargs.get("ports", {})
                
                container = self.docker_client.containers.run(
                    image,
                    name=name,
                    ports=ports,
                    detach=True
                )
                return {"success": True, "container_id": container.id[:12]}
            
        except Exception as e:
            return {"error": str(e)}
    
    async def manage_kubernetes_resources(self, action: str, **kwargs) -> Dict[str, Any]:
        """Manage Kubernetes resources"""
        
        if not self.k8s_v1:
            return {"error": "Kubernetes client not available"}
        
        try:
            if action == "list_pods":
                namespace = kwargs.get("namespace", "default")
                pods = self.k8s_v1.list_namespaced_pod(namespace)
                return {
                    "pods": [
                        {
                            "name": pod.metadata.name,
                            "namespace": pod.metadata.namespace,
                            "status": pod.status.phase,
                            "node": pod.spec.node_name
                        }
                        for pod in pods.items
                    ]
                }
            
            elif action == "scale_deployment":
                name = kwargs.get("deployment_name")
                namespace = kwargs.get("namespace", "default")
                replicas = kwargs.get("replicas", 1)
                
                deployment = self.k8s_apps.read_namespaced_deployment(name, namespace)
                deployment.spec.replicas = replicas
                
                self.k8s_apps.patch_namespaced_deployment(
                    name=name,
                    namespace=namespace,
                    body=deployment
                )
                
                return {"success": True, "message": f"Scaled {name} to {replicas} replicas"}
            
        except Exception as e:
            return {"error": str(e)}
````

## Conclusion

The OpenAI Operator style agent represents a sophisticated evolution in AI system control, enabling autonomous management of complex computing environments while maintaining critical safety boundaries. This approach bridges the gap between traditional system administration and intelligent automation, creating agents capable of understanding system contexts, making informed decisions, and executing operations with human-level comprehension.

**System Control Capabilities** demonstrate the agent's ability to monitor, analyze, and manage computer systems through secure interfaces. The implementation provides comprehensive monitoring of system resources, intelligent analysis of performance trends, and automated execution of administrative tasks. The multi-layered security framework ensures that powerful capabilities are balanced with robust protection mechanisms.

**Security Architecture** represents a critical component that validates operations, enforces access controls, and maintains audit trails. The separation of operation levels (read-only, safe-write, privileged, system-critical) provides granular control over agent capabilities while preventing unauthorized or destructive operations.

**AI-Powered Analysis** enables the agent to understand complex system states and provide intelligent recommendations. By combining real-time monitoring data with large language model analysis, the agent can identify patterns, predict issues, and suggest optimization strategies that go beyond simple rule-based systems.

**Integration Capabilities** with container orchestration, database systems, and cloud platforms demonstrate the agent's versatility in modern infrastructure environments. The ability to manage Docker containers, Kubernetes clusters, and various system services makes it applicable to diverse operational scenarios.

**Operational Intelligence** emerges from the combination of system monitoring, security validation, and AI analysis. The agent can adapt to changing conditions, learn from operational history, and provide insights that enhance both system performance and operational efficiency.

**Production Readiness** considerations include comprehensive logging, error handling, timeout management, and rollback capabilities. The implementation provides the foundation for deploying such agents in real-world environments where reliability and safety are paramount.

This approach represents a significant advancement in autonomous system management, offering the potential to transform how complex computing infrastructures are monitored, maintained, and optimized. The careful balance between capability and safety makes it suitable for gradual deployment in increasingly critical operational scenarios.